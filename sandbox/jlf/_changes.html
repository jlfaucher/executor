<!doctype html>
<html lang='en'>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
   Changes applied to ooRexx 4.2
    </title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel='stylesheet' href='https://jlfaucher.github.io/css/rexx-vim-light-zellner.css'>
    <link rel='stylesheet' href='https://jlfaucher.github.io/css/markdown.css'>
    <link rel='stylesheet' href='https://jlfaucher.github.io/css/markdown4xtr.css'>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Questrial&display=swap" rel="stylesheet">
    <!--[if lt IE 9]>
      <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class='container bg-white' lang='en'>
      <div class='row layout-main'>
        <div class='col-md-9 content-pane'>
          <div class='content' id="content">
<h1 id="changes-applied-to-oorexx-4.2">   Changes applied to ooRexx
4.2</h1>
<!-- ======================================================================= -->
<h2 id="new-native-classes">1.   New native classes</h2>
<!-- ======================================================================= -->
<p>Exported classes</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode c++"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>RexxBlock</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>RexxText</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>Unicode</span></code></pre></div>
<p>Internal classes</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode c++"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>ExtensionDirective</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>SourceLiteral</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>UpperInstruction</span></code></pre></div>
<!-- ======================================================================= -->
<h2 id="extensions">2.   Extensions</h2>
<!-- ======================================================================= -->
<p>See <a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/internals/notes/Extension%20-%20Expression%20problem.txt">Extension
- Expression problem.txt</a> for the critics of Rick regarding these
extensions (2011).</p>
<p>Two types of extensions are possible:</p>
<ul>
<li>Standard extensions, usable in production (not implemented in
Executor).</li>
<li>Unlocked extensions, that should not be used in production.</li>
</ul>
<p>Two forms of extensions are possible:</p>
<ul>
<li>Direct extensions (using <code>.class~define</code>)</li>
<li>Inherited extensions (using <code>.class~inherit</code>)</li>
</ul>
<p><strong>Overview:</strong></p>
<pre><code>                       +-------------------------------------------------------------------------------------+
                       |           Standard extensions            |           Unlocked extensions            |
                       |          (not yet implemented)           |        (implemented in Executor)         |
+----------------------|------------------------------------------|----------------------------------------- |
|                      | ::extension myClass                      | ::extension myClass                      |
|                      | ::method myMethod                        | ::method myMethod                        |
|                      |                                          |                                          |
|                      | or                                       |                                          |
|                      |                                          |                                          |
|                      | ::Method myClass:myMethod                |                                          |
|  Direct extensions   |                                          |                                          |
|                      | or                                       |                                          |
|                      |                                          |                                          |
|                      | ::Method myMethod Extends myClass        |                                          |
|                      |                                          |                                          |
|                      | or                                       |                                          |
|                      | ...                                      |                                          |
|----------------------|------------------------------------------|------------------------------------------|
|                      | ::extension myClass inherit myMixinClass | ::extension myClass inherit myMixinClass |
|                      |                                          |                                          |
| Inherited extensions | or                                       |                                          |
|                      |                                          |                                          |
|                      | ...                                      |                                          |
+------------------------------------------------------------------------------------------------------------+</code></pre>
<!-- ------------------------------- -->
<h3 id="standard-extensions">2.1.   Standard extensions</h3>
<!-- ------------------------------- -->
<p>Standard extensions are useful for modularizing class design.</p>
<p><strong>First need expressed by Josep Maria (JMB)</strong><br />
<a href="https://groups.io/g/rexxla-arb/topic/115749344">Syntax sugar
for adding new methods to an existing class: a proposal</a><br />
<em>Assume that C is a class (a non-predefined one: these cannot be
altered), defined somewhere</em>.<br />
<em>We want to add a new method "newM" to C, without altering the
package that defined C.</em><br />
<em>This can currently be done in several ways, using pure ooRexx
primitives.</em><br />
<em>It would be nice if the language offered some syntax sugar to add
methods to existing (non-predefined) classes.</em><br />
<em>A syntax which could be acceptable and doesn't break anything could
be:</em></p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-dir">::</span><span class="rx-dkw">Method</span><span class="rx-ws"> </span><span class="rx-const rx-method rx-oquo">"</span><span class="rx-const rx-method">Class:Method</span><span class="rx-const rx-method rx-cquo">"</span>
</code></pre>
</div>
<p><em>This would add the method "Method" to class "Class".</em></p>
<p><strong><a
href="https://groups.io/g/rexxla-arb/message/1156">Alternative syntax
proposed by Gil:</a></strong><br />
<em>As an alternative syntax, I'd suggest adding a new sub-keyword to
the ::Method directive.</em><br />
<em>Perhaps Extends <classname> ?</em></p>
<pre><code>::Method Foo &lt;other sub-keywords&gt; Extends MyArray</code></pre>
<p><em>where MyArray is a class defined in another package.</em></p>
<p><strong>Another alternative syntax</strong><br />
The <code>::extension</code> directive described later can be used as
is.<br />
This would also enable support for inherited extensions.</p>
<!-- ------------------------------- -->
<h3 id="unlocked-extensions">2.2.   Unlocked extensions</h3>
<!-- ------------------------------- -->
<p>Unlocked extensions are extensions applicable to the predefined
classes.<br />
They are useful for creating prototypes and proofs of concept (no need
to be an ooRexx developer).<br />
They are not designed for production use; therefore, they should not be
enabled by default.</p>
<p>If a prototype becomes candidate for official delivery then it should
be re-implemented without unlocked extensions.<br />
This may involve some changes to the interpreter, either natively or in
rexx.img (ooRexx developer profile).</p>
<!-- ------------------------------- -->
<h4 id="unleash-the-potential">2.2.1.   Unleash the potential</h4>
<!-- ------------------------------- -->
<p>ooRexx supports natively the extension of predefined classes during
the image building.</p>
<p>Executor does not limit such extensions to the image building:</p>
<ul>
<li>Unlock the <code>define</code> method.<br />
</li>
<li>Unlock the <code>inherit</code> method.</li>
</ul>
<p>Modifications are allowed on predefined classes and are propagated to
existing instances.</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-var">s</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">'</span><span class="rx-str">"he said ""hello"" "</span><span class="rx-str rx-cquo">'</span></code>
<code lineno="2"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">s</span><span class="rx-ws">                           </span><span class="rx-lncm">-- "he said ""hello"" "</span></code>
<code lineno="3"></code>
<code lineno="4"><span class="rx-lncm">-- Direct extension</span></code>
<code lineno="5"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">s</span><span class="rx-op">~</span><span class="rx-const rx-method">hasMethod</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">quoted</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span><span class="rx-ws">       </span><span class="rx-lncm">-- 0</span></code>
<code lineno="6"><span class="rx-env">.string</span><span class="rx-op">~</span><span class="rx-const rx-method">define</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">quoted</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">use strict arg quote='""'; return quote || self~changeStr(quote, quote||quote) || quote</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span></code>
<code lineno="7"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">s</span><span class="rx-op">~</span><span class="rx-const rx-method">hasMethod</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">quoted</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span><span class="rx-ws">       </span><span class="rx-lncm">-- 1 (the new method has been propagated to the old instances)</span></code>
<code lineno="8"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">s</span><span class="rx-op">~</span><span class="rx-const rx-method">quoted</span><span class="rx-ws">                    </span><span class="rx-lncm">-- """he said """"hello"""" """</span></code>
<code lineno="9"></code>
<code lineno="10"><span class="rx-lncm">-- Inherited extension</span></code>
<code lineno="11"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">s</span><span class="rx-op">~</span><span class="rx-const rx-method">hasMethod</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">unquoted</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span><span class="rx-ws">     </span><span class="rx-lncm">-- 0</span></code>
<code lineno="12"><span class="rx-env">.string</span><span class="rx-op">~</span><span class="rx-const rx-method">inherit</span><span class="rx-spe">(</span><span class="rx-env">.StringHelpers</span><span class="rx-spe">)</span></code>
<code lineno="13"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">s</span><span class="rx-op">~</span><span class="rx-const rx-method">hasMethod</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">unquoted</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span><span class="rx-ws">     </span><span class="rx-lncm">-- 1 (the new inherited methods have been propagated to the old instances)</span></code>
<code lineno="14"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">s</span><span class="rx-op">~</span><span class="rx-const rx-method">unquoted</span><span class="rx-ws">                  </span><span class="rx-lncm">-- he said "hello"</span></code>
<code lineno="15"></code>
<code lineno="16"><span class="rx-dir">::</span><span class="rx-dkw">class</span><span class="rx-ws"> </span><span class="rx-const rx-class rx-oquo">"</span><span class="rx-const rx-class">StringHelpers</span><span class="rx-const rx-class rx-cquo">"</span><span class="rx-ws"> </span><span class="rx-dskw">mixinclass</span><span class="rx-ws"> </span><span class="rx-const rx-class">Object</span><span class="rx-ws"> </span><span class="rx-dskw">public</span></code>
<code lineno="17"></code>
<code lineno="18"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">unquoted</span></code>
<code lineno="19"><span class="rx-ws">    </span><span class="rx-kw">use</span><span class="rx-ws"> </span><span class="rx-skw">strict</span><span class="rx-ws"> </span><span class="rx-skw">arg</span><span class="rx-ws"> </span><span class="rx-var">quote</span><span class="rx-op">=</span><span class="rx-str rx-oquo">'</span><span class="rx-str">"</span><span class="rx-str rx-cquo">'</span></code>
<code lineno="20"><span class="rx-ws">    </span><span class="rx-kw">if</span><span class="rx-ws"> </span><span class="rx-var">self</span><span class="rx-op">~</span><span class="rx-const rx-method">left</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-op">=</span><span class="rx-op">=</span><span class="rx-ws"> </span><span class="rx-var">quote</span><span class="rx-ws"> </span><span class="rx-op">&amp;</span><span class="rx-ws"> </span><span class="rx-var">self</span><span class="rx-op">~</span><span class="rx-const rx-method">right</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-op">=</span><span class="rx-op">=</span><span class="rx-ws"> </span><span class="rx-var">quote</span><span class="rx-ws"> </span><span class="rx-kw">then</span></code>
<code lineno="21"><span class="rx-ws">        </span><span class="rx-kw">return</span><span class="rx-ws"> </span><span class="rx-var">self</span><span class="rx-op">~</span><span class="rx-const rx-method">substr</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">2</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">self</span><span class="rx-op">~</span><span class="rx-const rx-method">length</span><span class="rx-ws"> </span><span class="rx-op">-</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">2</span><span class="rx-spe">)</span><span class="rx-op">~</span><span class="rx-const rx-method">changeStr</span><span class="rx-spe">(</span><span class="rx-var">quote</span><span class="rx-op">|</span><span class="rx-op">|</span><span class="rx-var">quote</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">quote</span><span class="rx-spe">)</span></code>
<code lineno="22"><span class="rx-ws">    </span><span class="rx-kw">else</span></code>
<code lineno="23"><span class="rx-ws">        </span><span class="rx-kw">return</span><span class="rx-ws"> </span><span class="rx-var">self</span>
</code></pre>
</div>
<!-- ------------------------------- -->
<h3 id="extension-directive">2.3.   ::extension directive</h3>
<!-- ------------------------------- -->
<pre><code>&gt;&gt;-::EXTENSION--classname----+-------------------+-----------------&gt;&lt;
                             +-INHERIT--iclasses-+</code></pre>
<p>This directive delegates to the <code>.class~define</code> and
<code>.class~inherit</code> methods.</p>
<p>Two forms of extension are possible:</p>
<ul>
<li>Direct extension (using <code>.class~define</code>)</li>
<li>Inherited extension (using <code>.class~inherit</code>)</li>
</ul>
<p>When the extensions of a package are installed, the
<code>extension</code> methods and the <code>inherit</code> declarations
of each <code>::extension</code> are processed in the order of
declaration.<br />
Each package is installed separately, this is the standard
behaviour.</p>
<p>The visibility rules for classes are also standard, nothing special
for extensions.<br />
Each package has its own visibility on classes.</p>
<p>Implementation (copy-paste of the ::class directive, with
adaptations):<br />
<a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/trunk/interpreter/instructions/ExtensionDirective.hpp">ExtensionDirective.hpp</a><br />
<a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/trunk/interpreter/instructions/ExtensionDirective.cpp">ExtensionDirective.cpp</a></p>
<p><span class="citation" data-cites="JMB">@JMB</span><br />
The equivalent of your <a
href="https://rexx.epbcn.com/rexx-parser/bin/modules/Load.Parser.Module.rex">Load.Parser.Module.rex</a>
is <a
href="https://github.com/jlfaucher/executor/blob/b6c255eabab3f75068c5956f7803ec6aeda66ce0/sandbox/jlf/trunk/interpreter/instructions/ExtensionDirective.cpp#L175-L183">ExtensionDirective::install</a>.</p>
<!-- ------------------------------- -->
<h4 id="direct-extension">2.3.1.   Direct extension</h4>
<!-- ------------------------------- -->
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-dir">::</span><span class="rx-dkw">extension</span><span class="rx-ws"> </span><span class="rx-const rx-class">myClass</span></code>
<code lineno="2"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">myMethod</span>
</code></pre>
</div>
<p>The following rules describe the current implementation in Executor
(no collision detection).<br />
They probably need to be modified to meet the JMB's requirement for
collisions:<br />
<em>For every such method "C::newM", it picks the class object
corresponding to C, checks if C already has a method "newM", complains
if this is the case, and uses the define method of the C class to add
newM to C.</em><br />
In <a
href="https://github.com/jlfaucher/executor/blob/b6c255eabab3f75068c5956f7803ec6aeda66ce0/sandbox/jlf/packages/extension/string.cls#L8-L10">rare
cases</a>, nevertheless, the collision is not an error (method
override). Can still be done using ~define.<br />
Collision detection would not generate any errors with current Executor
packages, so it could be enabled unconditionally.</p>
<p><strong>Executor rules</strong></p>
<p>If the same method appears multiple times in a given ::extension
directive, it's an error (because that's how it is with ::class).</p>
<pre><code>::class myClass
::extension myClass
::method myMethod
::method myMethod   -- Error 99.902:  Duplicate ::METHOD directive instruction.</code></pre>
<p>If the same method appears in multiple <code>::extension</code>
directives in the same package, there is no error.<br />
The newer one replaces the older one (because <code>define</code> works
like that).</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-env">.myclass</span><span class="rx-op">~</span><span class="rx-const rx-method">new</span><span class="rx-op">~</span><span class="rx-const rx-method">myMethod</span><span class="rx-ws">   </span><span class="rx-lncm">-- 2</span></code>
<code lineno="2"><span class="rx-dir">::</span><span class="rx-dkw">class</span><span class="rx-ws"> </span><span class="rx-const rx-class">myClass</span></code>
<code lineno="3"><span class="rx-dir">::</span><span class="rx-dkw">extension</span><span class="rx-ws"> </span><span class="rx-const rx-class">myClass</span></code>
<code lineno="4"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">myMethod</span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1</span></code>
<code lineno="5"><span class="rx-dir">::</span><span class="rx-dkw">extension</span><span class="rx-ws"> </span><span class="rx-const rx-class">myClass</span></code>
<code lineno="6"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">myMethod</span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">2</span>
</code></pre>
</div>
<p>If the same method appears in multiple <code>::extension</code>
directives in different packages, there is no error.<br />
The "last" extension wins.<br />
The definition of "last" depends on the resolution order of
<code>::requires</code>.<br />
See <a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/tests/extension/test_extension_order.rex">test_extension_order.rex</a><br />
See <a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/tests/extension/test_extension_order.output.reference.txt">test_extension_order.output.reference.txt</a></p>
<!-- ------------------------------- -->
<h4 id="inherited-extension">2.3.2.   Inherited extension</h4>
<!-- ------------------------------- -->
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-dir">::</span><span class="rx-dkw">extension</span><span class="rx-ws"> </span><span class="rx-const rx-class">myClass</span><span class="rx-ws"> </span><span class="rx-dskw">inherit</span><span class="rx-ws"> </span><span class="rx-const rx-class">myExtension</span>
</code></pre>
</div>
<p>It's possible to extend a class multiple times in the same
package.</p>
<p><strong>SourceFile.cls</strong></p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-dir">::</span><span class="rx-dkw">class</span><span class="rx-ws"> </span><span class="rx-const rx-class">myExtension1</span><span class="rx-ws"> </span><span class="rx-dskw">mixinclass</span><span class="rx-ws"> </span><span class="rx-const rx-class">Object</span></code>
<code lineno="2"><span class="rx-dir">::</span><span class="rx-dkw">extension</span><span class="rx-ws"> </span><span class="rx-const rx-class">myClass</span><span class="rx-ws"> </span><span class="rx-dskw">inherit</span><span class="rx-ws"> </span><span class="rx-const rx-class">myExtension1</span></code>
<code lineno="3"></code>
<code lineno="4"><span class="rx-dir">::</span><span class="rx-dkw">class</span><span class="rx-ws"> </span><span class="rx-const rx-class">myExtension2</span><span class="rx-ws"> </span><span class="rx-dskw">mixinclass</span><span class="rx-ws"> </span><span class="rx-const rx-class">Object</span></code>
<code lineno="5"><span class="rx-dir">::</span><span class="rx-dkw">extension</span><span class="rx-ws"> </span><span class="rx-const rx-class">myClass</span><span class="rx-ws"> </span><span class="rx-dskw">inherit</span><span class="rx-ws"> </span><span class="rx-const rx-class">myExtension2</span>
</code></pre>
</div>
<p>It's possible to extend a class in different packages.</p>
<p><strong>main.rexx</strong></p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-env">.myClass</span><span class="rx-op">~</span><span class="rx-const rx-method">new</span></code>
<code lineno="2"></code>
<code lineno="3"><span class="rx-dir">::</span><span class="rx-dkw">requires</span><span class="rx-ws"> </span><span class="rx-const rx-requires rx-oquo">"</span><span class="rx-const rx-requires">SourceFile1.cls</span><span class="rx-const rx-requires rx-cquo">"</span></code>
<code lineno="4"><span class="rx-dir">::</span><span class="rx-dkw">requires</span><span class="rx-ws"> </span><span class="rx-const rx-requires rx-oquo">"</span><span class="rx-const rx-requires">SourceFile2.cls</span><span class="rx-const rx-requires rx-cquo">"</span>
</code></pre>
</div>
<p><strong>SourceFile1.cls</strong></p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-dir">::</span><span class="rx-dkw">class</span><span class="rx-ws"> </span><span class="rx-const rx-class">myExtension</span><span class="rx-ws"> </span><span class="rx-dskw">mixinclass</span><span class="rx-ws"> </span><span class="rx-const rx-class">Object</span></code>
<code lineno="2"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">init</span></code>
<code lineno="3"><span class="rx-ws">    </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">init myExtension from SourceFile1</span><span class="rx-str rx-cquo">"</span></code>
<code lineno="4"><span class="rx-ws">    </span><span class="rx-kw">forward</span><span class="rx-ws"> </span><span class="rx-skw">class</span><span class="rx-ws"> </span><span class="rx-spe">(</span><span class="rx-var">super</span><span class="rx-spe">)</span></code>
<code lineno="5"></code>
<code lineno="6"><span class="rx-dir">::</span><span class="rx-dkw">requires</span><span class="rx-ws"> </span><span class="rx-const rx-requires rx-oquo">"</span><span class="rx-const rx-requires">myClass.cls</span><span class="rx-const rx-requires rx-cquo">"</span></code>
<code lineno="7"><span class="rx-dir">::</span><span class="rx-dkw">extension</span><span class="rx-ws"> </span><span class="rx-const rx-class">myClass</span><span class="rx-ws"> </span><span class="rx-dskw">inherit</span><span class="rx-ws"> </span><span class="rx-const rx-class">myExtension</span>
</code></pre>
</div>
<p><strong>SourceFile2.cls</strong></p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-dir">::</span><span class="rx-dkw">class</span><span class="rx-ws"> </span><span class="rx-const rx-class">myExtension</span><span class="rx-ws"> </span><span class="rx-dskw">mixinclass</span><span class="rx-ws"> </span><span class="rx-const rx-class">Object</span></code>
<code lineno="2"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">init</span></code>
<code lineno="3"><span class="rx-ws">    </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">init myExtension from SourceFile2</span><span class="rx-str rx-cquo">"</span></code>
<code lineno="4"><span class="rx-ws">    </span><span class="rx-kw">forward</span><span class="rx-ws"> </span><span class="rx-skw">class</span><span class="rx-ws"> </span><span class="rx-spe">(</span><span class="rx-var">super</span><span class="rx-spe">)</span></code>
<code lineno="5"></code>
<code lineno="6"><span class="rx-dir">::</span><span class="rx-dkw">requires</span><span class="rx-ws"> </span><span class="rx-const rx-requires rx-oquo">"</span><span class="rx-const rx-requires">myClass.cls</span><span class="rx-const rx-requires rx-cquo">"</span></code>
<code lineno="7"><span class="rx-dir">::</span><span class="rx-dkw">extension</span><span class="rx-ws"> </span><span class="rx-const rx-class">myClass</span><span class="rx-ws"> </span><span class="rx-dskw">inherit</span><span class="rx-ws"> </span><span class="rx-const rx-class">myExtension</span>
</code></pre>
</div>
<p><strong>myClass.cls</strong></p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-dir">::</span><span class="rx-dkw">class</span><span class="rx-ws"> </span><span class="rx-const rx-class">myClass</span><span class="rx-ws"> </span><span class="rx-dskw">public</span></code>
<code lineno="2"></code>
<code lineno="3"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">init</span></code>
<code lineno="4"><span class="rx-ws">    </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">init myClass</span><span class="rx-str rx-cquo">"</span></code>
<code lineno="5"><span class="rx-ws">    </span><span class="rx-kw">forward</span><span class="rx-ws"> </span><span class="rx-skw">class</span><span class="rx-ws"> </span><span class="rx-spe">(</span><span class="rx-var">super</span><span class="rx-spe">)</span>
</code></pre>
</div>
<p>display</p>
<pre><code>init myClass
init myExtension from SourceFile1
init myExtension from SourceFile2</code></pre>
<!-- ------------------------------- -->
<h5 id="the-class-object-cannot-inherit-from-itself">2.3.2.1.   The
class 'Object' cannot inherit from itself"</h5>
<!-- ------------------------------- -->
<p>I would like to write</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-dir">::</span><span class="rx-dkw">extension</span><span class="rx-ws"> </span><span class="rx-const rx-class">Object</span><span class="rx-ws"> </span><span class="rx-dskw">inherit</span><span class="rx-ws"> </span><span class="rx-const rx-class">ObjectUserData</span><span class="rx-ws"> </span><span class="rx-const rx-class">ObjectPrettyPrinter</span>
</code></pre>
</div>
<p>instead of <a
href="https://github.com/jlfaucher/executor/blob/b6c255eabab3f75068c5956f7803ec6aeda66ce0/sandbox/jlf/packages/extension/object.cls#L2">that</a>,
but the <code>Object</code> class cannot inherit from a mixin
class.<br />
Error "Class 'Object' cannot inherit from itself".</p>
<p>For the classes other than <code>Object</code>, Executor uses only
inherited extensions.<br />
Example:<br />
<a
href="https://github.com/jlfaucher/executor/blob/b6c255eabab3f75068c5956f7803ec6aeda66ce0/sandbox/jlf/packages/extension/string.cls#L15-L17">String</a>
in <code>string.cls</code><br />
<a
href="https://github.com/jlfaucher/executor/blob/b6c255eabab3f75068c5956f7803ec6aeda66ce0/sandbox/jlf/packages/extension/text.cls#L11-L12">String</a>
in <code>text.cls</code></p>
<!-- ------------------------------- -->
<h3 id="extensions-capabilities">2.4.   Extensions capabilities</h3>
<!-- ------------------------------- -->
<p>Extensions belong to the extended classes.<br />
They have access to encapsulated datas and private methods.</p>
<!-- ------------------------------- -->
<h4 id="access-to-encapsulated-datas">2.4.1.   Access to encapsulated
datas</h4>
<!-- ------------------------------- -->
<p>The main variables pool is accessible from a direct extension
method.<br />
The inherited extension methods have their own variables pool.<br />
This is a standard feature.</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-var">o</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-env">.myClass</span><span class="rx-op">~</span><span class="rx-const rx-method">new</span></code>
<code lineno="2"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">o</span><span class="rx-op">~</span><span class="rx-const rx-method">myVar</span><span class="rx-ws">                         </span><span class="rx-lncm">-- 0</span></code>
<code lineno="3"><span class="rx-var">o</span><span class="rx-op">~</span><span class="rx-const rx-method">update</span><span class="rx-ws">                            </span><span class="rx-lncm">-- direct extension</span></code>
<code lineno="4"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">o</span><span class="rx-op">~</span><span class="rx-const rx-method">myVar</span><span class="rx-ws">                         </span><span class="rx-lncm">-- 1 (main pool updated)</span></code>
<code lineno="5"><span class="rx-var">o</span><span class="rx-op">~</span><span class="rx-const rx-method">update</span><span class="rx-spe">:</span><span class="rx-env">.myExtension</span><span class="rx-ws">               </span><span class="rx-lncm">-- inherited extension</span></code>
<code lineno="6"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">o</span><span class="rx-op">~</span><span class="rx-const rx-method">myVar</span><span class="rx-ws">                         </span><span class="rx-lncm">-- 1 (main pool unchanged)</span></code>
<code lineno="7"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">o</span><span class="rx-op">~</span><span class="rx-const rx-method">myVar</span><span class="rx-spe">:</span><span class="rx-env">.myExtension</span><span class="rx-ws">            </span><span class="rx-lncm">-- 2</span></code>
<code lineno="8"></code>
<code lineno="9"><span class="rx-dir">::</span><span class="rx-dkw">class</span><span class="rx-ws"> </span><span class="rx-const rx-class">myClass</span></code>
<code lineno="10"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">init</span></code>
<code lineno="11"><span class="rx-ws">    </span><span class="rx-kw">expose</span><span class="rx-ws"> </span><span class="rx-xvar">myVar</span></code>
<code lineno="12"><span class="rx-ws">    </span><span class="rx-xvar">myVar</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">0</span></code>
<code lineno="13"><span class="rx-dir">::</span><span class="rx-dkw">attribute</span><span class="rx-ws"> </span><span class="rx-const rx-method">myVar</span><span class="rx-ws"> </span><span class="rx-dskw">get</span></code>
<code lineno="14"></code>
<code lineno="15"><span class="rx-lncm">-- Direct extension</span></code>
<code lineno="16"><span class="rx-dir">::</span><span class="rx-dkw">extension</span><span class="rx-ws"> </span><span class="rx-const rx-class">myClass</span></code>
<code lineno="17"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">update</span></code>
<code lineno="18"><span class="rx-ws">    </span><span class="rx-lncm">-- direct access to the main pool</span></code>
<code lineno="19"><span class="rx-ws">    </span><span class="rx-kw">expose</span><span class="rx-ws"> </span><span class="rx-xvar">myVar</span></code>
<code lineno="20"><span class="rx-ws">    </span><span class="rx-xvar">myVar</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1</span></code>
<code lineno="21"></code>
<code lineno="22"><span class="rx-lncm">-- Inherited extension</span></code>
<code lineno="23"><span class="rx-dir">::</span><span class="rx-dkw">class</span><span class="rx-ws"> </span><span class="rx-const rx-class">myExtension</span><span class="rx-ws"> </span><span class="rx-dskw">mixinclass</span><span class="rx-ws"> </span><span class="rx-const rx-class">Object</span></code>
<code lineno="24"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">update</span></code>
<code lineno="25"><span class="rx-ws">    </span><span class="rx-lncm">-- the variable pool is specific to this mixin class</span></code>
<code lineno="26"><span class="rx-ws">    </span><span class="rx-kw">expose</span><span class="rx-ws"> </span><span class="rx-xvar">myVar</span></code>
<code lineno="27"><span class="rx-ws">    </span><span class="rx-xvar">myVar</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">2</span></code>
<code lineno="28"><span class="rx-dir">::</span><span class="rx-dkw">attribute</span><span class="rx-ws"> </span><span class="rx-const rx-method">myVar</span><span class="rx-ws"> </span><span class="rx-dskw">get</span></code>
<code lineno="29"></code>
<code lineno="30"><span class="rx-dir">::</span><span class="rx-dkw">extension</span><span class="rx-ws"> </span><span class="rx-const rx-class">myClass</span><span class="rx-ws"> </span><span class="rx-dskw">inherit</span><span class="rx-ws"> </span><span class="rx-const rx-class">myExtension</span>
</code></pre>
</div>
<!-- ------------------------------- -->
<h4 id="access-to-private-methods">2.4.2.   Access to private
methods</h4>
<!-- ------------------------------- -->
<h5
id="private-methods-are-accessible-from-a-method-added-by-extension">2.4.2.1.   Private
methods are accessible from a method added by extension</h5>
<p>This is a standard feature.</p>
<p><strong>main.rex</strong></p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-var">o</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-env">.myClass</span><span class="rx-op">~</span><span class="rx-const rx-method">new</span></code>
<code lineno="2"><span class="rx-var">o</span><span class="rx-op">~</span><span class="rx-const rx-method">publicMethod</span></code>
<code lineno="3"><span class="rx-lncm">-- o~packageMethod                  -- not accessible</span></code>
<code lineno="4"><span class="rx-lncm">-- o~privateMethod                  -- not accessible</span></code>
<code lineno="5"><span class="rx-var">o</span><span class="rx-op">~</span><span class="rx-const rx-method">extendedMethod</span></code>
<code lineno="6"></code>
<code lineno="7"><span class="rx-dir">::</span><span class="rx-dkw">extension</span><span class="rx-ws"> </span><span class="rx-const rx-class">myClass</span></code>
<code lineno="8"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">extendedMethod</span></code>
<code lineno="9"><span class="rx-ws">    </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">execute extendedMethod</span><span class="rx-str rx-cquo">"</span></code>
<code lineno="10"><span class="rx-ws">    </span><span class="rx-lncm">-- self~packageMethod           -- not accessible</span></code>
<code lineno="11"><span class="rx-ws">    </span><span class="rx-var">self</span><span class="rx-op">~</span><span class="rx-const rx-method">privateMethod</span></code>
<code lineno="12"></code>
<code lineno="13"><span class="rx-dir">::</span><span class="rx-dkw">requires</span><span class="rx-ws"> </span><span class="rx-const rx-requires rx-oquo">"</span><span class="rx-const rx-requires">SourceFile.cls</span><span class="rx-const rx-requires rx-cquo">"</span>
</code></pre>
</div>
<p><strong>SourceFile.cls</strong></p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-dir">::</span><span class="rx-dkw">class</span><span class="rx-ws"> </span><span class="rx-const rx-class">myClass</span><span class="rx-ws"> </span><span class="rx-dskw">public</span></code>
<code lineno="2"></code>
<code lineno="3"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">publicMethod</span><span class="rx-ws"> </span><span class="rx-dskw">public</span></code>
<code lineno="4"><span class="rx-ws">    </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">execute publicMethod</span><span class="rx-str rx-cquo">"</span></code>
<code lineno="5"></code>
<code lineno="6"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">packageMethod</span><span class="rx-ws"> </span><span class="rx-dskw">package</span></code>
<code lineno="7"><span class="rx-ws">    </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">execute packageMethod</span><span class="rx-str rx-cquo">"</span></code>
<code lineno="8"></code>
<code lineno="9"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">privateMethod</span><span class="rx-ws"> </span><span class="rx-dskw">private</span></code>
<code lineno="10"><span class="rx-ws">    </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">execute privateMethod</span><span class="rx-str rx-cquo">"</span>
</code></pre>
</div>
<p>display</p>
<pre><code>execute publicMethod
execute extendedMethod
execute privateMethod</code></pre>
<h5 id="private-methods-of-predefined-classes">2.4.2.2.   Private
methods of predefined classes</h5>
<p>When using an unlocked extension method, the private methods of a
predefined class are <a
href="https://github.com/jlfaucher/executor/blob/b6c255eabab3f75068c5956f7803ec6aeda66ce0/sandbox/jlf/packages/extension/doers.cls#L421-L424">accessible</a>.</p>
<h5 id="package-scope-methods">2.4.2.3.   Package-scope methods</h5>
<p>Package-scope methods are not accessible when the extension is made
from a different package.<br />
This is a standard feature but surprising when the extension method and
the package-scope method are in the same class...<br />
A method defined in a C class should have access to all methods in the C
class.<br />
Reproductible without extensions:</p>
<p><strong>main.rex</strong></p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-env">.myClass</span><span class="rx-op">~</span><span class="rx-const rx-method">define</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">extendedMethod</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-env">.methods</span><span class="rx-spe">[</span><span class="rx-str rx-oquo">"</span><span class="rx-str">EXTENDEDMETHOD</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">]</span><span class="rx-spe">)</span></code>
<code lineno="2"><span class="rx-var">o</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-env">.myClass</span><span class="rx-op">~</span><span class="rx-const rx-method">new</span></code>
<code lineno="3"><span class="rx-var">o</span><span class="rx-op">~</span><span class="rx-const rx-method">extendedMethod</span></code>
<code lineno="4"></code>
<code lineno="5"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">extendedMethod</span></code>
<code lineno="6"><span class="rx-ws">    </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">execute extendedMethod</span><span class="rx-str rx-cquo">"</span></code>
<code lineno="7"><span class="rx-ws">    </span><span class="rx-lncm">-- self~packageMethod           -- not accessible</span></code>
<code lineno="8"><span class="rx-ws">    </span><span class="rx-var">self</span><span class="rx-op">~</span><span class="rx-const rx-method">privateMethod</span></code>
<code lineno="9"></code>
<code lineno="10"><span class="rx-dir">::</span><span class="rx-dkw">requires</span><span class="rx-ws"> </span><span class="rx-const rx-requires rx-oquo">"</span><span class="rx-const rx-requires">SourceFile.cls</span><span class="rx-const rx-requires rx-cquo">"</span>
</code></pre>
</div>
<!-- ======================================================================= -->
<h2 id="tokenizer">3.   Tokenizer</h2>
<!-- ======================================================================= -->
<p>Support this notation:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-int rx-ipart">1</span><span class="rx-op">+</span><span class="rx-int rx-ipart">2</span><span class="rx-var">i</span>
</code></pre>
</div>
<p>where <code>i</code> is an instance of
<code>the Complex class</code>.</p>
<p>The tokenizer has been modified to split a symbol of the form
<code>&lt;number&gt;&lt;after number&gt;</code> in two distinct
tokens.</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-int rx-ipart">2</span><span class="rx-var">a</span><span class="rx-ws">      </span><span class="rx-lncm">-- is the number 2 followed by the symbol `a`.  </span></code>
<code lineno="2"><span class="rx-int rx-ipart">2</span><span class="rx-var">a2b</span><span class="rx-ws">    </span><span class="rx-lncm">-- is the number 2 followed by the symbol `a2b`.  </span></code>
<code lineno="3"><span class="rx-exp rx-ipart">2</span><span class="rx-exp rx-emark">e</span><span class="rx-exp rx-expon">1</span><span class="rx-var">a2b</span><span class="rx-ws">  </span><span class="rx-lncm">-- is the number 2e1 followed by the symbol `a2b`.</span>
</code></pre>
</div>
<p>The rule is to stop immediatly after a VALID number, where a VALID
number is such as <code>datatype(number) = "NUM"</code>.</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-int rx-ipart">2</span><span class="rx-var">e</span><span class="rx-ws">      </span><span class="rx-lncm">-- is scanned as number `2` followed by symbol `E` because `datatype(2e)` is `CHAR`, not `NUM`.</span></code>
<code lineno="2"><span class="rx-ws">        </span><span class="rx-lncm">-- So only `2` is a VALID number.  </span></code>
<code lineno="3"><span class="rx-ws">        </span><span class="rx-lncm">-- In official ooRexx, this is scanned as symbol `2E`.</span>
</code></pre>
</div>
<pre><code>2e+     -- is scanned as number `2` followed by symbol `E` followed by operator `+`.  
        -- In official ooRexx, this is scanned as symbol `2E` followed by operator `+`.
        -- In both cases, this expression is invalid.</code></pre>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-exp rx-ipart">2</span><span class="rx-exp rx-emark">e</span><span class="rx-exp rx-expon">1</span><span class="rx-ws">     </span><span class="rx-lncm">-- is scanned as number `2E1`, same as official ooRexx.</span>
</code></pre>
</div>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-exp rx-ipart">2</span><span class="rx-exp rx-emark">e</span><span class="rx-exp rx-esign">+</span><span class="rx-exp rx-expon">1</span><span class="rx-ws">    </span><span class="rx-lncm">-- is scanned as number `2E+1`, same as official ooRexx</span>
</code></pre>
</div>
<p>An abuttal operator is inserted to re-concatenate
<code>&lt;number&gt;</code> with
<code>&lt;after number&gt;</code>.<br />
In this context, the precedence of this abuttal operator is very high,
to ensure both tokens are always linked together.</p>
<p>The end-user can provide his own implementation for abuttal, using
the alternative operator's message <code>"OP:RIGHT"</code>.<br />
This is how <code>2i</code> can become <code>2 * .Complex~i</code> when
<code>complex.cls</code> is loaded.<br />
Thanks to the high precedence in this context, <code>1+2i</code> is
parsed as <code>1+(2i)</code> instead of <code>(1+2)i</code>.</p>
<p>Legacy programs are impacted when</p>
<ol type="1">
<li><code>&lt;after number&gt;</code> is a valid variable symbol and the
<code>NOVALUE</code> condition is enabled.<br />
</li>
<li>A label starts with a number:</li>
</ol>
<pre><code>    signal 2a                   -- Data must not follow the SIGNAL label name; found &quot;&quot;
    2a:                         -- Incorrect expression detected at &quot;:&quot;
    do i=1 to 5; say i; end 2a  -- Data must not follow the END control variable name; found &quot;&quot;</code></pre>
<!-- ======================================================================= -->
<h2 id="parser">4.   Parser</h2>
<!-- ======================================================================= -->
<!-- ------------------------------- -->
<h3 id="refinement-of-tokens-subclass-attribute">4.1.   Refinement of
tokens 'subclass' attribute</h3>
<!-- ------------------------------- -->
<p>The scanner splits a source file in clauses, and decompose each
clause in tokens.<br />
Then the parser creates an AST from the tokens.<br />
The tokens were not annotated by the parser to attach semantic
information found during parsing.<br />
After a discussion with Rony about syntax coloring, I decided to see
which informations could be added to the tokens.<br />
I found that the attribute 'subclass' of the tokens could hold
informations like that:</p>
<pre><code>IS_KEYWORD
IS_SUBKEY
IS_DIRECTIVE
IS_SUBDIRECTIVE
IS_CONDITION
IS_BUILTIN</code></pre>
<p>For the moment, there is no access to the clauses/tokens from an
ooRexx script.<br />
If the environment variable <code>RXTRACE_PARSING=ON</code> then the
clauses and tokens are dumped to the debug output (Windows) or the log
(Unix) using <code>dbgprintf</code>.<br />
Works only with a debug version of ooRexx.</p>
<!-- ------------------------------- -->
<h3 id="arg...">4.2.   <code>arg(...)</code></h3>
<!-- ------------------------------- -->
<p>For good or bad reason, <code>arg(1)</code> at the begining of a
clause is recognized as an instruction, because arg is a keyword
instruction.</p>
<p>I often use source literals like <code>{arg(1)...}</code> where I
want <code>arg(1)</code> to be interpreted as a function call.<br />
So I decided to change the behavior of the parser to interpret as a
function call any symbol followed immediatly by a left paren, even if
the symbol is a keyword instruction.</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-lncm">-- Illustration from ooRexxShell:</span></code>
<code lineno="2"></code>
<code lineno="3"><span class="rx-ws">    </span><span class="rx-const rx-label">executor</span><span class="rx-spe">:</span></code>
<code lineno="4"><span class="rx-ws">    </span><span class="rx-const rx-bif-func">arg</span><span class="rx-spe">(</span><span class="rx-spe">)</span><span class="rx-ws">       </span><span class="rx-lncm">-- bash: 0: command not found</span></code>
<code lineno="5"></code>
<code lineno="6"><span class="rx-ws">    </span><span class="rx-const rx-label">oorexx</span><span class="rx-spe">:</span></code>
<code lineno="7"><span class="rx-ws">    </span><span class="rx-const rx-bif-func">arg</span><span class="rx-spe">(</span><span class="rx-spe">)</span><span class="rx-ws">       </span><span class="rx-lncm">-- Missing expression following "(" of parse template.</span></code>
<code lineno="8"></code>
<code lineno="9"><span class="rx-lncm">-- Not just arg! ALL the keywords are impacted.</span></code>
<code lineno="10"></code>
<code lineno="11"><span class="rx-ws">    </span><span class="rx-const rx-label">executor</span><span class="rx-spe">:</span></code>
<code lineno="12"><span class="rx-ws">    </span><span class="rx-const rx-ext-func">drop</span><span class="rx-spe">(</span><span class="rx-spe">)</span><span class="rx-ws">      </span><span class="rx-lncm">-- Could not find routine "DROP"</span></code>
<code lineno="13"></code>
<code lineno="14"><span class="rx-ws">    </span><span class="rx-const rx-label">oorexx</span><span class="rx-spe">:</span></code>
<code lineno="15"><span class="rx-ws">    </span><span class="rx-const rx-ext-func">drop</span><span class="rx-spe">(</span><span class="rx-spe">)</span><span class="rx-ws">      </span><span class="rx-lncm">-- Symbol expected after "(" of a variable reference.</span>
</code></pre>
</div>
<!-- ------------------------------- -->
<h3 id="section">4.3.   <code>=</code> <code>==</code></h3>
<!-- ------------------------------- -->
<p>With implicit return, such an expression is quite common when
filtering: <code>item==1</code></p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-env">.array</span><span class="rx-op">~</span><span class="rx-const rx-method">of</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">,</span><span class="rx-int rx-ipart">2</span><span class="rx-spe">,</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">)</span><span class="rx-op">~</span><span class="rx-const rx-method">pipe</span><span class="rx-spe">(</span><span class="rx-env">.select</span><span class="rx-op"> </span><span class="rx-spe">{</span><span class="rx-var">item</span><span class="rx-op">=</span><span class="rx-op">=</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">}</span><span class="rx-ws"> </span><span class="rx-op">|</span><span class="rx-ws"> </span><span class="rx-env">.console</span><span class="rx-spe">)</span>
</code></pre>
</div>
<p>but the parser raises an error to protect the user against a
potential typo error, assuming the user wanted to enter
<code>item=1</code>.</p>
<p>I deactivated this control, now the expression above is ok.<br />
Modified <a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/trunk/interpreter/parser/SourceFile.cpp">SourceFile.cpp</a>,
<code>RexxSource::instruction</code></p>
<p>Yes, it remains a problem (no syntax error, but it's an assignment,
not a test):</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-env">.array</span><span class="rx-op">~</span><span class="rx-const rx-method">of</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">,</span><span class="rx-int rx-ipart">2</span><span class="rx-spe">,</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">)</span><span class="rx-op">~</span><span class="rx-const rx-method">pipe</span><span class="rx-spe">(</span><span class="rx-env">.select</span><span class="rx-op"> </span><span class="rx-spe">{</span><span class="rx-var">item</span><span class="rx-asg">=</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">}</span><span class="rx-ws"> </span><span class="rx-op">|</span><span class="rx-ws"> </span><span class="rx-env">.console</span><span class="rx-spe">)</span>
</code></pre>
</div>
<p>good point, the lack of returned value is detected, must surround by
parentheses to make it a real expression.</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-env">.array</span><span class="rx-op">~</span><span class="rx-const rx-method">of</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">,</span><span class="rx-int rx-ipart">2</span><span class="rx-spe">,</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">)</span><span class="rx-op">~</span><span class="rx-const rx-method">pipe</span><span class="rx-spe">(</span><span class="rx-env">.select</span><span class="rx-op"> </span><span class="rx-spe">{</span><span class="rx-spe">(</span><span class="rx-var">item</span><span class="rx-op">=</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">)</span><span class="rx-spe">}</span><span class="rx-ws"> </span><span class="rx-op">|</span><span class="rx-ws"> </span><span class="rx-env">.console</span><span class="rx-spe">)</span>
</code></pre>
</div>
<pre><code>    (an Array),1 : 1
    (an Array),3 : 1</code></pre>
<!-- ------------------------------- -->
<h3 id="message-term">4.4.   Message term</h3>
<!-- ------------------------------- -->
<p>Tilde-call message <code>"~()"</code>. The message name can be
omitted, but the list of parameters is mandatory (can be empty).</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-var">target</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-spe">)</span></code>
<code lineno="2"><span class="rx-var">target</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-var">arg1</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">arg2</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-env">...</span><span class="rx-spe">)</span></code>
<code lineno="3"><span class="rx-var">target</span><span class="rx-op">~</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-spe">)</span></code>
<code lineno="4"><span class="rx-var">target</span><span class="rx-op">~</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-var">arg1</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">arg2</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-env">...</span><span class="rx-spe">)</span>
</code></pre>
</div>
<p>When the expression is evaluated, the target receives the message
<code>"~()"</code>.</p>
<pre><code>&gt;&gt;-receiver-+- ~ --+----+---------+----(--+----------------+--)--&gt;&lt;
            +- ~~ -+    +-:symbol-+       | +-,----------+ |
                                          | V            | |
                                          +---expression-+-+</code></pre>
<!-- ======================================================================= -->
<h2 id="clauser">5.   Clauser</h2>
<!-- ======================================================================= -->
<!-- ------------------------------- -->
<h3 id="description">5.1.   Description</h3>
<!-- ------------------------------- -->
<p>The Clauser class is implemented in <a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/trunk/interpreter/RexxClasses/Parser.orx">RexxClasses/Parser.orx</a>.<br />
Used internally by the interpreter when parsing a
RexxSourceLiteral.<br />
Used by ooRexxShell to transform the command line when a clause ends
with <code>'='</code>.</p>
<p>The Clauser works directly on the source array passed at
creation.<br />
It returns only non-empty clauses (unless you modify a clause, see
below).<br />
You can modify the source array by replacing the current clause by a new
one:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-var">myClauser</span><span class="rx-op">~</span><span class="rx-const rx-method">clause</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-var">mySourceFragment</span>
</code></pre>
</div>
<p>The new clause is inserted as-is and not iterated over by the
clauser.<br />
Of course, you can create a new clauser using the modified source, and
then you will iterate over your modified clauses.<br />
While you don't call <code>~nextClause</code>, <code>~clause</code> will
return the last assigned value, which can be anything, like an empty
string or a string containing several clauses.</p>
<p>Exemple:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-var">csource</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-spe">{</span></code>
<code lineno="2"><span class="rx-ws">    </span><span class="rx-var">clause1</span></code>
<code lineno="3"></code>
<code lineno="4"><span class="rx-ws">    </span><span class="rx-var">clause2</span><span class="rx-ws"> </span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-var">clause3</span></code>
<code lineno="5"><span class="rx-ws">    </span><span class="rx-var">clause4</span><span class="rx-ws"> </span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rexx">;</span></code>
<code lineno="6"><span class="rx-ws">    </span><span class="rx-var">clause5a</span><span class="rx-op">,</span><span class="rx-ws"> </span><span class="rx-lncm">-- comment</span></code>
<code lineno="7"><span class="rx-ws">    </span><span class="rx-var">clause5b</span><span class="rx-op"> </span><span class="rx-cm">/* multiline</span></code>
<code lineno="8"><span class="rx-cm">    comment */</span><span class="rx-ws"> </span><span class="rx-var">clause5c</span><span class="rx-ws"> </span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-var">clause6</span></code>
<code lineno="9"><span class="rx-spe">}</span></code>
<code lineno="10"><span class="rx-var">sourceArray</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-var">csource</span><span class="rx-op">~</span><span class="rx-const rx-method">source</span><span class="rx-ws"> </span><span class="rx-lncm">-- Each time you call this method, you get a copy of the original source literal</span></code>
<code lineno="11"></code>
<code lineno="12"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">Iterate over the original source:</span><span class="rx-str rx-cquo">"</span></code>
<code lineno="13"><span class="rx-var">i</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1</span></code>
<code lineno="14"><span class="rx-kw">do</span><span class="rx-ws"> </span><span class="rx-var">sourceLine</span><span class="rx-ws"> </span><span class="rx-skw">over</span><span class="rx-ws"> </span><span class="rx-var">sourceArray</span></code>
<code lineno="15"><span class="rx-ws">    </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">i</span><span class="rx-op"> </span><span class="rx-str rx-oquo">'</span><span class="rx-str">"</span><span class="rx-str rx-cquo">'</span><span class="rx-var">sourceLine</span><span class="rx-str rx-oquo">'</span><span class="rx-str">"</span><span class="rx-str rx-cquo">'</span></code>
<code lineno="16"><span class="rx-ws">    </span><span class="rx-var">i</span><span class="rx-ws"> </span><span class="rx-asg">+</span><span class="rx-asg">=</span><span class="rx-int rx-ipart">1</span></code>
<code lineno="17"><span class="rx-kw">end</span></code>
<code lineno="18"></code>
<code lineno="19"><span class="rx-kw">say</span></code>
<code lineno="20"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">Iterate over the clauses, surround clause2, remove clause3, shrink clause5:</span><span class="rx-str rx-cquo">"</span></code>
<code lineno="21"><span class="rx-var">clauser</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-env">.Clauser</span><span class="rx-op">~</span><span class="rx-const rx-method">new</span><span class="rx-spe">(</span><span class="rx-var">sourceArray</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-lncm">-- The clauser works directly on this source array, no copy</span></code>
<code lineno="22"><span class="rx-var">i</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1</span></code>
<code lineno="23"><span class="rx-kw">do</span><span class="rx-ws"> </span><span class="rx-skw">while</span><span class="rx-ws"> </span><span class="rx-var">clauser</span><span class="rx-op">~</span><span class="rx-const rx-method">clauseAvailable</span></code>
<code lineno="24"><span class="rx-ws">    </span><span class="rx-var">clause</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-var">clauser</span><span class="rx-op">~</span><span class="rx-const rx-method">clause</span></code>
<code lineno="25"><span class="rx-ws">    </span><span class="rx-kw">if</span><span class="rx-ws"> </span><span class="rx-var">clause</span><span class="rx-op">~</span><span class="rx-const rx-method">match</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">clause2</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-kw">then</span><span class="rx-ws"> </span><span class="rx-var">clauser</span><span class="rx-op">~</span><span class="rx-const rx-method">clause</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">clause2 before ; </span><span class="rx-str rx-cquo">"</span><span class="rx-var">clause</span><span class="rx-str rx-oquo">"</span><span class="rx-str"> ; clause2 after</span><span class="rx-str rx-cquo">"</span></code>
<code lineno="26"><span class="rx-ws">    </span><span class="rx-kw">if</span><span class="rx-ws"> </span><span class="rx-var">clause</span><span class="rx-op">~</span><span class="rx-const rx-method">match</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">clause3</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-kw">then</span><span class="rx-ws"> </span><span class="rx-var">clauser</span><span class="rx-op">~</span><span class="rx-const rx-method">clause</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str"></span><span class="rx-str rx-cquo">"</span></code>
<code lineno="27"><span class="rx-ws">    </span><span class="rx-kw">if</span><span class="rx-ws"> </span><span class="rx-var">clause</span><span class="rx-op">~</span><span class="rx-const rx-method">match</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">clause5</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-kw">then</span><span class="rx-ws"> </span><span class="rx-var">clauser</span><span class="rx-op">~</span><span class="rx-const rx-method">clause</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">clause5</span><span class="rx-str rx-cquo">"</span></code>
<code lineno="28"><span class="rx-ws">    </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">i</span><span class="rx-op"> </span><span class="rx-str rx-oquo">'</span><span class="rx-str">"</span><span class="rx-str rx-cquo">'</span><span class="rx-var">clause</span><span class="rx-str rx-oquo">'</span><span class="rx-str">" --&gt; "</span><span class="rx-str rx-cquo">'</span><span class="rx-var">clauser</span><span class="rx-op">~</span><span class="rx-const rx-method">clause</span><span class="rx-str rx-oquo">'</span><span class="rx-str">"</span><span class="rx-str rx-cquo">'</span></code>
<code lineno="29"><span class="rx-ws">    </span><span class="rx-var">clauser</span><span class="rx-op">~</span><span class="rx-const rx-method">nextClause</span></code>
<code lineno="30"><span class="rx-ws">    </span><span class="rx-var">i</span><span class="rx-ws"> </span><span class="rx-asg">+</span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1</span></code>
<code lineno="31"><span class="rx-kw">end</span></code>
<code lineno="32"></code>
<code lineno="33"><span class="rx-kw">say</span></code>
<code lineno="34"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">Iterate over the modified source:</span><span class="rx-str rx-cquo">"</span></code>
<code lineno="35"><span class="rx-var">i</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1</span></code>
<code lineno="36"><span class="rx-kw">do</span><span class="rx-ws"> </span><span class="rx-var">sourceLine</span><span class="rx-ws"> </span><span class="rx-skw">over</span><span class="rx-ws"> </span><span class="rx-var">sourceArray</span></code>
<code lineno="37"><span class="rx-ws">    </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">i</span><span class="rx-op"> </span><span class="rx-str rx-oquo">'</span><span class="rx-str">"</span><span class="rx-str rx-cquo">'</span><span class="rx-var">sourceLine</span><span class="rx-str rx-oquo">'</span><span class="rx-str">"</span><span class="rx-str rx-cquo">'</span></code>
<code lineno="38"><span class="rx-ws">    </span><span class="rx-var">i</span><span class="rx-ws"> </span><span class="rx-asg">+</span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1</span></code>
<code lineno="39"><span class="rx-kw">end</span></code>
<code lineno="40"></code>
<code lineno="41"><span class="rx-kw">say</span></code>
<code lineno="42"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">Iterate over the clauses of the modified source:</span><span class="rx-str rx-cquo">"</span></code>
<code lineno="43"><span class="rx-var">clauser</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-env">.Clauser</span><span class="rx-op">~</span><span class="rx-const rx-method">new</span><span class="rx-spe">(</span><span class="rx-var">sourceArray</span><span class="rx-spe">)</span></code>
<code lineno="44"><span class="rx-var">i</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1</span></code>
<code lineno="45"><span class="rx-kw">do</span><span class="rx-ws"> </span><span class="rx-skw">while</span><span class="rx-ws"> </span><span class="rx-var">clauser</span><span class="rx-op">~</span><span class="rx-const rx-method">clauseAvailable</span></code>
<code lineno="46"><span class="rx-ws">    </span><span class="rx-var">clause</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-var">clauser</span><span class="rx-op">~</span><span class="rx-const rx-method">clause</span></code>
<code lineno="47"><span class="rx-ws">    </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">i</span><span class="rx-op"> </span><span class="rx-str rx-oquo">'</span><span class="rx-str">"</span><span class="rx-str rx-cquo">'</span><span class="rx-var">clause</span><span class="rx-str rx-oquo">'</span><span class="rx-str">"</span><span class="rx-str rx-cquo">'</span></code>
<code lineno="48"><span class="rx-ws">    </span><span class="rx-var">clauser</span><span class="rx-op">~</span><span class="rx-const rx-method">nextClause</span></code>
<code lineno="49"><span class="rx-ws">    </span><span class="rx-var">i</span><span class="rx-ws"> </span><span class="rx-asg">+</span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1</span></code>
<code lineno="50"><span class="rx-kw">end</span>
</code></pre>
</div>
<p>Output:</p>
<pre><code>Iterate over the original source:
1 &quot;&quot;
2 &quot;    clause1&quot;
3 &quot;&quot;
4 &quot;    clause2 ; clause3&quot;
5 &quot;    clause4 ; ;&quot;
6 &quot;    clause5a, -- comment&quot;
7 &quot;    clause5b /* multiline&quot;
8 &quot;    comment */ clause5c ; clause6&quot;

Iterate over the clauses, surround clause2, remove clause3, shrink clause5:
1 &quot;clause1&quot; --&gt; &quot;clause1&quot;
2 &quot;clause2&quot; --&gt; &quot;clause2 before ; clause2 ; clause2 after&quot;
3 &quot;clause3&quot; --&gt; &quot;&quot;
4 &quot;clause4&quot; --&gt; &quot;clause4&quot;
5 &quot;clause5a     clause5b  clause5c&quot; --&gt; &quot;clause5&quot;
6 &quot;clause6&quot; --&gt; &quot;clause6&quot;

Iterate over the modified source:
1 &quot;&quot;
2 &quot;    clause1&quot;
3 &quot;&quot;
4 &quot;clause2 before ; clause2 ; clause2 after;&quot;
5 &quot;    clause4 ; ;&quot;
6 &quot;clause5&quot;
7 &quot;&quot;
8 &quot;; clause6&quot;

Iterate over the clauses of the modified source:
1 &quot;clause1&quot;
2 &quot;clause2 before&quot;
3 &quot;clause2&quot;
4 &quot;clause2 after&quot;
5 &quot;clause4&quot;
6 &quot;clause5&quot;
7 &quot;clause6&quot;</code></pre>
<!-- ------------------------------- -->
<h3 id="helper-for-immediate-parsing">5.2.   Helper for immediate
parsing</h3>
<!-- ------------------------------- -->
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-dir">::</span><span class="rx-dkw">class</span><span class="rx-ws"> </span><span class="rx-const rx-class rx-oquo">"</span><span class="rx-const rx-class">Clauser</span><span class="rx-const rx-class rx-cquo">"</span><span class="rx-ws"> </span><span class="rx-dskw">public</span></code>
<code lineno="2"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">rawExecutable</span><span class="rx-ws"> </span><span class="rx-dskw">class</span><span class="rx-ws"> </span><span class="rx-dskw">unguarded</span>
</code></pre>
</div>
<p>For each RexxSourceLiteral created during the parsing, the
interpreter will call this method to get the executable to store on the
RexxSourceLiteral.</p>
<!-- ------------------------------- -->
<h3 id="replace-the-current-clause">5.3.   Replace the current
clause</h3>
<!-- ------------------------------- -->
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method rx-oquo">"</span><span class="rx-const rx-method">clause=</span><span class="rx-const rx-method rx-cquo">"</span>
</code></pre>
</div>
<p>Replace the current clause by the new source fragment (black box, can
be several clauses, won't be scanned).<br />
The new source fragment is always monoline.<br />
The new source fragment is always inserted in the first line of the
current clause.<br />
If the current clause is multiline, then the remaining lines are made
empty.</p>
<!-- ------------------------------- -->
<h3
id="re-implementation-in-oorexx-of-rexxsourcecomment">5.4.   Re-implementation
in ooRexx of <code>RexxSource::comment</code></h3>
<!-- ------------------------------- -->
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">skipComment</span><span class="rx-ws"> </span><span class="rx-dskw">private</span>
</code></pre>
</div>
<p>Re-implementation in ooRexx of the native method
<code>RexxSource::comment</code> which is implemented in <a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/trunk/interpreter/parser/Scanner.cpp">interpreter/parser/scanner.cpp</a></p>
<!-- ------------------------------- -->
<h3
id="re-implementation-in-oorexx-of-rexxsourcelocatetoken">5.5.   Re-implementation
in ooRexx of <code>RexxSource::locateToken</code></h3>
<!-- ------------------------------- -->
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">locateToken</span><span class="rx-ws"> </span><span class="rx-dskw">private</span>
</code></pre>
</div>
<p>Re-implementation in ooRexx of the native method
<code>RexxSource::locateToken</code> which is implemented in <a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/trunk/interpreter/parser/Scanner.cpp">interpreter/parser/scanner.cpp</a></p>
<!-- ------------------------------- -->
<h3
id="re-implementation-in-oorexx-of-rexxsourcenextspecial">5.6.   Re-implementation
in ooRexx of <code>RexxSource::nextSpecial</code></h3>
<!-- ------------------------------- -->
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">nextSpecial</span><span class="rx-ws"> </span><span class="rx-dskw">private</span>
</code></pre>
</div>
<p>Re-implementation in ooRexx of the native method
<code>RexxSource::nextSpecial</code> which is implemented in <a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/trunk/interpreter/parser/Scanner.cpp">interpreter/parser/scanner.cpp</a></p>
<!-- ------------------------------- -->
<h3
id="re-implementation-in-oorexx-of-a-subset-of-rexxsourcesourcenexttoken">5.7.   Re-implementation
in ooRexx of a subset of <code>RexxSource::sourceNextToken</code></h3>
<!-- ------------------------------- -->
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">sourceNextToken</span>
</code></pre>
</div>
<p>Re-implementation in ooRexx of a subset of the native method
<code>RexxSource::sourceNextToken</code> which is implemented in <a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/trunk/interpreter/parser/Scanner.cpp">interpreter/parser/scanner.cpp</a><br />
I don't need to get ALL the tokens, I just need to skip them correctly
(in particular strings and source literal).<br />
The comments and continuation characters are also properly
supported.<br />
Possible result: <code>.nil</code> (end of source),
<code>TOKEN_EOC</code> (end of clause), <code>TOKEN_OTHER</code>.<br />
The clause is built incrementally, accumulating all the characters,
except comments.<br />
The line continuations are removed, replaced by a blank.<br />
So a clause is always monoline, even if it's distributed on several
lines in the source.</p>
<!-- ------------------------------- -->
<h3 id="helper-for-immediate-parsing.">5.8.   Helper for immediate
parsing.</h3>
<!-- ------------------------------- -->
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">kind</span>
</code></pre>
</div>
<p>For each <code>RexxSourceLiteral</code> created during the parsing,
the interpreter will call this method to get the kind of executable to
store on the RexxSourceLiteral.</p>
<p>If the first word is <code>::co[activity]</code> then remove this
word and remember it's a coactive routine: "r.co".<br />
If the first clause is an expose clause then it's a coactive closure:
"cl.co".</p>
<p>If the first word is <code>::r[outine]</code> then remove this word
and remember it's a routine: "r".<br />
If the first clause is an expose clause then it's a closure: "cl".</p>
<p>If the first word is <code>::[xxx]</code> then raise an error
(unknown tag)</p>
<!-- ------------------------------- -->
<h3 id="helper-to-transform-a-source.">5.9.   Helper to transform a
source.</h3>
<!-- ------------------------------- -->
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">transformSource</span></code>
<code lineno="2"><span class="rx-ws">    </span><span class="rx-kw">use</span><span class="rx-ws"> </span><span class="rx-skw">strict</span><span class="rx-ws"> </span><span class="rx-skw">arg</span><span class="rx-ws"> </span><span class="rx-var">clauseBefore</span><span class="rx-op">=</span><span class="rx-str rx-oquo">"</span><span class="rx-str"></span><span class="rx-str rx-cquo">"</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">clauseAfter</span><span class="rx-op">=</span><span class="rx-str rx-oquo">"</span><span class="rx-str"></span><span class="rx-str rx-cquo">"</span>
</code></pre>
</div>
<p>Possible transformations:</p>
<ul>
<li>Insert a clause at the begining (takes care of the expose
instruction, keep it always as first instruction).</li>
<li>Insert a clause at the end.</li>
</ul>
<!-- ======================================================================= -->
<h2 id="numeric-digits-propagate">6.   numeric digits propagate</h2>
<!-- ======================================================================= -->
<p>The problem I wanted to fix:<br />
numeric digits has no effect on the called routines/methods.<br />
Setting the precision at package level with <code>::option digits</code>
is not helping when you want to test several settings
interactively.<br />
With one-liners, you can hardcode the precision where you do a
calculation, but the code becomes polluted by these declarations.<br />
If you don't want to hardcode the precision, the code is still more
polluted with the use of arguments. See <a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/_diary.txt">Sandbox
diary</a> 2020 nov 16.</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-kw">numeric</span><span class="rx-ws"> </span><span class="rx-skw">digits</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">30</span></code>
<code lineno="2"><span class="rx-int rx-ipart">1</span><span class="rx-op">~</span><span class="rx-const rx-method">10000</span><span class="rx-op">~</span><span class="rx-const rx-method">reduce</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">*</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span><span class="rx-spe">=</span><span class="rx-ws">                               </span><span class="rx-lncm">-- 2.84625960E+35659, the precision is the default one</span></code>
<code lineno="3"><span class="rx-int rx-ipart">1</span><span class="rx-op">~</span><span class="rx-const rx-method">10000</span><span class="rx-op">~</span><span class="rx-const rx-method">reduce</span><span class="rx-spe">{</span><span class="rx-kw">numeric</span><span class="rx-ws"> </span><span class="rx-skw">digits</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">30</span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-var">accu</span><span class="rx-ws"> </span><span class="rx-op">*</span><span class="rx-ws"> </span><span class="rx-var">item</span><span class="rx-spe">}</span><span class="rx-spe">=</span><span class="rx-ws">    </span><span class="rx-lncm">-- 2.84625968091705451890641321250E+35659</span>
</code></pre>
</div>
<p>How to fix:<br />
Propagate the numeric settings of the current activation to its child
activations, recursively.<br />
Of course, that must be under control of the programmer.<br />
By default, the behavior is to not propagate.</p>
<p>Implemented solution:</p>
<ul>
<li>add the option <code>PROPAGATE</code> to
<code>NUMERIC DIGITS</code></li>
<li>add the method <code>.RexxContext~digitsPropagate</code></li>
</ul>
<p>The option is available only with <code>NUMERIC DIGITS</code> but it
controls the propagation of all the numeric settings.</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-kw">numeric</span><span class="rx-ws"> </span><span class="rx-skw">digits</span><span class="rx-ws">              </span><span class="rx-lncm">-- default precision, local</span></code>
<code lineno="2"><span class="rx-kw">numeric</span><span class="rx-ws"> </span><span class="rx-skw">digits</span><span class="rx-ws"> </span><span class="rx-var">propagate</span><span class="rx-ws">    </span><span class="rx-lncm">-- default precision, digits form and fuzz are propagated</span></code>
<code lineno="3"><span class="rx-kw">numeric</span><span class="rx-ws"> </span><span class="rx-skw">digits</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">30</span><span class="rx-ws">           </span><span class="rx-lncm">-- precision is 30, local</span></code>
<code lineno="4"><span class="rx-int rx-ipart">1</span><span class="rx-op">~</span><span class="rx-const rx-method">10000</span><span class="rx-op">~</span><span class="rx-const rx-method">reduce</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">*</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span><span class="rx-spe">=</span><span class="rx-ws">        </span><span class="rx-lncm">-- 2.84625960E+35659, the precision for this calculation is 9, it has not been propagated</span></code>
<code lineno="5"><span class="rx-kw">numeric</span><span class="rx-ws"> </span><span class="rx-skw">digits</span><span class="rx-ws"> </span><span class="rx-var">propagate</span><span class="rx-op"> </span><span class="rx-int rx-ipart">30</span><span class="rx-ws"> </span><span class="rx-lncm">-- precision is 30, digits form and fuzz are propagated</span></code>
<code lineno="6"><span class="rx-int rx-ipart">1</span><span class="rx-op">~</span><span class="rx-const rx-method">10000</span><span class="rx-op">~</span><span class="rx-const rx-method">reduce</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">*</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span><span class="rx-spe">=</span><span class="rx-ws">        </span><span class="rx-lncm">-- 2.84625968091705451890641321250E+35659, the precision has been propagated</span>
</code></pre>
</div>
<!-- ======================================================================= -->
<h2 id="blocks-source-literals">7.   Blocks (source literals)</h2>
<!-- ======================================================================= -->
<p>A RexxBlock is a piece of source code surrounded by curly
brackets.</p>
<!-- ------------------------------- -->
<h3 id="big-picture">7.1.   Big picture</h3>
<!-- ------------------------------- -->
<p>a RexxSourceLiteral is an internal rexx object, created by the
parser, not accessible from ooRexx scripts.</p>
<p>a RexxSourceLiteral holds the following properties, shared among all
the RexxBlock instances created from it:</p>
<ul>
<li>source: the text between the curly brackets <code>{...}</code> as an
array of lines, including the tag <code>::xxx</code> if any.</li>
<li>package: the package which contain the source literal.</li>
<li>kind: kind of source, derived from the source's tag.</li>
<li>rawExecutable: routine or method created at load-time (immediate
parsing).</li>
</ul>
<p>a RexxBlock is created each time the RexxSourceLiteral is evaluated,
and is accessible from ooRexx scripts.</p>
<p>a RexxBlock contains informations that depends on the evaluation
context.<br />
In particular, when a RexxBlock is a closure's source, it will hold a
snapshot of the context's variables:</p>
<ul>
<li><code>~source</code>: source of the
<code>RexxSourceLiteral</code>.</li>
<li><code>~variables</code>: snapshot of the context's variables (a
directory), created only if the source starts with
<code>expose</code>.</li>
<li><code>~rawExecutable</code>: the raw executable of the
<code>RexxSourceLiteral</code>, created at load-time (routine or
method).</li>
<li><code>~executable</code>: cached executable, managed by
<code>doers.cls</code>. <code>~executable~source</code> can be different
from <code>~source</code>.</li>
</ul>
<!-- ------------------------------- -->
<h3 id="kind-of-source">7.2.   Kind of source</h3>
<!-- ------------------------------- -->
<p>By default (no tag) the executable is a routine.<br />
Ex:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-spe">{</span><span class="rx-kw">use</span><span class="rx-ws"> </span><span class="rx-skw">strict</span><span class="rx-ws"> </span><span class="rx-skw">arg</span><span class="rx-ws"> </span><span class="rx-var">name</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">greetings</span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">hello</span><span class="rx-str rx-cquo">"</span><span class="rx-op"> </span><span class="rx-var">name</span><span class="rx-ws"> </span><span class="rx-op">|</span><span class="rx-op">|</span><span class="rx-ws"> </span><span class="rx-var">greetings</span><span class="rx-spe">}</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">John</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">, how are you ?</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-lncm">-- hello John, how are you ?</span>
</code></pre>
</div>
<p>If the source starts with "expose" then the doer is a closure.</p>
<p><code>::routine</code> is an optional tag to indicate that the doer
is a routine.<br />
Minimal abbreviation is <code>::r</code>.<br />
If the source after the tag starts with <code>expose</code> then the
doer is a closure.</p>
<p><code>::coactivity</code> is a tag to indicate that the doer is a
coactivity.<br />
Minimal abbreviation is <code>::co</code>.<br />
If the source after the tag starts with <code>expose</code> then the
doer is a coactive closure.</p>
<!-- ======================================================================= -->
<h2 id="threadlocal">8.   .ThreadLocal</h2>
<!-- ======================================================================= -->
<p>Implements the <a
href="https://sourceforge.net/p/oorexx/feature-requests/378/">feature
request 378</a>.<br />
Done by adding support for the variable <code>.threadLocal</code> in
<code>RexxActivation::rexxVariable</code>.</p>
<p>Note 1:<br />
I did not modify <code>RexxDotVariable</code> to search in
<code>.threadLocal</code>.<br />
Maybe should be done, but I find that the search made by
<code>RexxDotVariable</code> is already slow enough.</p>
<p>Note 2:<br />
Seems faster to do that:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-kw">do</span><span class="rx-ws"> </span><span class="rx-var">i</span><span class="rx-asg">=</span><span class="rx-int rx-ipart">1</span><span class="rx-ws"> </span><span class="rx-skw">to</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">100000</span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-var">v</span><span class="rx-asg">=</span><span class="rx-env">.threadlocal</span><span class="rx-spe">[</span><span class="rx-str rx-oquo">"</span><span class="rx-str">MY.VAR</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">]</span><span class="rx-ws"> </span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-kw">end</span>
</code></pre>
</div>
<pre><code>    5 runs: 0.078 0.109 0.109 0.046 0.046</code></pre>
<p>rather than that:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-kw">do</span><span class="rx-ws"> </span><span class="rx-var">i</span><span class="rx-asg">=</span><span class="rx-int rx-ipart">1</span><span class="rx-ws"> </span><span class="rx-skw">to</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">100000</span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-var">v</span><span class="rx-asg">=</span><span class="rx-env">.threadlocal</span><span class="rx-op">~</span><span class="rx-const rx-method">my.var</span><span class="rx-ws"> </span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-kw">end</span>
</code></pre>
</div>
<pre><code>        5 runs: 0.140 0.141 0.156 0.140 0.141</code></pre>
<!-- ======================================================================= -->
<h2 id="coactivity">9.   Coactivity</h2>
<!-- ======================================================================= -->
<!-- ------------------------------- -->
<h3 id="dependency-on-native-extensions">9.1.   Dependency on native
extensions</h3>
<!-- ------------------------------- -->
<p>Implemented by <a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/packages/concurrency/coactivity.cls">concurrency/coactivity.cls</a><br />
with a dependency on these native extensions:</p>
<ul>
<li><code>.context~parentContext</code>: let retrieve the context of the
yield's caller.</li>
<li><code>.context~setargs(&lt;array&gt;, &lt;directory&gt;)</code>: let
store the arguments passed to resume</li>
<li><code>.threadLocal</code></li>
</ul>
<!-- ------------------------------- -->
<h3 id="description-1">9.2.   Description</h3>
<!-- ------------------------------- -->
<p>A coactivity is an emulation of coroutine, named "coactivity" to
follow the ooRexx vocabulary.<br />
This is not a "real" coroutine implementation, because it's based on
ooRexx threads and synchronization.</p>
<p>A coactivity remembers its internal state.<br />
It can be called several times, the execution is resumed after the last
executed <code>.yield[]</code>.</p>
<p>Example:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-var">block</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-spe">{</span><span class="rx-dir">::</span><span class="rx-dkw">coactivity</span></code>
<code lineno="2"><span class="rx-ws">         </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">hello</span><span class="rx-str rx-cquo">"</span><span class="rx-op"> </span><span class="rx-const rx-bif-func">arg</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-op">|</span><span class="rx-op">|</span><span class="rx-ws"> </span><span class="rx-const rx-bif-func">arg</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">2</span><span class="rx-spe">)</span></code>
<code lineno="3"><span class="rx-ws">         </span><span class="rx-env">.yield</span><span class="rx-spe">[</span><span class="rx-spe">]</span></code>
<code lineno="4"><span class="rx-ws">         </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">good bye</span><span class="rx-str rx-cquo">"</span><span class="rx-op"> </span><span class="rx-const rx-bif-func">arg</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-op">|</span><span class="rx-op">|</span><span class="rx-ws"> </span><span class="rx-const rx-bif-func">arg</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">2</span><span class="rx-spe">)</span></code>
<code lineno="5"><span class="rx-ws">        </span><span class="rx-spe">}</span></code>
<code lineno="6"><span class="rx-var">block</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">John</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">, how are you ?</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-lncm">-- hello John, how are you ?</span></code>
<code lineno="7"><span class="rx-var">block</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">Kathie</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">, see you soon.</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-lncm">-- good bye Kathie, see you soon.</span></code>
<code lineno="8"><span class="rx-var">block</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">Keith</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">, bye</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-lncm">-- &lt;nothing done, the coactivity is ended&gt;</span>
</code></pre>
</div>
<!-- ------------------------------- -->
<h3 id="producer-consumer">9.3.   Producer / consumer</h3>
<!-- ------------------------------- -->
<p>Producer/consumer problems can often be implemented elegantly with
coactivities:</p>
<ul>
<li>The consumer can pass arguments:
<code>producerResult = aCoactivity~resume(args...)</code>.<br />
</li>
<li>The producer (aCoactivity) returns a result to the consumer:
<code>.yield[result]</code>.</li>
</ul>
<p><code>.context~setargs</code> is used to transfer to a coactivity the
arguments passed with <code>resume</code>.<br />
A coactivity can be suspended, and can receive a new set of arguments
after each resume.</p>
<pre><code>client (thread1)                            coactivity (thread2)
================                            ====================
                                            &lt;SUSPENDED&gt;
Result = resume(&lt;Arguments&gt;) ------------&gt;  &lt;ACTIVE&gt;
&lt;SUSPENDED&gt;                                 use arg ...; use named arg ...
                                            ...
                                            call yield value
&lt;ACTIVE&gt;                     &lt;---result---  &lt;SUSPENDED&gt;
...                                                     
Result = resume(&lt;Arguments&gt;) ------------&gt;  &lt;ACTIVE&gt;
                                            use arg ...; use named arg ...
                                            ...
                                            call yield value
&lt;ACTIVE&gt;                     &lt;---result---  &lt;SUSPENDED&gt;
etc...</code></pre>
<!-- ------------------------------- -->
<h3 id="stackful-coroutine">9.4.   Stackful coroutine</h3>
<!-- ------------------------------- -->
<p>A stackful coroutine is a coroutine able to suspend its execution
from within nested calls.<br />
<code>.threadLocal</code> is needed to retrieve the coactivity instance
from any invocation and send it the message yield<br />
(this instance is at the origin of the invocations stack, but is not
passed as a parameter to the invocations).</p>
<pre><code>myCoactivity~start  &lt;--------------+
    invocation                     |
        invocation                 |
            ...                    |
                invocation: .Coactivity~yield()</code></pre>
<!-- ------------------------------- -->
<h3 id="yield-implementation">9.5.   yield implementation</h3>
<!-- ------------------------------- -->
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">yield</span></code>
<code lineno="2"><span class="rx-ws">    </span><span class="rx-env">...</span></code>
<code lineno="3"><span class="rx-ws">    </span><span class="rx-lncm">-- yieldItem will be returned to the Coactivity's client by 'resume'</span></code>
<code lineno="4"><span class="rx-ws">    </span><span class="rx-kw">use</span><span class="rx-ws"> </span><span class="rx-skw">strict</span><span class="rx-ws"> </span><span class="rx-skw">arg</span><span class="rx-ws"> </span><span class="rx-var">yieldItem</span></code>
<code lineno="5"><span class="rx-ws">    </span><span class="rx-env">...</span></code>
<code lineno="6"><span class="rx-ws">    </span><span class="rx-var">status</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-env">.CoactivityObj</span><span class="rx-op">~</span><span class="rx-const rx-method">suspended</span><span class="rx-ws">                   </span><span class="rx-lncm">-- the producer is suspended</span></code>
<code lineno="7"><span class="rx-ws">    </span><span class="rx-kw">guard</span><span class="rx-ws"> </span><span class="rx-skw">off</span><span class="rx-ws">                                           </span><span class="rx-lncm">-- the client is active</span></code>
<code lineno="8"><span class="rx-ws">    </span><span class="rx-kw">guard</span><span class="rx-ws"> </span><span class="rx-skw">on</span><span class="rx-ws"> </span><span class="rx-skw">when</span><span class="rx-ws"> </span><span class="rx-var">status</span><span class="rx-ws"> </span><span class="rx-op">&lt;</span><span class="rx-op">&gt;</span><span class="rx-ws"> </span><span class="rx-env">.CoactivityObj</span><span class="rx-op">~</span><span class="rx-const rx-method">suspended</span><span class="rx-ws">    </span><span class="rx-lncm">-- the client is suspended, the producer is active</span></code>
<code lineno="9"><span class="rx-ws">    </span><span class="rx-env">...</span></code>
<code lineno="10"><span class="rx-ws">    </span><span class="rx-lncm">-- The client made a resume(arguments, :namedArguments)</span></code>
<code lineno="11"><span class="rx-ws">    </span><span class="rx-lncm">-- Update the arguments of the caller's context</span></code>
<code lineno="12"><span class="rx-ws">    </span><span class="rx-lncm">-- Must unwind until we reach a context whose package is not the current package.</span></code>
<code lineno="13"><span class="rx-ws">    </span><span class="rx-var">context</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-env">.context</span></code>
<code lineno="14"><span class="rx-ws">    </span><span class="rx-var">currentPackage</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-var">context</span><span class="rx-op">~</span><span class="rx-const rx-method">package</span></code>
<code lineno="15"><span class="rx-ws">    </span><span class="rx-kw">do</span><span class="rx-ws"> </span><span class="rx-skw">while</span><span class="rx-ws"> </span><span class="rx-env">.nil</span><span class="rx-ws"> </span><span class="rx-op">&lt;</span><span class="rx-op">&gt;</span><span class="rx-ws"> </span><span class="rx-var">context</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">context</span><span class="rx-op">~</span><span class="rx-const rx-method">package</span><span class="rx-ws"> </span><span class="rx-op">=</span><span class="rx-op">=</span><span class="rx-ws"> </span><span class="rx-var">currentPackage</span><span class="rx-ws"> </span><span class="rx-lncm">-- search for the first context outside this package</span></code>
<code lineno="16"><span class="rx-ws">        </span><span class="rx-var">context</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-var">context</span><span class="rx-op">~</span><span class="rx-const rx-method">parentContext</span><span class="rx-ws"> </span><span class="rx-lncm">-- .nil if native or top-level activation.</span></code>
<code lineno="17"><span class="rx-ws">    </span><span class="rx-kw">end</span></code>
<code lineno="18"><span class="rx-ws">    </span><span class="rx-kw">if</span><span class="rx-ws"> </span><span class="rx-env">.nil</span><span class="rx-ws"> </span><span class="rx-op">=</span><span class="rx-op">=</span><span class="rx-ws"> </span><span class="rx-var">context</span><span class="rx-ws"> </span><span class="rx-kw">then</span><span class="rx-ws"> </span><span class="rx-kw">raise</span><span class="rx-ws"> </span><span class="rx-skw">syntax</span><span class="rx-ws"> </span><span class="rx-deci rx-ipart">93</span><span class="rx-deci rx-dpoint">.</span><span class="rx-deci rx-fpart">900</span><span class="rx-ws"> </span><span class="rx-skw">array</span><span class="rx-ws"> </span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">Can't update the arguments, yield's context not found</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span></code>
<code lineno="19"><span class="rx-ws">    </span><span class="rx-var">context</span><span class="rx-op">~</span><span class="rx-const rx-method">setargs</span><span class="rx-spe">(</span><span class="rx-var">arguments</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-spe">:</span><span class="rx-const rx-argument-name">namedArguments</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-lncm">-- assigns the positional and named arguments that the coactivity's client passed to 'resume'</span>
</code></pre>
</div>
<!-- ======================================================================= -->
<h2 id="closures">10.   Closures</h2>
<!-- ======================================================================= -->
<p>A closure is an object created from a block whose source first word
after the optional tag is <code>expose</code>.<br />
A closure remembers the values of the variables defined in the outer
environment of the block.</p>
<!-- ------------------------------- -->
<h3 id="closure-by-value">10.1.   Closure by value</h3>
<!-- ------------------------------- -->
<p>The behaviour of the closure is a method generated from the block,
which is attached to the closure under the name <code>"do"</code>.<br />
The values of the captured variables are accessible from this method
<code>"do"</code> using expose.<br />
Updating a variable from the closure will have no impact on the original
context (hence the name "closure by value").<br />
A closure can be passed as argument, or returned as result.</p>
<p>Examples:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-var">v</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1</span></code>
<code lineno="2"><span class="rx-var">closure</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-spe">{</span><span class="rx-kw">expose</span><span class="rx-ws"> </span><span class="rx-xvar">v</span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-xvar">v</span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-xvar">v</span><span class="rx-ws"> </span><span class="rx-asg">+</span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">10</span><span class="rx-spe">}</span><span class="rx-ws">    </span><span class="rx-lncm">-- capture the value of v: 1</span></code>
<code lineno="3"><span class="rx-xvar">v</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">2</span></code>
<code lineno="4"><span class="rx-var">closure</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-spe">)</span><span class="rx-ws">                              </span><span class="rx-lncm">-- display 1</span></code>
<code lineno="5"><span class="rx-var">closure</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-spe">)</span><span class="rx-ws">                              </span><span class="rx-lncm">-- display 11</span></code>
<code lineno="6"><span class="rx-var">closure</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-spe">)</span><span class="rx-ws">                              </span><span class="rx-lncm">-- display 21</span></code>
<code lineno="7"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-xvar">v</span><span class="rx-ws">                                   </span><span class="rx-lncm">-- v not impacted by the closure: 2</span></code>
<code lineno="8"></code>
<code lineno="9"><span class="rx-var">range</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-spe">{</span><span class="rx-ws"> </span><span class="rx-kw">use</span><span class="rx-ws"> </span><span class="rx-skw">arg</span><span class="rx-ws"> </span><span class="rx-var">min</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">max</span><span class="rx-ws"> </span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-kw">return</span><span class="rx-ws"> </span><span class="rx-spe">{</span><span class="rx-ws"> </span><span class="rx-kw">expose</span><span class="rx-ws"> </span><span class="rx-xvar">min</span><span class="rx-ws"> </span><span class="rx-xvar">max</span><span class="rx-ws"> </span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-kw">use</span><span class="rx-ws"> </span><span class="rx-skw">arg</span><span class="rx-ws"> </span><span class="rx-var">num</span><span class="rx-ws"> </span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-kw">return</span><span class="rx-ws"> </span><span class="rx-xvar">min</span><span class="rx-ws"> </span><span class="rx-op">&lt;</span><span class="rx-op">=</span><span class="rx-ws"> </span><span class="rx-var">num</span><span class="rx-ws"> </span><span class="rx-op">&amp;</span><span class="rx-ws"> </span><span class="rx-var">num</span><span class="rx-ws"> </span><span class="rx-op">&lt;</span><span class="rx-op">=</span><span class="rx-ws"> </span><span class="rx-xvar">max</span><span class="rx-ws"> </span><span class="rx-spe">}</span><span class="rx-spe">}</span></code>
<code lineno="10"><span class="rx-var">from5to8</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-var">range</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">5</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">8</span><span class="rx-spe">)</span></code>
<code lineno="11"><span class="rx-var">from20to30</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-var">range</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">20</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">30</span><span class="rx-spe">)</span></code>
<code lineno="12"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">from5to8</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-int rx-fpart">6</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-lncm">-- 1</span></code>
<code lineno="13"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">from5to8</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">9</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-lncm">-- 0</span></code>
<code lineno="14"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">from20to30</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-int rx-fpart">6</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-lncm">-- 0</span></code>
<code lineno="15"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">from20to30</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">25</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-lncm">-- 1</span>
</code></pre>
</div>
<p>A coactive closure is both a closure and a coactivity:</p>
<ul>
<li>as a closure, it remembers its outer environment.</li>
<li>as a coactivity, it remembers its internal state.</li>
</ul>
<p>It can be called several times, the execution is resumed after the
last <code>.yield[]</code>.</p>
<p>Examples:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-var">v</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1</span></code>
<code lineno="2"><span class="rx-var">w</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">2</span></code>
<code lineno="3"><span class="rx-var">closure</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-spe">{</span><span class="rx-dir">::</span><span class="rx-dkw">coactivity</span><span class="rx-ws"> </span><span class="rx-kw">expose</span><span class="rx-ws"> </span><span class="rx-xvar">v</span><span class="rx-ws"> </span><span class="rx-xvar">w</span><span class="rx-ws"> </span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-env">.yield</span><span class="rx-spe">[</span><span class="rx-xvar">v</span><span class="rx-spe">]</span><span class="rx-ws"> </span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-env">.yield</span><span class="rx-spe">[</span><span class="rx-xvar">w</span><span class="rx-spe">]</span><span class="rx-spe">}</span></code>
<code lineno="4"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">closure</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-lncm">-- 1</span></code>
<code lineno="5"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">closure</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-lncm">-- 2</span>
</code></pre>
</div>
<p>Implementation note:<br />
Currently, the instance of closure is created by user code in <a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/packages/extension/doers.cls">doers.cls</a>.<br />
See the <code>sourceDoer</code> method of
<code>RexxBlockDoer</code>.<br />
See the <code>init</code> method of <code>Closure</code>.<br />
This is a very inefficient implementation, to replace by a native (C++)
implementation.</p>
<!-- ------------------------------- -->
<h3 id="closure-settings">10.2.   Closure settings</h3>
<!-- ------------------------------- -->
<!-- -------------------- -->
<h4 id="standard-oorexx-behavior">10.2.1.   Standard ooRexx
behavior</h4>
<!-- -------------------- -->
<p>When a routine or method is created, a new <code>RexxSource</code>
(i.e. a package) is created.<br />
All the settings defined on the package level (i.e.
<code>RexxSource</code>) have the default values.<br />
It's possible to pass a context from which a <code>RexxSource</code> is
taken (called <code>parentSource</code>) which allows the created
routine/method to inherit class and routine lookup scope from another
source.<br />
Nothing else is inherited.</p>
<p>[inherited from context]</p>
<pre><code>routines
merged_public_routines
installed_classes
merged_public_classes</code></pre>
<p>[not inherited from context]</p>
<pre><code>digits
fuzz
form
trace
enableCommands (sandbox only)
enableMacrospace (sandbox only)
the security manager</code></pre>
<!-- ------------------------- -->
<h4 id="q1-answered-and-implemented">10.2.2.   Q1 (answered and
implemented)</h4>
<!-- ------------------------- -->
<p>The raw executable created from a <code>RexxBlock</code> is a routine
or a method.<br />
Given the rule explained above, this raw executable has its own
<code>RexxSource</code> (i.e. package):</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-env">.context</span><span class="rx-op">~</span><span class="rx-const rx-method">package</span><span class="rx-op">~</span><span class="rx-const rx-method">identityHash</span><span class="rx-ws"> </span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-spe">{</span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-env">.context</span><span class="rx-op">~</span><span class="rx-const rx-method">package</span><span class="rx-op">~</span><span class="rx-const rx-method">identityHash</span><span class="rx-spe">}</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-lncm">-- the hashes are different</span>
</code></pre>
</div>
<p>Should a <code>RexxBlock</code> inherit the settings of the package
in which it's defined ? answer: yes.<br />
If yes, all kinds of <code>RexxBlock</code> or just a closure ? answer:
all kinds of <code>RexxBlock</code>.<br />
Currently, the visibility on routines/classes is inherited, but none of
the following options are inherited:</p>
<pre><code>::options digits
::options form
::options fuzz
::options trace
::options commands (sandbox only)
::options nocommands (sandbox only)
::options macrospace (sandbox only)
::options nomacrospace (sandbox only)
the security manager</code></pre>
<p>Illustration:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1</span><span class="rx-op">/</span><span class="rx-int rx-ipart">3</span></code>
<code lineno="2"><span class="rx-spe">{</span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1</span><span class="rx-op">/</span><span class="rx-int rx-ipart">3</span><span class="rx-spe">}</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-spe">)</span></code>
<code lineno="3"><span class="rx-dir">::</span><span class="rx-dkw">options</span><span class="rx-ws"> </span><span class="rx-dskw">trace</span><span class="rx-ws"> </span><span class="rx-var">i</span></code>
<code lineno="4"><span class="rx-dir">::</span><span class="rx-dkw">options</span><span class="rx-ws"> </span><span class="rx-dskw">digits</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">20</span>
</code></pre>
</div>
<p>Output:</p>
<pre><code>     1 *-* say 1/3
       &gt;L&gt;   &quot;1&quot;
       &gt;L&gt;   &quot;3&quot;
       &gt;O&gt;   &quot;/&quot; =&gt; &quot;0.33333333333333333333&quot;
       &gt;&gt;&gt;   &quot;0.33333333333333333333&quot;
0.33333333333333333333
     2 *-* {say 1/3}~()
       &gt;L&gt;   &quot;a RexxBlock&quot;
0.333333333</code></pre>
<p>[2014 jan 06] Q1 has been adressed:<br />
Inherit the toplevel source options settings, when creating a method or
routine for a block.<br />
A new optional parameter <code>isBlock</code> can be passed when
creating a method or routine:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-env">.Method</span><span class="rx-op">~</span><span class="rx-const rx-method">new</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">do</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">sourceArray</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">context</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">isBlock</span><span class="rx-spe">)</span></code>
<code lineno="2"><span class="rx-env">.Routine</span><span class="rx-op">~</span><span class="rx-const rx-method">new</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str"></span><span class="rx-str rx-cquo">"</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">sourceArray</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">context</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">isBlock</span><span class="rx-spe">)</span>
</code></pre>
</div>
<p>This indicator is used to activate specific behaviour, like
inheritance of toplevel source options.</p>
<!-- ----------------- -->
<h4 id="q2-not-yet-answered">10.2.3.   Q2 (not yet answered)</h4>
<!-- ----------------- -->
<p>Same question for the settings of the <code>RexxActivation</code> in
which the <code>RexxBlock</code> is evaluated.<br />
Here, only a closure is supposed to capture its environment.<br />
Should a closure remember the following settings of its defining
<code>RexxActivation</code>?<br />
The goal being to reuse automatically these settings at each execution
(so from a different <code>RexxActivation</code>).<br />
Currently, none of the following settings are captured:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-kw">numeric</span><span class="rx-ws"> </span><span class="rx-skw">digits</span></code>
<code lineno="2"><span class="rx-kw">numeric</span><span class="rx-ws"> </span><span class="rx-skw">form</span></code>
<code lineno="3"><span class="rx-kw">numeric</span><span class="rx-ws"> </span><span class="rx-skw">fuzz</span></code>
<code lineno="4"><span class="rx-kw">trace</span></code>
<code lineno="5"><span class="rx-kw">options</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">commands</span><span class="rx-str rx-cquo">"</span><span class="rx-op"> </span><span class="rx-spe">(</span><span class="rx-var">sandbox</span><span class="rx-op"> </span><span class="rx-var">only</span><span class="rx-spe">)</span></code>
<code lineno="6"><span class="rx-kw">options</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">nocommands</span><span class="rx-str rx-cquo">"</span><span class="rx-op"> </span><span class="rx-spe">(</span><span class="rx-var">sandbox</span><span class="rx-op"> </span><span class="rx-var">only</span><span class="rx-spe">)</span></code>
<code lineno="7"><span class="rx-kw">options</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">macrospace</span><span class="rx-str rx-cquo">"</span><span class="rx-op"> </span><span class="rx-spe">(</span><span class="rx-var">sandbox</span><span class="rx-op"> </span><span class="rx-var">only</span><span class="rx-spe">)</span></code>
<code lineno="8"><span class="rx-kw">options</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">nomacrospace</span><span class="rx-str rx-cquo">"</span><span class="rx-op"> </span><span class="rx-spe">(</span><span class="rx-var">sandbox</span><span class="rx-op"> </span><span class="rx-var">only</span><span class="rx-spe">)</span>
</code></pre>
</div>
<p>Illustration:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-kw">trace</span><span class="rx-ws"> </span><span class="rx-var">i</span></code>
<code lineno="2"><span class="rx-kw">numeric</span><span class="rx-ws"> </span><span class="rx-skw">digits</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">20</span></code>
<code lineno="3"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1</span><span class="rx-op">/</span><span class="rx-int rx-ipart">3</span></code>
<code lineno="4"><span class="rx-spe">{</span><span class="rx-kw">expose</span><span class="rx-ws"> </span><span class="rx-xvar">something</span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1</span><span class="rx-op">/</span><span class="rx-int rx-ipart">3</span><span class="rx-spe">}</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-spe">)</span>
</code></pre>
</div>
<p>Output:</p>
<pre><code>     2 *-* numeric digits 20
       &gt;L&gt;   &quot;20&quot;
       &gt;&gt;&gt;   &quot;20&quot;
     3 *-* say 1/3
       &gt;L&gt;   &quot;1&quot;
       &gt;L&gt;   &quot;3&quot;
       &gt;O&gt;   &quot;/&quot; =&gt; &quot;0.33333333333333333333&quot;
       &gt;&gt;&gt;   &quot;0.33333333333333333333&quot;
0.33333333333333333333
     4 *-* {expose something; say 1/3}~()
       &gt;L&gt;   &quot;a RexxBlock&quot;
0.333333333</code></pre>
<!-- ======================================================================= -->
<h2 id="new-option-nocommands">11.   New option NOCOMMANDS</h2>
<!-- ======================================================================= -->
<p>Added an option to control execution of commands:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-kw">options</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">COMMANDS</span><span class="rx-str rx-cquo">"</span></code>
<code lineno="2"><span class="rx-kw">options</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">NOCOMMANDS</span><span class="rx-str rx-cquo">"</span></code>
<code lineno="3"><span class="rx-dir">::</span><span class="rx-dkw">options</span><span class="rx-ws"> </span><span class="rx-dskw">COMMANDS</span></code>
<code lineno="4"><span class="rx-dir">::</span><span class="rx-dkw">options</span><span class="rx-ws"> </span><span class="rx-dskw">NOCOMMANDS</span>
</code></pre>
</div>
<p>By default, a clause consisting of an expression only is interpreted
as a command string.<br />
When using the option <code>NOCOMMANDS</code>, the value of the
expression is stored in the <code>RESULT</code> variable, and not
interpreted as a command string.</p>
<!-- ======================================================================= -->
<h2 id="no-value">12.   No value</h2>
<!-- ======================================================================= -->
<p>This is not an extension, it's a standard functionality, but
undocumented:<br />
When a variable has no value, the interpreter sends the message
<code>"NOVALUE"</code> to the object <code>.local["NOVALUE"]</code>.</p>
<p>I use this functionality to manage special variable like
<code>i</code>, <code>infinity</code>, <code>indeterminate</code>.</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-var">i</span><span class="rx-spe">=</span><span class="rx-ws">              </span><span class="rx-lncm">-- (0+1i)</span></code>
<code lineno="2"><span class="rx-var">infinity</span><span class="rx-spe">=</span><span class="rx-ws">       </span><span class="rx-lncm">-- (The positive infinity)</span></code>
<code lineno="3"><span class="rx-var">indeterminate</span><span class="rx-spe">=</span><span class="rx-ws">  </span><span class="rx-lncm">-- (The indeterminate value)</span>
</code></pre>
</div>
<p>Example:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-kw">signal</span><span class="rx-ws"> </span><span class="rx-skw">on</span><span class="rx-ws"> </span><span class="rx-skw">novalue</span><span class="rx-ws"> </span><span class="rx-skw">name</span><span class="rx-ws"> </span><span class="rx-const rx-label">novalue_continue</span></code>
<code lineno="2"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">foo</span></code>
<code lineno="3"></code>
<code lineno="4"><span class="rx-const rx-label">continue</span><span class="rx-spe">:</span></code>
<code lineno="5"><span class="rx-kw">signal</span><span class="rx-ws"> </span><span class="rx-skw">on</span><span class="rx-ws"> </span><span class="rx-skw">novalue</span><span class="rx-ws"> </span><span class="rx-skw">name</span><span class="rx-ws"> </span><span class="rx-const rx-label">novalue_exit</span></code>
<code lineno="6"></code>
<code lineno="7"><span class="rx-env">.local</span><span class="rx-spe">[</span><span class="rx-str rx-oquo">"</span><span class="rx-str">NOVALUE</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">]</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-env">.novalue</span></code>
<code lineno="8"></code>
<code lineno="9"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">infinity</span></code>
<code lineno="10"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">indeterminate</span></code>
<code lineno="11"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">foo</span></code>
<code lineno="12"></code>
<code lineno="13"><span class="rx-kw">return</span></code>
<code lineno="14"></code>
<code lineno="15"><span class="rx-const rx-label">novalue_continue</span><span class="rx-spe">:</span></code>
<code lineno="16"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">novalue condition!</span><span class="rx-str rx-cquo">"</span><span class="rx-op"> </span><span class="rx-const rx-bif-func">condition</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">description</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span></code>
<code lineno="17"><span class="rx-kw">signal</span><span class="rx-ws"> </span><span class="rx-const rx-label">continue</span></code>
<code lineno="18"></code>
<code lineno="19"><span class="rx-const rx-label">novalue_exit</span><span class="rx-spe">:</span></code>
<code lineno="20"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">novalue condition!</span><span class="rx-str rx-cquo">"</span></code>
<code lineno="21"></code>
<code lineno="22"><span class="rx-dir">::</span><span class="rx-dkw">class</span><span class="rx-ws"> </span><span class="rx-const rx-class">novalue</span></code>
<code lineno="23"></code>
<code lineno="24"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">novalue</span><span class="rx-ws"> </span><span class="rx-dskw">class</span></code>
<code lineno="25"><span class="rx-ws">    </span><span class="rx-kw">use</span><span class="rx-ws"> </span><span class="rx-skw">strict</span><span class="rx-ws"> </span><span class="rx-skw">arg</span><span class="rx-ws"> </span><span class="rx-var">name</span></code>
<code lineno="26"><span class="rx-ws">    </span><span class="rx-kw">call</span><span class="rx-ws"> </span><span class="rx-const rx-bif-proc">charout</span><span class="rx-ws"> </span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">Intercepting no value for</span><span class="rx-str rx-cquo">"</span><span class="rx-op"> </span><span class="rx-var">name</span><span class="rx-str rx-oquo">"</span><span class="rx-str">: </span><span class="rx-str rx-cquo">"</span></code>
<code lineno="27"><span class="rx-ws">    </span><span class="rx-kw">forward</span><span class="rx-ws"> </span><span class="rx-skw">message</span><span class="rx-ws"> </span><span class="rx-spe">(</span><span class="rx-var">name</span><span class="rx-spe">)</span></code>
<code lineno="28"></code>
<code lineno="29"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">infinity</span><span class="rx-ws"> </span><span class="rx-dskw">class</span></code>
<code lineno="30"><span class="rx-ws">    </span><span class="rx-kw">return</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">default value for infinity</span><span class="rx-str rx-cquo">"</span></code>
<code lineno="31"></code>
<code lineno="32"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">unknown</span><span class="rx-ws"> </span><span class="rx-dskw">class</span></code>
<code lineno="33"><span class="rx-ws">    </span><span class="rx-kw">use</span><span class="rx-ws"> </span><span class="rx-skw">strict</span><span class="rx-ws"> </span><span class="rx-skw">arg</span><span class="rx-ws"> </span><span class="rx-var">msg</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">args</span></code>
<code lineno="34"><span class="rx-ws">    </span><span class="rx-kw">if</span><span class="rx-ws"> </span><span class="rx-var">msg</span><span class="rx-op">~</span><span class="rx-const rx-method">caselessEquals</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">indeterminate</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-kw">then</span><span class="rx-ws"> </span><span class="rx-kw">return</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">default value for indeterminate</span><span class="rx-str rx-cquo">"</span>
</code></pre>
</div>
<p>Output:</p>
<pre><code>novalue condition! FOO
Intercepting no value for INFINITY: default value for infinity
Intercepting no value for INDETERMINATE: default value for indeterminate
Intercepting no value for FOO: novalue condition!</code></pre>
<!-- ======================================================================= -->
<h2 id="order-of-argument-checking-for-boolean-operators">13.   Order of
argument checking for Boolean operators</h2>
<!-- ======================================================================= -->
<p>Changed the order of argument checking for Boolean operators.<br />
In case of wrong value on both sides, the error about the right side was
raised first.</p>
<p>It's more clear to report an error about the left side when both
sides are wrong, otherwise you have the wrong impression that only the
right side is wrong (the evaluation is from left to right).</p>
<p>Before:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-str rx-oquo">"</span><span class="rx-str">not a boolean value</span><span class="rx-str rx-cquo">"</span><span class="rx-ws"> </span><span class="rx-op">|</span><span class="rx-ws"> </span><span class="rx-env">.console</span><span class="rx-ws">    </span><span class="rx-lncm">-- Logical value must be exactly "0" or "1"; found "The console class"</span>
</code></pre>
</div>
<p>Now:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-str rx-oquo">"</span><span class="rx-str">not a boolean value</span><span class="rx-str rx-cquo">"</span><span class="rx-ws"> </span><span class="rx-op">|</span><span class="rx-ws"> </span><span class="rx-env">.console</span><span class="rx-ws">    </span><span class="rx-lncm">-- Logical value must be exactly "0" or "1"; found "not a boolean value"</span>
</code></pre>
</div>
<!-- ======================================================================= -->
<h2 id="symmetric-implementation-of-operator">14.   Symmetric
implementation of operator</h2>
<!-- ======================================================================= -->
<!-- ------------------------------- -->
<h3 id="rationale">14.1.   Rationale</h3>
<!-- ------------------------------- -->
<p>The standard ooRexx doesn't allow to define symmetric overriding of
operators.<br />
You can define a user operator on <code>.array</code> which supports
<code>.array~of(1,2) + 10</code>.<br />
But you can't define a user operator whcih supports
<code>10 + .array~of(1,2)</code>.</p>
<p>The extended ooRexx has been modified to automatically try
<code>b~"op:right"(a)</code>when <code>a~"op"(b)</code> raises an
exception.</p>
<p>If an alternate implementation exists then use it, otherwise raise
the exception.<br />
That must be done in each implementation of operator.<br />
The two methods <code>Object::messageSend</code> have been modified to
let pass an additional parameter <code>processUnknown</code> which is
true by default (legacy behavior).<br />
When this parameter is false, and no method is found for the message,
then <code>Object::messageSend</code> returns false to indicate that no
implementation exists.<br />
There is no processing of the unknown message.</p>
<p>This is an efficient way to test if an alternate implementation
exists and use it.<br />
When the alternate implementation returns nothing, then don't complain
about that.<br />
Behave as if the alternate implementation did not exist, and raise the
exception related to the left argument.</p>
<p>Example of symmetric operator:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-dir">::</span><span class="rx-dkw">extension</span><span class="rx-ws"> </span><span class="rx-const rx-class">Array</span><span class="rx-ws"> </span><span class="rx-dskw">inherit</span><span class="rx-ws"> </span><span class="rx-const rx-class">ArrayOperators</span></code>
<code lineno="2"><span class="rx-dir">::</span><span class="rx-dkw">class</span><span class="rx-ws"> </span><span class="rx-const rx-class rx-oquo">"</span><span class="rx-const rx-class">ArrayOperators</span><span class="rx-const rx-class rx-cquo">"</span><span class="rx-ws"> </span><span class="rx-dskw">mixinclass</span><span class="rx-ws"> </span><span class="rx-const rx-class">Object</span><span class="rx-ws"> </span><span class="rx-dskw">public</span></code>
<code lineno="3"></code>
<code lineno="4"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method rx-oquo">"</span><span class="rx-const rx-method">+</span><span class="rx-const rx-method rx-cquo">"</span></code>
<code lineno="5"><span class="rx-ws">    </span><span class="rx-kw">if</span><span class="rx-ws"> </span><span class="rx-const rx-bif-func">arg</span><span class="rx-spe">(</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-op">=</span><span class="rx-op">=</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">0</span><span class="rx-ws"> </span><span class="rx-kw">then</span><span class="rx-ws"> </span><span class="rx-kw">return</span><span class="rx-ws"> </span><span class="rx-var">self</span><span class="rx-op">~</span><span class="rx-const rx-method">map</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">+</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span></code>
<code lineno="6"><span class="rx-ws">    </span><span class="rx-kw">use</span><span class="rx-ws"> </span><span class="rx-skw">strict</span><span class="rx-ws"> </span><span class="rx-skw">arg</span><span class="rx-ws"> </span><span class="rx-var">right</span></code>
<code lineno="7"><span class="rx-ws">    </span><span class="rx-kw">if</span><span class="rx-ws"> </span><span class="rx-var">right</span><span class="rx-op">~</span><span class="rx-const rx-method">isA</span><span class="rx-spe">(</span><span class="rx-env">.array</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-kw">then</span><span class="rx-ws"> </span><span class="rx-kw">do</span></code>
<code lineno="8"><span class="rx-ws">        </span><span class="rx-kw">if</span><span class="rx-ws"> </span><span class="rx-op">\</span><span class="rx-const rx-ext-func">SameDimensions</span><span class="rx-spe">(</span><span class="rx-var">self</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">right</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-kw">then</span><span class="rx-ws"> </span><span class="rx-kw">raise</span><span class="rx-ws"> </span><span class="rx-skw">syntax</span><span class="rx-ws"> </span><span class="rx-deci rx-ipart">93</span><span class="rx-deci rx-dpoint">.</span><span class="rx-deci rx-fpart">900</span><span class="rx-ws"> </span><span class="rx-skw">array</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">Dimensions are not equal</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span></code>
<code lineno="9"><span class="rx-ws">        </span><span class="rx-kw">return</span><span class="rx-ws"> </span><span class="rx-var">self</span><span class="rx-op">~</span><span class="rx-const rx-method">map</span><span class="rx-spe">{</span><span class="rx-kw">expose</span><span class="rx-ws"> </span><span class="rx-xvar">right</span><span class="rx-ws"> </span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-var">item</span><span class="rx-ws"> </span><span class="rx-op">+</span><span class="rx-ws"> </span><span class="rx-xvar">right</span><span class="rx-spe">[</span><span class="rx-var">index</span><span class="rx-spe">]</span><span class="rx-spe">}</span></code>
<code lineno="10"><span class="rx-ws">    </span><span class="rx-kw">end</span></code>
<code lineno="11"><span class="rx-ws">    </span><span class="rx-kw">return</span><span class="rx-ws"> </span><span class="rx-var">self</span><span class="rx-op">~</span><span class="rx-const rx-method">map</span><span class="rx-spe">{</span><span class="rx-kw">expose</span><span class="rx-ws"> </span><span class="rx-xvar">right</span><span class="rx-ws"> </span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-var">item</span><span class="rx-ws"> </span><span class="rx-op">+</span><span class="rx-ws"> </span><span class="rx-xvar">right</span><span class="rx-spe">}</span></code>
<code lineno="12"></code>
<code lineno="13"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method rx-oquo">"</span><span class="rx-const rx-method">+op:right</span><span class="rx-const rx-method rx-cquo">"</span></code>
<code lineno="14"><span class="rx-ws">    </span><span class="rx-kw">use</span><span class="rx-ws"> </span><span class="rx-skw">strict</span><span class="rx-ws"> </span><span class="rx-skw">arg</span><span class="rx-ws"> </span><span class="rx-var">left</span></code>
<code lineno="15"><span class="rx-ws">    </span><span class="rx-kw">if</span><span class="rx-ws"> </span><span class="rx-var">left</span><span class="rx-op">~</span><span class="rx-const rx-method">isA</span><span class="rx-spe">(</span><span class="rx-env">.array</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-kw">then</span><span class="rx-ws"> </span><span class="rx-kw">do</span></code>
<code lineno="16"><span class="rx-ws">        </span><span class="rx-kw">if</span><span class="rx-ws"> </span><span class="rx-op">\</span><span class="rx-const rx-ext-func">SameDimensions</span><span class="rx-spe">(</span><span class="rx-var">self</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">left</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-kw">then</span><span class="rx-ws"> </span><span class="rx-kw">raise</span><span class="rx-ws"> </span><span class="rx-skw">syntax</span><span class="rx-ws"> </span><span class="rx-deci rx-ipart">93</span><span class="rx-deci rx-dpoint">.</span><span class="rx-deci rx-fpart">900</span><span class="rx-ws"> </span><span class="rx-skw">array</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">Dimensions are not equal</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span></code>
<code lineno="17"><span class="rx-ws">        </span><span class="rx-kw">return</span><span class="rx-ws"> </span><span class="rx-var">self</span><span class="rx-op">~</span><span class="rx-const rx-method">map</span><span class="rx-spe">{</span><span class="rx-kw">expose</span><span class="rx-ws"> </span><span class="rx-xvar">left</span><span class="rx-ws"> </span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-xvar">left</span><span class="rx-spe">[</span><span class="rx-var">index</span><span class="rx-spe">]</span><span class="rx-ws"> </span><span class="rx-op">+</span><span class="rx-ws"> </span><span class="rx-var">item</span><span class="rx-spe">}</span></code>
<code lineno="18"><span class="rx-ws">    </span><span class="rx-kw">end</span></code>
<code lineno="19"><span class="rx-ws">    </span><span class="rx-kw">return</span><span class="rx-ws"> </span><span class="rx-var">self</span><span class="rx-op">~</span><span class="rx-const rx-method">map</span><span class="rx-spe">{</span><span class="rx-kw">expose</span><span class="rx-ws"> </span><span class="rx-xvar">left</span><span class="rx-ws"> </span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-xvar">left</span><span class="rx-ws"> </span><span class="rx-op">+</span><span class="rx-ws"> </span><span class="rx-var">item</span><span class="rx-spe">}</span>
</code></pre>
</div>
<p>Now you can write:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-env">.array</span><span class="rx-op">~</span><span class="rx-const rx-method">of</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">,</span><span class="rx-int rx-ipart">2</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-op">+</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">10</span><span class="rx-spe">=</span><span class="rx-ws">                </span><span class="rx-lncm">-- [11,12]</span></code>
<code lineno="2"><span class="rx-int rx-ipart">10</span><span class="rx-ws"> </span><span class="rx-op">+</span><span class="rx-ws"> </span><span class="rx-env">.array</span><span class="rx-op">~</span><span class="rx-const rx-method">of</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">,</span><span class="rx-int rx-ipart">2</span><span class="rx-spe">)</span><span class="rx-spe">=</span><span class="rx-ws">                </span><span class="rx-lncm">-- [11,12]</span></code>
<code lineno="3"><span class="rx-env">.array</span><span class="rx-op">~</span><span class="rx-const rx-method">of</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">,</span><span class="rx-int rx-ipart">2</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-op">+</span><span class="rx-ws"> </span><span class="rx-env">.array</span><span class="rx-op">~</span><span class="rx-const rx-method">of</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">3</span><span class="rx-spe">,</span><span class="rx-int rx-ipart">4</span><span class="rx-spe">)</span><span class="rx-spe">=</span><span class="rx-ws">    </span><span class="rx-lncm">-- [4,6]</span>
</code></pre>
</div>
<!-- ------------------------------- -->
<h3 id="design-decisions">14.2.   Design decisions</h3>
<!-- ------------------------------- -->
<p>Modification of the following methods to give a chance for an
alternative operator before forcing the second argument to a string:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode c++"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>RexxInteger<span class="op">::</span>concatBlank</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>RexxInteger<span class="op">::</span>concat</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>RexxNumberString<span class="op">::</span>concatBlank</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>RexxNumberString<span class="op">::</span>concat</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>RexxString<span class="op">::</span>concatRexx</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>RexxString<span class="op">::</span>concatBlank</span></code></pre></div>
<p>If the second argument is not a string, then try the alternative
operator before <code>REQUEST_STRING</code>.</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-var">a</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-env">.array</span><span class="rx-op">~</span><span class="rx-const rx-method">of</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">10</span><span class="rx-spe">,</span><span class="rx-int rx-ipart">20</span><span class="rx-spe">,</span><span class="rx-int rx-ipart">30</span><span class="rx-spe">)</span></code>
<code lineno="2"><span class="rx-int rx-ipart">100</span><span class="rx-op"> </span><span class="rx-var">a</span><span class="rx-spe">=</span><span class="rx-ws">                  </span><span class="rx-lncm">-- ['100 10','100 20','100 30'] instead of '100 an Array'</span></code>
<code lineno="3"><span class="rx-var">a</span><span class="rx-op"> </span><span class="rx-int rx-ipart">100</span><span class="rx-spe">=</span><span class="rx-ws">                  </span><span class="rx-lncm">-- ['10 100','20 100','30 100']</span></code>
<code lineno="4"><span class="rx-int rx-ipart">100</span><span class="rx-ws"> </span><span class="rx-op">|</span><span class="rx-op">|</span><span class="rx-ws"> </span><span class="rx-var">a</span><span class="rx-ws"> </span><span class="rx-spe">=</span><span class="rx-ws">              </span><span class="rx-lncm">-- [10010,10020,10030]          instead of '100an Array'</span></code>
<code lineno="5"><span class="rx-var">a</span><span class="rx-ws"> </span><span class="rx-op">|</span><span class="rx-op">|</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">100</span><span class="rx-ws"> </span><span class="rx-spe">=</span><span class="rx-ws">              </span><span class="rx-lncm">-- [10100,20100,30100]</span>
</code></pre>
</div>
<p>Modification of the following methods in <a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/trunk/interpreter/RexxClasses/CoreClasses.orx">CoreClasses.orx</a>
to give a chance for an alternative operator:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-env">.DateTime</span><span class="rx-op">~</span><span class="rx-const rx-method rx-oquo">"</span><span class="rx-const rx-method">-</span><span class="rx-const rx-method rx-cquo">"</span></code>
<code lineno="2"><span class="rx-env">.DateTime</span><span class="rx-op">~</span><span class="rx-const rx-method rx-oquo">"</span><span class="rx-const rx-method">+</span><span class="rx-const rx-method rx-cquo">"</span></code>
<code lineno="3"><span class="rx-env">.TimeSpan</span><span class="rx-op">~</span><span class="rx-const rx-method rx-oquo">"</span><span class="rx-const rx-method">-</span><span class="rx-const rx-method rx-cquo">"</span></code>
<code lineno="4"><span class="rx-env">.TimeSpan</span><span class="rx-op">~</span><span class="rx-const rx-method rx-oquo">"</span><span class="rx-const rx-method">+</span><span class="rx-const rx-method rx-cquo">"</span>
</code></pre>
</div>
<p>Illustration:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-var">ts1day</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-env">.TimeSpan</span><span class="rx-op">~</span><span class="rx-const rx-method">fromDays</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">)</span><span class="rx-ws">                  </span><span class="rx-lncm">-- (1.00:00:00.000000)</span></code>
<code lineno="2"><span class="rx-var">ts1hour</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-env">.TimeSpan</span><span class="rx-op">~</span><span class="rx-const rx-method">fromHours</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">)</span><span class="rx-ws">                </span><span class="rx-lncm">-- (01:00:00.000000)</span></code>
<code lineno="3"><span class="rx-var">date</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-env">.datetime</span><span class="rx-op">~</span><span class="rx-const rx-method">new</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">2013</span><span class="rx-spe">,</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">,</span><span class="rx-int rx-ipart">10</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">12</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">30</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">10</span><span class="rx-spe">)</span><span class="rx-ws">     </span><span class="rx-lncm">-- (2013-01-10T12:30:10.000000)</span></code>
<code lineno="4"><span class="rx-var">date</span><span class="rx-ws"> </span><span class="rx-op">+</span><span class="rx-ws"> </span><span class="rx-env">.array</span><span class="rx-op">~</span><span class="rx-const rx-method">of</span><span class="rx-spe">(</span><span class="rx-var">ts1hour</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">ts1day</span><span class="rx-spe">)</span><span class="rx-spe">=</span><span class="rx-ws">              </span><span class="rx-lncm">-- [(2013-01-10T13:30:10.000000),(2013-01-11T12:30:10.000000)]</span>
</code></pre>
</div>
<p>Got a crash because I don't always return a value from an
operator.<br />
In my approach of operator overriding, not returning a value is the way
to indicate that the current implementation doesn't know how to support
the current arguments.<br />
The lack of result is managed in the new implementation of the
operators, but is not managed in the rest of the interpreter.<br />
The crash was here:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode c++"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> RexxObject<span class="op">::</span>isEqual<span class="op">(</span>RexxObject <span class="op">*</span>other<span class="op">)</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>        ProtectedObject result<span class="op">;</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">-&gt;</span>sendMessage<span class="op">(</span>OREF_STRICT_EQUAL<span class="op">,</span> other<span class="op">,</span> result<span class="op">);</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">((</span>RexxObject <span class="op">*)</span>result<span class="op">)-&gt;</span>truthValue<span class="op">(</span>Error_Logical_value_method<span class="op">);</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>result is <code>NULL</code> when the user code doesn't return a
result, must be tested.<br />
Review of all the <code>sendMessage</code> used internally by the
interpreter, which need a test:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode c++"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>RexxClass<span class="op">::</span>isEqual</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>RexxInteger<span class="op">::</span>isEqual</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>RexxNumberString<span class="op">::</span>isEqual</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>RexxObject<span class="op">::</span>isEqual</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>RexxString<span class="op">::</span>hash</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>RexxString<span class="op">::</span>isEqual</span></code></pre></div>
<p>Made a review of all my ooRexx scripts to swap the position of
<code>.nil</code> in the tests, to make it the first argument.<br />
Since I defined the array operators, I can have an array as result for
operators "=", "==", "&lt;&gt;", etc... when the first argument is an
array.<br />
Had to swap <code>.nil</code> in <a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/trunk/interpreter/RexxClasses/StreamClasses.orx">StreamClasses.orx</a>.</p>
<p>This technique of putting <code>.nil</code> as first argument is
already used in several places of the interpreter.<br />
The reason is explained in rexxref (section Required string
values):<br />
When comparing a string object with <code>the Nil object</code>, if the
<code>NOSTRING</code> condition is being trapped, then</p>
<pre><code>if string = .nil</code></pre>
<p>will raise the <code>NOSTRING</code> condition, whereas</p>
<pre><code>if .nil = string</code></pre>
<p>will not as <code>the Nil object</code>’s "=" method does not expect
a string as an argument.</p>
<p>Previous work about swaping the position of .nil is not enough to
avoid errors.<br />
I have this case in <a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/samples/pipeline/pipe_extension_test.rex">pipe_extension_test.rex</a>:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-var">datas</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-env">.directory</span><span class="rx-op">~</span><span class="rx-const rx-method">new</span></code>
<code lineno="2"><span class="rx-var">datas</span><span class="rx-spe">[</span><span class="rx-str rx-oquo">"</span><span class="rx-str">key1</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">]</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-env">.array</span><span class="rx-op">~</span><span class="rx-const rx-method">of</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">header</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">2</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">footer</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span></code>
<code lineno="3"><span class="rx-var">datas</span><span class="rx-spe">[</span><span class="rx-str rx-oquo">"</span><span class="rx-str">key2</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">]</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-env">.array</span><span class="rx-op">~</span><span class="rx-const rx-method">of</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">header</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">5</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">3</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-op">-</span><span class="rx-int rx-ipart">9</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">12</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">footer</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span></code>
<code lineno="4"><span class="rx-var">datas</span><span class="rx-spe">[</span><span class="rx-str rx-oquo">"</span><span class="rx-str">key3</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">]</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-env">.array</span><span class="rx-op">~</span><span class="rx-const rx-method">of</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">header</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">4</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-int rx-fpart">6</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">5</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">footer</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span></code>
<code lineno="5"><span class="rx-lncm">-- The datas without the headers and footers</span></code>
<code lineno="6"><span class="rx-var">datas</span><span class="rx-op">~</span><span class="rx-const rx-method">pipe</span><span class="rx-spe">(</span><span class="rx-env">.inject</span><span class="rx-op"> </span><span class="rx-spe">{</span><span class="rx-var">item</span><span class="rx-spe">}</span><span class="rx-op"> </span><span class="rx-var">iterateBefore</span><span class="rx-op"> </span><span class="rx-var">memorize</span><span class="rx-ws"> </span><span class="rx-op">|</span><span class="rx-ws"> </span><span class="rx-env">.drop</span><span class="rx-op"> </span><span class="rx-var">first</span><span class="rx-op"> </span><span class="rx-spe">{</span><span class="rx-var">dataflow</span><span class="rx-spe">[</span><span class="rx-str rx-oquo">"</span><span class="rx-str">source</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">]</span><span class="rx-op">~</span><span class="rx-const rx-method">item</span><span class="rx-ws"> </span><span class="rx-spe">}</span><span class="rx-ws"> </span><span class="rx-op">|</span><span class="rx-ws"> </span><span class="rx-env">.drop</span><span class="rx-op"> </span><span class="rx-var">last</span><span class="rx-op"> </span><span class="rx-spe">{</span><span class="rx-var">dataflow</span><span class="rx-spe">[</span><span class="rx-str rx-oquo">"</span><span class="rx-str">source</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">]</span><span class="rx-op">~</span><span class="rx-const rx-method">item</span><span class="rx-ws"> </span><span class="rx-spe">}</span><span class="rx-ws"> </span><span class="rx-op">|</span><span class="rx-ws"> </span><span class="rx-env">.console</span><span class="rx-spe">)</span>
</code></pre>
</div>
<p>where the source of the pipe is a directory of arrays.<br />
The code in charge of the partitioning do this test:</p>
<pre><code>if previousPartitionItem &lt;&gt; partitionItem then do</code></pre>
<p>and an error is raised because the two arguments are arrays, and the
result is an array.<br />
Here, the goal is to test if the two arguments are the same object.</p>
<p>Conclusion:<br />
The operators for array programming should be:</p>
<ul>
<li>either activated only when needed, under control of the
programmer.</li>
<li>or deactivated by the interpreter when the context is a scalar
context (ex: when calling truthValue).</li>
<li>or not defined at all when conflicting with the interpreter
semantics.</li>
</ul>
<p>I select the third option: no longer override the operators "=", "=",
"&gt;&lt;", "&lt;&gt;", "==", "==".<br />
I provide the methods ~mapEqual, ~mapNotEqual, ~mapStrictEqual,
~mapStrictNotEqual.</p>
<p>Remember:<br />
When operators for array programming are activated, the only way to use
the scalar semantic is to refer explicitly to the <code>.Object</code>'s
operators.</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-var">a</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-env">.array</span><span class="rx-op">~</span><span class="rx-const rx-method">of</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">,</span><span class="rx-int rx-ipart">2</span><span class="rx-spe">,</span><span class="rx-int rx-ipart">3</span><span class="rx-spe">)</span></code>
<code lineno="2"><span class="rx-var">a</span><span class="rx-ws"> </span><span class="rx-op">=</span><span class="rx-op">=</span><span class="rx-ws"> </span><span class="rx-var">a</span><span class="rx-spe">=</span><span class="rx-ws">              </span><span class="rx-lncm">-- [1,1,1]</span></code>
<code lineno="3"><span class="rx-var">a</span><span class="rx-op">~</span><span class="rx-const rx-method rx-oquo">"</span><span class="rx-const rx-method">==</span><span class="rx-const rx-method rx-cquo">"</span><span class="rx-spe">(</span><span class="rx-var">a</span><span class="rx-spe">)</span><span class="rx-spe">=</span><span class="rx-ws">           </span><span class="rx-lncm">-- [1,1,1]</span></code>
<code lineno="4"><span class="rx-var">a</span><span class="rx-op">~</span><span class="rx-const rx-method rx-oquo">"</span><span class="rx-const rx-method">==</span><span class="rx-const rx-method rx-cquo">"</span><span class="rx-spe">:</span><span class="rx-env">.object</span><span class="rx-spe">(</span><span class="rx-var">a</span><span class="rx-spe">)</span><span class="rx-spe">=</span><span class="rx-ws">   </span><span class="rx-lncm">-- 1</span>
</code></pre>
</div>
<p>I have no problem with <code>.array~ppRepresentation</code>, whereas
there is a test of equality to detect if a recursive array is
printed.<br />
Normally should raise an error because of <code>"=="</code> returning an
array.<br />
But it seems that <code>level = stack~index(val)</code> is not impacted
by the array operator <code>"=="</code>.<br />
Verification in the implementation:</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode c++"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>RexxObject <span class="op">*</span>RexxQueue<span class="op">::</span>index<span class="op">(</span>RexxObject <span class="op">*</span>target<span class="op">)</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    uses<span class="op">:</span> <span class="cf">if</span> <span class="op">(</span>target<span class="op">-&gt;</span>equalValue<span class="op">(</span>element<span class="op">-&gt;</span>value<span class="op">))</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> RexxObject <span class="op">:</span> <span class="kw">public</span> RexxInternalObject <span class="op">{</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>     <span class="dt">bool</span> <span class="kw">inline</span> equalValue<span class="op">(</span>RexxObject <span class="op">*</span>other<span class="op">)</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>     <span class="op">{</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>         <span class="co">// test first for direct equality, followed by value equality.</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>         <span class="cf">return</span> <span class="op">(</span><span class="kw">this</span> <span class="op">==</span> other<span class="op">)</span> <span class="op">||</span> <span class="kw">this</span><span class="op">-&gt;</span>isEqual<span class="op">(</span>other<span class="op">);</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>     <span class="op">}</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> RexxObject<span class="op">::</span>isEqual<span class="op">(</span> RexxObject <span class="op">*</span>other <span class="op">)</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span><span class="kw">this</span><span class="op">-&gt;</span>isBaseClass<span class="op">())</span> <span class="cf">return</span> <span class="op">((</span>RexxObject <span class="op">*)</span><span class="kw">this</span><span class="op">)</span> <span class="op">==</span> other<span class="op">;</span></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>  <span class="co">/* return truth value of a compare   */</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>        ProtectedObject result<span class="op">;</span></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">-&gt;</span>sendMessage<span class="op">(</span>OREF_STRICT_EQUAL<span class="op">,</span> other<span class="op">,</span> result<span class="op">);</span></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">((</span>RexxObject <span class="op">*)</span>result <span class="op">==</span> OREF_NULL<span class="op">)</span> reportException<span class="op">(</span>Error_No_result_object_message<span class="op">,</span> OREF_STRICT_EQUAL<span class="op">);</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">((</span>RexxObject <span class="op">*)</span>result<span class="op">)-&gt;</span>truthValue<span class="op">(</span>Error_Logical_value_method<span class="op">);</span></span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>So we have three cases for this test of equality:</p>
<ol type="1">
<li>If arg1 and arg2 are the same instance, then the equality is
true</li>
<li>If arg1 is a base class (i.e. not a subclass instance or an enhanced
one-off), then return true when arg1 and arg2 are the same
instance.</li>
<li>return <code>arg1~"=="(arg2)</code></li>
</ol>
<p>Only 1) and 2) happen because my test is done with instances of
<code>.Array</code> (so a base class).<br />
That explains why I don't have an error...</p>
<!-- ------------------------------- -->
<h3 id="shared-implementation-to-rework">14.3.   Shared implementation
to rework</h3>
<!-- ------------------------------- -->
<p>Some alternative messages are never sent by the interpreter, because
there is a shared implementation for some operators.<br />
For example: <code>""</code> and <code>"||"</code> are implemented by
the same method <code>concat</code>.<br />
The alternative message <code>"||op:right"</code> can be send, but the
message <code>"op:right"</code> will NEVER be sent.</p>
<pre><code>OP    RexxObject                          RexxInteger           RexxNumberString      RexxString            Comment
&quot;+&quot;   operator_plus                       plus                  plus                  plus
&quot;-&quot;   operator_minus                      minus                 minus                 minus
&quot;*&quot;   operator_multiply                   multiply              multiply              multiply
&quot;/&quot;   operator_divide                     divide                divide                divide
&quot;%&quot;   operator_integerDivide              integerDivide         integerDivide         integerDivide
&quot;//&quot;  operator_remainder                  remainder             remainder             remainder
&quot;**&quot;  operator_power                      power                 power                 power
&quot;&quot;    operator_abuttal                    concat                concat                concatRexx            should be ::abuttal everywhere
&quot;||&quot;  operator_concat                     concat                concat                concatRexx
&quot; &quot;   operator_concatBlank                concatBlank           concatBlank           concatBlank
&quot;=&quot;   operator_equal                      equal                 equal                 equal
&quot;\=&quot;  operator_notEqual                   notEqual              notEqual              notEqual
&quot;&gt;&quot;   operator_isGreaterThan              isGreaterThan         isGreaterThan         isGreaterThan
&quot;\&gt;&quot;  operator_isBackslashGreaterThan     isLessOrEqual         isLessOrEqual         isLessOrEqual         should be ::isBackslashGreaterThan everywhere
&quot;&lt;&quot;   operator_isLessThan                 isLessThan            isLessThan            isLessThan
&quot;\&lt;&quot;  operator_isBackslashLessThan        isGreaterOrEqual      isGreaterOrEqual      isGreaterOrEqual      should be ::isBackslashLessThan everywhere
&quot;&gt;=&quot;  operator_isGreaterOrEqual           isGreaterOrEqual      isGreaterOrEqual      isGreaterOrEqual
&quot;&lt;=&quot;  operator_isLessOrEqual              isLessOrEqual         isLessOrEqual         isLessOrEqual
&quot;==&quot;  operator_strictEqual                strictEqual           strictEqual           strictEqual
&quot;\==&quot; operator_strictNotEqual             strictNotEqual        strictNotEqual        strictNotEqual
&quot;&gt;&gt;&quot;  operator_strictGreaterThan          strictGreaterThan     strictGreaterThan     strictGreaterThan
&quot;\&gt;&gt;&quot; operator_strictBackslashGreaterThan strictLessOrEqual     strictLessOrEqual     strictLessOrEqual     should be ::strictBackslashGreaterThan everywhere
&quot;&lt;&lt;&quot;  operator_strictLessThan             strictLessThan        strictLessThan        strictLessThan
&quot;\&lt;&lt;&quot; operator_strictBackslashLessThan    strictGreaterOrEqual  strictGreaterOrEqual  strictGreaterOrEqual  should be ::strictBackslashLessThan everywhere
&quot;&gt;&gt;=&quot; operator_strictGreaterOrEqual       strictGreaterOrEqual  strictGreaterOrEqual  strictGreaterOrEqual
&quot;&lt;&lt;=&quot; operator_strictLessOrEqual          strictLessOrEqual     strictLessOrEqual     strictLessOrEqual
&quot;&lt;&gt;&quot;  operator_lessThanGreaterThan        notEqual              notEqual              notEqual              should be ::lessThanGreaterThan everywhere
&quot;&gt;&lt;&quot;  operator_greaterThanLessThan        notEqual              notEqual              notEqual              should be ::greaterThanLessThan everywhere
&quot;&amp;&quot;   operator_and                        andOp                 andOp                 andOp
&quot;|&quot;   operator_or                         orOp                  orOp                  orOp
&quot;&amp;&amp;&quot;  operator_xor                        xorOp                 xorOp                 xorOp
&quot;\&quot;   operator_not                        operatorNot           operatorNot           operatorNot</code></pre>
<!-- ======================================================================= -->
<h2 id="positional-arguments">15.   Positional arguments</h2>
<!-- ======================================================================= -->
<p>The correspondence between a caller's argument and a callee's
argument is done using the argument's position.</p>
<!-- ------------------------------- -->
<h3 id="argument-list">15.1.   Argument list</h3>
<!-- ------------------------------- -->
<p>Keep the trailing omitted arguments.</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-env">.array</span><span class="rx-op">~</span><span class="rx-const rx-method">of</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">10</span><span class="rx-spe">,</span><span class="rx-int rx-ipart">20</span><span class="rx-spe">,</span><span class="rx-int rx-ipart">30</span><span class="rx-spe">,</span><span class="rx-spe">,</span><span class="rx-spe">)</span><span class="rx-op">~</span><span class="rx-const rx-method">dimensions</span><span class="rx-spe">=</span><span class="rx-ws"> </span><span class="rx-lncm">-- [5] instead of [3]</span>
</code></pre>
</div>
<p>This is consistent with the array literals:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-const rx-ext-func">v</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">,</span><span class="rx-int rx-ipart">2</span><span class="rx-spe">,</span><span class="rx-spe">)</span><span class="rx-op"> </span><span class="rx-var">is</span><span class="rx-op"> </span><span class="rx-var">the</span><span class="rx-op"> </span><span class="rx-var">same</span><span class="rx-op"> </span><span class="rx-var">as</span><span class="rx-op"> </span><span class="rx-int rx-ipart">1</span><span class="rx-spe">,</span><span class="rx-int rx-ipart">2</span><span class="rx-spe">,</span>
</code></pre>
</div>
<p>[03/04/2021]<br />
I just discovered that rexxref.pdf acknowledges this
inconsistency:<br />
"If the array term has trailing commas, the returned array has a bigger
size than what <code>.Array~of(…)</code> would have returned:".<br />
So for official ooRexx, that's normal to have this inconsistency.</p>
<p>[01/05/2018]<br />
The change above has an unexpected effect on the regression tests:</p>
<pre><code>base/bif: [SYNTAX 40.5] raised unexpectedly
40.5 &quot;Missing argument in invocation of XXX; argument 2 is required&quot;</code></pre>
<p>is raised instead of</p>
<pre><code>40.3 &quot;Not enough arguments in invocation of XXX; minimum expected is 2.&quot;</code></pre>
<p>--&gt; <a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/trunk/interpreter/expression/BuiltinFunctions.cpp">BuiltinFunctions.cpp</a>:
function <code>expandArgs</code> updated to raise 40.3</p>
<!-- ------------------------------- -->
<h3 id="array-literals">15.2.   Array literals</h3>
<!-- ------------------------------- -->
<p>Retrofit from ooRexx5 the parsing of an expression where the
expression can be treated as a comma-separated list of
subexpressions.<br />
For an empty vector, or a vector of one element, the routine v is still
needed:</p>
<pre><code>()=     -- Syntax error: Incorrect expression detected at &quot;(&quot;
v()=    -- []
(1)=    -- 1
v(1)    -- [1]</code></pre>
<p>Align implementation of forward arguments to keep the trailing
omitted arguments</p>
<ul>
<li>official: <code>forward message "m" arguments ( (1,2,,) )</code> --
pass (1,2)</li>
<li>executor: <code>forward message "m" arguments ( (1,2,,) )</code> --
pass (1,2,,)</li>
</ul>
<!-- ------------------------------- -->
<h3 id="trailing-blocks">15.3.   Trailing blocks</h3>
<!-- ------------------------------- -->
<p>Added support for trailing blocks (similar to Groovy &amp; Swift
syntax for closures):</p>
<ul>
<li><code>f{...}</code> is equivalent to <code>f({...})</code></li>
<li><code>f(a1,a2,...){...}</code> is equivalent to
<code>f(a1,a2,...,{...})</code></li>
</ul>
<p>Example:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-int rx-ipart">10</span><span class="rx-op">~</span><span class="rx-const rx-method">times</span><span class="rx-spe">{</span><span class="rx-kw">call</span><span class="rx-ws"> </span><span class="rx-const rx-bif-proc">charout</span><span class="rx-ws"> </span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-const rx-bif-func">arg</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">)</span><span class="rx-spe">}</span><span class="rx-ws">  </span><span class="rx-lncm">-- 12345678910</span></code>
<code lineno="2"><span class="rx-int rx-ipart">4</span><span class="rx-op">~</span><span class="rx-const rx-method">upto</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">7</span><span class="rx-spe">)</span><span class="rx-spe">{</span><span class="rx-kw">call</span><span class="rx-ws"> </span><span class="rx-const rx-bif-proc">charout</span><span class="rx-ws"> </span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-const rx-bif-func">arg</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">)</span><span class="rx-spe">}</span><span class="rx-ws"> </span><span class="rx-lncm">-- 4567</span>
</code></pre>
</div>
<!-- ======================================================================= -->
<h2 id="named-arguments">16.   Named arguments</h2>
<!-- ======================================================================= -->
<p>The correspondence between a caller's argument and a callee's
argument is done using the argument's name.</p>
<!-- ------------------------------- -->
<h3 id="description-2">16.1.   Description</h3>
<!-- ------------------------------- -->
<p><a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/docs/NamedArguments/NamedArguments-Spec.md">Specification</a></p>
<p>Implemented.</p>
<p>The count of named arguments is passed with an additional C++
parameter.</p>
<pre><code>count=3, named_count=2
              +----+----+----+----+----+----+----+
              | P1 | P2 | P3 | N1 | V1 | N2 | V2 |
              +----+----+----+----+----+----+----+</code></pre>
<p><code>CPPCode::run</code> has only two cases to support: with or
without named arguments.<br />
The named arguments are passed as an array: ptr and count.<br />
<code>native_cpp_method(P1, P2, P3, array_ptr, array_count)</code></p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode c++"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> CPPCode<span class="op">::</span>run<span class="op">(</span>RexxActivity <span class="op">*</span>activity<span class="op">,</span> RexxMethod <span class="op">*</span>method<span class="op">,</span> RexxObject <span class="op">*</span>receiver<span class="op">,</span> RexxString <span class="op">*</span>messageName<span class="op">,</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    RexxObject <span class="op">**</span>argPtr<span class="op">,</span> <span class="dt">size_t</span> count<span class="op">,</span> <span class="dt">size_t</span> named_count<span class="op">,</span> ProtectedObject <span class="op">&amp;</span>result<span class="op">)</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>        RexxObject <span class="op">**</span>named_argPtr <span class="op">=</span> argPtr <span class="op">+</span> count<span class="op">;</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>              <span class="co">// positional only</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>              <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>                result <span class="op">=</span> <span class="op">(</span>receiver<span class="op">-&gt;*((</span>PCPPM2<span class="op">)</span>methodEntry<span class="op">))(</span>argPtr<span class="op">[</span><span class="dv">0</span><span class="op">],</span> argPtr<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>              <span class="co">// positional and named arguments</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>              <span class="cf">case</span> <span class="dv">2</span><span class="op">:</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>                result <span class="op">=</span> <span class="op">(</span>receiver<span class="op">-&gt;*((</span>PCPPM2N<span class="op">)</span>methodEntry<span class="op">))(</span>argPtr<span class="op">[</span><span class="dv">0</span><span class="op">],</span> argPtr<span class="op">[</span><span class="dv">1</span><span class="op">],</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>                                                            named_argPtr<span class="op">,</span> named_count<span class="op">);</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">...</span></span></code></pre></div>
<p>The callee can use the helper <code>NamedArguments.match</code> to
collect the named arguments in a useful order.<br />
Example:</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode c++"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>defineKernelMethod<span class="op">(</span><span class="st">&quot;UTF8PROC_TRANSFORM&quot;</span><span class="op">,</span> TheUnicodeClassBehaviour<span class="op">,</span> CPPM<span class="op">(</span>Unicode<span class="op">::</span>utf8proc_transform<span class="op">),</span> <span class="dv">1</span><span class="op">,</span> <span class="kw">true</span><span class="op">);</span>  <span class="co">// true ==&gt; support named arguments</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>RexxObject <span class="op">*</span>Unicode<span class="op">::</span>utf8proc_transform<span class="op">(</span>RexxString <span class="op">*</span>string<span class="op">,</span> RexxObject <span class="op">**</span>named_arglist<span class="op">,</span> <span class="dt">size_t</span> named_argcount<span class="op">)</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    string <span class="op">=</span> stringArgument<span class="op">(</span>string<span class="op">,</span> OREF_positional<span class="op">,</span> ARG_ONE<span class="op">);</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// use strict named arg casefold = .false, lump= .false, nlf = 0, normalization = 0, stripCC = .false, stripIgnorable= .false, stripMark = .false, stripNA = .false</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>    NamedArguments expectedNamedArguments<span class="op">(</span><span class="dv">8</span><span class="op">);</span> <span class="co">// 8 named arguments</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>    expectedNamedArguments<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> NamedArgument<span class="op">(</span><span class="st">&quot;CASEFOLD&quot;</span><span class="op">,</span>      TheFalseObject<span class="op">);</span> <span class="co">// default value = .false</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>    expectedNamedArguments<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> NamedArgument<span class="op">(</span><span class="st">&quot;LUMP&quot;</span><span class="op">,</span>          TheFalseObject<span class="op">);</span> <span class="co">// default value = .false</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>    expectedNamedArguments<span class="op">.</span>match<span class="op">(</span>named_arglist<span class="op">,</span> named_argcount<span class="op">,</span> <span class="co">/*strict*/</span> <span class="kw">true</span><span class="op">,</span> <span class="co">/*extraAllowed*/</span> <span class="kw">false</span><span class="op">);</span></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">ssize_t</span> casefold <span class="op">=</span>      integerRange<span class="op">(</span>expectedNamedArguments<span class="op">[</span><span class="dv">0</span><span class="op">].</span>value<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> Error_Logical_value_user_defined<span class="op">,</span> <span class="st">&quot;Transform: value of named argument </span><span class="sc">\&quot;</span><span class="st">casefold</span><span class="sc">\&quot;</span><span class="st"> must be 0 or 1&quot;</span><span class="op">);</span></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">ssize_t</span> lump <span class="op">=</span>          integerRange<span class="op">(</span>expectedNamedArguments<span class="op">[</span><span class="dv">1</span><span class="op">].</span>value<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> Error_Logical_value_user_defined<span class="op">,</span> <span class="st">&quot;Transform: value of named argument </span><span class="sc">\&quot;</span><span class="st">lump</span><span class="sc">\&quot;</span><span class="st"> must be 0 or 1&quot;</span><span class="op">);</span></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span></code></pre></div>
<p>All the native methods <code>A_COUNT</code> support named
arguments.</p>
<p>Native methods not <code>A_COUNT</code> which support named
arguments:</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode c++"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>TheObjectBehaviour        RexxObject<span class="op">::</span>startWith</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>TheObjectBehaviour        RexxObject<span class="op">::</span>sendWith</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>TheRoutineBehaviour       RoutineClass<span class="op">::</span>callWithRexx</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>TheRexxContextBehaviour   RexxContext<span class="op">::</span>setArgs</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>TheDirectoryBehaviour     RexxObject<span class="op">::</span>unknownRexx</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>TheStemBehaviour          RexxObject<span class="op">::</span>unknownRexx</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>TheIntegerBehaviour       RexxObject<span class="op">::</span>unknownRexx</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>TheNumberStringBehaviour  RexxObject<span class="op">::</span>unknownRexx</span></code></pre></div>
<!-- ------------------------------- -->
<h3 id="remaining-todo">16.2.   Remaining todo</h3>
<!-- ------------------------------- -->
<p><code>Message~new</code><br />
add support for the named argument <code>NAMEDARGUMENTS</code><br />
whose value <code>exprd</code> is a RexxDirectory.</p>
<pre><code>&gt;&gt;-new(-target-,-messagename-+-------------------------------------------------------+-)--&gt;&lt;
                             +-,-&quot;Individual&quot;--| Arguments |-------------------------+
                             +--+-------------------+--+--------------------------+--+
                                +-,-&quot;Array&quot;-,-expra-+  +-,-NAMEDARGUMENTS-:-exprd-+</code></pre>
<p><code>Message~namedArguments</code><br />
to implement</p>
<p>Changes in ooRexx5 that I don't need to support until
retrofitting:</p>
<pre><code>Message~send allows to pass arguments
Message~sendWith: new method
Message~start allows to pass arguments
Message~startWith: new method</code></pre>
<p><code>StackFrame~namedArguments</code><br />
to implement</p>
<p>Security manager <code>CALL</code><br />
Add <code>NAMEDARGUMENTS</code>: a directory of the function named
arguments to the information directory.</p>
<p>Security manager <code>METHOD</code><br />
Add <code>NAMEDARGUMENTS</code>: a directory of the method named
arguments to the information directory.</p>
<p><code>RexxNativeActivation::callNativeRoutine</code><br />
The named arguments are not passed to the native routine.</p>
<p>And of course the C++ API of ooRexx...</p>
<!-- ======================================================================= -->
<h2 id="dynamic-target-when-sending-a-message">17.   Dynamic target when
sending a message</h2>
<!-- ======================================================================= -->
<!-- ------------------------------- -->
<h3 id="description-3">17.1.   Description</h3>
<!-- ------------------------------- -->
<p>Add support for dynamic target when sending messages.<br />
The target is calculated based on the initial target and the arguments
values/types of the message.<br />
It's still a single-dispatch.<br />
The <code>~~</code> form of message is not impacted: it returns the
object that received the message (the initial target), not the
calculated target.</p>
<p>The forward instruction does not depend on the dynamic target
calculation.<br />
If you need to forward using the dynamic target then do:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-kw">forward</span><span class="rx-ws"> </span><span class="rx-skw">message</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">DYNAMICTARGET</span><span class="rx-str rx-cquo">"</span><span class="rx-ws"> </span><span class="rx-skw">continue</span></code>
<code lineno="2"><span class="rx-kw">forward</span><span class="rx-ws"> </span><span class="rx-skw">to</span><span class="rx-ws"> </span><span class="rx-spe">(</span><span class="rx-var">result</span><span class="rx-spe">)</span>
</code></pre>
</div>
<p>New method <code>.Object~dynamicTarget</code> which returns the
target in function of the arguments:</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode c++"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>RexxObject <span class="op">*</span>RexxObject<span class="op">::</span>dynamicTargetRexx<span class="op">(</span>RexxObject <span class="op">**</span>arguments<span class="op">,</span> <span class="dt">size_t</span> argCount<span class="op">,</span> <span class="dt">size_t</span> named_argCount<span class="op">)</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">this</span><span class="op">-&gt;</span>dynamicTarget<span class="op">(</span>arguments<span class="op">,</span> argCount<span class="op">,</span> named_argCount<span class="op">);</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<!-- ------------------------------- -->
<h3 id="default-dynamic-target">17.2.   Default dynamic target</h3>
<!-- ------------------------------- -->
<p>By default, the dynamic target is the receiver object.<br />
Native classes can override the virtual method dynamicTarget.<br />
For the moment, it's not possible to override this method with an ooRexx
method.</p>
<p>Examples:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">,</span><span class="rx-int rx-ipart">2</span><span class="rx-spe">)</span><span class="rx-op">~</span><span class="rx-const rx-method">dynamicTarget</span><span class="rx-spe">=</span><span class="rx-ws">                       </span><span class="rx-lncm">-- initial target: [ 1, 2]</span></code>
<code lineno="2"><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">,</span><span class="rx-int rx-ipart">2</span><span class="rx-spe">)</span><span class="rx-op">~</span><span class="rx-const rx-method">dynamicTarget</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">string</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span><span class="rx-spe">=</span><span class="rx-ws">             </span><span class="rx-lncm">-- initial target: [ 1, 2]</span></code>
<code lineno="3"><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">,</span><span class="rx-int rx-ipart">2</span><span class="rx-spe">)</span><span class="rx-op">~</span><span class="rx-const rx-method">dynamicTarget</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">string</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">teẌt</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span><span class="rx-spe">=</span><span class="rx-ws">     </span><span class="rx-lncm">-- initial target: [ 1, 2]</span>
</code></pre>
</div>
<!-- ------------------------------- -->
<h3 id="string-dynamic-target">17.3.   String dynamic target</h3>
<!-- ------------------------------- -->
<p>The <code>RexxString</code> class overrides the virtual method
<code>dynamicTarget</code>:</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode c++"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>RexxObject <span class="op">*</span>RexxString<span class="op">::</span>dynamicTarget<span class="op">(</span>RexxObject <span class="op">**</span>arguments<span class="op">,</span> <span class="dt">size_t</span> count<span class="op">,</span> <span class="dt">size_t</span> named_count<span class="op">)</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>hasRexxTextArguments<span class="op">(</span>arguments<span class="op">,</span> count<span class="op">,</span> named_count<span class="op">))</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>        RexxText <span class="op">*</span>text <span class="op">=</span> <span class="kw">this</span><span class="op">-&gt;</span>requestText<span class="op">();</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> text<span class="op">;</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">this</span><span class="op">;</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Examples:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-str rx-oquo">"</span><span class="rx-str">Noel</span><span class="rx-str rx-cquo">"</span><span class="rx-op">~</span><span class="rx-const rx-method">dynamicTarget</span><span class="rx-spe">=</span><span class="rx-ws">                       </span><span class="rx-lncm">-- initial target: 'Noel'</span></code>
<code lineno="2"><span class="rx-str rx-oquo">"</span><span class="rx-str">Noel</span><span class="rx-str rx-cquo">"</span><span class="rx-op">~</span><span class="rx-const rx-method">dynamicTarget</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">string</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span><span class="rx-spe">=</span><span class="rx-ws">             </span><span class="rx-lncm">-- initial target: 'Noel'</span></code>
<code lineno="3"><span class="rx-str rx-oquo">"</span><span class="rx-str">Noel</span><span class="rx-str rx-cquo">"</span><span class="rx-op">~</span><span class="rx-const rx-method">dynamicTarget</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">string</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">teẌt</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span><span class="rx-spe">=</span><span class="rx-ws">     </span><span class="rx-lncm">-- text counterpart of the initial target: T'Noel'  because "teẌt" is a RexxText</span>
</code></pre>
</div>
<!-- ======================================================================= -->
<h2 id="method-search-order">18.   Method search order</h2>
<!-- ======================================================================= -->
<p>(ooRexx5 has been modified to support that)</p>
<p>Allow to modify the method search order from anywhere.<br />
Before, was possible only from methods of the target object.</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-env">.c1</span><span class="rx-op">~</span><span class="rx-const rx-method">new</span><span class="rx-op">~</span><span class="rx-const rx-method">m</span></code>
<code lineno="2"><span class="rx-env">.c1</span><span class="rx-op">~</span><span class="rx-const rx-method">new</span><span class="rx-op">~</span><span class="rx-const rx-method">m</span><span class="rx-spe">:</span><span class="rx-env">.c2</span><span class="rx-ws"> </span><span class="rx-lncm">-- Now it's ok, interpreter modified to no longer raise:</span></code>
<code lineno="3"><span class="rx-ws">              </span><span class="rx-lncm">-- Message search overrides can be used only from methods of the target object</span></code>
<code lineno="4"></code>
<code lineno="5"><span class="rx-dir">::</span><span class="rx-dkw">class</span><span class="rx-ws"> </span><span class="rx-const rx-class">c1</span><span class="rx-ws"> </span><span class="rx-dskw">inherit</span><span class="rx-ws"> </span><span class="rx-const rx-class">c2</span></code>
<code lineno="6"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">m</span></code>
<code lineno="7"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">c1::m</span><span class="rx-str rx-cquo">"</span></code>
<code lineno="8"><span class="rx-var">self</span><span class="rx-op">~</span><span class="rx-const rx-method">m</span><span class="rx-spe">:</span><span class="rx-env">.c2</span></code>
<code lineno="9"></code>
<code lineno="10"><span class="rx-dir">::</span><span class="rx-dkw">class</span><span class="rx-ws"> </span><span class="rx-const rx-class">c2</span><span class="rx-ws"> </span><span class="rx-dskw">mixinclass</span><span class="rx-ws"> </span><span class="rx-const rx-class">object</span></code>
<code lineno="11"><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">m</span></code>
<code lineno="12"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">c2::m</span><span class="rx-str rx-cquo">"</span>
</code></pre>
</div>
<!-- ======================================================================= -->
<h2 id="routines-search-order">19.   Routines search order</h2>
<!-- ======================================================================= -->
<p>New entry <code>GLOBALROUTINES</code> in <code>.environment</code>,
which gives access to <code>TheFunctionsDirectory</code>.</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode c++"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>kernel_public<span class="op">(</span><span class="st">&quot;GLOBALROUTINES&quot;</span><span class="op">,</span> TheFunctionsDirectory<span class="op">,</span> TheEnvironment<span class="op">);</span> <span class="co">// give direct access to TheFunctionsDirectory</span></span></code></pre></div>
<p>This is a directory of global routines that are made available
everywhere, like the builtin functions.<br />
No need of ::requires directive to use them.</p>
<p><code>TheFunctionsDirectory</code> is no longer supported in ooRexx5
(deprecated).</p>
<p>A global routine with the same name as a builtin function overrides
this function.<br />
This is done by searching in TheFunctionsDirectory from</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode c++"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>RexxExpressionFunction<span class="op">::</span>evaluate</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>RexxInstructionCall<span class="op">::</span>execute</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>RexxInstructionCall<span class="op">::</span>trap</span></code></pre></div>
<p>when the target is a builtin function.<br />
If the call or function invocation uses a string literal, then the
search in <code>TheFunctionsDirectory</code> is bypassed.</p>
<p>This new functionality is used to override the builtin function
<code>XRANGE</code>, and make if compatible with ooRexx5.</p>
<p>Example of builtin function override:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-kw">call</span><span class="rx-ws"> </span><span class="rx-const rx-pkg-proc">internal</span><span class="rx-ws">   </span><span class="rx-lncm">-- override with internal routine</span></code>
<code lineno="2"><span class="rx-kw">call</span><span class="rx-ws"> </span><span class="rx-const rx-pkg-proc">external</span><span class="rx-ws">   </span><span class="rx-lncm">-- no override because the routine date is not global</span></code>
<code lineno="3"><span class="rx-kw">call</span><span class="rx-ws"> </span><span class="rx-const rx-pkg-proc">global</span><span class="rx-ws">     </span><span class="rx-lncm">-- override with global routine</span></code>
<code lineno="4"></code>
<code lineno="5"><span class="rx-dir">::</span><span class="rx-dkw">routine</span><span class="rx-ws"> </span><span class="rx-const rx-routine">internal</span></code>
<code lineno="6"><span class="rx-ws">    </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-const rx-int-func">date</span><span class="rx-spe">(</span><span class="rx-spe">)</span><span class="rx-ws">                                    </span><span class="rx-lncm">-- Internal date is 2 Jul 2021</span></code>
<code lineno="7"><span class="rx-ws">    </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-const rx-bif-func rx-oquo">"</span><span class="rx-const rx-bif-func">DATE</span><span class="rx-const rx-bif-func rx-cquo">"</span><span class="rx-spe">(</span><span class="rx-spe">)</span><span class="rx-ws">                                  </span><span class="rx-lncm">-- 2 Jul 2021</span></code>
<code lineno="8"><span class="rx-ws">    </span><span class="rx-kw">return</span></code>
<code lineno="9"><span class="rx-ws">    </span><span class="rx-const rx-label">date</span><span class="rx-spe">:</span><span class="rx-ws"> </span><span class="rx-kw">return</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">Internal date is </span><span class="rx-str rx-cquo">"</span><span class="rx-ws"> </span><span class="rx-op">|</span><span class="rx-op">|</span><span class="rx-ws"> </span><span class="rx-const rx-bif-func rx-oquo">"</span><span class="rx-const rx-bif-func">DATE</span><span class="rx-const rx-bif-func rx-cquo">"</span><span class="rx-spe">(</span><span class="rx-spe">)</span></code>
<code lineno="10"></code>
<code lineno="11"><span class="rx-dir">::</span><span class="rx-dkw">routine</span><span class="rx-ws"> </span><span class="rx-const rx-routine">external</span></code>
<code lineno="12"><span class="rx-ws">    </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-const rx-bif-func">date</span><span class="rx-spe">(</span><span class="rx-spe">)</span><span class="rx-ws">                                    </span><span class="rx-lncm">-- 2 Jul 2021</span></code>
<code lineno="13"><span class="rx-ws">    </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-const rx-bif-func rx-oquo">"</span><span class="rx-const rx-bif-func">DATE</span><span class="rx-const rx-bif-func rx-cquo">"</span><span class="rx-spe">(</span><span class="rx-spe">)</span><span class="rx-ws">                                  </span><span class="rx-lncm">-- 2 Jul 2021</span></code>
<code lineno="14"></code>
<code lineno="15"><span class="rx-dir">::</span><span class="rx-dkw">routine</span><span class="rx-ws"> </span><span class="rx-const rx-routine">global</span></code>
<code lineno="16"><span class="rx-ws">    </span><span class="rx-env">.globalRoutines</span><span class="rx-spe">[</span><span class="rx-str rx-oquo">"</span><span class="rx-str">DATE</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">]</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-env">.routines</span><span class="rx-spe">[</span><span class="rx-str rx-oquo">"</span><span class="rx-str">DATE</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">]</span></code>
<code lineno="17"><span class="rx-ws">    </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-const rx-bif-func">date</span><span class="rx-spe">(</span><span class="rx-spe">)</span><span class="rx-ws">                                    </span><span class="rx-lncm">-- Global date is 2 Jul 2021</span></code>
<code lineno="18"><span class="rx-ws">    </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-const rx-bif-func rx-oquo">"</span><span class="rx-const rx-bif-func">DATE</span><span class="rx-const rx-bif-func rx-cquo">"</span><span class="rx-spe">(</span><span class="rx-spe">)</span><span class="rx-ws">                                  </span><span class="rx-lncm">-- 2 Jul 2021</span></code>
<code lineno="19"></code>
<code lineno="20"><span class="rx-dir">::</span><span class="rx-dkw">routine</span><span class="rx-ws"> </span><span class="rx-const rx-routine">date</span></code>
<code lineno="21"><span class="rx-ws">    </span><span class="rx-kw">return</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">Global date is </span><span class="rx-str rx-cquo">"</span><span class="rx-ws"> </span><span class="rx-op">|</span><span class="rx-op">|</span><span class="rx-ws"> </span><span class="rx-const rx-bif-func rx-oquo">"</span><span class="rx-const rx-bif-func">DATE</span><span class="rx-const rx-bif-func rx-cquo">"</span><span class="rx-spe">(</span><span class="rx-spe">)</span>
</code></pre>
</div>
<!-- ======================================================================= -->
<h2 id="encoded-strings">20.   Encoded strings</h2>
<!-- ======================================================================= -->
<!-- ------------------------------- -->
<h3 id="native-integration">20.1.   Native integration</h3>
<!-- ------------------------------- -->
<p>The support of the encoded strings is implemented in <a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/trunk/interpreter/classes/TextClass.cpp">trunk/interpreter/classes/TextClass.cpp</a>.</p>
<p>Libraries:</p>
<ul>
<li><a
href="https://github.com/jlfaucher/executor/tree/master/sandbox/jlf/trunk/interpreter/classes/support/m17n/uni-algo">trunk/interpreter/classes/support/m17n/uni-algo</a></li>
<li><a
href="https://github.com/jlfaucher/executor/tree/master/sandbox/jlf/trunk/interpreter/classes/support/m17n/utf8proc">trunk/interpreter/classes/support/m17n/utf8proc</a></li>
</ul>
<p>99% of the integration is currently implemented by extension of these
native ooRexx classes:</p>
<pre><code>String
Text
MutableBuffer
Package
Unicode (expose the services provided by the libraries)</code></pre>
<p>New native methods:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-env">.String</span><span class="rx-op">~</span><span class="rx-const rx-method">!setEncoding</span></code>
<code lineno="2"><span class="rx-env">.String</span><span class="rx-op">~</span><span class="rx-const rx-method">!setText</span></code>
<code lineno="3"><span class="rx-env">.MutableBuffer</span><span class="rx-op">~</span><span class="rx-const rx-method">!setEncoding</span></code>
<code lineno="4"><span class="rx-env">.Package</span><span class="rx-op">~</span><span class="rx-const rx-method">!setEncoding</span>
</code></pre>
</div>
<p>to store natively these informations.<br />
Currently I have a dual storage (managed by extension, and managed by
these methods).<br />
In the end, only the native storage will remain.</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode c++"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> RexxString<span class="op">:</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>   <span class="co">// new attributes</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>   RexxObject <span class="op">*</span>text<span class="op">;</span>                   <span class="co">// The text counterpart or OREF_NULL</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>   RexxObject <span class="op">*</span>encoding<span class="op">;</span>               <span class="co">// The encoding or OREF_NULL.</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> RexxMutableBufferClass<span class="op">:</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>   <span class="co">// new attribute</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>   RexxObject <span class="op">*</span>encoding<span class="op">;</span>               <span class="co">// The encoding or OREF_NULL.</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PackageClass<span class="op">:</span></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>   <span class="co">// new attribute</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>   RexxObject <span class="op">*</span>encoding<span class="op">;</span>               <span class="co">// The encoding or OREF_NULL.</span></span></code></pre></div>
<p>Start native integration of RexxText in the interpreter.</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode c++"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co">// methods</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>RexxText <span class="op">*</span>RexxInternalObject<span class="op">::</span>textValue<span class="op">()</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>RexxText <span class="op">*</span>RexxObject<span class="op">::</span>textValue<span class="op">()</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>RexxText <span class="op">*</span>RexxInternalObject<span class="op">::</span>makeText<span class="op">()</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>RexxText <span class="op">*</span>RexxInternalObject<span class="op">::</span>primitiveMakeText<span class="op">()</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>RexxText <span class="op">*</span>RexxObject<span class="op">::</span>makeText<span class="op">()</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>RexxText <span class="op">*</span>RexxObject<span class="op">::</span>requestText<span class="op">()</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a><span class="co">// static methods</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> RexxText <span class="op">*</span>nullText<span class="op">;</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> RexxText <span class="op">*</span>newText<span class="op">(</span>RexxString <span class="op">*</span>s<span class="op">);</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a><span class="at">static</span> RexxText <span class="op">*</span>newText<span class="op">(</span><span class="at">const</span> <span class="dt">char</span> <span class="op">*</span>s<span class="op">,</span> <span class="dt">size_t</span> l<span class="op">);</span></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a><span class="co">// functions</span></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> RexxText <span class="op">*</span>new_text<span class="op">(</span>RexxString <span class="op">*</span>s<span class="op">)</span></span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> RexxText <span class="op">*</span>new_text<span class="op">(</span><span class="at">const</span> <span class="dt">char</span> <span class="op">*</span>s<span class="op">,</span> <span class="dt">size_t</span> l<span class="op">)</span></span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> RexxText <span class="op">*</span>new_text<span class="op">(</span><span class="at">const</span> <span class="dt">char</span> <span class="op">*</span>s<span class="op">)</span></span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>Metaclass RexxTextClass to mark the <span class="at">static</span> field RexxText<span class="op">::</span>nullText<span class="op">.</span></span></code></pre></div>
<!-- ------------------------------- -->
<h3 id="isascii">20.2.   <code>isASCII</code></h3>
<!-- ------------------------------- -->
<p>Add method <code>String~isASCII</code></p>
<p>Add method <code>MutableBuffer~isASCII</code><br />
Implementation more complex than for <code>String</code>, because
mutable.<br />
Try to avoid to rescan the whole buffer, when possible.<br />
The native methods that modify the buffer are never scanning the buffer,
they are just setting the boolean indicators
<code>is_ASCII_checked</code> and <code>is_ASCII</code>.<br />
It's only the Rexx method <code>~isASCII</code> which scans the whole
buffer, if needed.<br />
Impacted methods:</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode c++"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>append</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>caselessChangeStr</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>changeStr</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="kw">delete</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>delWord</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>insert</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>overlay</span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>replaceAt</span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>setBufferSize</span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>space</span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>translate</span></code></pre></div>
<!-- ------------------------------- -->
<h3 id="encoded-string-evaluation">20.3.   Encoded string
evaluation</h3>
<!-- ------------------------------- -->
<p>Automatic conversion of <code>String</code> literals to
<code>RexxText</code> instances.<br />
This is managed in <code>RexxString::evaluate</code>.<br />
Rules:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-kw">if</span><span class="rx-ws"> </span><span class="rx-var">string</span><span class="rx-op">~</span><span class="rx-const rx-method">isASCII</span><span class="rx-ws"> </span><span class="rx-kw">then</span><span class="rx-ws"> </span><span class="rx-var">value</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-var">string</span><span class="rx-ws">                               </span><span class="rx-lncm">-- R1 don't convert to RexxText if the string literal is ASCII (here, NO test of encoding, just testing the bytes)</span></code>
<code lineno="2"><span class="rx-kw">else</span><span class="rx-ws"> </span><span class="rx-kw">if</span><span class="rx-ws"> </span><span class="rx-env">.context</span><span class="rx-op">~</span><span class="rx-const rx-method">package</span><span class="rx-op">~</span><span class="rx-const rx-method">encoding</span><span class="rx-op">~</span><span class="rx-const rx-method">isByte</span><span class="rx-ws"> </span><span class="rx-kw">then</span><span class="rx-ws"> </span><span class="rx-var">value</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-var">string</span><span class="rx-ws">        </span><span class="rx-lncm">-- R2 don't convert to RexxText if the encoding of its definition package is the Byte_Encoding or a subclass of it (legacy package).</span></code>
<code lineno="3"><span class="rx-lncm">-- else if string~isCompatibleWithByteString then value = string    -- R3 (no longer applied) don't convert to RexxText if the string literal is compatible with a Byte string.</span></code>
<code lineno="4"><span class="rx-kw">else</span><span class="rx-ws"> </span><span class="rx-var">value</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-var">string</span><span class="rx-op">~</span><span class="rx-const rx-method">text</span><span class="rx-ws">                                            </span><span class="rx-lncm">-- R4 convert to RexxText</span>
</code></pre>
</div>
<p>The string BIFs become polymorphic on
<code>RexxString</code>/<code>RexxText</code>.<br />
If at least one positional argument is a <code>RexxText</code> then the
string BIFs forwards to <code>RexxText</code>,<br />
otherwise the string BIFs forward to <code>RexxString</code>.</p>
<p>The <code>String</code> messages become polymorphic on
<code>RexxString</code>/<code>RexxText</code>.<br />
If at least one positional argument is a <code>RexxText</code><br />
then the String message is sent to the <code>RexxText</code> counterpart
of the <code>String</code> instance,<br />
otherwise the <code>String</code> message is sent to the String
instance.<br />
This is implemented with a dynamic target.</p>
<!-- ======================================================================= -->
<h2 id="collection">21.   Collection</h2>
<!-- ======================================================================= -->
<p>Retrofit the method MapCollection~of from ooRexx5:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-var">aMapCollection</span><span class="rx-op">~</span><span class="rx-const rx-method">of</span><span class="rx-spe">(</span><span class="rx-ws"> </span><span class="rx-spe">(</span><span class="rx-var">key1</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">value1</span><span class="rx-spe">)</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-spe">(</span><span class="rx-var">key2</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">value2</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-cm">/*, ...*/</span><span class="rx-spe">)</span>
</code></pre>
</div>
<p>while keeping my own implementation that was available for
.Directory:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-var">aMapCollection</span><span class="rx-op">~</span><span class="rx-const rx-method">of</span><span class="rx-spe">(</span><span class="rx-var">key1</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">value1</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">key2</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">value2</span><span class="rx-ws"> </span><span class="rx-cm">/*, ...*/</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-const rx-argument-name">n1</span><span class="rx-spe">:</span><span class="rx-var">v1</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-const rx-argument-name">n2</span><span class="rx-spe">:</span><span class="rx-var">v2</span><span class="rx-ws"> </span><span class="rx-cm">/*, ...*/</span><span class="rx-spe">)</span>
</code></pre>
</div>
<p>The key-value where the key is compatible with a named argument can
be passed as named argument.<br />
The key-value where the key is not compatible with a named argument can
be passed as a pair of positional arguments.</p>
<p>ooRexx5 wants each key-value to be an array (key, value).<br />
I prefer to pass each key-value as 2 positional arguments, or as one
named argument.</p>
<p>I make my implementation compatible with ooRexx5:<br />
If the first argument is an array then assume it's the ooRexx5 way,
otherwise it's mine.</p>
<p>Examples:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-env">.stem</span><span class="rx-op">~</span><span class="rx-const rx-method">of</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">un</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">deux</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">2</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-const rx-argument-name">trois</span><span class="rx-spe">:</span><span class="rx-int rx-ipart">3</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-const rx-argument-name">quatre</span><span class="rx-spe">:</span><span class="rx-int rx-ipart">4</span><span class="rx-spe">)</span><span class="rx-spe">=</span>
</code></pre>
</div>
<pre><code>    a Stem (4 items)
    &#39;deux&#39;   :  2
    &#39;QUATRE&#39; :  4
    &#39;TROIS&#39;  :  3
    &#39;un&#39;     :  1</code></pre>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-env">.relation</span><span class="rx-op">~</span><span class="rx-const rx-method">of</span><span class="rx-spe">(</span><span class="rx-str rx-oquo">"</span><span class="rx-str">UN</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">10</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">DEUX</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">20</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-const rx-argument-name">un</span><span class="rx-spe">:</span><span class="rx-int rx-ipart">100</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-const rx-argument-name">deux</span><span class="rx-spe">:</span><span class="rx-int rx-ipart">200</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-const rx-argument-name">quatre</span><span class="rx-spe">:</span><span class="rx-int rx-ipart">400</span><span class="rx-spe">)</span><span class="rx-spe">=</span>
</code></pre>
</div>
<pre><code>    a Relation (5 items)
    &#39;DEUX&#39;   : [ 20, 200]
    &#39;QUATRE&#39; :  400
    &#39;UN&#39;     : [ 10, 100]</code></pre>
<!-- ======================================================================= -->
<h2 id="performance">22.   Performance</h2>
<!-- ======================================================================= -->
<!-- ------------------------------- -->
<h3 id="new-option-nomacrospace">22.1.   New option
<code>NOMACROSPACE</code></h3>
<!-- ------------------------------- -->
<p>Each call to an external function (like <code>SysXxx</code>
functions) triggers a communication with the <code>rxapi</code> server
through a socket (<code>QUERY_MACRO</code>, to test is the function is
defined in the macrospace).<br />
This has a major impact on performance !<br />
Example with <code>.yield[]</code> which calls <code>SysGetTid()</code>
or <code>SysQueryProcess("TID")</code> at each call:</p>
<pre><code>10000 calls to .yield[] with macrospace enabled  : 2.1312
10000 calls to .yield[] with macrospace disabled : 0.4531</code></pre>
<p>(JLF 2012 mar 23: <code>.yield[]</code> no longer depends on
<code>SysXXX</code> functions, now depends on <code>.threadLocal</code>
--&gt; faster)<br />
(<a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/samples/benchmark/doers-benchmark.output.txt">samples/benchmark/doers-benchmark-output.txt</a>)</p>
<p>The following options control the use of macrospace:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-kw">options</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">MACROSPACE</span><span class="rx-str rx-cquo">"</span></code>
<code lineno="2"><span class="rx-kw">options</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">NOMACROSPACE</span><span class="rx-str rx-cquo">"</span></code>
<code lineno="3"><span class="rx-dir">::</span><span class="rx-dkw">options</span><span class="rx-ws"> </span><span class="rx-dskw">MACROSPACE</span></code>
<code lineno="4"><span class="rx-dir">::</span><span class="rx-dkw">options</span><span class="rx-ws"> </span><span class="rx-dskw">NOMACROSPACE</span>
</code></pre>
</div>
<p>By default, the macrospace is queried, according to the rules
described in rexxref section "7.2.1 Search order".<br />
When using the option <code>NOMACROSPACE</code>, the macrospace is not
queried.</p>
<!-- ------------------------------- -->
<h3 id="optimization-of-.context">22.2.   Optimization of
<code>.context</code></h3>
<!-- ------------------------------- -->
<p>Changed the search order in
<code>RexxDotVariable::evaluate</code>:<br />
Try first <code>context-&gt;rexxVariable</code>: <code>.methods</code>,
<code>.routines</code>, <code>.rs</code>, <code>.line</code>,
<code>.context</code><br />
then try <code>context-&gt;resolveDotVariable</code>:
<code>getSourceObject()-&gt;findClass(name)</code></p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode c++"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>findInstalledClass<span class="op">(</span>internalName<span class="op">)</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>findPublicClass<span class="op">(</span>internalName<span class="op">)</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>ActivityManager<span class="op">::</span>getLocalEnvironment<span class="op">(</span>internalName<span class="op">)</span> controlled by security manager</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>TheEnvironment<span class="op">-&gt;</span>at<span class="op">(</span>internalName<span class="op">)</span>                   controlled by security manager</span></code></pre></div>
<p>The use of <code>.context</code> becomes prominent with coactivities,
the goal of this change is to find the value of <code>.context</code> as
fast as possible.</p>
<p>Tested from ooRexxShell where more than 700 classes are loaded:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-kw">do</span><span class="rx-ws"> </span><span class="rx-var">i</span><span class="rx-asg">=</span><span class="rx-int rx-ipart">1</span><span class="rx-ws"> </span><span class="rx-skw">to</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">100000</span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-var">v</span><span class="rx-asg">=</span><span class="rx-env">.context</span><span class="rx-ws"> </span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-kw">end</span>
</code></pre>
</div>
<pre><code>    5 runs: 0.032 0.047 0.078 0.063 0.078</code></pre>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-env">.environment</span><span class="rx-op">~</span><span class="rx-const rx-method">my.var</span><span class="rx-asg">=</span><span class="rx-int rx-ipart">1</span></code>
<code lineno="2"><span class="rx-kw">do</span><span class="rx-ws"> </span><span class="rx-var">i</span><span class="rx-asg">=</span><span class="rx-int rx-ipart">1</span><span class="rx-ws"> </span><span class="rx-skw">to</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">100000</span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-var">v</span><span class="rx-asg">=</span><span class="rx-env">.my.var</span><span class="rx-ws"> </span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-kw">end</span>
</code></pre>
</div>
<pre><code>    5 runs: 0.703 0.625 0.593 0.594 0.672</code></pre>
<!-- ------------------------------- -->
<h3 id="optimization-of-sysactivityyield">22.3.   Optimization of
<code>SysActivity::yield</code></h3>
<!-- ------------------------------- -->
<p><a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/trunk/interpreter/platform/windows/SysActivity.hpp">interpreter.hpp</a><br />
<a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/trunk/interpreter/platform/unix/SysActivity.hpp">interpreter.hpp</a></p>
<p>Moved <code>SysActivity::yield</code> to the .cpp file to reduce the
amount of recompilation when experimenting various settings.<br />
For the moment, <code>sleep(0)</code> under Windows works fine for me,
and is quit faster than sleep(1) used in standard ooRexx.</p>
<pre><code>sleep(0): rexx coactivity-stress.rex 100 --&gt; global duration=1.671, duration per consumer=0.01671
sleep(1): rexx coactivity-stress.rex 100 --&gt; global duration=24.625, duration per consumer=0.24625</code></pre>
<!-- ------------------------------- -->
<h3 id="performance-notes">22.4.   Performance notes</h3>
<!-- ------------------------------- -->
<p>Apply fix for SVN bug #1402<br />
There is a subtle interaction between native and rexx activations
when<br />
native calls make calls to APIs that in turn invoke Rexx code. When
conditions<br />
occur and the stack is being unwound, the ApiContext destructors will
release<br />
the kernel access, which can leave us with no active Activity.</p>
<p>While retrofiting this bug fix, I discover that the interpreter is
client of his external API:</p>
<p><a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/trunk/interpreter/streamLibrary/StreamNative.cpp">StreamNative.cpp</a></p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode c++"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>RexxMethod3<span class="op">(</span><span class="dt">int</span><span class="op">,</span> stream_lineout<span class="op">,</span> CSELF<span class="op">,</span> streamPtr<span class="op">,</span> OPTIONAL_RexxStringObject<span class="op">,</span> string<span class="op">,</span> <span class="dt">OPTIONAL_int64_t</span><span class="op">,</span> position<span class="op">)</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> StreamInfo<span class="op">::</span>lineout<span class="op">(</span>RexxStringObject data<span class="op">,</span> <span class="dt">bool</span> _setPosition<span class="op">,</span> <span class="dt">int64_t</span> position<span class="op">)</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">char</span> <span class="op">*</span>stringData <span class="op">=</span> context<span class="op">-&gt;</span>StringData<span class="op">(</span>data<span class="op">);</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">size_t</span> length <span class="op">=</span> context<span class="op">-&gt;</span>StringLength<span class="op">(</span>data<span class="op">);</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p>These calls seems rather costly in term of performance.<br />
Any API entry starts with</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode c++"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>ApiContext context<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>which calls<span class="op">:</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    activity<span class="op">-&gt;</span>enterCurrentThread<span class="op">();</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>        requestAccess<span class="op">();</span></span></code></pre></div>
<p>On return from the API entry, the destructors calls:</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode c++"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>activity<span class="op">-&gt;</span>exitCurrentThread<span class="op">();</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>    releaseAccess<span class="op">()</span></span></code></pre></div>
<!-- ======================================================================= -->
<h2 id="monitoring">23.   Monitoring</h2>
<!-- ======================================================================= -->
<p>Added counters for monitoring interpreter activities:</p>
<ul>
<li><code>.yieldCounter</code>: how many times
<code>SysActivity::yield</code> has been called since the begining</li>
<li><code>.addWaitingActivityCounter</code>: how many times
<code>ActivityManager::addWaitingActivity</code> has been called since
the begining</li>
<li><code>.relinquishCounter</code>: how many times
<code>ActivityManager::relinquish</code> has been called since the
begining</li>
<li><code>.requestAccessCounter</code>: how many times
<code>RexxActivity::requestAccess</code> has been called since the
begining</li>
<li><code>.getAPIManagerCounter</code>: how many times
<code>LocalAPIContext::getAPIManager</code> has been called since the
begining</li>
</ul>
<p>See <a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/samples/concurrency/coactivity-stress.rex">samples/concurrency/coactivity-stress.rex</a><br />
See <a
href="https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/samples/concurrency/factorials_generators.rex">samples/concurrency/factorials_generators.rex</a></p>
<!-- ======================================================================= -->
<h2 id="security-manager-optimization">24.   Security manager:
optimization</h2>
<!-- ======================================================================= -->
<!-- ------------------------------- -->
<h3 id="optional-methods">24.1.   Optional methods</h3>
<!-- ------------------------------- -->
<p>It's no longer mandatory to implement all the methods of a security
manager.<br />
When a check is not needed, just don't provide the corresponding
method.<br />
That can reduce drastically the number of security checkpoint messages
sent by the interpreter.</p>
<!-- ------------------------------- -->
<h3 id="method-unknowndisabled">24.2.   Method unknownDisabled</h3>
<!-- ------------------------------- -->
<p>This is an optimization available only with Executor.<br />
If the method <code>unknownDisabled</code> exists, then the method
<code>unknown</code> of the security manager is disabled (never
called).</p>
<p>When a security manager is registered, the official ooRexx
interpreter raises an error if the following messages are not
understood:<br />
<code>call</code>, <code>command</code>, <code>environment</code>,
<code>local</code>, <code>method</code>, <code>requires</code>,
<code>stream</code>.<br />
So no choice with official ooRexx, either the corresponding method or
the method <code>unknown</code> must be defined.</p>
<p>Optimizations with Executor:<br />
When the security manager is registered, the methods <code>call</code>,
<code>command</code>, <code>environment</code>, <code>local</code>,
<code>method</code>, <code>requires</code>, <code>stream</code> are
searched on the security manager.<br />
If not found, and <code>unknown</code> is not defined or
<code>unknownDisabled</code> is defined then the corresponding messages
are flagged to be never sent.<br />
The test of existence is done only when the security manager is
registered, not at each checkpoint.</p>
<!-- ------------------------------- -->
<h3 id="two-messages-for-each-check">24.3.   Two messages for each
check</h3>
<!-- ------------------------------- -->
<p>Each access to the global <code>.environment</code> will raise two
messages sent to the security manager:<br />
<code>local</code> and then <code>environment</code>.</p>
<p>Messages sent for nothing, since I return 0 to indicate that the
program is authorized to perform the action.<br />
if <code>unknownDisabled</code> is defined:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-kw">do</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1000000</span><span class="rexx">;</span><span class="rx-var">x</span><span class="rx-asg">=</span><span class="rx-env">.stdout</span><span class="rexx">;</span><span class="rx-kw">end</span><span class="rx-ws">   </span><span class="rx-lncm">-- 0.86 sec with ooRexx5, 0.08 sec with Executor (10x faster)</span></code>
<code lineno="2"><span class="rx-kw">do</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1000000</span><span class="rexx">;</span><span class="rx-var">x</span><span class="rx-asg">=</span><span class="rx-env">.context</span><span class="rexx">;</span><span class="rx-kw">end</span><span class="rx-ws">  </span><span class="rx-lncm">-- 1.64 sec with ooRexx5, 0.06 sec with Executor (27x faster, special optimization)</span></code>
<code lineno="3"><span class="rx-kw">do</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1000000</span><span class="rexx">;</span><span class="rx-var">x</span><span class="rx-asg">=</span><span class="rx-int rx-ipart">1</span><span class="rexx">;</span><span class="rx-kw">end</span><span class="rx-ws">         </span><span class="rx-lncm">-- 0.03 sec (here, the security manager is not used)</span>
</code></pre>
</div>
<p>if <code>unknownDisabled</code> is not defined:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-kw">do</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1000000</span><span class="rexx">;</span><span class="rx-var">x</span><span class="rx-asg">=</span><span class="rx-env">.stdout</span><span class="rexx">;</span><span class="rx-kw">end</span><span class="rx-ws">   </span><span class="rx-lncm">-- 0.86 sec with ooRexx5, 0.75 sec with Executor (equivalent)</span></code>
<code lineno="2"><span class="rx-kw">do</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1000000</span><span class="rexx">;</span><span class="rx-var">x</span><span class="rx-asg">=</span><span class="rx-env">.context</span><span class="rexx">;</span><span class="rx-kw">end</span><span class="rx-ws">  </span><span class="rx-lncm">-- 1.66 sec with ooRexx5, 0.07 sec with Executor (23x faster, special optimization)</span></code>
<code lineno="3"><span class="rx-kw">do</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1000000</span><span class="rexx">;</span><span class="rx-var">x</span><span class="rx-asg">=</span><span class="rx-int rx-ipart">1</span><span class="rexx">;</span><span class="rx-kw">end</span><span class="rx-ws">         </span><span class="rx-lncm">-- 0.03 sec (here, the security manager is not used)</span>
</code></pre>
</div>
<!-- ======================================================================= -->
<h2 id="compatibility-with-classic-rexx">25.   Compatibility with
classic rexx</h2>
<!-- ======================================================================= -->
<p>Add support for variables <code>#</code> <code>@</code>
<code>$</code> <code>¢</code>.</p>
<p>Add support for assignment <code>V=</code> -- assign ""</p>
<p>Add support for instruction <code>UPPER</code>:</p>
<ul>
<li>same syntax as instruction <code>DROP</code></li>
<li>translate to upper case the value of each variable</li>
</ul>
<p>The Roseta Code script
"<code>Check-that-file-exists/check-that-file-exists-2.rexx</code>" uses
<code>~</code> as a negator character.<br />
Regina supports the following characters as negators:</p>
<pre><code>\ Backslash (ANSI Standard)
^ Caret
~ Tilde
¬ Logical Not</code></pre>
<p>Add support for <code>^</code> and <code>¬</code>.<br />
Not possible to use <code>~</code> as a negator character.</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-op">^</span><span class="rx-int rx-ipart">0</span><span class="rx-spe">=</span><span class="rx-ws">     </span><span class="rx-lncm">-- 1</span></code>
<code lineno="2"><span class="rx-op">^</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">=</span><span class="rx-ws">     </span><span class="rx-lncm">-- 0</span></code>
<code lineno="3"><span class="rx-op">¬</span><span class="rx-int rx-ipart">0</span><span class="rx-spe">=</span><span class="rx-ws">     </span><span class="rx-lncm">-- 1</span></code>
<code lineno="4"><span class="rx-op">¬</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">=</span><span class="rx-ws">     </span><span class="rx-lncm">-- 0</span></code>
<code lineno="5"><span class="rx-op">^</span><span class="rx-op">¬</span><span class="rx-op">^</span><span class="rx-int rx-ipart">0</span><span class="rx-spe">=</span><span class="rx-ws">   </span><span class="rx-lncm">-- 1</span></code>
<code lineno="6"><span class="rx-op">^</span><span class="rx-op">¬</span><span class="rx-op">^</span><span class="rx-op">¬</span><span class="rx-int rx-ipart">0</span><span class="rx-spe">=</span><span class="rx-ws">  </span><span class="rx-lncm">-- 0</span>
</code></pre>
</div>
<p>The operators <code>/=</code> and <code>/==</code> are supported in
TSO/E REXX as alternatives to <code>\=</code> and <code>\==</code>,
respectively.<br />
The Roseta Code script
"<code>Determine-if-a-string-is-numeric/determine-if-a-string-is-numeric.rexx</code>"
uses <code>/==</code>.<br />
Add support for <code>/=</code> and <code>/==</code></p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-str rx-oquo">"</span><span class="rx-str">a</span><span class="rx-str rx-cquo">"</span><span class="rx-ws"> </span><span class="rx-op">/</span><span class="rx-op">=</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str"> a </span><span class="rx-str rx-cquo">"</span><span class="rx-ws"> </span><span class="rx-spe">=</span><span class="rx-ws">      </span><span class="rx-lncm">-- 0</span></code>
<code lineno="2"><span class="rx-str rx-oquo">"</span><span class="rx-str">a</span><span class="rx-str rx-cquo">"</span><span class="rx-ws"> </span><span class="rx-op">/</span><span class="rx-op">=</span><span class="rx-op">=</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str"> a </span><span class="rx-str rx-cquo">"</span><span class="rx-ws"> </span><span class="rx-spe">=</span><span class="rx-ws">     </span><span class="rx-lncm">-- 1</span></code>
<code lineno="3"><span class="rx-str rx-oquo">"</span><span class="rx-str">a</span><span class="rx-str rx-cquo">"</span><span class="rx-ws"> </span><span class="rx-op">/</span><span class="rx-op">=</span><span class="rx-op">=</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">a</span><span class="rx-str rx-cquo">"</span><span class="rx-ws"> </span><span class="rx-spe">=</span><span class="rx-ws">       </span><span class="rx-lncm">-- 0</span>
</code></pre>
</div>
<!-- ======================================================================= -->
<h2 id="oodialog">26.   oodialog</h2>
<!-- ======================================================================= -->
<p>This is a very old version of ooDialog.</p>
<p>Added support for wide-chars in oodialog.<br />
Currently, the <code>"A"</code> Windows API is called, and the
conversion occurs there, inside Windows, based on the current
locale.<br />
When compiling ooDialog with wide chars UTF-16, the <code>"W"</code> API
is called directly, making the dialogs Unicode-enabled.</p>
<p>GTK+ uses UTF-8 internally.<br />
Most of the Unix-style operating systems use UTF-8 internally.<br />
So it's natural to use multi-byte chars in ooRexx instead of wide chars,
and to provide string services which supports UTF-8.</p>
<p>But the case of ooDialog is different:<br />
This is a Windows-only subsystem, and for better integration with
Windows, it must use UTF-16 chars internally.<br />
The conversion to UTF-16 is under the responsability of ooDialog, which
lets support code pages that are different from the system's default
code page.<br />
Typically, we can pass UTF-8 string to ooDialog which convert them to
UTF-16 strings before calling the Windows <code>"W"</code> API.</p>
<!-- ======================================================================= -->
<h2 id="thoughts-about-lazy-evaluation-of-arguments">27.   Thoughts
about lazy evaluation of arguments</h2>
<!-- ======================================================================= -->
<p>Not yet implemented.</p>
<p>Some articles:<br />
<a
href="https://dlang.org/articles/lazy-evaluation.html">https://dlang.org/articles/lazy-evaluation.html</a><br />
<a
href="https://colinfay.me/lazyeval/">https://colinfay.me/lazyeval/</a></p>
<p>Goal:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-var">x</span><span class="rx-asg">=</span><span class="rx-int rx-ipart">5</span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-spe">(</span><span class="rx-var">x</span><span class="rx-op">&lt;</span><span class="rx-op">&gt;</span><span class="rx-int rx-ipart">0</span><span class="rx-spe">)</span><span class="rx-op">~</span><span class="rx-const rx-method">?</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-op">/</span><span class="rx-var">x</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">infinity</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span><span class="rx-ws">      </span><span class="rx-lncm">-- 0.2</span></code>
<code lineno="2"><span class="rx-var">x</span><span class="rx-asg">=</span><span class="rx-int rx-ipart">0</span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-spe">(</span><span class="rx-var">x</span><span class="rx-op">&lt;</span><span class="rx-op">&gt;</span><span class="rx-int rx-ipart">0</span><span class="rx-spe">)</span><span class="rx-op">~</span><span class="rx-const rx-method">?</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">1</span><span class="rx-op">/</span><span class="rx-var">x</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">infinity</span><span class="rx-str rx-cquo">"</span><span class="rx-spe">)</span><span class="rx-ws">      </span><span class="rx-lncm">-- "infinity", instead of the error "divisor must not be zero"</span></code>
<code lineno="3"><span class="rx-var">a</span><span class="rx-asg">=</span><span class="rx-int rx-ipart">1</span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-var">b</span><span class="rx-asg">=</span><span class="rx-int rx-ipart">2</span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-kw">call</span><span class="rx-ws"> </span><span class="rx-const rx-ext-proc">swap</span><span class="rx-ws"> </span><span class="rx-var">a</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">b</span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">a</span><span class="rx-op"> </span><span class="rx-var">b</span><span class="rx-ws">       </span><span class="rx-lncm">-- 2 1</span>
</code></pre>
</div>
<p>When calling a routine, the target is evaluated and found.<br />
The target indicates if the arguments must be evaluated or not.<br />
This is independant from any instruction 'use arg' on the target
side.<br />
If the arguments must be evaluated then it's the current implementation:
pass an array of evaluated expressions.<br />
Otherwise pass an array of not-evaluated expressions.<br />
Probably an array of <code>LazyRexxExpression</code> which is a wrapper
holding the expression and the context for the evaluation (a
<code>RexxActivation</code>).</p>
<p>Signature for evaluation:</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode c++"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">virtual</span> RexxObject  <span class="op">*</span>evaluate<span class="op">(</span>RexxActivation <span class="op">*,</span> RexxExpressionStack <span class="op">*)</span></span></code></pre></div>
<p>Concrete implementations (Executor):</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode c++"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>RexxNumberString<span class="op">::</span>evaluate          stack<span class="op">-&gt;</span>push<span class="op">(</span><span class="kw">this</span><span class="op">);</span> <span class="cf">return</span> <span class="kw">this</span><span class="op">;</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>RexxInteger<span class="op">::</span>evaluate               stack<span class="op">-&gt;</span>push<span class="op">(</span><span class="kw">this</span><span class="op">);</span> <span class="cf">return</span> <span class="kw">this</span><span class="op">;</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>RexxUnaryOperator<span class="op">::</span>evaluate         stack<span class="op">-&gt;</span>prefixResult<span class="op">(</span>result<span class="op">);</span> <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>RexxBinaryOperator<span class="op">::</span>evaluate        stack<span class="op">-&gt;</span>operatorResult<span class="op">(</span>result<span class="op">);</span> <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>RexxExpressionMessage<span class="op">::</span>evaluate     loop <span class="op">{</span> <span class="kw">this</span><span class="op">-&gt;</span>arguments<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">]-&gt;</span>evaluate<span class="op">(</span>context<span class="op">,</span> stack<span class="op">);</span> <span class="op">}</span> stack<span class="op">-&gt;</span>send<span class="op">(</span><span class="kw">this</span><span class="op">-&gt;</span>messageName<span class="op">,</span> argcount<span class="op">,</span> namedArgcount<span class="op">,</span> result<span class="op">);</span> <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>RexxStemVariable<span class="op">::</span>evaluate          value <span class="op">=</span> context<span class="op">-&gt;</span>getLocalStem<span class="op">(</span><span class="kw">this</span><span class="op">-&gt;</span>stem<span class="op">,</span> <span class="kw">this</span><span class="op">-&gt;</span>index<span class="op">);</span> stack<span class="op">-&gt;</span>push<span class="op">(</span>value<span class="op">);</span> <span class="cf">return</span> value<span class="op">;</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>RexxCompoundVariable<span class="op">::</span>evaluate      value <span class="op">=</span> context<span class="op">-&gt;</span>evaluateLocalCompoundVariable<span class="op">(</span>stemName<span class="op">,</span> index<span class="op">,</span> <span class="op">&amp;</span>tails<span class="op">[</span><span class="dv">0</span><span class="op">],</span> tailCount<span class="op">);</span>stack<span class="op">-&gt;</span>push<span class="op">(</span>value<span class="op">);</span> <span class="cf">return</span> value<span class="op">;</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>RexxParseVariable<span class="op">::</span>evaluate         variable <span class="op">=</span> context<span class="op">-&gt;</span>getLocalVariable<span class="op">(</span>variableName<span class="op">,</span> index<span class="op">);</span> value <span class="op">=</span> variable<span class="op">-&gt;</span>getVariableValue<span class="op">();</span> stack<span class="op">-&gt;</span>push<span class="op">(</span>value<span class="op">);</span> <span class="cf">return</span> value<span class="op">;</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>RexxString<span class="op">::</span>evaluate                stack<span class="op">-&gt;</span>push<span class="op">(</span><span class="kw">this</span><span class="op">);</span> <span class="cf">return</span> <span class="kw">this</span><span class="op">;</span></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>RexxInternalObject<span class="op">::</span>evaluate        <span class="cf">return</span> OREF_NULL</span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>RexxSourceLiteral<span class="op">::</span>evaluate         value <span class="op">=</span> <span class="kw">new</span> RexxBlock<span class="op">(</span><span class="kw">this</span><span class="op">,</span> rexxContext<span class="op">);</span> stack<span class="op">-&gt;</span>push<span class="op">(</span>value<span class="op">);</span> <span class="cf">return</span> value<span class="op">;</span></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>RexxExpressionList<span class="op">::</span>evaluate        result <span class="op">=</span> new_array<span class="op">(</span>expressionCount<span class="op">);</span> loop <span class="op">{</span> expr <span class="op">=</span> expressions<span class="op">[</span>i<span class="op">];</span> value <span class="op">=</span> expr<span class="op">-&gt;</span>evaluate<span class="op">(</span>context<span class="op">,</span> stack<span class="op">);</span> result<span class="op">-&gt;</span>put<span class="op">(</span>value<span class="op">,</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">);</span> <span class="op">}</span> stack<span class="op">-&gt;</span>push<span class="op">(</span>result<span class="op">);</span> <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>RexxExpressionFunction<span class="op">::</span>evaluate    loop <span class="op">{</span> <span class="kw">this</span><span class="op">-&gt;</span>arguments<span class="op">[</span>i<span class="op">]-&gt;</span>evaluate<span class="op">(</span>context<span class="op">,</span> stack<span class="op">);</span> call internal <span class="kw">or</span> builtin <span class="kw">or</span> external<span class="op">...;</span> stack<span class="op">-&gt;</span>push<span class="op">(</span>result<span class="op">);</span> <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>RexxDotVariable<span class="op">::</span>evaluate           result <span class="op">=</span> context<span class="op">-&gt;</span>rexxVariable<span class="op">(</span><span class="kw">this</span><span class="op">-&gt;</span>variableName<span class="op">);</span> stack<span class="op">-&gt;</span>push<span class="op">(</span>result<span class="op">);</span> <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a>RexxExpressionLogical<span class="op">::</span>evaluate     loop <span class="op">{</span> value <span class="op">=</span> expressions<span class="op">[</span>i<span class="op">]-&gt;</span>evaluate<span class="op">(</span>context<span class="op">,</span> stack<span class="op">);</span> <span class="cf">return</span> <span class="kw">true</span> <span class="kw">or</span> <span class="kw">false</span> <span class="op">}</span></span></code></pre></div>
<p>Example of lazy evaluation:</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-lncm">-- context = theRexxActivation1</span></code>
<code lineno="2"><span class="rx-var">a</span><span class="rx-asg">=</span><span class="rx-int rx-ipart">1</span><span class="rx-ws">                 </span><span class="rx-lncm">-- theRexxParseVariable1(variableName="A", index=6)</span></code>
<code lineno="3"><span class="rx-ws">                    </span><span class="rx-lncm">--     when evaluated in the context theRexxActivation1, it's theRexxVariable1(variable_name="A", variableValue=1, creator=theRexxActivation1)</span></code>
<code lineno="4"><span class="rx-var">b</span><span class="rx-asg">=</span><span class="rx-int rx-ipart">2</span><span class="rx-ws">                 </span><span class="rx-lncm">-- theRexxParseVariable2(variableName="B", index=7)</span></code>
<code lineno="5"><span class="rx-ws">                    </span><span class="rx-lncm">--     when evaluated in the context theRexxActivation1, it's theRexxVariable2(variable_name="B", variableValue=2, creator=theRexxActivation1)</span></code>
<code lineno="6"><span class="rx-kw">call</span><span class="rx-ws"> </span><span class="rx-const rx-pkg-proc">swap</span><span class="rx-ws"> </span><span class="rx-var">a</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-cont">-</span><span class="rx-ws">      </span><span class="rx-lncm">-- pass LazyRexxExpression~new(theRexxActivation1, theRexxParseVariable1)</span></code>
<code lineno="7"><span class="rx-ws">          </span><span class="rx-var">b</span><span class="rx-ws">         </span><span class="rx-lncm">-- pass LazyRexxExpression~new(theRexxActivation1, theRexxParseVariable2)</span></code>
<code lineno="8"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">a</span><span class="rx-ws">               </span><span class="rx-lncm">-- 2</span></code>
<code lineno="9"><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-var">b</span><span class="rx-ws">               </span><span class="rx-lncm">-- 1</span></code>
<code lineno="10"></code>
<code lineno="11"></code>
<code lineno="12"><span class="rx-dir">::</span><span class="rx-dkw">routine</span><span class="rx-ws"> </span><span class="rx-const rx-routine">swap</span><span class="rx-ws"> </span><span class="rx-cm">/*lazyargs*/</span><span class="rx-ws">         </span><span class="rx-lncm">-- The LAZYARGS option indicates that the arguments must not be evaluated on call</span></code>
<code lineno="13"><span class="rx-ws">    </span><span class="rx-lncm">-- context = RexxActivation2    -- The callee's context is different from the caller's context</span></code>
<code lineno="14"><span class="rx-ws">    </span><span class="rx-kw">use</span><span class="rx-ws"> </span><span class="rx-skw">strict</span><span class="rx-ws"> </span><span class="rx-skw">arg</span><span class="rx-ws"> </span><span class="rx-var">x</span><span class="rx-spe">,</span><span class="rx-ws"> </span><span class="rx-var">y</span><span class="rx-ws">             </span><span class="rx-lncm">-- x = theLazyRexxExpression1(theRexxActivation1, theRexxParseVariable1)</span></code>
<code lineno="15"><span class="rx-ws">                                    </span><span class="rx-lncm">-- y = theLazyRexxExpression2(theRexxActivation1, theRexxParseVariable2)</span></code>
<code lineno="16"><span class="rx-ws">                                    </span><span class="rx-lncm">-- If an argument is a LazyRexxExpression whose expression is a subclass of RexxVariableBase supporting assignment</span></code>
<code lineno="17"><span class="rx-ws">                                    </span><span class="rx-lncm">-- (RexxStemVariable, RexxCompoundVariable, RexxParseVariable, but not RexxDotVariable)</span></code>
<code lineno="18"><span class="rx-ws">                                    </span><span class="rx-lncm">-- then create an alias variable.</span></code>
<code lineno="19"><span class="rx-ws">                                    </span><span class="rx-lncm">-- [2021 Jul 7] Better to declare explictly that a special retriever must be used.</span></code>
<code lineno="20"><span class="rx-ws">                                    </span><span class="rx-lncm">--              The syntax would be the same as variable reference, but on callee side only.</span></code>
<code lineno="21"><span class="rx-ws">                                    </span><span class="rx-lncm">--              use strict arg &gt;x, &gt;y</span></code>
<code lineno="22"><span class="rx-ws">    </span><span class="rx-var">tmp</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-var">x</span><span class="rx-ws">                         </span><span class="rx-lncm">-- First evaluation of x, the value 1 is cached on theLazyRexxExpression1</span></code>
<code lineno="23"><span class="rx-ws">    </span><span class="rx-var">x</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-var">y</span><span class="rx-ws">                           </span><span class="rx-lncm">-- First evaluation of y, the value 2 is cached on theLazyRexxExpression2</span></code>
<code lineno="24"><span class="rx-ws">                                    </span><span class="rx-lncm">-- The assignment 'x =' is delegated to theRexxParseVariable1</span></code>
<code lineno="25"><span class="rx-ws">    </span><span class="rx-var">y</span><span class="rx-ws"> </span><span class="rx-asg">=</span><span class="rx-ws"> </span><span class="rx-var">x</span><span class="rx-ws">                           </span><span class="rx-lncm">-- Retrieve the cached value 2 stored on theLazyRexxExpression1</span></code>
<code lineno="26"><span class="rx-ws">                                    </span><span class="rx-lncm">-- The assignment 'y =' is delegated to theRexxParseVariable1</span>
</code></pre>
</div>
<p>To investigate:</p>
<ul>
<li><p><code>expose var</code><br />
<code>use arg &gt;var</code><br />
Will it work with <code>LazyRexxExpression</code> ?<br />
ooRexx5 raises
<code>Error 98.995:  Unable to reference variable "VAR"; it must be an uninitialized local variable</code>.</p></li>
<li><p><code>use arg &gt;var</code><br />
<code>drop var</code><br />
Will it work with LazyRexxExpression ?<br />
ooRexx5 drops the value of the referenced variable.</p></li>
<li><p>The reference operator supports stems but doesn't support
compound symbols.<br />
Will compound symbols be supported with <code>LazyRexxExpression</code>
?</p></li>
</ul>
<!-- ======================================================================= -->
<h2 id="thoughts-about-tail-recursion">28.   Thoughts about tail
recursion</h2>
<!-- ======================================================================= -->
<p>Not yet implemented.</p>
<p>See if it's possible to modify the implementation of FORWARD to
reduce the comsumption of stack frames.<br />
Should be possible when the option CONTINUE is not used.<br />
Could be used to emulate tail recursion.</p>
<p>Under MacOs, last value before stack overflow when calculating the
factorial:</p>
<!-- ------------------------------- -->
<h3 id="internal-procedure">28.1.   Internal procedure</h3>
<!-- ------------------------------- -->
<pre><code>x86_64  Executor: 1056      ooRexx5: 17441 (yes! and then segmentation fault)
arm64   Executor: 3568      ooRexx5: 20073 and then seg fault</code></pre>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-ws">    </span><span class="rx-kw">use</span><span class="rx-ws"> </span><span class="rx-skw">arg</span><span class="rx-ws"> </span><span class="rx-var">n</span></code>
<code lineno="2"><span class="rx-ws">    </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-const rx-int-func">factorial</span><span class="rx-spe">(</span><span class="rx-var">n</span><span class="rx-spe">)</span></code>
<code lineno="3"><span class="rx-ws">    </span><span class="rx-kw">return</span></code>
<code lineno="4"><span class="rx-ws">    </span><span class="rx-const rx-label">factorial</span><span class="rx-spe">:</span></code>
<code lineno="5"><span class="rx-ws">    </span><span class="rx-kw">use</span><span class="rx-ws"> </span><span class="rx-skw">arg</span><span class="rx-ws"> </span><span class="rx-var">n</span></code>
<code lineno="6"><span class="rx-ws">    </span><span class="rx-kw">if</span><span class="rx-ws"> </span><span class="rx-var">n</span><span class="rx-op">=</span><span class="rx-op">=</span><span class="rx-int rx-ipart">0</span><span class="rx-ws"> </span><span class="rx-kw">then</span><span class="rx-ws"> </span><span class="rx-kw">return</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1</span></code>
<code lineno="7"><span class="rx-ws">    </span><span class="rx-kw">else</span><span class="rx-ws"> </span><span class="rx-kw">return</span><span class="rx-ws"> </span><span class="rx-var">n</span><span class="rx-ws"> </span><span class="rx-op">*</span><span class="rx-ws"> </span><span class="rx-const rx-int-func">factorial</span><span class="rx-spe">(</span><span class="rx-var">n</span><span class="rx-op">-</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">)</span>
</code></pre>
</div>
<!-- ------------------------------- -->
<h3 id="routine-recursion-by-name">28.2.   Routine, recursion by
name</h3>
<!-- ------------------------------- -->
<pre><code>x86_64  Executor:  736      ooRexx5: 793
arm64   Executor: 3568      ooRexx5: 15230</code></pre>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-ws">    </span><span class="rx-kw">use</span><span class="rx-ws"> </span><span class="rx-skw">arg</span><span class="rx-ws"> </span><span class="rx-var">n</span></code>
<code lineno="2"><span class="rx-ws">    </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-const rx-pkg-func">factorial</span><span class="rx-spe">(</span><span class="rx-var">n</span><span class="rx-spe">)</span></code>
<code lineno="3"><span class="rx-ws">    </span><span class="rx-kw">return</span></code>
<code lineno="4"><span class="rx-ws">    </span><span class="rx-dir">::</span><span class="rx-dkw">routine</span><span class="rx-ws"> </span><span class="rx-const rx-routine">factorial</span></code>
<code lineno="5"><span class="rx-ws">    </span><span class="rx-kw">use</span><span class="rx-ws"> </span><span class="rx-skw">arg</span><span class="rx-ws"> </span><span class="rx-var">n</span></code>
<code lineno="6"><span class="rx-ws">    </span><span class="rx-kw">if</span><span class="rx-ws"> </span><span class="rx-var">n</span><span class="rx-op">=</span><span class="rx-op">=</span><span class="rx-int rx-ipart">0</span><span class="rx-ws"> </span><span class="rx-kw">then</span><span class="rx-ws"> </span><span class="rx-kw">return</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1</span></code>
<code lineno="7"><span class="rx-ws">    </span><span class="rx-kw">else</span><span class="rx-ws"> </span><span class="rx-kw">return</span><span class="rx-ws"> </span><span class="rx-var">n</span><span class="rx-ws"> </span><span class="rx-op">*</span><span class="rx-ws"> </span><span class="rx-const rx-pkg-func">factorial</span><span class="rx-spe">(</span><span class="rx-var">n</span><span class="rx-op">-</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">)</span>
</code></pre>
</div>
<!-- ------------------------------- -->
<h3 id="routine-recursion-by-calling-the-executable">28.3.   Routine,
recursion by calling the executable</h3>
<!-- ------------------------------- -->
<pre><code>x86_64  Executor:  487      ooRexx5: 511
arm64   Executor: 2214      ooRexx5: 10153</code></pre>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-ws">    </span><span class="rx-kw">use</span><span class="rx-ws"> </span><span class="rx-skw">arg</span><span class="rx-ws"> </span><span class="rx-var">n</span></code>
<code lineno="2"><span class="rx-ws">    </span><span class="rx-kw">say</span><span class="rx-ws"> </span><span class="rx-const rx-pkg-func">factorial</span><span class="rx-spe">(</span><span class="rx-var">n</span><span class="rx-spe">)</span></code>
<code lineno="3"><span class="rx-ws">    </span><span class="rx-kw">return</span></code>
<code lineno="4"><span class="rx-ws">    </span><span class="rx-dir">::</span><span class="rx-dkw">routine</span><span class="rx-ws"> </span><span class="rx-const rx-routine">factorial</span></code>
<code lineno="5"><span class="rx-ws">    </span><span class="rx-kw">use</span><span class="rx-ws"> </span><span class="rx-skw">arg</span><span class="rx-ws"> </span><span class="rx-var">n</span></code>
<code lineno="6"><span class="rx-ws">    </span><span class="rx-kw">if</span><span class="rx-ws"> </span><span class="rx-var">n</span><span class="rx-op">=</span><span class="rx-op">=</span><span class="rx-int rx-ipart">0</span><span class="rx-ws"> </span><span class="rx-kw">then</span><span class="rx-ws"> </span><span class="rx-kw">return</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1</span></code>
<code lineno="7"><span class="rx-ws">    </span><span class="rx-kw">else</span><span class="rx-ws"> </span><span class="rx-kw">return</span><span class="rx-ws"> </span><span class="rx-var">n</span><span class="rx-ws"> </span><span class="rx-op">*</span><span class="rx-ws"> </span><span class="rx-env">.context</span><span class="rx-op">~</span><span class="rx-const rx-method">executable</span><span class="rx-op">~</span><span class="rx-const rx-method">call</span><span class="rx-spe">(</span><span class="rx-var">n</span><span class="rx-op">-</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">)</span>
</code></pre>
</div>
<!-- ------------------------------- -->
<h3
id="block-recursion-by-calling-the-executable-with-call">28.4.   Block,
recursion by calling the executable with ~call</h3>
<!-- ------------------------------- -->
<pre><code>x86_64   484
arm64   2211</code></pre>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-ws">    </span><span class="rx-spe">{</span><span class="rx-kw">use</span><span class="rx-ws"> </span><span class="rx-skw">arg</span><span class="rx-ws"> </span><span class="rx-var">n</span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-kw">if</span><span class="rx-ws"> </span><span class="rx-var">n</span><span class="rx-op">=</span><span class="rx-op">=</span><span class="rx-int rx-ipart">0</span><span class="rx-ws"> </span><span class="rx-kw">then</span><span class="rx-ws"> </span><span class="rx-kw">return</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1</span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-kw">else</span><span class="rx-ws"> </span><span class="rx-kw">return</span><span class="rx-ws"> </span><span class="rx-var">n</span><span class="rx-ws"> </span><span class="rx-op">*</span><span class="rx-ws"> </span><span class="rx-env">.context</span><span class="rx-op">~</span><span class="rx-const rx-method">executable</span><span class="rx-op">~</span><span class="rx-const rx-method">call</span><span class="rx-spe">(</span><span class="rx-var">n</span><span class="rx-op">-</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-spe">}</span><span class="rx-op">~</span><span class="rx-const rx-method">call</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">484</span><span class="rx-spe">)</span><span class="rx-spe">=</span>
</code></pre>
</div>
<!-- ------------------------------- -->
<h3 id="block-recursion-by-calling-the-executable-with">28.5.   Block,
recursion by calling the executable with ~()</h3>
<!-- ------------------------------- -->
<pre><code>x86_64  197
arm64   832</code></pre>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-ws">    </span><span class="rx-spe">{</span><span class="rx-kw">use</span><span class="rx-ws"> </span><span class="rx-skw">arg</span><span class="rx-ws"> </span><span class="rx-var">n</span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-kw">if</span><span class="rx-ws"> </span><span class="rx-var">n</span><span class="rx-op">=</span><span class="rx-op">=</span><span class="rx-int rx-ipart">0</span><span class="rx-ws"> </span><span class="rx-kw">then</span><span class="rx-ws"> </span><span class="rx-kw">return</span><span class="rx-ws"> </span><span class="rx-int rx-ipart">1</span><span class="rexx">;</span><span class="rx-ws"> </span><span class="rx-kw">else</span><span class="rx-ws"> </span><span class="rx-kw">return</span><span class="rx-ws"> </span><span class="rx-var">n</span><span class="rx-ws"> </span><span class="rx-op">*</span><span class="rx-ws"> </span><span class="rx-env">.context</span><span class="rx-op">~</span><span class="rx-const rx-method">executable</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-var">n</span><span class="rx-op">-</span><span class="rx-int rx-ipart">1</span><span class="rx-spe">)</span><span class="rx-ws"> </span><span class="rx-spe">}</span><span class="rx-op">~</span><span class="rx-spe">(</span><span class="rx-int rx-ipart">197</span><span class="rx-spe">)</span><span class="rx-spe">=</span>
</code></pre>
</div>
<p>I would like to support the same limit 484 when using the doer method
~().</p>
<div class="highlight-rexx-vim-light-zellner">
<pre><code lineNo="1"><span class="rx-ws">    </span><span class="rx-dir">::</span><span class="rx-dkw">class</span><span class="rx-ws"> </span><span class="rx-const rx-class rx-oquo">"</span><span class="rx-const rx-class">Doer</span><span class="rx-const rx-class rx-cquo">"</span><span class="rx-ws"> </span><span class="rx-dskw">mixinclass</span><span class="rx-ws"> </span><span class="rx-const rx-class">Object</span><span class="rx-ws"> </span><span class="rx-dskw">public</span><span class="rx-ws"> </span><span class="rx-dskw">inherit</span><span class="rx-ws"> </span><span class="rx-const rx-class">DoerFactory</span></code>
<code lineno="2"><span class="rx-ws">    </span><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method rx-oquo">"</span><span class="rx-const rx-method">~()</span><span class="rx-const rx-method rx-cquo">"</span><span class="rx-ws"> </span><span class="rx-dskw">unguarded</span></code>
<code lineno="3"><span class="rx-ws">        </span><span class="rx-kw">forward</span><span class="rx-ws"> </span><span class="rx-skw">message</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">do</span><span class="rx-str rx-cquo">"</span></code>
<code lineno="4"><span class="rx-ws">        </span></code>
<code lineno="5"><span class="rx-ws">    </span><span class="rx-dir">::</span><span class="rx-dkw">class</span><span class="rx-ws"> </span><span class="rx-const rx-class rx-oquo">"</span><span class="rx-const rx-class">RoutineDoer</span><span class="rx-const rx-class rx-cquo">"</span><span class="rx-ws"> </span><span class="rx-dskw">mixinclass</span><span class="rx-ws"> </span><span class="rx-const rx-class">Object</span><span class="rx-ws"> </span><span class="rx-dskw">public</span><span class="rx-ws"> </span><span class="rx-dskw">inherit</span><span class="rx-ws"> </span><span class="rx-const rx-class">Doer</span></code>
<code lineno="6"><span class="rx-ws">    </span><span class="rx-dir">::</span><span class="rx-dkw">method</span><span class="rx-ws"> </span><span class="rx-const rx-method">do</span><span class="rx-ws"> </span><span class="rx-dskw">unguarded</span></code>
<code lineno="7"><span class="rx-ws">        </span><span class="rx-kw">forward</span><span class="rx-ws"> </span><span class="rx-skw">message</span><span class="rx-ws"> </span><span class="rx-str rx-oquo">"</span><span class="rx-str">call</span><span class="rx-str rx-cquo">"</span>
</code></pre>
</div>
          </div>
        </div>
        <div class="resize-handle"></div>
        <div class="col-md-3 toc-pane">

    <aside class="outline">
      <nav id="toc">
        <strong>Outline</strong>
        <ul></ul>
      </nav>
    </aside>

    <script>
        /* Auto-Generate the Outline from Headings */
        const content = document.getElementById("content");
        const tocList = document.querySelector("#toc ul");
        const headings = content.querySelectorAll("h2, h3, h4");

        headings.forEach((heading, index) => {
          if (!heading.id) {
            heading.id = `section-${index}`;
          }

          const li = document.createElement("li");
          li.classList.add(`level-${heading.tagName.toLowerCase()}`);

          const a = document.createElement("a");
          a.href = `#${heading.id}`;
          a.textContent = heading.textContent;

          li.appendChild(a);
          tocList.appendChild(li);
        });
    </script>

    <script>
        /* Highlight Active Section While Scrolling */
        const tocLinks = document.querySelectorAll("#toc a");

        const observer = new IntersectionObserver(
          entries => {
            entries.forEach(entry => {
              if (entry.isIntersecting) {
                tocLinks.forEach(link =>
                  link.classList.toggle(
                    "active",
                    link.getAttribute("href") === `#${entry.target.id}`
                  )
                );
              }
            });
          },
          {
            rootMargin: "-80px 0px -70% 0px"
          }
        );

        headings.forEach(h => observer.observe(h));
    </script>

    <script>
        /* Drag-to-Resize */
        (function () {
          const handle = document.querySelector(".resize-handle");
          const toc = document.querySelector(".toc-pane");

          let startX, startWidth;

          handle.addEventListener("mousedown", function (e) {
            startX = e.clientX;
            startWidth = toc.offsetWidth;

            document.addEventListener("mousemove", onMouseMove);
            document.addEventListener("mouseup", onMouseUp);
            e.preventDefault();
          });

          function onMouseMove(e) {
            const delta = startX - e.clientX;
            const newWidth = Math.min(
              420,
              Math.max(180, startWidth + delta)
            );

            toc.style.flexBasis = newWidth + "px";
          }

          function onMouseUp() {
            document.removeEventListener("mousemove", onMouseMove);
            document.removeEventListener("mouseup", onMouseUp);
          }
        })();
    </script>

        </div>
      </div>
    </div>
    <script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha384-nvAa0+6Qg9clwYCGGPpDQLVpLNn0fRaROjHqs13t4Ggj3Ez50XnGQqc/r8MhnRDZ" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
  </body>
</html>