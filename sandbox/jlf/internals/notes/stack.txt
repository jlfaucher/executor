================================================================================
Activation frame
================================================================================

RexxActivity.hpp
   RexxActivationStack   frameStack;   /* our stack used for activation frames */

   // the activation frame stack.  This stack is one RexxActivation or
   // RexxNativeActivation for every level of the call stack.  The activationStackSize
   // is the current size of the stack (which is expanded, if necessary).  The
   // activationStackDepth is the current count of frames in the stack.
   RexxInternalStack  *activations;
   size_t   activationStackSize;
   size_t   stackFrameDepth;

   // the following two fields represent the current top of the activation stack
   // and the top Rexx frame in the stack.  Generally, if executing Rexx code,
   // then currentRexxFrame == topStackFrame.  If we're at the base of the stack
   // topStackFrame will be the root stack element (a RexxNativeActivation instance)
   // and the currentRexxFrame will be OREF_NULL.  If we've made a callout from a
   // Rexx context, then the topStackFrame will be the RexxNativeActivation that
   // made the callout and the currentRexxFrame will be the predecessor frame.
   RexxActivation     *currentRexxFrame;
   RexxActivationBase *topStackFrame;

   inline RexxActivation *getCurrentRexxFrame() {return currentRexxFrame;}


===================================================================

   void        popStackFrame(bool  reply);
   void        popStackFrame(RexxActivationBase *);
   void        unwindStackFrame();
   void        unwindToDepth(size_t depth);
   void        unwindToFrame(RexxActivation *frame);
   void        cleanupStackFrame(RexxActivationBase *poppedStackFrame);

findRexxContext

setPreviousStackFrame
    RexxActivity::pushStackFrame
        RexxActivity::exitKernel
        RexxActivity::run
        RexxActivation::run
        RexxActivation::interpret
        RexxActivation::debugInterpret
        RexxActivation::internalCall
        RexxActivation::internalCallTrap
        RexxCode::call
        RexxCode::run
        RexxNativeMethod::run
        RexxNativeRoutine::call
        RegisteredRoutine::call


================================================================================
Review of stack space checking (because doers-stress.rex crashes under win7)
================================================================================

checkStackSpace

Controlled by the following macro definitions :
    interpreter\platform\unix\PlatformDefinitions.h
        #define MIN_C_STACK 1024*16                         16384
        #define STACKCHECK
    interpreter\platform\windows\PlatformDefinitions.h
        #define MIN_C_STACK 1024*(32 + sizeof(void *))      before fix : 32768, after fix for 32 bits : 1024*(32+4)=36864, for 64 bits : 1024*(32+8)=40960
        #define STACKCHECK
and also by activity->stackcheck, which is always true, except here :
    RexxActivity::messageSubstitution
don't know why this special case...


RexxActivity.cpp
    void RexxActivity::checkStackSpace()
    /******************************************************************************/
    /* Function:  Make sure there is enough stack space to run a method           */
    /******************************************************************************/
    {
    #ifdef STACKCHECK
      size_t temp;                          // if checking and there isn't room
      if (((char *)&temp - (char *)this->stackBase) < MIN_C_STACK && this->stackcheck == true)
      {
                                            // go raise an exception
          reportException(Error_Control_stack_full);
      }
    #endif
    }

called from :
    void RexxObject::messageSend        (ObjectClass.cpp)
    RexxActivation::interpret           (RexxActivation.cpp)
    RexxCode::call                      (RexxCode.cpp)
    RexxExpressionFunction::evaluate    (ExpressionFunction.cpp)
    RexxInstructionCall::execute        (CallInstruction.cpp)


---------------------------------------------------------------
Review of stack size declarations
---------------------------------------------------------------

There are TWO implementations of threads.                           Unix                                Windows
one used by trunk\rexxapi\server
    stack size (used to create thread, to calculate stack base)     THREAD_STACK_SIZE = 1024*96         THREAD_STACK_SIZE = 1024*512
    check stack space                                               no                                  no
one used by trunk\interpreter
    stack size (used only to calculate the stack base)              TOTAL_STACK_SIZE = 1024*512         TOTAL_STACK_SIZE = 1024*512
    check stack space : minimal reserve                             MIN_C_STACK = 1024*16               MIN_C_STACK = 1024*(32 + sizeof(void *))
    stack size used to create thread                                C_STACK_SIZE = TOTAL_STACK_SIZE     C_STACK_SIZE = 60000
                                                                                                        /STACK:524288 (1024 * 512)
Note :
MIN_C_STACK for Windows 32 bits = 1024*(32+4)=36864
MIN_C_STACK for Windows 64 bits = 1024*(32+8)=40960

Note :
The first thread is not created by ooRexx, it's the main thread of the process.
The stack size of this first thread is system dependent :
    Windows : given by /STACK:524288
    Unix : ???


Only in trunk\rexxapi\server :

    trunk\common\platform\unix\SysThread.hpp
        THREAD_STACK_SIZE = 1024*96

    trunk\common\platform\unix\SysThread.cpp
        NOT USED !
        char *SysThread::getStackBase()
        {
           int32_t temp;
           return ((char *)(&temp)) - THREAD_STACK_SIZE;
        }

    trunk\common\platform\windows\SysThread.hpp
        THREAD_STACK_SIZE = 1024*512

    trunk\common\platform\windows\SysThread.cpp
        NOT USED !
        char *SysThread::getStackBase()
        {
           int32_t temp;
           return ((char *)(&temp)) - THREAD_STACK_SIZE;
    }

Only in trunk\interpreter :
    trunk\interpreter\platform\unix\PlatformDefinitions.h
        #define MIN_C_STACK 1024*16
        #define TOTAL_STACK_SIZE 1024*512               0x80000    524288

    trunk\interpreter\platform\windows\PlatformDefinitions.h
        // we need a little more space on 64-bit platforms, so add some padding based on
        // the size of a pointer
        #define MIN_C_STACK 1024*(32 + sizeof(void *))   0xa000     40960   sizeof(void *) == 8 bytes
        #define TOTAL_STACK_SIZE 1024*512               0x80000    524288

    trunk\interpreter\platform\unix\SysActivity.cpp
        char *SysActivity::getStackBase(size_t stackSize)
        {
            size_t temp;
            return (char *)&temp - stackSize;
        }
    trunk\interpreter\platform\windows\SysActivity.cpp
        char *SysActivity::getStackBase(size_t stackSize)
        {
            size_t temp;
            return(char *)&temp - stackSize;
        }

    trunk\interpreter\concurrency\RexxActivity.hpp
        class RexxActivity : public RexxInternalObject {
            SysActivity currentThread;          /* descriptor for this thread        */
            char       *stackBase;              /* pointer to base of C stack        */

    trunk\interpreter\concurrency\RexxActivity.cpp
        void RexxActivity::runThread()
        {
            this->stackBase = currentThread.getStackBase(TOTAL_STACK_SIZE);
            ...

        void RexxActivity::checkStackSpace()
        {
            size_t temp;                          // if checking and there isn't room
            if (((char *)&temp - (char *)this->stackBase) < MIN_C_STACK && this->stackcheck == true)
            ...


(char *)&temp =           0x00000000000c75a0
(char *)this->stackBase = 0x00000000000bd5e0
                                        9fc0

RexxActivity.cpp
RexxActivity::RexxActivity
if (createThread)   --> 1er appel : false


 	rexx.dll!RexxActivity::RexxActivity(bool createThread)  Ligne 265	C++
 	rexx.dll!ActivityManager::createCurrentActivity()  Ligne 378 + 0x23 octets	C++
 	rexx.dll!ActivityManager::getRootActivity()  Ligne 691 + 0x5 octets	C++
 	rexx.dll!Interpreter::createInterpreterInstance(RexxOption * options)  Ligne 315 + 0x5 octets	C++
 	rexx.dll!Interpreter::createInterpreterInstance()  Ligne 95 + 0xb octets	C++
 	rexx.dll!InstanceBlock::InstanceBlock()  Ligne 383 + 0x5 octets	C++
 	rexx.dll!Interpreter::startInterpreter(Interpreter::InterpreterStartupMode mode)  Ligne 144 + 0xa octets	C++
 	rexx.dll!Interpreter::createInterpreterInstance(RexxOption * options)  Ligne 308 + 0xa octets	C++
 	rexx.dll!Interpreter::createInstance(RexxInstance_ * & instance, RexxThreadContext_ * & threadContext, RexxOption * options)  Ligne 266 + 0xd octets	C++
 	rexx.dll!RexxCreateInterpreter(RexxInstance_ * * instance, RexxThreadContext_ * * context, RexxOption * options)  Ligne 382 + 0x14 octets	C++
>	rexx.exe!main(int argc, char * * argv)  Ligne 198	C++

GetCurrentThreadId
GetCurrentThread

MSDN
http://msdn.microsoft.com/en-us/library/windows/desktop/ms686774%28v=vs.85%29.aspx
The default size for the reserved and initially committed stack memory is specified in the executable file header.
The default stack reservation size used by the linker is 1 MB. To specify a different default stack reservation size for all threads and fibers, use the STACKSIZE statement in the module definition (.def) file. The operating system rounds up the specified size to the nearest multiple of the system's allocation granularity (typically 64 KB).


trunk\utilities\rexx\platform\windows\rexx.mak
trunk\utilities\rexxc\platform\windows\rexxc.mak
trunk\utilities\platform\windows\rexxpaws\rexxpaws.mak
trunk\utilities\platform\windows\rexxhide\rexxhide.mak
trunk\platform\windows\rexximage.mak
/STACK:524288       JLF = 1024 * 512 donc mÃªme taille que pour thread stack


trunk\extensions\platform\windows\orxscrpt\orxscrpt.def
STACKSIZE 10240

trunk\extensions\platform\windows\orxscrpt\orxscrpt.mak
$(OR_OUTDIR)\ORXSCRPT.lib : $(CPPOBJS) $(OR_ORXSCRIPTSRC)\ORXSCRPT.def


