Remember :
To activate the GC diagnostics, add these definitions in RexxCore.h :
[later]
no... RexxCore.h is not included by all the files !
    #define CHECKOREFS      --> MemorySegment.hpp, used in RexxMemory.cpp
    #define MEMPROFILE      --> RexxMemory.hpp, DeadObject.hpp, RexxMemory.cpp, DeadObject.cpp
    #define VERBOSE_GC      --> RexxMemory.hpp, MemorySegment.cpp
or better : could be added in lib/orxwin32.mak to my_cdebug, when debug mode.
    /DCHECKOREFS /DMEMPROFILE /DVERBOSE_GC
or added in CMakeCacheText.txt
    CMAKE_CXX_FLAGS_DEBUG:STRING=/D_DEBUG /DCHECKOREFS /MDd /Zi /Ob0 /Od /RTC1
    CMAKE_C_FLAGS_DEBUG:STRING=/D_DEBUG /DCHECKOREFS /MDd /Zi /Ob0 /Od /RTC1

Remember :
When the crash occurs during GC (ex : in ObjectHeader::isObjectMarked), it's possible
to see which ooRexx object is corrupted. Here the object is 0x7eeff200
 	rexx.dll!ObjectHeader::isObjectMarked(unsigned int mark)  Line 106 + 0xa bytes	C++
 	rexx.dll!RexxInternalObject::isObjectMarked(unsigned int markword)  Line 247 + 0x16 bytes	C++
 	rexx.dll!RexxListTable::live(unsigned int liveMark)  Line 55 + 0x26 bytes	C++
>	rexx.dll!RexxMemory::markObjectsMain(RexxObject * rootObject)  Line 374	C++                 <-- markObject = 0x7eeff200 {size=2129676696 elements=0x7eeff214 }  RexxListTable with OVERWRITTEN size !!!
 	rexx.dll!RexxMemory::markObjects()  Line 645	C++
 	rexx.dll!RexxMemory::collect()  Line 1022	C++

A conditional break "newObj == 0x7eeff200" on the last line of RexxMemory::newObject (RexxMemory.cpp)
lets stop the execution when the object is created. If too long, then modify the source :
    if (newObj == (RexxObject*)0x7eeff200)
    {
        int dummy=0;    //  <-- put breakpoint here
    }
    return newObj;
Once the interpreter is stopped here, it's relatively easy to do a code review of the methods
in the call stack, to check if an intermediate object must be protected.

If needed, a data breakpoint can be set on the part of memory which is overwritten
(here the 'size' attribute). In my case, was triggered when the object was inserted
in the list of dead objects.


================================================================================

https://github.com/llvm/llvm-project/blob/main/llvm/docs/GarbageCollection.rst

================================================================================
2015 Sept

GC review
stringArgument can return a new string
which should be protected
--> review all the calls of stringArgument : done in v4.2

idem optionalStringArgument : done in v4.2
idem ->requiredString : done in v4.2
idem requiredStringArg : no problem, stored in expression stack
idem required_string : no problem, stored in expression stack
idem requestArray : done in v4.2
idem REQUEST_ARRAY : done in v4.2
idem makeArray : done

--------------------------------------------------------------------------------
Review the fixes done for GC in executor.
The goal is to apply them to v4.2

12/03/2012 "Commit pending changes" --> lot of changes for GC
06/03/2012 diary : list plenty of GC fixes
04/03/2012 diary : GC fixes
16/08/2011 diary : GC fixes
    Remember
    RexxCollection.cpp, RexxHashTableCollection::copy : newObj is not protected.
        Should be protected only if ActivityManager::currentActivity != NULL, otherwise crash in implementation of ProtectedObject's methods
        (RexxHashTableCollection::copy is called during interpreter initialization, and at this time, ActivityManager::currentActivity == NULL).


ArrayClass.cpp                              done 4.2, 4.2 work
RexxObject  *RexxArray::copy(void)
    todo : newArray is not protected


BuiltinFunctions.cpp                        done 4.2, 4.2 work
BUILTIN(VALUE)
before
            result = ((RexxString *)OREF_PERIOD)->concat(variable->upper());
after
            variable = variable->upper();
            ProtectedObject p(variable);
            result = ((RexxString *)OREF_PERIOD)->concat(variable);


CallInstruction.cpp                         done 4.2 work
void RexxInstructionCall::execute(
    ProtectedObject p_name;
    ...
            p_name = _name;


ClassClass.cpp                              done 4.2 work
ProtectedObject p1(enhanced_instance_mdict);
ProtectedObject p(enhancing_class_methods);


ClassClass.cpp                              done 4.2 work
RexxString *RexxClass::defaultName()
    /*RexxString * */ ProtectedObject defaultname = this->id;  /* use the id directly               */
                                         /* prefix with "The"                 */
    defaultname = ((RexxString*)defaultname)->concatToCstring("The ");
    /* add on "class"                    */
    defaultname = ((RexxString*)defaultname)->concatWithCstring(" class");


ClassClass.cpp                              done 4.2 work (including method_object)
RexxObject *RexxClass::defineMethod(
    ProtectedObject p(method_name);
    JLF : method_object should be also protected, according to my comment in diary on 16/08/2011


ClassClass.cpp                              done 4.2 work
RexxObject *RexxClass::defineClassMethod(RexxString *method_name, RexxMethod *newMethod)
    ProtectedObject p(method_name);


ClassClass.cpp                              done 4.2 work
RexxObject *RexxClass::deleteMethod(
    ProtectedObject p(method_name);


ClassClass.cpp                              done 4.2 work
RexxMethod *RexxClass::method(
    ProtectedObject p(method_name);


ClassClass.cpp                              done 4.2 work
void RexxClass::methodDictionaryMerge(
        ProtectedObject p(method_name);


ClassClass.cpp                              done 4.2 work
RexxTable *RexxClass::methodDictionaryCreate(
        ProtectedObject p(method_name);


ContextClass.cpp                            done 4.2 work
void RexxContext::live(size_t liveMark)
    (jlf : I don't see this variable in .h, is it coming from the superclass ?)
    memory_mark(this->objectVariables);


ContextClass.cpp                            done 4.2 work
void RexxContext::liveGeneral(int reason)
    memory_mark_general(this->objectVariables);


ContextClass.cpp                            not done
void RexxContext::flatten(RexxEnvelope *envelope)
  flatten_reference(newThis->objectVariables, envelope);                jlf : are you sure ??? not done


DirectoryClass.cpp                          done 4.2 work
RexxObject *RexxDirectory::copy()
    jlf : newObj must be protected (todo)


DirectoryClass.cpp                          done 4.2 work
RexxObject *RexxDirectory::setEntry(
    ProtectedObject p(entryname);


DirectoryClass.cpp                          done 4.2 work
RexxObject *RexxDirectory::setMethod(
    ProtectedObject p(entryname);


DirectoryClass.cpp                          done 4.2 work
RexxObject *RexxDirectory::newRexx(
    ProtectedObject p(newDirectory);


DoInstruction.cpp                           done 4.2 work
void RexxInstructionDo::execute(
    /*RexxObject * */ ProtectedObject result; /* expression evaluation result      */
    ...
                if (isOfClass(Array, (RexxObject*)result))      /* already an array item?            */
    ...
                        reportException(Error_Execution_noarray, (RexxObject*)result);
    ...
                if (isOfClass(Array, (RexxObject*)result))      /* already an array item?            */
    ...
                        reportException(Error_Execution_noarray, (RexxObject*)result);
    ...
                if (isOfClass(Integer, (RexxObject*)result) && context->digits() >= Numerics::DEFAULT_DIGITS)
    ...
                    count = ((RexxInteger *)(RexxObject*)result)->getValue();
    ...
                    if (!((RexxObject*)result)->requestNumber(count, number_digits()))
    ...
                if (isOfClass(Integer, (RexxObject*)result) && context->digits() >= Numerics::DEFAULT_DIGITS)
    ...
                    count = ((RexxInteger *)(RexxObject*)result)->getValue();
    ...
                    if (!((RexxObject*)result)->requestNumber(count, number_digits()))


DoInstruction.cpp                           done 4.2 work
void RexxInstructionDo::controlSetup(
    /*RexxObject * */ ProtectedObject result; /* expression result                 */
    ...
    + several casts


ExceptionClass.cpp                          not done (not in official 4.2)
void ExceptionClass::live(size_t liveMark)
    memory_mark(this->objectVariables);
}


ExceptionClass.cpp                          not done (not in official 4.2)
void ExceptionClass::liveGeneral(int reason)
    memory_mark_general(this->objectVariables);
}


ExceptionClass.cpp                          not done (not in official 4.2)
void ExceptionClass::flatten(RexxEnvelope *envelope)
  flatten_reference(newThis->objectVariables, envelope);

  cleanUpFlatten
}


ExceptionClass.cpp                          not done (not in official 4.2)
RexxDirectory *ExceptionClass::getCondition()
        ProtectedObject p(condition);


ExpressionStack.cpp                         done 4.2 work
#include "ProtectedObject.hpp"


ExpressionStack.cpp                         done 4.2 work
RexxString *RexxExpressionStack::requiredStringArg(
    ProtectedObject p(newStr);


ExpressionStack.cpp                         done 4.2 work
RexxString *RexxExpressionStack::optionalStringArg(
    ProtectedObject p(newStr);


ForwardInstruction.cpp
void RexxInstructionForward::execute(       done 4.2 work
    ProtectedObject p_message;
    ...
        _message = REQUEST_STRING(temp);    /* get the string version            */
        p_message = _message;
        _message = _message->upper();       /* and force to uppercase            */
        p_message = _message;


IdentityTableClass.cpp                      already done in official 4.2
#include "ProtectedObject.hpp"


IdentityTableClass.cpp                      already done in official 4.2
RexxObject *RexxIdentityTable::newRexx(RexxObject **args, size_t argCount)
    ProtectedObject p(newObj);


InstructionParser.cpp                       done 4.2 work
RexxInstruction *RexxSource::callNew()
    /* RexxString * */ ProtectedObject _condition = (RexxObject*)OREF_NULL; /* clear the condition               */
    ...
    + casts


InstructionParser.cpp                       done 4.2 work
RexxInstruction *RexxSource::raiseNew()
    /* RexxString * */ ProtectedObject _condition = token->value;           /* use the condition string value    */
    ...
    + casts


InstructionParser.cpp                       done 4.2 work (including newObject - another occurence also protected)
RexxInstruction *RexxSource::signalNew()
    /* RexxString * */ ProtectedObject _condition = (RexxString*)OREF_NULL; /* and no condition                  */
    ...
    + casts
    ----
    jlf : newObject to protect ? (not done)


IntegerClass.cpp                            done 4.2 work
RexxString *RexxInteger::concatBlank(
  ProtectedObject p(other);


IntegerClass.cpp                            done 4.2 work
RexxString *RexxInteger::concat(
  ProtectedObject p(other);


Interpreter.cpp                             done 4.2 work
RexxClass *Interpreter::findClass(RexxString *className)
    ProtectedObject p(internalName);


InterpreterInstance.cpp                     done 4.2 work
CommandHandler *InterpreterInstance::resolveCommandHandler(RexxString *name)
    ProtectedObject p(upperName);


InterpretInstruction.cpp                    done 4.2 work
void RexxInstructionInterpret::execute(
    ProtectedObject p(interpretString);


ListClass.cpp                               done 4.2 work
RexxObject *RexxList::copy(void)
    jlf : newlist must be protected (todo)


ListClass.cpp                               done 4.2 work
RexxSupplier *RexxList::supplier(void)
    indices = this->makeArrayIndices();
    ProtectedObject p_indices(indices);
    values = this->makeArray();          /* get the list values               */
    ProtectedObject p_values(values);


ListClass.cpp                               already done in official 4.2
RexxList *RexxList::newRexx(
    ProtectedObject p(newList);


MessageClass.cpp                            done v4.2 work (newMessage already done)
RexxObject *RexxMessage::newRexx(
    ProtectedObject m(msgName);
    ...
        ProtectedObject p(newMessage);


MethodClass.cpp                             done v4.2 work
RexxMethod *RexxMethod::newMethodObject(RexxString *pgmname, RexxObject *source, RexxObject *position, RexxSource *parentSource)
        ProtectedObject p(sourceString);
    ...
            ProtectedObject p(sourceString);


MethodClass.cpp                             done v4.2 work
RexxMethod *RexxMethod::newRexx(
            ProtectedObject p(option);


ObjectClass.cpp                             done v4.2 work
RexxMethod *RexxObject::instanceMethod(RexxString  *method_name)
    ProtectedObject p(method_name);


ObjectClass.cpp                             done v4.2 work (optim ok ?)
RexxObject * RexxObject::copy()
    jlf : newObj must be protected (todo)


ObjectClass.cpp                             done v4.2 work
void RexxObject::copyIntoTail(RexxCompoundTail *tail)
    ProtectedObject p(value);


ObjectClass.cpp                             done v4.2 work
RexxObject  *RexxObject::setMethod(
    ProtectedObject p(msgname);


ObjectClass.cpp                             done v4.2 work
RexxObject  *RexxObject::unsetMethod(
  ProtectedObject p(msgname);


ObjectClass.cpp                             done v4.2 work
RexxObject  *RexxObject::requestRexx(
    className = stringArgument(className, ARG_ONE)->upper();
    ProtectedObject p_className(className);
    RexxString *class_id = this->id()->upper();      /* get the class name in uppercase   */
    ProtectedObject p_class_id(class_id);


ObjectClass.cpp                             done v4.2 work
RexxObject *RexxObject::sendWith(RexxObject *message, RexxArray *arguments)
    decodeMessageName(this, message, messageName, startScope);
    ProtectedObject m(messageName);

    arguments = arrayArgument(arguments, ARG_TWO);
    ProtectedObject p(arguments);


ObjectClass.cpp                             done v4.2 work
RexxObject *RexxObject::send(RexxObject **arguments, size_t argCount)
    ProtectedObject m(messageName);


ObjectClass.cpp                             done v4.2 work
RexxMessage *RexxObject::startWith(RexxObject *message, RexxArray *arguments)
    ProtectedObject p(arguments);


ObjectClass.cpp                             done v4.2 work
RexxMessage *RexxObject::startCommon(RexxObject *message, RexxObject **arguments, size_t argCount)
    ProtectedObject m(messageName);


ObjectClass.cpp                             done v4.2 work
void RexxObject::decodeMessageName(RexxObject *target, RexxObject *message, RexxString *&messageName, RexxObject *&startScope)
        ProtectedObject p(messageArray);


ObjectClass.cpp                             done v4.2 work
RexxObject  *RexxObject::defMethods(
        name = name->upper();              /* make sure the name is upperCase.  */
        ProtectedObject p(name);


ObjectClass.cpp                             done v4.2 work (including methcopy)
RexxObject  *RexxObject::defMethod(
    msgname = msgname->upper();          /* add this as an uppercase name     */
    ProtectedObject p(msgname);
    ---
    jlf : methcopy to protect ? (not sure...)(todo)


ObjectClass.cpp                             done v4.2 work
RexxString *RexxObject::concatRexx(RexxObject *otherObj)
    RexxString *alias = (RexxString *)REQUEST_STRING(this);
    ProtectedObject p(alias);


ObjectClass.cpp                             done v4.2 work
RexxString *RexxObject::concatBlank(RexxObject *otherObj)
    RexxString *alias = (RexxString *)REQUEST_STRING(this);
    ProtectedObject p(alias);


OptionsInstruction.cpp                      done v4.2 work
void RexxInstructionOptions::execute(
    stringVal = REQUEST_STRING(value);   /* get the string version            */
    ProtectedObject p(stringVal);


PackageClass.cpp                            done v4.2 work
PackageClass *PackageClass::loadPackage(RexxString *name, RexxArray *s)
        s = arrayArgument(s, "source");
        ProtectedObject p(s);


PackageClass.cpp                            done v4.2 work
PackageClass *PackageClass::newRexx(
        RexxArray *sourceArray = arrayArgument(_source, "source");
        ProtectedObject p(sourceArray);
        package = instance->loadRequires(activity, nameString, sourceArray);
    }

    ProtectedObject p(package);


PackageManager.cpp                          done v4.2 work
RoutineClass *PackageManager::createRegisteredRoutine(RexxString *function)
    RoutineClass *func = new RoutineClass(function, new RegisteredRoutine(function, (RexxRoutineHandler *)entry));
    function = function->upper();
    ProtectedObject p(function);


PackageManager.cpp                          done v4.2 work
RexxObject *PackageManager::dropRegisteredRoutine(RexxString *name)
    name = name->upper();
    ProtectedObject p(name);


PackageManager.cpp                          done v4.2 work
RexxObject *PackageManager::queryRegisteredRoutine(RexxString *name)
    name = name->upper();
    ProtectedObject p(name);


PackageManager.cpp                          done v4.2 work
bool PackageManager::callNativeRoutine(RexxActivity *activity, RexxString *name,
    name = name->upper();
    ProtectedObject p(name);


ProtectedObject.hpp                         not done (for me it's useful, but modifying this class may be not appreciated)
// To let the compiler tell you it's forbidden !
// You want to assign a rexx object, not an other protected object.
// The list of protected objects is broken if such an assignement is done.
private:
    ProtectedObject(const ProtectedObject&);
    ProtectedObject &operator=(const ProtectedObject&);


QueueClass.cpp                              done v4.2 work
RexxObject *RexxQueue::supplier()
    RexxArray *values = this->makeArray();          /* convert into an array             */
    ProtectedObject p(values);


QueueClass.cpp                              done v4.2 work
RexxObject *RexxQueue::newRexx(RexxObject **init_args, size_t argCount)
    RexxObject *newObj =  new RexxQueue;             /* get a new queue                   */
    ProtectedObject p(newObj);


QueueInstruction.cpp                        done v4.2 work
void RexxInstructionQueue::execute(
    ProtectedObject p_value;
    ...
        value = REQUEST_STRING(result);    /* get the string version            */
        p_value = value;


RaiseInstruction.cpp                        done v4.2 work
void RexxInstructionRaise::execute(
    ProtectedObject p_result;
    ProtectedObject p_description;
    ProtectedObject p_additional;
...
        _additional = TheNullArray->copy(); /* change default additional info    */
        p_additional = _additional;
...
        errorcode = REQUEST_STRING(rc);    /* get the string version            */
        ProtectedObject p(errorcode);
...
        _description = (RexxString *)this->description->evaluate(context, stack);
        p_description = _description;
...
        _additional = this->additional[0]->evaluate(context, stack);
        p_additional = _additional;
...
        _result = this->result->evaluate(context, stack);
        p_result = _result;
...
            _additional = REQUEST_ARRAY(_additional);
            p_additional = _additional;


RelationClass.cpp                           already done in official v4.2
RexxObject *RexxRelation::newRexx(
    RexxRelation *newObj = new_relation();             /* get a new relation                */
    ProtectedObject p(newObj);


RexxActivation.cpp                          not done, not needed 4.2
void RexxActivation::live(size_t liveMark)
    memory_mark(this->contextObject);
    memory_mark(this->arguments); // arguments can be user-redefined (ex : yield), must be marked


RexxActivation.cpp                          not done, not needed 4.2
void RexxActivation::liveGeneral(int reason)
    memory_mark_general(this->contextObject);
    memory_mark_general(this->arguments); // arguments can be user-redefined (ex : yield), must be marked


RexxActivation.cpp                          done 4.2, 4.2 work
void RexxActivation::raise(
{
    ProtectedObject p_conditionobj;
...
        conditionobj = new_directory();    /* get a new directory               */
        p_conditionobj = conditionobj;


RexxActivation.cpp                          was cancelled, nothing to apply for 4.2
RexxObject *RexxActivation::evaluateLocalCompoundVariable(RexxString *stemName, size_t index, RexxObject **tail, size_t tailCount)
    if (tracingIntermediates())
    {
        ProtectedObject p(stem_table);


// JLF : fix of Rony problem ? NO !
RexxActivation.cpp                          done 4.2, 4.2 work (keep the change made in official, which is different)
StackFrameClass *RexxActivation::createStackFrame()
    ProtectedObject p_arguments(arguments); // getArguments() returns a new array, so must be protected
    ProtectedObject p;
    return new (p) StackFrameClass(type, getMessageName(), (BaseExecutable *)getExecutableObject(), target, arguments, getTraceBack(), getContextLineNumber());


RexxActivation.hpp                          not needed 4.2
   RexxActivation      *parent;        // previous running activation for internal call/interpret
   RexxArray           *arguments;     /* user-redefined, GC protected      */          <-- jlf : new
   RexxObject         **arglist;       /* activity argument list            */


RexxActivity.cpp                            done v4.2 work
RexxDirectory *RexxActivity::createConditionObject(RexxString *condition, RexxObject *rc, RexxString *description, RexxObject *additional, RexxObject *result)
    RexxDirectory *conditionObj = new_directory();
    ProtectedObject p(conditionObj);


RexxActivity.cpp                            done v4.2 work
RexxString *RexxActivity::messageSubstitution(
    size_t substitutions = additional->size();  /* get the substitution count        */
    /* RexxString * */ ProtectedObject newmessage = OREF_NULLSTRING;        /* start with a null string          */
...
        /* RexxString * */ ProtectedObject front = message->extractC(0, subposition - 1);
        /* pull off the remainder            */
        /* RexxString * */ ProtectedObject back = message->extractC(subposition + 1, message->getCLength() - (subposition + 1));
...
        /* not a good number?                */
        /* RexxString * */ ProtectedObject stringVal = OREF_NULLSTRING;
...
        /* accumulate the front part         */
        ProtectedObject front_stringVal = ((RexxString*)front)->concat(stringVal);
        newmessage = ((RexxString*)newmessage)->concat(front_stringVal);
...
    /* add on any remainder              */
    newmessage = ((RexxString*)newmessage)->concat(message);


RexxActivity.cpp                            done v4.2 work
RexxObject *RexxActivity::display(RexxDirectory *exobj)
    /* get the header                    */
    /* RexxString * */ ProtectedObject text = SystemInterpreter::getMessageHeader(errorCode);
...
    else                                 /* add to the message text           */
    {
        text = ((RexxString*)text)->concat(SystemInterpreter::getMessageText(Message_Translations_error));
...
    /* add on the error number           */
    ProtectedObject rcString = REQUEST_STRING(rc);
    text = ((RexxString*)text)->concatWith(rcString, ' ');
...
        /* add on the "running" part         */
        text = ((RexxString*)text)->concatWith(SystemInterpreter::getMessageText(Message_Translations_running), ' ');
        /* add on the program name           */
        text = ((RexxString*)text)->concatWith(programname, ' ');
...
            /* Yes, add on the "line" part       */
            text = ((RexxString*)text)->concatWith(SystemInterpreter::getMessageText(Message_Translations_line), ' ');
            /* add on the line number            */
            ProtectedObject positionString = REQUEST_STRING(position);
            text = ((RexxString*)text)->concatWith(positionString, ' ');
...
    text = ((RexxString*)text)->concatWithCstring(":  ");
    /* and finally the error message     */
    text = ((RexxString*)text)->concat((RexxString *)exobj->at(OREF_ERRORTEXT));
...
        else                               /* add to the message text           */
        {
            text = ((RexxString*)text)->concat(SystemInterpreter::getMessageText(Message_Translations_error));
        }
        /* add on the error number           */
        text = ((RexxString*)text)->concatWith((RexxString *)rc, ' ');
        /* add on the ":  "                  */
        text = ((RexxString*)text)->concatWithCstring(":  ");
        /* and finally the error message     */
        text = ((RexxString*)text)->concat(secondary);


RexxActivity.cpp                            done v4.2 work
RexxObject *RexxActivity::displayDebug(RexxDirectory *exobj)
  RexxString *secondary;               /* secondary message                 */
  /* RexxString * */ ProtectedObject text;/* constructed final message         */
...
  ProtectedObject rcString = REQUEST_STRING(exobj->at(OREF_RC));
  text = ((RexxString*)text)->concatWith(rcString, ' ');
                                       /* add on the ":  "                  */
  text = ((RexxString*)text)->concatWithCstring(":  ");
                                       /* and finally the error message     */
  text = ((RexxString*)text)->concatWith((RexxString *)exobj->at(OREF_ERRORTEXT), ' ');
...
    text = ((RexxString*)text)->concatWith((RexxString *)exobj->at(OREF_CODE), ' ');
                                       /* add on the ":  "                  */
    text = ((RexxString*)text)->concatWithCstring(":  ");
                                       /* and finally the error message     */
    text = ((RexxString*)text)->concat(secondary);


RexxActivity.cpp                            not done, specific to executor
void  RexxActivity::traceOutput(       /* write a line of trace information */
    ProtectedObject p_line = line->stringTrace(); /* get traceable form of this        */
    + casts


RexxBehaviour.cpp                           done 4.2, 4.2 work
RexxObject *RexxBehaviour::copy()
    RexxBehaviour *newBehaviour = (RexxBehaviour *)this->clone();
    ProtectedObject p(newBehaviour);


RexxCompoundTable.cpp                       done v4.2 work
RexxCompoundElement *RexxCompoundTable::findEntry(
    /* create a new compound variable */
    ProtectedObject p_tailString(tail->makeString());
    anchor = new_compoundElement(p_tailString);


RexxInstruction.cpp                         already done in official v4.2
RexxInstructionRaise::execute
    _result to protect (done)
    _description to protect (done)
    _additional to protect (done)


RexxNativeActivation.cpp                    done v4.2 work
int RexxNativeActivation::stemSort(const char *stemname, int order, int type, size_t start, size_t end, size_t firstcol, size_t lastcol)
        RexxString *tail = OREF_NULLSTRING ;
        ProtectedObject p2(tail); // JLF useless here !
...
            tail = tail->upper();
            p2 = tail; // JLF here, it's useful


RexxNativeActivation.cpp                    done v4.2 work (keep the change made in official, which is different)
StackFrameClass *RexxNativeActivation::createStackFrame()
    ProtectedObject p;
    return new (p) StackFrameClass(type, getMessageName(), (BaseExecutable *)getExecutableObject(), receiver, getArguments(), new_string(COMPILED_MARKER), SIZE_MAX);


RexxVariableDictionary.cpp                  done v4.2
RexxVariableBase  *RexxVariableDictionary::getVariableRetriever(
    variable = variable->upper();        /* upper case the variable           */
    ProtectedObject p(variable);


RoutineClass.cpp                            done v4.2
RexxObject *RoutineClass::callWithRexx(RexxArray *args)
    args = arrayArgument(args, ARG_ONE);
    ProtectedObject p(args);


RoutineClass.cpp                            done v4.2
RoutineClass *RoutineClass::newRoutineObject(RexxString *pgmname, RexxObject *source, RexxObject *position, RexxSource *parentSource)
        RexxString *sourceString = source->makeString();
        ProtectedObject p(sourceString);
...
            RexxString *sourceString = newSourceArray ->get(counter)->makeString();
            ProtectedObject p(sourceString);


RoutineClass.cpp                            done v4.2
RoutineClass *RoutineClass::newRoutineObject(RexxString *pgmname, RexxArray *source, RexxObject *position)
            RexxString *sourceString = newSourceArray ->get(counter)->makeString();
            ProtectedObject p(sourceString);


SayInstruction.cpp                          done v4.2
void  RexxInstructionSay::execute(
    RexxString *value;                   /* string version of output value    */
    ProtectedObject p_value;
...
        value = REQUEST_STRING(result);    /* get the string version            */
        p_value = value;


SignalInstruction.cpp                       done v4.2
void RexxInstructionSignal::execute(
            stringResult = REQUEST_STRING(result);
            ProtectedObject p(stringResult);


SourceFile.cpp                              not done, specific executor
void RexxSource::live(size_t liveMark)
  memory_mark(this->interpret_activation);      <-- jlf : added by me
}


SourceFile.cpp                              not done, specific executor
void RexxSource::liveGeneral(int reason)
  memory_mark_general(this->interpret_activation);  <-- jlf : added by me
}


SourceFile.cpp                              not done, specific executor
void RexxSource::flatten (RexxEnvelope *envelope)
    this->securityManager = OREF_NULL;
    this->interpret_activation = OREF_NULL;         <-- jlf : added by me
...
    flatten_reference(newThis->interpret_activation, envelope);

  cleanUpFlatten
}


SourceFile.cpp                              done v4.2 but keeping the changes of official
StackFrameClass *RexxSource::createStackFrame()
    ProtectedObject p;
    return new (p) StackFrameClass(FRAME_PARSE, programName, OREF_NULL, OREF_NULL, OREF_NULL, traceBack(clauseLocation, 0, true), clauseLocation.getLineNumber());


SourceFile.cpp                              done v4.2 but differently from executor
RexxString *RexxSource::extract(
    /* RexxString * */ ProtectedObject line = OREF_NULLSTRING;  /* returned source line              */
    RexxString *source_line;             /* current extracting line           */
    size_t  counter;                     /* line counter                      */
...
            /* concatenate the next line on      */
            if (newline) line = ((RexxString*)line)->concatWith(this->get(counter), '\n');
            else line = ((RexxString*)line)->concat(this->get(counter));
        }
        /* now add on the last part          */
        if (newline) line = ((RexxString*)line)->concatWith(this->get(counter)->extractB(0, location.getEndOffset()), '\n');
        else line = ((RexxString*)line)->concat(this->get(counter)->extractB(0, location.getEndOffset()));


SourceFile.cpp                              done v4.2
RexxClass *RexxSource::findClass(RexxString *className)
    RexxString *internalName = className->upper();   /* upper case it                     */
    ProtectedObject p(internalName);


SourceFile.cpp                              done v4.2
void RexxSource::classDirective()
    RexxString *public_name = this->commonString(name->upper());
    ProtectedObject p(public_name);


SourceFile.cpp                              done v4.2
void RexxSource::methodDirective()
    RexxString *internalname = this->commonString(name->upper());
    ProtectedObject p(internalname);
...
            decodeExternalMethod(internalname, externalname, library, procedure);
            ProtectedObject p_library(library);
            ProtectedObject p_procedure(procedure);


SourceFile.cpp                              done v4.2
void RexxSource::attributeDirective()
    RexxString *internalname = this->commonString(name->upper());
    ProtectedObject p(internalname);
...
                decodeExternalMethod(internalname, externalname, library, procedure);
                ProtectedObject p_library(library);
                ProtectedObject p_procedure(procedure);
...
                decodeExternalMethod(internalname, externalname, library, procedure);
                ProtectedObject p_library(library);
                ProtectedObject p_procedure(procedure);
...
                    procedure = procedure->concatToCstring("GET");
                    p_procedure = procedure;
...
                decodeExternalMethod(internalname, externalname, library, procedure);
                ProtectedObject p_library(library);
                ProtectedObject p_procedure(procedure);
...
                    procedure = procedure->concatToCstring("SET");
                    p_procedure = procedure;


SourceFile.cpp                              done v4.2
void RexxSource::constantDirective()
    RexxString *internalname = this->commonString(name->upper());
    ProtectedObject p(internalname);


SourceFile.cpp                              done v4.2 but differently from executor
RexxString *RexxSource::commonString(
    ProtectedObject p(string); // JLF I see a lot of calls where string is a not protected object


SourceFile.cpp                              not done because the fix for commonString is enough
RexxArray  *RexxSource::words(
    word = ((RexxString *)(string->word(IntegerOne)))->upper();
    ProtectedObject p(word);


SourceFile.cpp                              not done... complicated, many occurences of _instruction
RexxCode *RexxSource::translateBlock(
    jlf : _instruction to protect ? (not done)


SourceFile.cpp                              already done
RexxArray *RexxSource::extractSource(
        /* get the result array              */
        RexxArray *source = new_array(location.getEndLine() - location.getLineNumber() + 1);
        ProtectedObject p(source);


StackFrameClass.cpp                         already done
void StackFrameClass::live(size_t liveMark)
    memory_mark(this->objectVariables);
}


StackFrameClass.cpp                         already done
void StackFrameClass::liveGeneral(int reason)
    memory_mark_general(this->objectVariables);
}


StackFrameClass.cpp                         already done
void StackFrameClass::flatten(RexxEnvelope *envelope)
  newThis->objectVariables = OREF_NULL;

  cleanUpFlatten
}


StackFrameClass.cpp                         already done
#include "ProtectedObject.hpp"


StackFrameClass.cpp                         not done, no longer needed because I kept the official approach
/**
 * Allocate a new GC-protected StackFrame object
 *
 * @param size   The size of the object.
 * @param p      The protected object
 *
 * @return The newly allocated object.
 */
void *StackFrameClass::operator new(size_t size, ProtectedObject &p)
{
    /* Get new object                    */
    p = new_object(size, T_StackFrame);
    return p;
}


StackFrameClass.hpp                         not done, no longer needed because I kept the official approach
class RexxSource;
class ProtectedObject;
...
    void *operator new(size_t);
    void *operator new(size_t, ProtectedObject &);      <-- this one was added by me, but no longer needed


StemClass.cpp                               done v4.2
RexxObject *RexxStem::request(
    makeclass = stringArgument(makeclass, ARG_ONE)->upper();
    ProtectedObject p(makeclass);


StemClass.cpp                               already done
RexxObject *RexxStem::newRexx(
    newObj = new RexxStem ((RexxString *)name);   /* get a new stem                    */
    ProtectedObject p(newObj);


StringClass.cpp                             already done
RexxString *RexxString::newRexx(RexxObject **init_args, size_t argCount)
    string = new_string(string->getStringData(), string->getBLength(), string->getCLength(), string->getCharset(), string->getEncoding());
    ProtectedObject p(string);


SupplierClass.cpp                           already done
RexxObject  *RexxSupplierClass::newRexx(
    RexxObject *newObj = new RexxSupplier();
    ProtectedObject p = newObj;


TableClass.cpp                              already done
#include "ProtectedObject.hpp"


TableClass.cpp                              already done
RexxObject *RexxTable::newRexx(
    RexxTable *newObj = new_table();                /* get a new table                   */
    ProtectedObject p(newObj);


TraceInstruction.cpp                        not done (not sure it's needed)
void RexxInstructionTrace::execute(
        result = this->expression->evaluate(context, stack);
        ProtectedObject p_result(result);
        value = REQUEST_STRING(result);    /* force to string form              */
        ProtectedObject p_value(value);


WeakReferenceClass.cpp                      already done
void WeakReference::live(size_t liveMark)
    // we need to get called, but we don't do any marking of the referent.
    // we do, however, need to mark the object variables in case this is a subclass.
    memory_mark(this->objectVariables);


WeakReferenceClass.cpp                      already done
void WeakReference::liveGeneral(int reason)
    // this might be a subclass, so we need to mark the object variables always
    memory_mark_general(this->objectVariables);


WeakReferenceClass.cpp                      already done
void WeakReference::flatten(RexxEnvelope *envelope)
  setUpFlatten(WeakReference)
   // not normally needed, but this might be a subclass
   flatten_reference(newThis->objectVariables, envelope);


WeakReferenceClass.cpp                      already done
RexxObject *WeakReference::newRexx(RexxObject **init_args, size_t argCount)
  RexxObject *newObj = new WeakReference(refObj);
  ProtectedObject p(newObj);

===============================================================================
2015 sept 13

GC review
stringArgument can return a new string
which should be protected
--> review all the calls of stringArgument : done

idem optionalStringArgument : done
idem ->requiredString : done
idem requiredStringArg : no problem, stored in expression stack
idem required_string : no problem, stored in expression stack
idem requestArray : done
idem REQUEST_ARRAY : done
idem makeArray : done


===============================================================================
2013 apr 13

[GC]
Fix crash due to unprotected object.
In ClassClass.cpp
method RexxClass::enhanced : enhanced_instance_mdict must be GC-protected.
method RexxClass::subclass : enhancing_class_methods must be GC-protected.


===============================================================================
2012 mar 23

Remember :
GC crash while running functional-test.rex :
The list of protected objects was corrupted, because of that :
In RexxExpressionMessage::evaluate (ExpressionMessage.cpp), I declared _target as a protected object.
The assignment result = _target, which was supposed to store the RexxObject target in the protected
object result, corrupted the list of protected objects because the default operator= stored a copy of
all the attributes of _target onto the protected object result, overwriting the next attribute.
Fixed by declaring these methods private :
    ProtectedObject(const ProtectedObject&);
    ProtectedObject &operator=(const ProtectedObject&);
Now the compiler forces to cast like that :
result = (RexxObject*)_target
[later]
I think I don't need to protect the intermediate objects returned by ->evaluate, because they should
be protected by the stack. I keep the changes made to ProtectedObject.


===============================================================================
2012 mar 06

Another GC crash
 	rexx.dll!RexxMemory::markObjectsMain(RexxObject * rootObject)  Line 373 + 0xc bytes	C++
 	rexx.dll!RexxMemory::markObjects()  Line 653	C++
 	rexx.dll!RexxMemory::collect()  Line 1030	C++
 	rexx.dll!NormalSegmentSet::handleAllocationFailure(unsigned int allocationLength)  Line 1272	C++
 	rexx.dll!RexxMemory::newObject(unsigned int requestLength, unsigned int type)  Line 1110 + 0x12 bytes	C++
 	rexx.dll!new_object(unsigned int s, unsigned int t)  Line 426 + 0x1e bytes	C++
 	rexx.dll!RexxListTable::operator new(unsigned int size, unsigned int initialSize)  Line 94 + 0x16 bytes	C++
 	rexx.dll!RexxList::getFree()  Line 123 + 0x12 bytes	C++
 	rexx.dll!RexxList::insert(RexxObject * _value, RexxObject * _index)  Line 556 + 0x8 bytes	C++
 	rexx.dll!RexxList::append(RexxObject * _value)  Line 542	C++
 	rexx.dll!RexxActivity::generateProgramInformation(RexxDirectory * exobj)  Line 941	C++
 	rexx.dll!RexxActivity::createExceptionObject(long errcode, RexxString * description, RexxArray * additional, RexxObject * result)  Line 894	C++
 	rexx.dll!RexxActivity::raiseException(long errcode, RexxString * description, RexxArray * additional, RexxObject * result)  Line 774 + 0x18 bytes	C++
 	rexx.dll!RexxActivation::raise(RexxString * condition, RexxObject * rc, RexxString * description, RexxObject * additional, RexxObject * resultObj, RexxDirectory * conditionobj)  Line 1639	C++
 	rexx.dll!RexxActivation::raiseExit(RexxString * condition, RexxObject * rc, RexxString * description, RexxObject * additional, RexxObject * resultObj, RexxDirectory * conditionobj)  Line 1544	C++
>	rexx.dll!RexxInstructionRaise::execute(RexxActivation * context, RexxExpressionStack * stack)  Line 280	C++
 	rexx.dll!RexxActivation::run(RexxObject * _receiver, RexxString * msgname, RexxObject * * _arglist, unsigned int _argcount, RexxInstruction * start, ProtectedObject & resultObj)  Line 544	C++
----------
Review of RexxInstructionRaise::execute
    _result to protect (done)
    _description to protect (done)
    _additional to protect (done)
Review of RexxActivation::raise
    _conditionObj to protect if not a propagation, because new directory created (done)


Previous protection are not enough... Crash again.
Now using /DCHECKOREFS
 	rexx.dll!RexxInternalObject::getObjectTypeNumber()  Line 2045 + 0x3 bytes	C++
 	rexx.dll!RexxInternalObject::isObjectType(unsigned int t)  Line 263 + 0xf bytes	C++
 	rexx.dll!RexxMemory::objectReferenceOK(RexxObject * o)  Line 339 + 0xa bytes	C++
 	rexx.dll!RexxMemory::orphanCheckMark(RexxObject * markObject, RexxObject * * pMarkObject)  Line 1565 + 0xc bytes	C++
 	rexx.dll!RexxMemory::markGeneral(void * obj)  Line 1471	C++
 	rexx.dll!StackFrameClass::liveGeneral(int reason)  Line 143	C++
 	rexx.dll!RexxMemory::killOrphans(RexxObject * rootObject)  Line 440	C++
 	rexx.dll!RexxMemory::markObjects()  Line 641	C++
 	rexx.dll!RexxMemory::collect()  Line 1030	C++
 	rexx.dll!NormalSegmentSet::handleAllocationFailure(unsigned int allocationLength)  Line 1272	C++
 	rexx.dll!RexxMemory::newObject(unsigned int requestLength, unsigned int type)  Line 1110 + 0x12 bytes	C++
 	rexx.dll!new_object(unsigned int s, unsigned int t)  Line 426 + 0x1e bytes	C++
 	rexx.dll!RexxListTable::operator new(unsigned int size, unsigned int initialSize)  Line 94 + 0x16 bytes	C++
 	rexx.dll!RexxList::getFree()  Line 123 + 0x12 bytes	C++
 	rexx.dll!RexxList::insert(RexxObject * _value, RexxObject * _index)  Line 556 + 0x8 bytes	C++
 	rexx.dll!RexxList::append(RexxObject * _value)  Line 542	C++
 	rexx.dll!RexxActivity::generateProgramInformation(RexxDirectory * exobj)  Line 941	C++
 	rexx.dll!RexxActivity::createExceptionObject(long errcode, RexxString * description, RexxArray * additional, RexxObject * result)  Line 894	C++
 	rexx.dll!RexxActivity::raiseException(long errcode, RexxString * description, RexxArray * additional, RexxObject * result)  Line 774 + 0x18 bytes	C++
 	rexx.dll!RexxActivation::raise(RexxString * condition, RexxObject * rc, RexxString * description, RexxObject * additional, RexxObject * resultObj, RexxDirectory * conditionobj)  Line 1641	C++
 	rexx.dll!RexxActivation::raiseExit(RexxString * condition, RexxObject * rc, RexxString * description, RexxObject * additional, RexxObject * resultObj, RexxDirectory * conditionobj)  Line 1544	C++
 	rexx.dll!RexxInstructionRaise::execute(RexxActivation * context, RexxExpressionStack * stack)  Line 289	C++
 	rexx.dll!RexxActivation::run(RexxObject * _receiver, RexxString * msgname, RexxObject * * _arglist, unsigned int _argcount, RexxInstruction * start, ProtectedObject & resultObj)  Line 544	C++
 	rexx.dll!RexxCode::run(RexxActivity * activity, RexxMethod * method, RexxObject * receiver, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, ProtectedObject & result)  Line 136	C++
 	rexx.dll!RexxMethod::run(RexxActivity * activity, RexxObject * receiver, RexxString * msgname, RexxObject * * argPtr, unsigned int count, ProtectedObject & result)  Line 325	C++
>	rexx.dll!RexxObject::messageSend(RexxString * msgname, RexxObject * * arguments, unsigned int count, ProtectedObject & result)  Line 793	C++             // JLF : "yield"
----------
objectReferenceOK :
o = 0x7f23f050 {objectVariables=0x00000000 operatorMethods=0x00558920 classInstance=0x7fcc0a50 }
    objectSize = 6
    instanceClass.id = "Object"
    RexxBehaviour *type = o->getObjectType();       // JLF : NULL
StackFrameClass::liveGeneral :
    memory_mark_general(this->name);                // JLF this->name = 0x7f23f050
        this = 0x7de6d440 {type=0x0052ee64 "METHOD" name=0x7f23f050 executable=0x7fcc2e90 ...}
So we have a problem with the argument 'name' passed to the StackFrameClass constructor.
RexxActivation::createStackFrame
    pass getMessageName() : I don't see a problem here, because returns this->settings.msgname which is protected.
    The name stored in settings.msgname comes from the method RexActivation::run, I don't think there is a problem here.
    But I see a potential problem with the local variable 'arguments' : receives a new array returned by getArguments() --> must be protected (done)
RexxNativeActivation::createStackFrame
    pass getMessageName() : I don't see a problem here, because returns this->msgname which is protected.
    The names comes from :
        RexxNativeActivation::run : _msgname
        RexxNativeActivation::callNativeRoutine : functionName
            RexxNativeRoutine::call : functionName
        RexxNativeActivation::callRegisteredRoutine : functionName
            RegisteredRoutine::call : functionName
RexxSource::createStackFrame
    pass programName : I don't see a problem here
    The programName comes from :
        RexxSource::RexxSource
PackageManager::callNativeRoutine
    Maybe a problem here : name = name->upper(); --> to protect (done)
SystemInterpreter::invokeExternalFunction : target
    RexxActivation::externalCall : target
        RexxInstructionCall::execute --> I see a problem here : _name = REQUEST_STRING(result) --> to protect (done)
RexxActivation::callExternalRexx : target


review of risky code :
->upper
    RexxBehaviour::methodObject : no risk ?
    RexxClass::defineMethod : done
    RexxClass::defineClassMethod : done
    RexxClass::deleteMethod : done
    RexxClass::method : done
    RexxClass::methodDictionaryCreate : done
    RexxDirectory::setEntry : done
    RexxDirectory::remove : no risk ?
    RexxDirectory::setMethod : done
    RexxObject::instanceMethod : to protect because of reportException (done)
    RexxObject::setMethod : done
    RexxObject::unsetMethod : done
    RexxObject::requestRexx : two variables to protect (done)
    RexxObject::decodeMessageName : no risk ?
    RexxObject::defMethods : done
    RexxObject::defMethod : done
    RexxStem::request : done
    RexxNativeActivation::stemSort : incomplete protection (fixed)
    RexxVariableDictionary::getVariableRetriever : done
    BUILTIN(VALUE) : to protect (done, the code has been slightly rewritten)
    RexxInstructionForward::execute : done
    PackageManager::createRegisteredRoutine : done
    PackageManager::dropRegisteredRoutine : done
    PackageManager::queryRegisteredRoutine : done
    PackageManager::callNativeRoutine : done
    RexxSource::findClass : done
    RexxSource::classDirective : done
    RexxSource::extensionDirective : done
    RexxSource::methodDirective : done
    RexxSource::attributeDirective : done
    RexxSource::constantDirective : done
    RexxSource::words : done
    Interpreter::findClass : I think it must be protected because a method could be attached to the environment, no ? (done)
    InterpreterInstance::resolveCommandHandler : done
    SystemInterpreter::valueFunction : no risk, I think
    SystemInterpreter::valueFunction : I think it's ok, SystemInterpreter::allocateResultMemory has no relation with GC
REQUEST_STRING (requestString)
    RexxClass::methodDictionaryMerge : done
    RexxClass::methodDictionaryCreate : already done
    RexxInteger::concatBlank : to protect, I think (done)
    RexxInteger::concat : to protect, I think (done)
    RexxObject::copyIntoTail : done
    RexxObject::concatRexx : done
    RexxObject::concatBlank : done
    RexxStem::sort : is there a risk of GC in array->put(nextValue, j + bounds) ? (NOT done)
    StringClass.cpp : I hope it's ok ! did not investigate
    RexxActivity::display : done, but really not sure if I need to do that
    RexxActivity::displayDebug :  done, but really not sure if I need to do that
    RexxActivity::callFunctionExit : nothing done, I don't understand the code with temp
    RexxInstructionDo::execute : done
    RexxInstructionDo::controlSetup : done
    RexxInstructionForward::execute : done
    RexxInstructionInterpret::execute : done
    RexxInstructionOptions::execute : done
    RexxInstructionQueue::execute : done
    RexxInstructionRaise::execute : done
    RexxInstructionSay::execute : done
    RexxInstructionSignal::execute : done
    RexxInstructionTrace::execute : done
requestString
    RexxMethod::newRexx : I think protection is needed (done)
    RexxNativeActivation::processArguments : is ok, according to the comment
    RexxExpressionStack::requiredStringArg : done
    RexxExpressionStack::optionalStringArg : done
makeString
    RexxMethod::newMethodObject : done
    RoutineClass::newRoutineObject : done
    RoutineClass::newRoutineObject : done
    RexxCompoundTable::findEntry : done
arrayArgument (requestArray)
    RexxObject::sendWith : for me, protection is needed, no ? (done)
    RexxObject::startWith : for me, protection is needed, no ? (done)
    RexxObject::decodeMessageName : for me, protection is needed, no ? (done)
    PackageClass::loadPackage : for me, protection is needed, no ? (done)
    PackageClass::newRexx :  for me, protection is needed, no ? (done)
    RoutineClass::callWithRexx : for me, protection is needed, no ? (done)
    RexxNativeActivation::processArguments : is ok, according to the comment
    RexxNativeActivation::objectToValue : is ok, according to the comment
requestArray (makeArray)
    RexxMethod::newMethodObject : already protected
    RoutineClass::newRoutineObject : already protected
makeArray
    RexxArray::toString : already protected
    RexxList::supplier : done
    RexxQueue::supplier : done
    RexxActivity::display : already protected
    RexxInstructionDo::execute : is ok, assigned to this
    RexxSource::getGuard : is ok, assigned to this
->request
    Nothing new to protect (requestString and requestArray already reviewed)
required_string (macro, requiredStringArg)
    requiredStringArg already reviewed
optional_string (macro, optionalStringArg)
    optionalStringArg already reviewed
decodeMessageName : the string returned in messageName is not protected, see what's done by the caller
    RexxObject::sendWith : for me, protection needed, no ? (done)
    RexxObject::send : for me, protection needed, no ? (done)
    RexxObject::startCommon : for me, protection needed, no ? (done)
    RexxMessage::newRexx : for me, protection needed, no ? (done)
->concat
    RexxObject::requestRexx : I think it's ok, methodLookup should not trigger a GC, right ?
    RexxActivity::messageSubstitution : done
    RexxActivity::traceOutput : done
    RexxSource::commonString : no "->concat" inside, but while looking for "->concat", I saw a lot of calls to commonString where the passed parameter is not protected. Now the parameter string is protected.
    RexxSource::callNew : done
    RexxSource::raiseNew : done
    RexxSource::signalNew : done
    RexxSource::extract : done
    RexxSource::methodDirective : done
    RexxSource::attributeDirective : done
->evaluate
    RexxActivation::evaluateLocalCompoundVariable : done --> cancelled
    <to continue...> --> not needed, the objects should be protected by the stack
decodeExternalMethod
    RexxSource::methodDirective : done
    RexxSource::attributeDirective : done


===============================================================================
2012 mar 04

Fixed a GC crash.
RexxActivity::generateProgramInformation calls createStackFrame.
In RexxActivation::createStackFrame, the last line is
    return new StackFrameClass(type, getMessageName(), (BaseExecutable *)getExecutableObject(), target, arguments, getTraceBack(), getContextLineNumber());
The operator 'new' of StackFrameClass is overloaded and returns a new object before the constructor is called.
This object is not protected.
The call to getTraceBack triggered a GC and the new object was put on the list of dead objects.
The object is returned to generateProgramInformation which puts it in the stackFrames list.
Later, crash because the behaviour pointer of the stack frame is NULL.
Fixed by passing a ProtectedObject to the 'new' operator of StackFrameClass.
Applied the same fix to :
RexxSource::createStackFrame
RexxNativeActivation::createStackFrame


Fixed another GC crash, but less sure I identified the real problem...
A crash occured while searching the method ~available on a supplier. The behaviour was NULL.
I have a subclass of Supplier (CoactivitySupplier) whose init method creates an empty array.
That could explain the problem : in case of GC during init, the supplier is put on the list of dead objects.
After modifying RexxSupplierClass::newRexx to protect newObj before sending the message "init",
no more crash (for the moment).


Remember :
Fix done in RexxSupplierClass::newRexx also done in :
(search for OREF_INIT in interpreter source files)
RexxDirectory::newRexx
RexxIdentityTable::newRexx
RexxList::newRexx
RexxMessage::newRexx
PackageClass::newRexx
RexxQueue::newRexx
RexxRelation::newRexx
RexxStem::newRexx
RexxString::newRexx
RexxSupplierClass::newRexx
RexxTable::newRexx
WeakReference::newRexx


ContextClass : mark this->objectVariables.
It's an exported class, so better to do that... (done)


===============================================================================
2011 oct 26

Fixed a crash in relation with RexxContextualSource and GC :
Must mark objectVariables.


===============================================================================
2011 aug 16

Fixed a crash in relation with source literals and GC.
Two problems :
1) Forgot to replace RexxDirectory by RexxList when disabling the optimization
for source literals (was a copy-paste of optimization done for string literals).
2) The constructor RexxSourceLiteral::RexxSourceLiteral can trigger a GC. Must protect
'this'.


Remember1:
----------
When the crash occurs during GC (ex : in ObjectHeader::isObjectMarked), it's possible
to see which ooRexx object is corrupted. Here the object is 0x7eeff200
 	rexx.dll!ObjectHeader::isObjectMarked(unsigned int mark)  Line 106 + 0xa bytes	C++
 	rexx.dll!RexxInternalObject::isObjectMarked(unsigned int markword)  Line 247 + 0x16 bytes	C++
 	rexx.dll!RexxListTable::live(unsigned int liveMark)  Line 55 + 0x26 bytes	C++
>	rexx.dll!RexxMemory::markObjectsMain(RexxObject * rootObject)  Line 374	C++                 <-- markObject = 0x7eeff200 {size=2129676696 elements=0x7eeff214 }  RexxListTable with OVERWRITTEN size !!!
 	rexx.dll!RexxMemory::markObjects()  Line 645	C++
 	rexx.dll!RexxMemory::collect()  Line 1022	C++

A conditional break "newObj == 0x7eeff200" on the last line of RexxMemory::newObject (RexxMemory.cpp)
lets stop the execution when the object is created. If too long, then modify the source :
    if (newObj == (RexxObject*)0x7eeff200)
    {
        int dummy=0;    //  <-- put breakpoint here
    }
    return newObj;
Once the interpreter is stopped here, it's relatively easy to do a code review of the methods
in the call stack, to check if an intermediate object must be protected.

If needed, a data breakpoint can be set on the part of memory which is overwritten
(here the 'size' attribute). In my case, was triggered when the object was inserted
in the list of dead objects.


Remember2:
----------
Occurences of new_directory, not protected (no crash so far, except for createConditionObject) :
DirectoryClass.cpp, RexxDirectory::newRexx (05/03/2012 : done when fixing OREF_INIT)
ExceptionClass.cpp, ExceptionClass::getCondition (05/03/2012 : done)
RexxActivation.cpp, RexxActivation::raise  : here, the conditionObj is passed by argument.
                                             BUT there is one case where conditionObj is created. To protect !
    called by RexxActivation::raiseExit --> the directory conditionobj is passed by argument, no need of protect here.
        called by RexxInstructionRaise::execute --> the directory conditionobj is created here, seems ok because comes from context->getConditionObj()
                                                    [06/03/2012] Got a GC crash where RexxInstructionRaise::execute is in the call stack...
                                                                 After a new review, I think that following variables must be protected : _result, _additional
    called by RexxInstructionRaise::execute --> the directory is created here, seems ok because comes from context->getConditionObj().
RexxActivity.cpp, RexxActivity::createConditionObject (fixed in sandbox)

Other potential problems. A fresh created object is not protected, and some calls are made that could trigger GC.
RexxBehaviour.cpp, RexxBehaviour::copy : newBehaviour is not protected. (05/03/2012 : done)
RexxBehaviour.cpp, RexxBehaviour::addScope : this->scopes->allAt(TheNilObject) creates an object which is not protected. (05/03/2012 : added to this->scopes, so seems protected)
RexxCollection.cpp, RexxHashTableCollection::copy : newObj is not protected.
    Should be protected only if ActivityManager::currentActivity != NULL, otherwise crash in implementation of ProtectedObject's methods
    (RexxHashTableCollection::copy is called during interpreter initialization, and at this time, ActivityManager::currentActivity == NULL).
ArrayClass.cpp, RexxArray::copy : newArray is not protected.
ClassClass.cpp, RexxClass::defineMethod : method_name and method_object are not protected.
ClassClass.cpp, RexxClass::methodDictionaryCreate : method_name is not protected.
DirectoryClass.cpp, RexxDirectory::copy : newObj is not protected.
ListClass.cpp, RexxList::copy : newList is not protected.
ObjectClass.cpp, RexxObject::copy : newObj is not protected.
ObjectClass.cpp, RexxObject::defMethod : msgname and methcopy are not protected.
InstructionParser.cpp, RexxSource::signalNew : newObject is not protected.
SourceFile.cpp, RexxSource::translateBlock : _instruction is not protected.


===============================================================================
2011 aug 14

Fixed a crash that occured after GC : in RexxActivity::createConditionObject),
the value returned by new_directory() must be protected.


===============================================================================
2010 july 3

Debug crash in gc
RexxMemory::markObjectsMain
    markObject->live(liveMark);

0x003d2b8c                                          --> this is 0x7eee1ac0->behaviour
Access violation reading location 0x44414550        --> this is the vfptr of the behaviour of a string

((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*markObject))))).__vfptr


RexxMemory::mark(RexxObject *markObject)
    pushLiveStack((RexxObject *)markObject->behaviour);
markObject = 0x7eee1ac0                             --> see below, this is the 30th element of string array
    [RexxString]
               if tmp<2 then         -- start at first char

called by RexxArray::live(size_t liveMark)      ArrayClass.cpp
where this = 0x7f30ed70
this->objects = 7f30ed98
arrayPtr=7f30ee0c
0x7f30ee0c - 0x7f30ed98 = 116 = 29 * 4 --> this is the 30th element

element 1 to 13 : not a string... but doesn't be a problem
+		(*(RexxString*)this->get(14)).stringData	0x7eee36a4 "  len1=length(arg1string)        -- get length of string"	char [4]
+		(*(RexxString*)this->get(15)).stringData	0x7eee3704 "  newArr=.array~new        -- create new array for the arguments"	char [4]
+		(*(RexxString*)this->get(16)).stringData	0x7eee376c "  newArr[1]=new1string     -- "new"-string"	char [4]
+		(*(RexxString*)this->get(18)).stringData	0x7eee37e4 "  prepend=""               -- optional prepend string (if positioning before start!)"	char [4]
+		(*(RexxString*)this->get(20)).stringData	0x7eee388c "  arg2startori=arg2start         -- save passed-in value, if any"	char [4]
+		(*(RexxString*)this->get(21)).stringData	0x7eee38f4 "  if arg4pad=="" then arg4pad=" "-- define blank as the default pad char"	char [4]
+		(*(RexxString*)this->get(23)).stringData	0x7eee398c "  if arg(3,"Exists") then  -- start in "target"-string"	char [4]
+		(*(RexxString*)this->get(24)).stringData	0x7eee2dfc "  do"	char [4]
+		(*(RexxString*)this->get(25)).stringData	0x7eee2e2c "     if datatype(arg2start,"W") then"	char [4]
+		(*(RexxString*)this->get(26)).stringData	0x7eee2e7c "     do"	char [4]
+		(*(RexxString*)this->get(27)).stringData	0x7eee2eac "        if arg2start<0 then      -- negative, start from right"	char [4]
+		(*(RexxString*)this->get(28)).stringData	0x7eee2f14 "        do"	char [4]
+		(*(RexxString*)this->get(29)).stringData	0x7eee2f44 "           tmp=len1+arg2start+1  -- get starting position"	char [4]
+		(*(RexxString*)this->get(30)).stringData	0x7eee1ae4 "           if tmp<2 then         -- start at first char"	char [4]
+		(*(RexxString*)this->get(31)).stringData	0x7eee1b44 "           do"	char [4]
+		(*(RexxString*)this->get(32)).stringData	0x7eee1b7c "              if tmp<0 then"	char [4]

The behaviour of the 30th element is broken :
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(28))))).behaviour)))))).__vfptr	0x003aa62c const RexxBehaviour::`vftable'	*
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(29))))).behaviour)))))).__vfptr	0x003aa62c const RexxBehaviour::`vftable'	*
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(30))))).behaviour)))))).__vfptr	0x44414548	*
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(31))))).behaviour)))))).__vfptr	0x003aa62c const RexxBehaviour::`vftable'	*
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(32))))).behaviour)))))).__vfptr	0x003aa62c const RexxBehaviour::`vftable'	*

the behaviour of 30th element is stored at 0x7eee1acc


called by RexxMemory::markObjectsMain(RexxObject *rootObject)
where rootObject =
+		rootObject	0x003d2a90 class RexxMemory memoryObject {markWord=1 markReason=1 variableCache=0x7f5b55a8 ...}	RexxObject *

called by RexxMemory::markObjects()

called by RexxMemory::collect()

objectclass.hpp
inline void   setBehaviour(RexxBehaviour *b) { behaviour = b; }         <-- this method is called to assign the behavior of type 22 (T_String)
>	rexx.dll!RexxInternalObject::setBehaviour(RexxBehaviour * b)  Line 265 + 0x10 bytes	C++
 	rexx.dll!RexxObject::initializeNewObject(unsigned int mark, void * vft, RexxBehaviour * b)  Line 362	C++
 	rexx.dll!RexxMemory::newObject(unsigned int requestLength, unsigned int type)  Line 1134	C++
 	rexx.dll!new_object(unsigned int s, unsigned int t)  Line 422 + 0x1e bytes	C++
 	rexx.dll!RexxString::newString(const char * string, unsigned int length)  Line 1894 + 0xd bytes	C++
 	rexx.dll!new_string(const char * s, unsigned int l)  Line 521	C++
 	rexx.dll!RexxSource::get(unsigned int _position)  Line 838 + 0x1d bytes	C++
 	rexx.dll!RexxSource::extractSource(SourceLocation & location)  Line 1119 + 0x10 bytes	C++                 <-- counter = 735
 	rexx.dll!RexxCode::getSource()  Line 199	C++
 	rexx.dll!BaseExecutable::source()  Line 149	C++
 	rexx.dll!CPPCode::run(RexxActivity * activity, RexxMethod * method, RexxObject * receiver, RexxString * messageName, RexxObject * * argPtr, unsigned int count, ProtectedObject & result)  Line 144 + 0x6 bytes	C++
 	rexx.dll!RexxMethod::run(RexxActivity * activity, RexxObject * receiver, RexxString * msgname, RexxObject * * argPtr, unsigned int count, ProtectedObject & result)  Line 325	C++
 	rexx.dll!RexxObject::messageSend(RexxString * msgname, RexxObject * * arguments, unsigned int count, ProtectedObject & result)  Line 793	C++
 	rexx.dll!RexxExpressionStack::send(RexxString * message, unsigned int count, ProtectedObject & result)  Line 74 + 0x33 bytes	C++
 	rexx.dll!RexxExpressionMessage::evaluate(RexxActivation * context, RexxExpressionStack * stack)  Line 139	C++
 	rexx.dll!RexxExpressionMessage::evaluate(RexxActivation * context, RexxExpressionStack * stack)  Line 123 + 0x23 bytes	C++
 	rexx.dll!RexxInstructionAssignment::execute(RexxActivation * context, RexxExpressionStack * stack)  Line 122 + 0x1d bytes	C++
 	rexx.dll!RexxActivation::run(RexxObject * _receiver, RexxString * msgname, RexxObject * * _arglist, unsigned int _argcount, RexxInstruction * start, ProtectedObject & resultObj)  Line 522	C++
 	rexx.dll!RexxCode::call(RexxActivity * activity, RoutineClass * routine, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, RexxString * calltype, RexxString * environment, int context, ProtectedObject & result)  Line 116	C++
 	rexx.dll!RexxCode::call(RexxActivity * activity, RoutineClass * routine, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, ProtectedObject & result)  Line 92	C++
 	rexx.dll!RoutineClass::call(RexxActivity * activity, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, ProtectedObject & result)  Line 234	C++
 	rexx.dll!InterpreterInstance::runRequires(RexxActivity * activity, RexxString * name, RoutineClass * code)  Line 877	C++
 	rexx.dll!InterpreterInstance::loadRequires(RexxActivity * activity, RexxString * shortName, RexxString * fullName)  Line 932	C++
 	rexx.dll!RexxSource::loadRequires(RexxActivity * activity, RexxString * target)  Line 6082 + 0x14 bytes	C++
 	rexx.dll!PackageClass::loadPackage(RexxString * name, RexxArray * s)  Line 366 + 0x16 bytes	C++             <-- rgf_util2.rex


The previous behaviour is overwritten by
inline void insertAfter(DeadObject *newDead)            DeadObject.hpp
where newDead = 7eee1ac0
 	rexx.dll!DeadObject::insertAfter(DeadObject * newDead)  Line 89	C++
 	rexx.dll!DeadObjectPool::add(DeadObject * obj)  Line 165	C++
>	rexx.dll!NormalSegmentSet::addDeadObject(char * object, unsigned int length)  Line 461	C++
 	rexx.dll!MemorySegmentSet::sweep()  Line 1170	C++
 	rexx.dll!RexxMemory::collect()  Line 1038	C++
 	rexx.dll!NormalSegmentSet::handleAllocationFailure(unsigned int allocationLength)  Line 1272	C++
 	rexx.dll!RexxMemory::newObject(unsigned int requestLength, unsigned int type)  Line 1117 + 0x12 bytes	C++ <-- length = 48, we are in "small object" part (lesser than LargeBlockThreshold 4096)
 	rexx.dll!new_object(unsigned int s, unsigned int t)  Line 422 + 0x1e bytes	C++
 	rexx.dll!RexxString::newString(const char * string, unsigned int length)  Line 1894 + 0xd bytes	C++
 	rexx.dll!new_string(const char * s, unsigned int l)  Line 521	C++
 	rexx.dll!new_string(const char * s, unsigned int l)  Line 521	C++
 	rexx.dll!RexxSource::get(unsigned int _position)  Line 838 + 0x1d bytes	C++
 	rexx.dll!RexxSource::extractSource(SourceLocation & location)  Line 1119 + 0x10 bytes	C++                 <-- counter = 754
 	rexx.dll!RexxCode::getSource()  Line 199	C++
 	rexx.dll!BaseExecutable::source()  Line 149	C++
 	rexx.dll!CPPCode::run(RexxActivity * activity, RexxMethod * method, RexxObject * receiver, RexxString * messageName, RexxObject * * argPtr, unsigned int count, ProtectedObject & result)  Line 144 + 0x6 bytes	C++
 	rexx.dll!RexxMethod::run(RexxActivity * activity, RexxObject * receiver, RexxString * msgname, RexxObject * * argPtr, unsigned int count, ProtectedObject & result)  Line 325	C++
 	rexx.dll!RexxObject::messageSend(RexxString * msgname, RexxObject * * arguments, unsigned int count, ProtectedObject & result)  Line 793	C++
 	rexx.dll!RexxExpressionStack::send(RexxString * message, unsigned int count, ProtectedObject & result)  Line 74 + 0x33 bytes	C++
 	rexx.dll!RexxExpressionMessage::evaluate(RexxActivation * context, RexxExpressionStack * stack)  Line 139	C++
 	rexx.dll!RexxExpressionMessage::evaluate(RexxActivation * context, RexxExpressionStack * stack)  Line 123 + 0x23 bytes	C++
 	rexx.dll!RexxInstructionAssignment::execute(RexxActivation * context, RexxExpressionStack * stack)  Line 122 + 0x1d bytes	C++
 	rexx.dll!RexxActivation::run(RexxObject * _receiver, RexxString * msgname, RexxObject * * _arglist, unsigned int _argcount, RexxInstruction * start, ProtectedObject & resultObj)  Line 522	C++
 	rexx.dll!RexxCode::call(RexxActivity * activity, RoutineClass * routine, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, RexxString * calltype, RexxString * environment, int context, ProtectedObject & result)  Line 116	C++
 	rexx.dll!RexxCode::call(RexxActivity * activity, RoutineClass * routine, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, ProtectedObject & result)  Line 92	C++
 	rexx.dll!RoutineClass::call(RexxActivity * activity, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, ProtectedObject & result)  Line 234	C++
 	rexx.dll!InterpreterInstance::runRequires(RexxActivity * activity, RexxString * name, RoutineClass * code)  Line 877	C++
 	rexx.dll!InterpreterInstance::loadRequires(RexxActivity * activity, RexxString * shortName, RexxString * fullName)  Line 932	C++
 	rexx.dll!RexxSource::loadRequires(RexxActivity * activity, RexxString * target)  Line 6082 + 0x14 bytes	C++
 	rexx.dll!PackageClass::loadPackage(RexxString * name, RexxArray * s)  Line 366 + 0x16 bytes	C++             <-- rgf_util2.rex
    while loading rgf_util2.rex

Why is 0x7eee1ac0 a dead object ?
In RexxSource::extractSource, the array "source" is created, but is not a ProtectedObject.


================================================================================

Revue des protected objects
Risque de GC avant l'initialisation :

ObjectClass.cpp
RexxObject::operator new(
    ProtectedObject newObject = new (classObject) RexxObject;


================================================================================

While testing pipeline/one-liners.rex, got a GC crash...
It's part of the remaining code to review (->evaluate).
Strange... I fixed the crash by protecting the variables _super and _target in RexxExpressionMessage::evaluate.
But, they should be protected by the stack, no ?
_target = this->target->evaluate(context, stack);       --> see code below, the result is pushed on the stack
_super = this->super->evaluate(context, stack);     (not called in my case)
>	rexx.dll!RexxParseVariable::evaluate(RexxActivation * context, RexxExpressionStack * stack)  Line 102	C++
 	rexx.dll!RexxExpressionMessage::evaluate(RexxActivation * context, RexxExpressionStack * stack)  Line 97 + 0x1b bytes	C++
 	rexx.dll!RexxInstructionAssignment::execute(RexxActivation * context, RexxExpressionStack * stack)  Line 109 + 0x1b bytes	C++
 	rexx.dll!RexxActivation::run(RexxObject * _receiver, RexxString * msgname, RexxObject * * _arglist, unsigned int _argcount, RexxInstruction * start, ProtectedObject & resultObj)  Line 544	C++
----------
RexxObject  *RexxParseVariable::evaluate(
    RexxActivation      *context,      /* current activation context        */
    RexxExpressionStack *stack )       /* evaluation stack                  */
{
    RexxVariable *variable = context->getLocalVariable(variableName, index);
    RexxObject *value = variable->getVariableValue();/* get the value                     */
    ...
    stack->push(value);                  /* place on the evaluation stack     */        <-- here, the result is protected
    ...
    return value;                        /* return the located variable       */
}

