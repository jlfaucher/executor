
-- --------------------------------------------------------------
-- Reducing a collection with a message
-- --------------------------------------------------------------

-- A doer of type string is a message name

-- Reduce
--   arg(1) - accu  : accumulated result
--   arg(2) - item : current item of collection
--   arg(3) - index : current index of collection (passed if the action has an arity >= 3).
-- The messages like "+" "-" etc. have the default arity -1, and as such are called with two arguments (no index).
-- Any doer which is created from a RexxBlock is called with three arguments (index).

-- Ordered collection, the operation can be non-commutative
   .Array~of(1,2,3)~reduce("-")~dump -- initial value is the first item (default)
-4
   .Array~of(1,2,3)~reduce(100, "-")~dump -- initial value is 100
 94


-- Non-ordered collection, the operation must be commutative
   .Bag~of(1,2,3)~reduce("+")~dump
 6
   .Bag~of(1,2,3)~reduce(100, "+")~dump
 106


-- Ordered collection, the operation can be non-commutative
   .CircularQueue~of(1,2,3)~reduce("-")~dump
-4
   .CircularQueue~of(1,2,3)~reduce(100, "-")~dump
 94


-- Non-ordered collection, the operation must be commutative
   .Directory~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~reduce("+")~dump
 6
   .Directory~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~reduce(100, "+")~dump
 106


-- Ordered collection, the operation can be non-commutative
   .List~of(1,2,3)~reduce("-")~dump
-4
   .List~of(1,2,3)~reduce(100, "-")~dump
 94


-- Non-ordered collection, the operation must be commutative
   .Properties~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~reduce("+")~dump
 6
   .Properties~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~reduce(100, "+")~dump
 106


-- Ordered collection, the operation can be non-commutative
   .Queue~of(1,2,3)~reduce("-")~dump
-4
   .Queue~of(1,2,3)~reduce(100, "-")~dump
 94


-- Non-ordered collection, the operation must be commutative
   .Relation~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~reduce("+")~dump
 6
   .Relation~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~reduce(100, "+")~dump
 106


-- A relation which has more than one item per index is supported
   .Relation~new~~put(1, "v1")~~put(2, "v1")~~put(3, "v3")~reduce("+")~dump
 6
   .Relation~new~~put(1, "v1")~~put(2, "v1")~~put(3, "v3")~reduce(100, "+")~dump
 106


-- Non-ordered collection, the operation must be commutative
   .Set~of(1,2,3)~reduce("+")~dump
 6
   .Set~of(1,2,3)~reduce(100, "+")~dump
 106


-- Non-ordered collection, the operation must be commutative
   .Stem~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~reduce("+")~dump
 6
   .Stem~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~reduce(100, "+")~dump
 106


-- Non-ordered collection, the operation must be commutative
   .Table~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~reduce("+")~dump
 6
   .Table~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~reduce(100, "+")~dump
 106


-- Non-ordered collection, the operation must be commutative
   .IdentityTable~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~reduce("+")~dump
 6
   .IdentityTable~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~reduce(100, "+")~dump
 106


-- --------------------------------------------------------------
-- Reducing a string with a message
-- --------------------------------------------------------------

-- initial value is the first char (default)
   123~reduceC("-")~dump
-4


-- initial value is 100
   123~reduceC(100, "-")~dump
 94


   123~reduceC("min")~dump
 1


   123~reduceC("max")~dump
 3


-- initial value is the first word (default)
   "10 20 30"~reduceW("-")~dump
-40


-- initial value is 100
   "10 20 30"~reduceW(100, "-")~dump
 40


-- http://projecteuler.net/problem=16
-- Problem 16
-- 2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
-- What is the sum of the digits of the number 2^1000?
-- Factor : 2 1000 (pow) number>string 1 group [ string>number ] map sum
   numeric digits 302; (2**1000)~reduceC("+")~dump
 1366


-- --------------------------------------------------------------
-- Reducing a mutable buffer with a message
-- --------------------------------------------------------------

-- initial value is the first char (default)
   .MutableBuffer~new(123)~reduceC("-")~dump
-4


-- initial value is 100
   .MutableBuffer~new(123)~reduceC(100, "-")~dump
 94


   .MutableBuffer~new(123)~reduceC("min")~dump
 1


   .MutableBuffer~new(123)~reduceC("max")~dump
 3


-- initial value is the first word (default)
   .MutableBuffer~new("10 20 30")~reduceW("-")~dump
-40


-- initial value is 100
   .MutableBuffer~new("10 20 30")~reduceW(100, "-")~dump
 40


-- --------------------------------------------------------------
-- Reducing a coactivity with a message
-- --------------------------------------------------------------

-- The full tag is "::coactivity".
-- The shortest abbreviation is "::co".
-- initial value is the first yielded item (default)
   {::coactivity .yield[10]; .yield[20]; .yield[30]}~doer~reduce("-")~dump
-40


-- initial value is 100
   {::coactivity .yield[10]; .yield[20]; .yield[30]}~doer~reduce(100, "-")~dump
 40


-- --------------------------------------------------------------
-- Mapping a collection with a message, not-in-place
-- --------------------------------------------------------------

   array = .Array~of(-1,2,-3)
   array~dump -- collection before mapping
an Array (shape [3], 3 items)
 1 : -1
 2 :  2
 3 : -3
   array~map("sign")~dump
an Array (shape [3], 3 items)
 1 : -1
 2 :  1
 3 : -1
   array~dump -- collection after mapping (unchanged)
an Array (shape [3], 3 items)
 1 : -1
 2 :  2
 3 : -3


   bag = .Bag~of(-1,2,-3)
   bag~dump -- collection before mapping
a Bag (3 items)
-1 : -1
-3 : -3
 2 :  2
   bag~map("sign")~dump
a Bag (3 items)
-1 : -1
-1 : -1
 1 :  1
   bag~dump -- collection after mapping (unchanged)
a Bag (3 items)
-1 : -1
-3 : -3
 2 :  2


   circularQueue = .CircularQueue~of(-1,2,-3)
   circularQueue~dump -- collection before mapping
a CircularQueue (3 items)
 1 : -1
 2 :  2
 3 : -3
   circularQueue~map("sign")~dump
a CircularQueue (3 items)
 1 : -1
 2 :  1
 3 : -1
   circularQueue~dump -- collection after mapping (unchanged)
a CircularQueue (3 items)
 1 : -1
 2 :  2
 3 : -3


   directory = .Directory~new~~put(-1, "v1")~~put(2, "v2")~~put(-3, "v3")
   directory~dump -- collection before mapping
a Directory (3 items)
'v1' : -1
'v2' :  2
'v3' : -3
   directory~map("sign")~dump
a Directory (3 items)
'v1' : -1
'v2' :  1
'v3' : -1
   directory~dump -- collection after mapping (unchanged)
a Directory (3 items)
'v1' : -1
'v2' :  2
'v3' : -3


   list = .List~of(-1,2,-3)
   list~dump -- collection before mapping
a List (3 items)
 0 : -1
 1 :  2
 2 : -3
   list~map("sign")~dump
a List (3 items)
 0 : -1
 1 :  1
 2 : -1
   list~dump -- collection after mapping (unchanged)
a List (3 items)
 0 : -1
 1 :  2
 2 : -3


   properties = .Properties~new~~put(-1, "v1")~~put(2, "v2")~~put(-3, "v3")
   properties~dump -- collection before mapping
a Properties (3 items)
'v1' : -1
'v2' :  2
'v3' : -3
   properties~map("sign")~dump
a Properties (3 items)
'v1' : -1
'v2' :  1
'v3' : -1
   properties~dump -- collection after mapping (unchanged)
a Properties (3 items)
'v1' : -1
'v2' :  2
'v3' : -3


   queue = .Queue~of(-1,2,-3)
   queue~dump -- collection before mapping
a Queue (3 items)
 1 : -1
 2 :  2
 3 : -3
   queue~map("sign")~dump
a Queue (3 items)
 1 : -1
 2 :  1
 3 : -1
   queue~dump -- collection after mapping (unchanged)
a Queue (3 items)
 1 : -1
 2 :  2
 3 : -3


   relation = .Relation~new~~put(-1, "v1")~~put(2, "v2")~~put(-3, "v3")
   relation~dump -- collection before mapping
a Relation (3 items)
'v1' : -1
'v2' :  2
'v3' : -3
   relation~map("sign")~dump
a Relation (3 items)
'v1' : -1
'v2' :  1
'v3' : -1
   relation~dump -- collection after mapping (unchanged)
a Relation (3 items)
'v1' : -1
'v2' :  2
'v3' : -3


-- A relation which has more than one item per index is supported
   relation = .Relation~new~~put(-1, "v1")~~put(1, "v1")~~put(-3, "v3")
   relation~dump -- collection before mapping
a Relation (3 items)
'v1' : [ 1,-1]
'v3' : -3
   relation~map("sign")~dump
a Relation (3 items)
'v1' : [-1, 1]
'v3' : -1
   relation~dump -- collection after mapping (unchanged)
a Relation (3 items)
'v1' : [ 1,-1]
'v3' : -3


-- The resulting set has less items (normal... it's a set)
   set = .Set~of(-1,2,-3)
   set~dump -- collection before mapping
a Set (3 items)
-1 : -1
-3 : -3
 2 :  2
   set~map("sign")~dump
a Set (2 items)
-1 : -1
 1 :  1
   set~dump -- collection after mapping (unchanged)
a Set (3 items)
-1 : -1
-3 : -3
 2 :  2


   stem = .Stem~new~~put(-1, "v1")~~put(2, "v2")~~put(-3, "v3")
   stem~dump -- collection before mapping
a Stem (3 items)
'v1' : -1
'v2' :  2
'v3' : -3
   stem~map("sign")~dump
a Stem (3 items)
'v1' : -1
'v2' :  1
'v3' : -1
   stem~dump -- collection after mapping (unchanged)
a Stem (3 items)
'v1' : -1
'v2' :  2
'v3' : -3


   table = .Table~new~~put(-1, "v1")~~put(2, "v2")~~put(-3, "v3")
   table~dump -- collection before mapping
a Table (3 items)
'v1' : -1
'v2' :  2
'v3' : -3
   table~map("sign")~dump
a Table (3 items)
'v1' : -1
'v2' :  1
'v3' : -1
   table~dump -- collection after mapping (unchanged)
a Table (3 items)
'v1' : -1
'v2' :  2
'v3' : -3


   identityTable = .IdentityTable~new~~put(-1, "v1")~~put(2, "v2")~~put(-3, "v3")
   identityTable~dump -- collection before mapping
an IdentityTable (3 items)
'v1' : -1
'v2' :  2
'v3' : -3
   identityTable~map("sign")~dump
an IdentityTable (3 items)
'v1' : -1
'v2' :  1
'v3' : -1
   identityTable~dump -- collection after mapping (unchanged)
an IdentityTable (3 items)
'v1' : -1
'v2' :  2
'v3' : -3


-- --------------------------------------------------------------
-- Mapping a collection with a message, in-place (replace the items)
-- --------------------------------------------------------------

   array = .Array~of(-1,2,-3)
   array~dump -- collection before mapping
an Array (shape [3], 3 items)
 1 : -1
 2 :  2
 3 : -3
   array~mapR("sign")~dump
an Array (shape [3], 3 items)
 1 : -1
 2 :  1
 3 : -1
   array~dump -- collection after mapping (impacted by mapping)
an Array (shape [3], 3 items)
 1 : -1
 2 :  1
 3 : -1


   bag = .Bag~of(-1,2,-3)
   bag~dump -- collection before mapping
a Bag (3 items)
-1 : -1
-3 : -3
 2 :  2
   bag~mapR("sign")~dump
a Bag (3 items)
-1 : -1
-1 : -1
 1 :  1
   bag~dump -- collection after mapping (impacted by mapping
a Bag (3 items)
-1 : -1
-1 : -1
 1 :  1


   circularQueue = .CircularQueue~of(-1,2,-3)
   circularQueue~dump -- collection before mapping
a CircularQueue (3 items)
 1 : -1
 2 :  2
 3 : -3
   circularQueue~mapR("sign")~dump
a CircularQueue (3 items)
 1 : -1
 2 :  1
 3 : -1
   circularQueue~dump -- collection after mapping (impacted by mapping
a CircularQueue (3 items)
 1 : -1
 2 :  1
 3 : -1


   directory = .Directory~new~~put(-1, "v1")~~put(2, "v2")~~put(-3, "v3")
   directory~dump -- collection before mapping
a Directory (3 items)
'v1' : -1
'v2' :  2
'v3' : -3
   directory~mapR("sign")~dump
a Directory (3 items)
'v1' : -1
'v2' :  1
'v3' : -1
   directory~dump -- collection after mapping (impacted by mapping
a Directory (3 items)
'v1' : -1
'v2' :  1
'v3' : -1


   list = .List~of(-1,2,-3)
   list~dump -- collection before mapping
a List (3 items)
 0 : -1
 1 :  2
 2 : -3
   list~mapR("sign")~dump
a List (3 items)
 0 : -1
 1 :  1
 2 : -1
   list~dump -- collection after mapping (impacted by mapping
a List (3 items)
 0 : -1
 1 :  1
 2 : -1


   properties = .Properties~new~~put(-1, "v1")~~put(2, "v2")~~put(-3, "v3")
   properties~dump -- collection before mapping
a Properties (3 items)
'v1' : -1
'v2' :  2
'v3' : -3
   properties~mapR("sign")~dump
a Properties (3 items)
'v1' : -1
'v2' :  1
'v3' : -1
   properties~dump -- collection after mapping (impacted by mapping
a Properties (3 items)
'v1' : -1
'v2' :  1
'v3' : -1


   queue = .Queue~of(-1,2,-3)
   queue~dump -- collection before mapping
a Queue (3 items)
 1 : -1
 2 :  2
 3 : -3
   queue~mapR("sign")~dump
a Queue (3 items)
 1 : -1
 2 :  1
 3 : -1
   queue~dump -- collection after mapping (impacted by mapping
a Queue (3 items)
 1 : -1
 2 :  1
 3 : -1


   relation = .Relation~new~~put(-1, "v1")~~put(2, "v2")~~put(-3, "v3")
   relation~dump -- collection before mapping
a Relation (3 items)
'v1' : -1
'v2' :  2
'v3' : -3
   relation~mapR("sign")~dump
a Relation (3 items)
'v1' : -1
'v2' :  1
'v3' : -1
   relation~dump -- collection after mapping (impacted by mapping
a Relation (3 items)
'v1' : -1
'v2' :  1
'v3' : -1


-- A relation which has more than one item per index is supported
   relation = .Relation~new~~put(-1, "v1")~~put(1, "v1")~~put(-3, "v3")
   relation~dump -- collection before mapping
a Relation (3 items)
'v1' : [ 1,-1]
'v3' : -3
   relation~mapR("sign")~dump
a Relation (3 items)
'v1' : [-1, 1]
'v3' : -1
   relation~dump -- collection after mapping (impacted by mapping
a Relation (3 items)
'v1' : [-1, 1]
'v3' : -1


-- The resulting set has less items (normal... it's a set)
   set = .Set~of(-1,2,-3)
   set~dump -- collection before mapping
a Set (3 items)
-1 : -1
-3 : -3
 2 :  2
   set~mapR("sign")~dump
a Set (2 items)
-1 : -1
 1 :  1
   set~dump -- collection after mapping (impacted by mapping
a Set (2 items)
-1 : -1
 1 :  1


   stem = .Stem~new~~put(-1, "v1")~~put(2, "v2")~~put(-3, "v3")
   stem~dump -- collection before mapping
a Stem (3 items)
'v1' : -1
'v2' :  2
'v3' : -3
   stem~mapR("sign")~dump
a Stem (3 items)
'v1' : -1
'v2' :  1
'v3' : -1
   stem~dump -- collection after mapping (impacted by mapping
a Stem (3 items)
'v1' : -1
'v2' :  1
'v3' : -1


   table = .Table~new~~put(-1, "v1")~~put(2, "v2")~~put(-3, "v3")
   table~dump -- collection before mapping
a Table (3 items)
'v1' : -1
'v2' :  2
'v3' : -3
   table~mapR("sign")~dump
a Table (3 items)
'v1' : -1
'v2' :  1
'v3' : -1
   table~dump -- collection after mapping (impacted by mapping
a Table (3 items)
'v1' : -1
'v2' :  1
'v3' : -1


   identityTable = .IdentityTable~new~~put(-1, "v1")~~put(2, "v2")~~put(-3, "v3")
   identityTable~dump -- collection before mapping
an IdentityTable (3 items)
'v1' : -1
'v2' :  2
'v3' : -3
   identityTable~mapR("sign")~dump
an IdentityTable (3 items)
'v1' : -1
'v2' :  1
'v3' : -1
   identityTable~dump -- collection after mapping (impacted by mapping
an IdentityTable (3 items)
'v1' : -1
'v2' :  1
'v3' : -1


-- --------------------------------------------------------------
-- Mapping a string with a message
-- --------------------------------------------------------------

   "abcdefghijklmnopqrstuvwxyz"~mapC("c2x")~dump
'6162636465666768696A6B6C6D6E6F707172737475767778797A'


   "The quick brown fox jumps over the lazy dog"~mapW("length")~dump
'3 5 5 3 5 4 3 4 3'


-- --------------------------------------------------------------
-- Mapping a mutable buffer with a message
-- --------------------------------------------------------------

--  Not-in-place mapping (map the characters)
   buffer = .MutableBuffer~new("abcdefghijklmnopqrstuvwxyz")
   buffer~dump -- mutable buffer before mapping
M'abcdefghijklmnopqrstuvwxyz'
   buffer~mapC("c2x")~dump
M'6162636465666768696A6B6C6D6E6F707172737475767778797A'
   buffer~dump -- mutable buffer after mapping
M'abcdefghijklmnopqrstuvwxyz'


--  Not-in-place mapping (map the words)
   buffer = .MutableBuffer~new("The quick brown fox jumps over the lazy dog")
   buffer~dump -- mutable buffer before mapping
M'The quick brown fox jumps over the lazy dog'
   buffer~mapW("length")~dump
M'3 5 5 3 5 4 3 4 3'
   buffer~dump -- mutable buffer after mapping
M'The quick brown fox jumps over the lazy dog'


-- In place mapping (Replace the characters)
   buffer = .MutableBuffer~new("abcdefghijklmnopqrstuvwxyz")
   buffer~dump -- mutable buffer before mapping
M'abcdefghijklmnopqrstuvwxyz'
   buffer~mapCR("c2x")~dump
M'6162636465666768696A6B6C6D6E6F707172737475767778797A'
   buffer~dump -- mutable buffer after mapping
M'6162636465666768696A6B6C6D6E6F707172737475767778797A'


-- In place mapping (Replace the words)
   buffer = .MutableBuffer~new("The quick brown fox jumps over the lazy dog")
   buffer~dump -- mutable buffer before mapping
M'The quick brown fox jumps over the lazy dog'
   buffer~mapWR("length")~dump
M'3 5 5 3 5 4 3 4 3'
   buffer~dump -- mutable buffer after mapping
M'3 5 5 3 5 4 3 4 3'


-- --------------------------------------------------------------
-- Reducing a collection with a routine
-- --------------------------------------------------------------

-- A literal source is a routine source by default

-- Reduce :
--   arg(1) - accu  : accumulated result
--   arg(2) - item : current item of collection
--   arg(3) - index : current index of collection (passed if the doer has an arity >= 3)

-- The source literal is transformed at parse time, which lets use an implicit return.
-- You can see the transformed source by running that from ooRexxShell :
--    {accu + item + index}~doer~source=
-- The output is :
--  1 : 'use auto named arg ; options "NOCOMMANDS" ; accu + item + index'
--  2 : 'if var("result") then return result'

   .Array~of(10, 20, 30)~reduce{accu + item + index}~dump -- returns 10 + 20+2 + 30+3 = 65
 65
   .Array~of(10, 20, 30)~reduce(0){accu + item + index}~dump -- returns 0 + 10+1 + 20+2 + 30+3 = 66
 66


-- Remember ! In a bag, the index and the item have the same value
   .Bag~of(10 ,20 ,30)~reduce{accu + item + index}~dump
 90
   .Bag~of(10 ,20 ,30)~reduce(0){accu + item + index}~dump
 120


   .CircularQueue~of(10, 20, 30)~reduce{accu + item + index}~dump
 65
   .CircularQueue~of(10, 20, 30)~reduce(0){accu + item + index}~dump
 66


-- Here the index is not a number, hence the (arbitrary) use of ~c2d to derive a number from the index
   .Directory~new~~put(10, "v1")~~put(20, "v2")~~put(30, "v3")~reduce{accu + item + index~c2d}~dump
 60577
   .Directory~new~~put(10, "v1")~~put(20, "v2")~~put(30, "v3")~reduce(0){accu + item + index~c2d}~dump
 90834


-- Special case ! The index of a list starts at 0...
   .List~of(10, 20, 30)~reduce{accu + item + index}~dump
 63
   .List~of(10, 20, 30)~reduce(0){accu + item + index}~dump
 63


-- Here the index is not a number, hence the (arbitrary) use of ~c2d to derive a number from the index
   .Properties~new~~put(10, "v1")~~put(20, "v2")~~put(30, "v3")~reduce{accu + item + index~c2d}~dump
 60577
   .Properties~new~~put(10, "v1")~~put(20, "v2")~~put(30, "v3")~reduce(0){accu + item + index~c2d}~dump
 90834


   .Queue~of(10, 20, 30)~reduce{accu + item + index}~dump
 65
   .Queue~of(10, 20, 30)~reduce(0){accu + item + index}~dump
 66


-- Here the index is not a number, hence the (arbitrary) use of ~c2d to derive a number from the index
   .Relation~new~~put(10, "v1")~~put(20, "v2")~~put(30, "v3")~reduce{accu + item + index~c2d}~dump
 60577
   .Relation~new~~put(10, "v1")~~put(20, "v2")~~put(30, "v3")~reduce(0){accu + item + index~c2d}~dump
 90834


-- A relation which has more than one item per index is supported
-- Here the index is not a number, hence the (arbitrary) use of ~c2d to derive a number from the index
   .Relation~new~~put(10, "v1")~~put(20, "v1")~~put(30, "v3")~reduce{accu + item + index~c2d}~dump
 60576
   .Relation~new~~put(10, "v1")~~put(20, "v1")~~put(30, "v3")~reduce(0){accu + item + index~c2d}~dump
 90833


-- Remember ! In a set, the index and the item have the same value
   .Set~of(10 ,20 ,30)~reduce{accu + item + index}~dump
 90
   .Set~of(10 ,20 ,30)~reduce(0){accu + item + index}~dump
 120


-- Here the index is not a number, hence the (arbitrary) use of ~c2d to derive a number from the index
   .Stem~new~~put(10, "v1")~~put(20, "v2")~~put(30, "v3")~reduce{accu + item + index~c2d}~dump
 60577
   .Stem~new~~put(10, "v1")~~put(20, "v2")~~put(30, "v3")~reduce(0){accu + item + index~c2d}~dump
 90834


-- Here the index is not a number, hence the (arbitrary) use of ~c2d to derive a number from the index
   .Table~new~~put(10, "v1")~~put(20, "v2")~~put(30, "v3")~reduce{accu + item + index~c2d}~dump
 60577
   .Table~new~~put(10, "v1")~~put(20, "v2")~~put(30, "v3")~reduce(0){accu + item + index~c2d}~dump
 90834


-- Here the index is not a number, hence the (arbitrary) use of ~c2d to derive a number from the index
   .IdentityTable~new~~put(10, "v1")~~put(20, "v2")~~put(30, "v3")~reduce{accu + item + index~c2d}~dump
 60577
   .IdentityTable~new~~put(10, "v1")~~put(20, "v2")~~put(30, "v3")~reduce(0){accu + item + index~c2d}~dump
 90834


-- --------------------------------------------------------------
-- Reducing a string with a routine
-- --------------------------------------------------------------

-- initial value is the first char (default), index passed as 3rd argument, returns 1 + 2+2 + 3+3 = 11
   123~reduceC{accu + item + index}~dump
 11


-- initial value is 0, index passed as 3rd argument, returns 0 + 1+1 + 2+2 + 3+3 = 12
   123~reduceC(0){accu + item + index}~dump
 12


-- initial value is the first word (default), index passed as 3rd argument, returns 10 + 20+2 + 30+3 = 65
   "10 20 30"~reduceW{accu + item + index}~dump
 65


-- initial value is 0, index passed as 3rd argument, returns 0 + 10+1 + 20+2 + 30+3 = 66
   "10 20 30"~reduceW(0){accu + item + index}~dump
 66


-- --------------------------------------------------------------
-- Reducing a mutable buffer with a routine
-- --------------------------------------------------------------

-- initial value is the first char (default), index passed as 3rd argument, returns 1 + 2+2 + 3+3 = 11
   .MutableBuffer~new(123)~reduceC{accu + item + index}~dump
 11


-- initial value is 0, index passed as 3rd argument, returns 0 + 1+1 + 2+2 + 3+3 = 12
   .MutableBuffer~new(123)~reduceC(0){accu + item + index}~dump
 12


-- initial value is the first word (default), index passed as 3rd argument, returns 10 + 20+2 + 30+3 = 65
   .MutableBuffer~new("10 20 30")~reduceW{accu + item + index}~dump
 65


-- initial value is 0, index passed as 3rd argument, returns 0 + 10+1 + 20+2 + 30+3 = 66
   .MutableBuffer~new("10 20 30")~reduceW(0){accu + item + index}~dump
 66


-- --------------------------------------------------------------
-- Reducing a coactivity with a routine
-- --------------------------------------------------------------

-- initial value is the first yielded item (default)
   {::coactivity .yield[10]; .yield[20]; .yield[30]}~doer~reduce{accu + item + index}~dump
 65


-- initial value is 0
   {::coactivity .yield[10]; .yield[20]; .yield[30]}~doer~reduce(0){accu + item + index}~dump
 66


-- --------------------------------------------------------------
-- Mapping a collection with a routine
-- --------------------------------------------------------------

-- Map :
--   arg(1) - item : current item of collection
--   arg(2) - index : current index of collection (passed if the action has an arity >= 3)

   .Array~of(1,2,3,4)~map{item * 2}~dump
an Array (shape [4], 4 items)
 1 :  2
 2 :  4
 3 :  6
 4 :  8


   .Array~of(1,2,3,4)~map{use arg n ; if n == 0 then 1 ; else n * .context~executable~call(n - 1)}~dump
an Array (shape [4], 4 items)
 1 :  1
 2 :  2
 3 :  6
 4 :  24


   .List~of(1,2,3,4)~map{item * 2}~dump
a List (4 items)
 0 :  2
 1 :  4
 2 :  6
 3 :  8


   .List~of(1,2,3,4)~map{use arg n ; if n == 0 then 1 ; else n * .context~executable~call(n - 1)}~dump
a List (4 items)
 0 :  1
 1 :  2
 2 :  6
 3 :  24


   .Queue~of(1,2,3,4)~map{item * 2}~dump
a Queue (4 items)
 1 :  2
 2 :  4
 3 :  6
 4 :  8


   .Queue~of(1,2,3,4)~map{use arg n ; if n == 0 then 1 ; else n * .context~executable~call(n - 1)}~dump
a Queue (4 items)
 1 :  1
 2 :  2
 3 :  6
 4 :  24


   .CircularQueue~of(1,2,3,4)~map{item * 2}~dump
a CircularQueue (4 items)
 1 :  2
 2 :  4
 3 :  6
 4 :  8


   .CircularQueue~of(1,2,3,4)~map{use arg n ; if n == 0 then 1 ; else n * .context~executable~call(n - 1)}~dump
a CircularQueue (4 items)
 1 :  1
 2 :  2
 3 :  6
 4 :  24


-- Filtering : When no value is returned by the routine, then the current item is removed from the collection.
   .Array~of("one", "two", "three")~map{if item~length == 3 then item}~dump
an Array (shape [3], 2 items)
 1 : 'one'
 2 : 'two'
   .Bag~of("one", "two", "three")~map{if item~length == 3 then item}~dump
a Bag (2 items)
'one' : 'one'
'two' : 'two'
   .CircularQueue~of("one", "two", "three")~map{if item~length == 3 then item}~dump
a CircularQueue (2 items)
 1 : 'one'
 2 : 'two'
   .Directory~new~~put(1, "one")~~put(2, "two")~~put(3, "three")~map{if index~length == 3 then item}~dump
a Directory (2 items)
'one' :  1
'two' :  2
   .IdentityTable~new~~put(1, "one")~~put(2, "two")~~put(3, "three")~map{if index~length == 3 then item}~dump
an IdentityTable (2 items)
'one' :  1
'two' :  2
   .List~of("one", "two", "three")~map{if item~length == 3 then item}~dump
a List (2 items)
 0 : 'one'
 1 : 'two'
   .Properties~new~~put(1, "one")~~put(2, "two")~~put(3, "three")~map{if index~length == 3 then item}~dump
a Properties (2 items)
'one' :  1
'two' :  2
   .Queue~of("one", "two", "three")~map{if item~length == 3 then item}~dump
a Queue (2 items)
 1 : 'one'
 2 : 'two'
   .Relation~new~~put(1, "one")~~put(2, "two")~~put(3, "three")~map{if index~length == 3 then item}~dump
a Relation (2 items)
'one' :  1
'two' :  2
   .Set~of("one", "two", "three")~map{if item~length == 3 then item}~dump
a Set (2 items)
'one' : 'one'
'two' : 'two'
   .Stem~new~~put(1, "one")~~put(2, "two")~~put(3, "three")~map{if index~length == 3 then item}~dump
a Stem (2 items)
'one' :  1
'two' :  2
   .Table~new~~put(1, "one")~~put(2, "two")~~put(3, "three")~map{if index~length == 3 then item}~dump
a Table (2 items)
'one' :  1
'two' :  2


-- A source can be tagged explicitely as a routine (but you don't need that, because it's the default)
   .Array~of(1,2,3,4)~map{::routine item * 2}~dump
an Array (shape [4], 4 items)
 1 :  2
 2 :  4
 3 :  6
 4 :  8


-- The shortest abbreviation of "::routine" is "::r"
   .Array~of(1,2,3,4)~map{use arg n ; if n == 0 then 1 ; else n * .context~executable~call(n - 1)}~dump
an Array (shape [4], 4 items)
 1 :  1
 2 :  2
 3 :  6
 4 :  24


-- A routine object can be used directly.
   .Array~of(1,2,3,4)~map(.context~package~findRoutine("factorial"))~dump
an Array (shape [4], 4 items)
 1 :  1
 2 :  2
 3 :  6
 4 :  24


-- --------------------------------------------------------------
-- Mapping a string with a routine
-- --------------------------------------------------------------

   "abcdefghijklmnopqrstuvwxyz"~mapC{item~verify('aeiouy')}~dump
 01110111011111011111011101


-- Filtering (if no result returned by the doer, then nothing appended)
   "abcdefghijklmnopqrstuvwxyz"~mapC{if item~verify('aeiouy') then item}~dump
'bcdfghjklmnpqrstvwxz'


   "one two three"~mapW{if item~length == 3 then item}~dump
'one two'


-- Reminder : index passed as 2nd argument
   "one two three"~mapW{index":"item}~dump
'1:one 2:two 3:three'


-- --------------------------------------------------------------
-- Mapping a mutable buffer with a routine
-- --------------------------------------------------------------

-- Looks like a filtering, but it's not : a value is returned for each character (can be empty string)
   .MutableBuffer~new("abcdefghijklmnopqrstuvwxyz")~mapC{if item~verify('aeiouy') == 1 then item ; else ''}~dump
M'bcdfghjklmnpqrstvwxz'


   .MutableBuffer~new("abcdefghijklmnopqrstuvwxyz")~mapC{if item~verify('aeiouy') == 1 then item}~dump
M'bcdfghjklmnpqrstvwxz'


   translation = .Directory~of("quick", "slow", "lazy", "nervous", "brown", "yellow", "dog", "cat")
   translation~setMethod("UNKNOWN", "return arg(1)")
   "The quick brown fox jumps over the lazy dog"~mapW{expose translation ; translation[arg(1)]}~dump
'The slow yellow fox jumps over the nervous cat'
   .MutableBuffer~new("The quick brown fox jumps over the lazy dog")~mapW{expose translation ; translation[arg(1)]}~dump
M'The slow yellow fox jumps over the nervous cat'


-- --------------------------------------------------------------
-- Repeating & collecting with a routine
-- --------------------------------------------------------------

-- No resulting array because no result returned during the iteration.
   3~times{say 2*item}
2
4
6


-- ~times can act as an array collector : it collects the values returned by the doer.
   3~times{2*item}~dump
an Array (shape [3], 3 items)
 1 :  2
 2 :  4
 3 :  6


   3~times{0}~dump
an Array (shape [3], 3 items)
 1 :  0
 2 :  0
 3 :  0


-- returns .array~of(1,2,3) because the default action is {item}
   3~times~dump
an Array (shape [3], 3 items)
 1 :  1
 2 :  2
 3 :  3


-- No resulting array because no result returned during the iteration.
   11~upto(13){say 2*item}
22
24
26


-- ~upto can act as an array collector : it collects the values returned by the doer.
   11~upto(13){2*item}~dump
an Array (shape [3], 3 items)
 1 :  22
 2 :  24
 3 :  26


   11~upto(13){0}~dump
an Array (shape [3], 3 items)
 1 :  0
 2 :  0
 3 :  0


-- returns .array~of(11,12,13) because the default action is {item}
   11~upto(13)~dump
an Array (shape [3], 3 items)
 1 :  11
 2 :  12
 3 :  13


-- Note that -1 MUST be surrounded by paren or quotes
   (-1)~upto(3)~dump
an Array (shape [5], 5 items)
 1 : -1
 2 :  0
 3 :  1
 4 :  2
 5 :  3


-- No resulting array because no result returned during the iteration
   13~downto(11){say 2*item}
26
24
22


-- ~downto can act as an array collector : it collects the values returned by the doer.
   13~downto(11){2*item}~dump
an Array (shape [3], 3 items)
 1 :  26
 2 :  24
 3 :  22


-- returns .array~of(13,12,11) because the default action is {item}
   13~downto(11)~dump
an Array (shape [3], 3 items)
 1 :  13
 2 :  12
 3 :  11


   3~downto(-1)~dump
an Array (shape [5], 5 items)
 1 :  3
 2 :  2
 3 :  1
 4 :  0
 5 : -1


-- --------------------------------------------------------------
-- Iterating over a collection & collecting with a routine
-- --------------------------------------------------------------

-- each :
-- The values returned by the action are collected in an array

   .Array~of(1,2,3)~each{2*item}~dump
an Array (shape [3], 3 items)
 1 :  2
 2 :  4
 3 :  6
   .Array~of(1,2,3)~each{2*item + index}~dump
an Array (shape [3], 3 items)
 1 :  3
 2 :  6
 3 :  9
   .Array~of(1,2,3)~eachI{2*item + index}~dump
an Array (shape [3], 3 items)
 1 : [ 3, 1]
 2 : [ 6, 2]
 3 : [ 9, 3]


   .Bag~of(1,2,3)~each{2*item}~dump
an Array (shape [3], 3 items)
 1 :  2
 2 :  4
 3 :  6
   .Bag~of(1,2,3)~each{2*item + index}~dump
an Array (shape [3], 3 items)
 1 :  3
 2 :  6
 3 :  9
   .Bag~of(1,2,3)~eachI{2*item + index}~dump
an Array (shape [3], 3 items)
 1 : [ 3, 1]
 2 : [ 6, 2]
 3 : [ 9, 3]


   .CircularQueue~of(1,2,3)~each{2*item}~dump
an Array (shape [3], 3 items)
 1 :  2
 2 :  4
 3 :  6
   .CircularQueue~of(1,2,3)~each{2*item + index}~dump
an Array (shape [3], 3 items)
 1 :  3
 2 :  6
 3 :  9
   .CircularQueue~of(1,2,3)~eachI{2*item + index}~dump
an Array (shape [3], 3 items)
 1 : [ 3, 1]
 2 : [ 6, 2]
 3 : [ 9, 3]


   .Directory~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~each{2*item}~dump
an Array (shape [3], 3 items)
 1 :  2
 2 :  4
 3 :  6
-- Here the index is not a number, hence the (arbitrary) use of ~c2d to derive a number from the index
   .Directory~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~each{2*item + index~c2d}~dump
an Array (shape [3], 3 items)
 1 :  30259
 2 :  30262
 3 :  30265
   .Directory~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~eachI{2*item + index~c2d}~dump
an Array (shape [3], 3 items)
 1 : [ 30259,'v1']
 2 : [ 30262,'v2']
 3 : [ 30265,'v3']


   .List~of(1,2,3)~each{2*item}~dump
an Array (shape [3], 3 items)
 1 :  2
 2 :  4
 3 :  6
   .List~of(1,2,3)~each{2*item + index}~dump
an Array (shape [3], 3 items)
 1 :  2
 2 :  5
 3 :  8
   .List~of(1,2,3)~eachI{2*item + index}~dump
an Array (shape [3], 3 items)
 1 : [ 2, 0]
 2 : [ 5, 1]
 3 : [ 8, 2]


   .Properties~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~each{2*item}~dump
an Array (shape [3], 3 items)
 1 :  2
 2 :  4
 3 :  6
-- Here the index is not a number, hence the (arbitrary) use of ~c2d to derive a number from the index
   .Properties~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~each{2*item + index~c2d}~dump
an Array (shape [3], 3 items)
 1 :  30259
 2 :  30262
 3 :  30265
   .Properties~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~eachI{2*item + index~c2d}~dump
an Array (shape [3], 3 items)
 1 : [ 30259,'v1']
 2 : [ 30262,'v2']
 3 : [ 30265,'v3']


   .Queue~of(1,2,3)~each{2*item}~dump
an Array (shape [3], 3 items)
 1 :  2
 2 :  4
 3 :  6
   .Queue~of(1,2,3)~each{2*item + index}~dump
an Array (shape [3], 3 items)
 1 :  3
 2 :  6
 3 :  9
   .Queue~of(1,2,3)~eachI{2*item + index}~dump
an Array (shape [3], 3 items)
 1 : [ 3, 1]
 2 : [ 6, 2]
 3 : [ 9, 3]


   .Relation~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~each{2*item}~dump
an Array (shape [3], 3 items)
 1 :  2
 2 :  4
 3 :  6
-- Here the index is not a number, hence the (arbitrary) use of ~c2d to derive a number from the index
   .Relation~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~each{2*item + index~c2d}~dump
an Array (shape [3], 3 items)
 1 :  30259
 2 :  30262
 3 :  30265
   .Relation~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~eachI{2*item + index~c2d}~dump
an Array (shape [3], 3 items)
 1 : [ 30259,'v1']
 2 : [ 30262,'v2']
 3 : [ 30265,'v3']


   .Set~of(1,2,3)~each{2*item}~dump
an Array (shape [3], 3 items)
 1 :  2
 2 :  4
 3 :  6
   .Set~of(1,2,3)~each{2*item + index}~dump
an Array (shape [3], 3 items)
 1 :  3
 2 :  6
 3 :  9
   .Set~of(1,2,3)~eachI{2*item + index}~dump
an Array (shape [3], 3 items)
 1 : [ 3, 1]
 2 : [ 6, 2]
 3 : [ 9, 3]


   .Stem~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~each{2*item}~dump
an Array (shape [3], 3 items)
 1 :  2
 2 :  6
 3 :  4
-- Here the index is not a number, hence the (arbitrary) use of ~c2d to derive a number from the index
   .Stem~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~each{2*item + index~c2d}~dump
an Array (shape [3], 3 items)
 1 :  30259
 2 :  30265
 3 :  30262
   .Stem~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~eachI{2*item + index~c2d}~dump
an Array (shape [3], 3 items)
 1 : [ 30259,'v1']
 2 : [ 30265,'v3']
 3 : [ 30262,'v2']


   .Table~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~each{2*item}~dump
an Array (shape [3], 3 items)
 1 :  2
 2 :  4
 3 :  6
-- Here the index is not a number, hence the (arbitrary) use of ~c2d to derive a number from the index
   .Table~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~each{2*item + index~c2d}~dump
an Array (shape [3], 3 items)
 1 :  30259
 2 :  30262
 3 :  30265
   .Table~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~eachI{2*item + index~c2d}~dump
an Array (shape [3], 3 items)
 1 : [ 30259,'v1']
 2 : [ 30262,'v2']
 3 : [ 30265,'v3']


   .IdentityTable~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~each{2*item}~dump
an Array (shape [3], 3 items)
 1 :  2
 2 :  4
 3 :  6
-- Here the index is not a number, hence the (arbitrary) use of ~c2d to derive a number from the index
   .IdentityTable~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~each{2*item + index~c2d}~dump
an Array (shape [3], 3 items)
 1 :  30259
 2 :  30262
 3 :  30265
   .IdentityTable~new~~put(1, "v1")~~put(2, "v2")~~put(3, "v3")~eachI{2*item + index~c2d}~dump
an Array (shape [3], 3 items)
 1 : [ 30259,'v1']
 2 : [ 30262,'v2']
 3 : [ 30265,'v3']


-- --------------------------------------------------------------
-- Iterating over a supplier & collecting with a routine
-- --------------------------------------------------------------

-- supplier : the collection generated by ~each is always an array
   .set~of(1,2,3)~supplier~each{2*item}~dump
an Array (shape [3], 3 items)
 1 :  2
 2 :  4
 3 :  6


-- --------------------------------------------------------------
-- Iterating over a string & collecting with a routine
-- --------------------------------------------------------------

-- string : the collection generated by ~each is always an array

   "abcdef"~eachC{item}~dump
an Array (shape [6], 6 items)
 1 : 'a'
 2 : 'b'
 3 : 'c'
 4 : 'd'
 5 : 'e'
 6 : 'f'
   "abcdef"~eachC{".."~copies(index)item}~dump
an Array (shape [6], 6 items)
 1 : '..a'
 2 : '....b'
 3 : '......c'
 4 : '........d'
 5 : '..........e'
 6 : '............f'
   "abcdef"~eachCI{".."~copies(index)item}~dump
an Array (shape [6], 6 items)
 1 : ['..a', 1]
 2 : ['....b', 2]
 3 : ['......c', 3]
 4 : ['........d', 4]
 5 : ['..........e', 5]
 6 : ['............f', 6]


   "The quick brown fox"~eachW{item}~dump
an Array (shape [4], 4 items)
 1 : 'The'
 2 : 'quick'
 3 : 'brown'
 4 : 'fox'
   "The quick brown fox"~eachW{".."~copies(index)item}~dump
an Array (shape [4], 4 items)
 1 : '..The'
 2 : '....quick'
 3 : '......brown'
 4 : '........fox'
   "The quick brown fox"~eachWI{".."~copies(index)item}~dump
an Array (shape [4], 4 items)
 1 : ['..The', 1]
 2 : ['....quick', 2]
 3 : ['......brown', 3]
 4 : ['........fox', 4]


-- --------------------------------------------------------------
-- Iterating over a mutable buffer & collecting with a routine
-- --------------------------------------------------------------

-- mutable buffer : the collection generated by ~each is always an array

   .MutableBuffer~new("abcdef")~eachC{item}~dump
an Array (shape [6], 6 items)
 1 : 'a'
 2 : 'b'
 3 : 'c'
 4 : 'd'
 5 : 'e'
 6 : 'f'
   .MutableBuffer~new("abcdef")~eachC{".."~copies(index)item}~dump
an Array (shape [6], 6 items)
 1 : '..a'
 2 : '....b'
 3 : '......c'
 4 : '........d'
 5 : '..........e'
 6 : '............f'
   .MutableBuffer~new("abcdef")~eachCI{".."~copies(index)item}~dump
an Array (shape [6], 6 items)
 1 : ['..a', 1]
 2 : ['....b', 2]
 3 : ['......c', 3]
 4 : ['........d', 4]
 5 : ['..........e', 5]
 6 : ['............f', 6]


   .MutableBuffer~new("The quick brown fox")~eachW{item}~dump
an Array (shape [4], 4 items)
 1 : 'The'
 2 : 'quick'
 3 : 'brown'
 4 : 'fox'
   .MutableBuffer~new("The quick brown fox")~eachW{".."~copies(index)item}~dump
an Array (shape [4], 4 items)
 1 : '..The'
 2 : '....quick'
 3 : '......brown'
 4 : '........fox'
   .MutableBuffer~new("The quick brown fox")~eachWI{".."~copies(index)item}~dump
an Array (shape [4], 4 items)
 1 : ['..The', 1]
 2 : ['....quick', 2]
 3 : ['......brown', 3]
 4 : ['........fox', 4]


-- --------------------------------------------------------------
-- Iterating over a coactivity & collecting with a routine
-- --------------------------------------------------------------

-- coactivity : ~makeArray is not a lazy method : it collects ALL the yielded values and return an array

   {::coactivity do i=1 to 3; .yield[i]; end}~doer~each{2*item}~makeArray~dump
an Array (shape [3], 3 items)
 1 :  2
 2 :  4
 3 :  6
   {::coactivity do i=1 to 3; .yield[i]; end}~doer~each{2*item + index}~makeArray~dump
an Array (shape [3], 3 items)
 1 :  3
 2 :  6
 3 :  9
   {::coactivity do i=1 to 3; .yield[i]; end}~doer~eachI{2*item + index}~makeArray~dump
an Array (shape [3], 3 items)
 1 : [ 3, 1]
 2 : [ 6, 2]
 3 : [ 9, 3]


-- --------------------------------------------------------------
-- Iterating over a coactivity & generating with a routine
-- --------------------------------------------------------------

-- coactivity : each is a lazy method which returns another coactivity, not an array
-- Note : each example ends with c~do, to end the coactivities. This is not mandatory.
-- If you put in comment these c~do, then you will see 6 pending coactivities at the end of the output :
-- each example creates 2 coactivities : the first one by ~doer, the second one by ~each.
   c = {::coactivity do i=1 to 3; .yield[i]; end}~doer~each{2*item}
   c~dump
(a Coactivity)
   c~do~dump
 2
   c~do~dump
 4
   c~do~dump
 6
   c~do -- optional, this is to end the chain of coactivities
   c = {::coactivity do i=1 to 3; .yield[i]; end}~doer~each{2*item + index}
   c~dump
(a Coactivity)
   c~do~dump
 3
   c~do~dump
 6
   c~do~dump
 9
   c~do -- optional, this is to end the chain of coactivities
   c = {::coactivity do i=1 to 3; .yield[i]; end}~doer~eachI{2*item + index}
   c~dump
(a Coactivity)
   c~do~dump
an Array (shape [2], 2 items)
 1 :  3
 2 :  1
   c~do~dump
an Array (shape [2], 2 items)
 1 :  6
 2 :  2
   c~do~dump
an Array (shape [2], 2 items)
 1 :  9
 2 :  3
   c~do -- optional, this is to end the chain of coactivities


-- --------------------------------------------------------------
-- Mapping with a method
-- --------------------------------------------------------------

   colors = .Array~of( ,
       .Color~new("black", "000000") ,,
       .Color~new("blue",  "0000FF") ,,
       .Color~new("green", "008000") ,,
       .Color~new("grey",  "BEBEBE") ,
       )


-- A method object can be used directly
-- No need to define the method on the receiver class...
   colors~map(.methods~entry("decimalColor"))~dump
an Array (shape [4], 4 items)
 1 : '0 (0, 0, 0)'
 2 : '255 (0, 0, 255)'
 3 : '32768 (0, 128, 0)'
 4 : '12500670 (190, 190, 190)'


-- ... except when the method is recursive and recalls itself by name
   .String~define("factorial", .methods~entry("factorial"))
   .Array~of(1,2,3,4)~map(.methods~entry("factorial"))~dump
an Array (shape [4], 4 items)
 1 :  1
 2 :  2
 3 :  6
 4 :  24


-- Here, the method is recursive, but does not recall itself by name
   .Array~of(1,2,3,4)~map(.methods~entry("factorialExecutable"))~dump
an Array (shape [4], 4 items)
 1 :  1
 2 :  2
 3 :  6
 4 :  24

Ended coactivities: 0
