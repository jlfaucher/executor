********************************************************************************
*                          Call an internal procedure                          *
********************************************************************************

call myprocedure
    positional count=0 size=0
    named count=0


call myprocedure 1, 2, 3
    positional count=3 size=3
        1 : 1
        2 : 2
        3 : 3
    named count=0


call myprocedure 1, 2, a3:3
    positional count=2 size=2
        1 : 1
        2 : 2
    named count=1
        A3 : 3


call myprocedure 1, a2:2, a3:3
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


call myprocedure 1, a2:(2*5/4)**5, a3:.array~new(3,3)
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 97.65625
        A3 : an Array


call myprocedure , , 3, ,
    positional count=1 size=4
        3 : 3
    named count=0


call myprocedure , , 3, , a5:5
    positional count=1 size=4
        3 : 3
    named count=1
        A5 : 5


call myprocedure 1, 2, 3, {}
    positional count=4 size=4
        1 : 1
        2 : 2
        3 : 3
        4 : a RexxBlock
    named count=0


call myprocedure 1, 2, {}, a3:3
    positional count=3 size=3
        1 : 1
        2 : 2
        3 : a RexxBlock
    named count=1
        A3 : 3


call myprocedure 1, {}, a2:2, a3:3
    positional count=2 size=2
        1 : 1
        2 : a RexxBlock
    named count=2
        A2 : 2
        A3 : 3


********************************************************************************
*                    Continuation of the interpreted string                    *
********************************************************************************

call interpret 'call myprocedure 1,',
               'a2:2, a3:3'
call myprocedure 1, a2:2, a3:3
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


call interpret 'call myprocedure 1, a2',
               ':2, a3:3'
call myprocedure 1, a2 :2, a3:3
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


call interpret 'call myprocedure 1, a2:',
               '2, a3:3'
call myprocedure 1, a2: 2, a3:3
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


call interpret 'call myprocedure 1, a2:2,',
               'a3:3'
call myprocedure 1, a2:2, a3:3
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


********************************************************************************
*                     Continuation of the CALL instruction                     *
********************************************************************************

call myprocedure 1,,
     a2:2, a3:3
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


call myprocedure 1, a2,
     :2, a3:3
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


call myprocedure 1, a2:,
     2, a3:3
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


call myprocedure 1, a2:2,,
     a3:3
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


********************************************************************************
*                   Call an internal procedure as a function                   *
********************************************************************************

r = myprocedure()
    positional count=0 size=0
    named count=0


r = myprocedure(1, 2, 3)
    positional count=3 size=3
        1 : 1
        2 : 2
        3 : 3
    named count=0


r = myprocedure(1, 2, a3:3)
    positional count=2 size=2
        1 : 1
        2 : 2
    named count=1
        A3 : 3


r = myprocedure(1, a2:2, a3:3)
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


r = myprocedure(1, a2:(2*5/4)**5, a3:.array~new(3,3))
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 97.65625
        A3 : an Array


r = myprocedure( , , 3, ,)
    positional count=1 size=5
        3 : 3
    named count=0


r = myprocedure( , , 3, , a5:5)
    positional count=1 size=4
        3 : 3
    named count=1
        A5 : 5


r = myprocedure(1, 2, 3){}
    positional count=4 size=4
        1 : 1
        2 : 2
        3 : 3
        4 : a RexxBlock
    named count=0


r = myprocedure(1, 2, a3:3){}
    positional count=3 size=3
        1 : 1
        2 : 2
        3 : a RexxBlock
    named count=1
        A3 : 3


r = myprocedure(1, a2:2, a3:3){}
    positional count=2 size=2
        1 : 1
        2 : a RexxBlock
    named count=2
        A2 : 2
        A3 : 3


********************************************************************************
*                    Continuation of the interpreted string                    *
********************************************************************************

call interpret 'r=myprocedure(1,',
               'a2:2, a3:3)'
r=myprocedure(1, a2:2, a3:3)
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


call interpret 'r = myprocedure(1, a2',
               ':2, a3:3)'
r = myprocedure(1, a2 :2, a3:3)
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


call interpret 'r = myprocedure(1, a2:',
               '2, a3:3)'
r = myprocedure(1, a2: 2, a3:3)
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


call interpret 'r = myprocedure(1, a2:2,',
               'a3:3)'
r = myprocedure(1, a2:2, a3:3)
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


********************************************************************************
*                      Continuation of the function call                       *
********************************************************************************

r = myprocedure(1,,
     a2:2, a3:3)
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


r = myprocedure(1, a2,
     :2, a3:3)
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


r = myprocedure(1, a2:,
     2, a3:3)
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


r = myprocedure(1, a2:2,,
     a3:3)
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


********************************************************************************
*                                Call a routine                                *
********************************************************************************

call myroutine
    positional count=0 size=0
    named count=0


call myroutine 1, 2, 3
    positional count=3 size=3
        1 : 1
        2 : 2
        3 : 3
    named count=0


call myroutine 1, 2, a3:3
    positional count=2 size=2
        1 : 1
        2 : 2
    named count=1
        A3 : 3


call myroutine 1, a2:2, a3:3
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


call myroutine 1, a2:(2*5/4)**5, a3:.array~new(3,3)
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 97.65625
        A3 : an Array


call myroutine , , 3, ,
    positional count=1 size=4
        3 : 3
    named count=0


call myroutine , , 3, , a5:5
    positional count=1 size=4
        3 : 3
    named count=1
        A5 : 5


********************************************************************************
*                         Call a routine as a function                         *
********************************************************************************

r = myroutine()
    positional count=0 size=0
    named count=0


r = myroutine(1, 2, 3)
    positional count=3 size=3
        1 : 1
        2 : 2
        3 : 3
    named count=0


r = myroutine(1, 2, a3:3)
    positional count=2 size=2
        1 : 1
        2 : 2
    named count=1
        A3 : 3


r = myroutine(1, a2:2, a3:3)
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


r = myroutine(1, a2:(2*5/4)**5, a3:.array~new(3,3))
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 97.65625
        A3 : an Array


r = myroutine( , , 3, ,)
    positional count=1 size=5
        3 : 3
    named count=0


r = myroutine( , , 3, , a5:5)
    positional count=1 size=4
        3 : 3
    named count=1
        A5 : 5


r = myroutine(1, 2, 3){}
    positional count=4 size=4
        1 : 1
        2 : 2
        3 : 3
        4 : a RexxBlock
    named count=0


r = myroutine(1, 2, a3:3){}
    positional count=3 size=3
        1 : 1
        2 : 2
        3 : a RexxBlock
    named count=1
        A3 : 3


r = myroutine(1, a2:2, a3:3){}
    positional count=2 size=2
        1 : 1
        2 : a RexxBlock
    named count=2
        A2 : 2
        A3 : 3


********************************************************************************
*                      Call a method using a message term                      *
********************************************************************************

r = .myclass~mymethod
    positional count=0 size=0
    named count=0


r = .myclass~mymethod()
    positional count=0 size=0
    named count=0


r = .myclass~mymethod(1, 2, 3)
    positional count=3 size=3
        1 : 1
        2 : 2
        3 : 3
    named count=0


r = .myclass~mymethod(1, 2, a3:3)
    positional count=2 size=2
        1 : 1
        2 : 2
    named count=1
        A3 : 3


r = .myclass~mymethod(1, a2:2, a3:3)
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


r = .myclass~mymethod(1, a2:(2*5/4)**5, a3:.array~new(3,3))
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 97.65625
        A3 : an Array


r = .myclass~mymethod( , , 3, ,)
    positional count=1 size=5
        3 : 3
    named count=0


r = .myclass~mymethod( , , 3, , a5:5)
    positional count=1 size=4
        3 : 3
    named count=1
        A5 : 5


r = .myclass~mymethod(1, 2, 3){}
    positional count=4 size=4
        1 : 1
        2 : 2
        3 : 3
        4 : a RexxBlock
    named count=0


r = .myclass~mymethod(1, 2, a3:3){}
    positional count=3 size=3
        1 : 1
        2 : 2
        3 : a RexxBlock
    named count=1
        A3 : 3


r = .myclass~mymethod(1, a2:2, a3:3){}
    positional count=2 size=2
        1 : 1
        2 : a RexxBlock
    named count=2
        A2 : 2
        A3 : 3


********************************************************************************
*                              Forward a message                               *
********************************************************************************

r = .myclass~forwardArray
    forward message "mymethod" array ( 10, 20, 30, a1:40, a2:50 ) continue
    positional count=3 size=3
        1 : 10
        2 : 20
        3 : 30
    named count=2
        A1 : 40
        A2 : 50


r = .myclass~forwardNamedArguments
    forward message "mymethod" namedArguments (.directory~of(a1:1, a2:2)) continue
    positional count=0 size=0
    named count=2
        A1 : 1
        A2 : 2


r = .myclass~forwardPositionalNamedArguments
    forward message "mymethod" arguments ((1,2)) namedArguments (.directory~of(a1:1, a2:2)) continue
    positional count=2 size=2
        1 : 1
        2 : 2
    named count=2
        A1 : 1
        A2 : 2


r = .myclass~forwardNamedPositionalArguments
    forward message "mymethod" namedArguments (.directory~of(a1:1, a2:2)) arguments ((1,2)) continue
    positional count=2 size=2
        1 : 1
        2 : 2
    named count=2
        A1 : 1
        A2 : 2


********************************************************************************
*                               Instruction USE                                *
********************************************************************************

call usePositionalNamed 1, , 3, , a5:5, a6:6
    positional count=2 size=4
        1 : 1
        3 : 3
    named count=2
        A5 : 5
        A6 : 6
    use arg p1, p2, p3, p4
    use named arg a5, a6
    variables count=4
        A5 : 5
        A6 : 6
        P1 : 1
        P3 : 3


call useStrictPositionalNamed 1, , 3, , a5:5, a6:6
    positional count=2 size=4
        1 : 1
        3 : 3
    named count=2
        A5 : 5
        A6 : 6
    use strict arg p1, p2=2, p3, p4=4
    use strict named arg a5, a6
    variables count=6
        A5 : 5
        A6 : 6
        P1 : 1
        P2 : 2
        P3 : 3
        P4 : 4


call useStrictZeroNamed
    positional count=0 size=0
    named count=0
    use strict named arg
    variables count=0


call useStrictOneNamed_NoDefault a1:1
    positional count=0 size=0
    named count=1
        A1 : 1
    use strict named arg a1
    variables count=1
        A1 : 1


call useStrictOneNamed_WithDefault
    positional count=0 size=0
    named count=0
    use strict named arg a1=1
    variables count=1
        A1 : 1


call useStrictOneNamed_WithDefault a1:2
    positional count=0 size=0
    named count=1
        A1 : 2
    use strict named arg a1=1
    variables count=1
        A1 : 2


call useStrictOneNamed_WithDefaultExpression
    positional count=0 size=0
    named count=0
    use strict named arg a1=(1+0)
    variables count=1
        A1 : 1


call useStrictOneNamed_WithDefaultExpression a1:2
    positional count=0 size=0
    named count=1
        A1 : 2
    use strict named arg a1=(1+0)
    variables count=1
        A1 : 2


call useStrictAutoNamed_WithEllipse
    positional count=0 size=0
    named count=0
    use strict auto named arg ...
    variables count=0


call useNamed_SimpleSymbol v1:1, v3:3, v5:5
    positional count=0 size=0
    named count=3
        V1 : 1
        V3 : 3
        V5 : 5
    use named arg v1, v2=2
    variables count=2
        V1 : 1
        V2 : 2


call useNamed_WithMinimumLength
    use named arg n(1)
    use named arg n(10)
    use named arg n(100)
    use named arg n(+1)
    use named arg n(1) = 10


call useAutoNamed_SimpleSymbol v1:1, v3:3, v5:5, index:"My index", item:"My item"
    positional count=0 size=0
    named count=5
        INDEX : My index
        ITEM : My item
        V1 : 1
        V3 : 3
        V5 : 5
    use auto named arg v1=(item), v2=(index)
    variables count=6
        INDEX : My index
        ITEM : My item
        V1 : 1
        V2 : My index
        V3 : 3
        V5 : 5
Expected:
The automatic variables are created first (here v3=3, v5=5, index="My index" and item="My item"), in the order of declaration on caller side (left to right).
Then the declared named arguments are assigned with the passed values, in the order of declaration on called side (left to right).
So it's possible to initialize a named argument with an automatic variable (here v2 is assigned the value of index).


call useNamed_Stem_CompoundSymbol stem.v1:1, stem.:0, stem.v3:3, stem.v4:4, index:"My index", item:"My item"
    positional count=0 size=0
    named count=6
        INDEX : My index
        ITEM : My item
        STEM. : 0
        STEM.V1 : 1
        STEM.V3 : 3
        STEM.V4 : 4
    use named arg stem., stem.v1, stem.v2=(item), stem.v3=(index)
    variables count=1
        STEM. : 0
    stem count=3
        V1 : 1
        V2 : ITEM
        V3 : 3
Expected:
The option auto is not used, so stem.v4, index and item are not created as local variables.
The declared named arguments are assigned with the passed values, in the order of declaration on called side (left to right).
The assignment stem.=0 resets the stem.
Then the assignments stem.v1=1, stem.v2="ITEM" (default) and stem.v3=3 are made.


call useAutoNamed_Stem_CompoundSymbol stem.v1:1, stem.:0, stem.v3:3, stem.v4:4, index:"My index", item:"My item"
    positional count=0 size=0
    named count=6
        INDEX : My index
        ITEM : My item
        STEM. : 0
        STEM.V1 : 1
        STEM.V3 : 3
        STEM.V4 : 4
    use auto named arg stem., stem.v1, stem.v2=(item), stem.v3=(index)
    variables count=3
        INDEX : My index
        ITEM : My item
        STEM. : 0
    stem count=3
        V1 : 1
        V2 : My item
        V3 : 3
Expected:
Same test case as previous, except the option auto which is used.
The automatic variables are created first (here stem.v4=4, index="My index" and item="My item"), in the order of declaration on caller side (left to right).
Then the declared named arguments are assigned with the passed values, in the order of declaration on called side (left to right).
The assignment stem.=0 resets the stem, and erase the automatic variables stem.v4.
Then the assignments stem.v1=1, stem.v2="My index" (default) and stem.v3=3 are made.


call useAutoNamed_Stem_CompoundSymbol stem.v1:1, stem.v3:3, stem.v4:4, index:"My index", item:"My item"
    positional count=0 size=0
    named count=5
        INDEX : My index
        ITEM : My item
        STEM.V1 : 1
        STEM.V3 : 3
        STEM.V4 : 4
    use auto named arg stem., stem.v1, stem.v2=(item), stem.v3=(index)
    variables count=3
        INDEX : My index
        ITEM : My item
        STEM. : STEM.
    stem count=3
        V1 : 1
        V2 : My item
        V3 : 3
Expected:
Same test case as previous, except that stem.:0 is no longer passed by the caller.
The automatic variables are created first (here stem.v4=4, index="My index" and item="My item"), in the order of declaration on caller side (left to right).
Then the declared named arguments are assigned with the passed values, in the order of declaration on called side (left to right).
The stem is dropped, which drops the automatic variables stem.v4.
Then the assignments stem.v1=1, stem.v2="My index" (default) and stem.v3=3 are made.


call useAutoNamed_CompoundSymbol stem.v1:1, stem.v3:3, stem.v4:4, index:"My index", item:"My item"
    positional count=0 size=0
    named count=5
        INDEX : My index
        ITEM : My item
        STEM.V1 : 1
        STEM.V3 : 3
        STEM.V4 : 4
    use auto named arg stem.v1, stem.v2=(item), stem.v3=(index)
    variables count=3
        INDEX : My index
        ITEM : My item
        STEM. : STEM.
    stem count=4
        V1 : 1
        V2 : My item
        V3 : 3
        V4 : 4
Expected:
Same test case as previous, except that the named argument 'stem.' is no longer declared by the callee, so no longer reset.
The automatic variables are created first (here stem.v4=4, index="My index" and item="My item"), in the order of declaration on caller side (left to right).
Then the declared named arguments are assigned with the passed values, in the order of declaration on called side (left to right).
Then the assignments stem.v1=1, stem.v2="My index" (default) and stem.v3=3 are made.
Note that the automatic variable stem.v4 is available, since the stem is not reset.


Testing the display of trace
{...<source>..}~(a:1,b:"letter b",stem.:"default", stem.a:100, stem.b:200, stem.c:300)
use auto named arg ; options "NOCOMMANDS" ; call sayCollection "source", .context~executable~source, displayHeader:.false, displayIndex:.false, displayIndent:.false
    say "-----------------------------------------"
    trace i
    -- the names of the compound symbols are used for matching, independently of the values of their components.
    -- Even if a==50, stem.a will be matched as "STEM.A", not "STEM.50"
    a = 50
    b = 51
    c = 52
    use strict /*auto*/ named arg a, b, stem., stem.a, stem.b, stem.c
    trace o
    say "-----------------------------------------"
    call sayArg .context
    call sayCollection "variables", .context~variables
    call sayCollection "stem", stem.
    say; say
if var("result") then return result
-----------------------------------------
     7 *-* a = 50
       >L>   "50"
       >>>   "50"
       >=>   A <= "50"
     8 *-* b = 51
       >L>   "51"
       >>>   "51"
       >=>   B <= "51"
     9 *-* c = 52
       >L>   "52"
       >>>   "52"
       >=>   C <= "52"
    10 *-* use strict /*auto*/ named arg a, b, stem., stem.a, stem.b, stem.c
       >>>   "1"
       >=>   A <= "1"
       >>>   "letter b"
       >=>   B <= "letter b"
       >>>   "default"
       >=>   STEM. <= "default"
       >>>   "100"
       >C>   STEM.A => "STEM.1"
       >=>   STEM.A <= "100"
       >>>   "200"
       >C>   STEM.B => "STEM.letter b"
       >=>   STEM.B <= "200"
       >>>   "300"
       >C>   STEM.C => "STEM.52"
       >=>   STEM.C <= "300"
    11 *-* trace o
-----------------------------------------
    positional count=0 size=0
    named count=6
        A : 1
        B : letter b
        STEM. : default
        STEM.A : 100
        STEM.B : 200
        STEM.C : 300
    variables count=4
        A : 1
        B : letter b
        C : 52
        STEM. : default
    stem count=3
        1 : 100
        52 : 300
        letter b : 200


********************************************************************************
*                                Unknown method                                *
********************************************************************************

r = .myclass~foo
    method 'unknown'
        positional count=2 size=2
            1 : FOO
            2 : an Array
        named count=1
            NAMEDARGUMENTS : The NIL object
    method 'unknown' forward to (.myfooclass) message (name) arguments (arguments) namedArguments (namedArguments)
        positional count=0 size=0
        named count=0


r = .myclass~foo()
    method 'unknown'
        positional count=2 size=2
            1 : FOO
            2 : an Array
        named count=1
            NAMEDARGUMENTS : The NIL object
    method 'unknown' forward to (.myfooclass) message (name) arguments (arguments) namedArguments (namedArguments)
        positional count=0 size=0
        named count=0


r = .myclass~foo(1, 2, 3)
    method 'unknown'
        positional count=2 size=2
            1 : FOO
            2 : an Array
        named count=1
            NAMEDARGUMENTS : The NIL object
    method 'unknown' forward to (.myfooclass) message (name) arguments (arguments) namedArguments (namedArguments)
        positional count=3 size=3
            1 : 1
            2 : 2
            3 : 3
        named count=0


r = .myclass~foo(1, 2, a3:3)
    method 'unknown'
        positional count=2 size=2
            1 : FOO
            2 : an Array
        named count=1
            NAMEDARGUMENTS : a Directory
    method 'unknown' forward to (.myfooclass) message (name) arguments (arguments) namedArguments (namedArguments)
        positional count=2 size=2
            1 : 1
            2 : 2
        named count=1
            A3 : 3


r = .myclass~foo(1, a2:2, a3:3)
    method 'unknown'
        positional count=2 size=2
            1 : FOO
            2 : an Array
        named count=1
            NAMEDARGUMENTS : a Directory
    method 'unknown' forward to (.myfooclass) message (name) arguments (arguments) namedArguments (namedArguments)
        positional count=1 size=1
            1 : 1
        named count=2
            A2 : 2
            A3 : 3


r = .myclass~foo(1, a2:(2*5/4)**5, a3:.array~new(3,3))
    method 'unknown'
        positional count=2 size=2
            1 : FOO
            2 : an Array
        named count=1
            NAMEDARGUMENTS : a Directory
    method 'unknown' forward to (.myfooclass) message (name) arguments (arguments) namedArguments (namedArguments)
        positional count=1 size=1
            1 : 1
        named count=2
            A2 : 97.65625
            A3 : an Array


r = .myclass~foo( , , 3, ,)
    method 'unknown'
        positional count=2 size=2
            1 : FOO
            2 : an Array
        named count=1
            NAMEDARGUMENTS : The NIL object
    method 'unknown' forward to (.myfooclass) message (name) arguments (arguments) namedArguments (namedArguments)
        positional count=1 size=5
            3 : 3
        named count=0


r = .myclass~foo( , , 3, , a5:5)
    method 'unknown'
        positional count=2 size=2
            1 : FOO
            2 : an Array
        named count=1
            NAMEDARGUMENTS : a Directory
    method 'unknown' forward to (.myfooclass) message (name) arguments (arguments) namedArguments (namedArguments)
        positional count=1 size=4
            3 : 3
        named count=1
            A5 : 5


r = .myclass~foo(1, 2, 3){}
    method 'unknown'
        positional count=2 size=2
            1 : FOO
            2 : an Array
        named count=1
            NAMEDARGUMENTS : The NIL object
    method 'unknown' forward to (.myfooclass) message (name) arguments (arguments) namedArguments (namedArguments)
        positional count=4 size=4
            1 : 1
            2 : 2
            3 : 3
            4 : a RexxBlock
        named count=0


r = .myclass~foo(1, 2, a3:3){}
    method 'unknown'
        positional count=2 size=2
            1 : FOO
            2 : an Array
        named count=1
            NAMEDARGUMENTS : a Directory
    method 'unknown' forward to (.myfooclass) message (name) arguments (arguments) namedArguments (namedArguments)
        positional count=3 size=3
            1 : 1
            2 : 2
            3 : a RexxBlock
        named count=1
            A3 : 3


r = .myclass~foo(1, a2:2, a3:3){}
    method 'unknown'
        positional count=2 size=2
            1 : FOO
            2 : an Array
        named count=1
            NAMEDARGUMENTS : a Directory
    method 'unknown' forward to (.myfooclass) message (name) arguments (arguments) namedArguments (namedArguments)
        positional count=2 size=2
            1 : 1
            2 : a RexxBlock
        named count=2
            A2 : 2
            A3 : 3


********************************************************************************
*                            Run a floating method                             *
********************************************************************************

r = .myclass~myrun(.methods["MYFLOATINGMETHOD"])
    positional count=0 size=0
    named count=0


r = .myclass~myrun(.methods["MYFLOATINGMETHOD"], "I")
    positional count=0 size=0
    named count=0


r = .myclass~myrun(.methods["MYFLOATINGMETHOD"], "I", 1, 2, 3)
    positional count=3 size=3
        1 : 1
        2 : 2
        3 : 3
    named count=0


r = .myclass~myrun(.methods["MYFLOATINGMETHOD"], "I", 1, 2, a3:3)
    positional count=2 size=2
        1 : 1
        2 : 2
    named count=1
        A3 : 3


r = .myclass~myrun(.methods["MYFLOATINGMETHOD"], "I", 1, a2:2, a3:3)
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


r = .myclass~myrun(.methods["MYFLOATINGMETHOD"], "I", 1, a2:(2*5/4)**5, a3:.array~new(3,3))
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 97.65625
        A3 : an Array


r = .myclass~myrun(.methods["MYFLOATINGMETHOD"], "I", , , 3, ,)
    positional count=1 size=5
        3 : 3
    named count=0


r = .myclass~myrun(.methods["MYFLOATINGMETHOD"], "I", , , 3, , a5:5)
    positional count=1 size=4
        3 : 3
    named count=1
        A5 : 5


r = .myclass~myrun(.methods["MYFLOATINGMETHOD"], "I", 1, 2, a3:3, namedArguments:.directory~of(a2:2, a3:3))
    positional count=2 size=2
        1 : 1
        2 : 2
    named count=2
        A3 : 3
        NAMEDARGUMENTS : a Directory


r = .myclass~myrun(.methods["MYFLOATINGMETHOD"], "I", 1, 2, 3){}
    positional count=4 size=4
        1 : 1
        2 : 2
        3 : 3
        4 : a RexxBlock
    named count=0


r = .myclass~myrun(.methods["MYFLOATINGMETHOD"], "I", 1, 2, a3:3){}
    positional count=3 size=3
        1 : 1
        2 : 2
        3 : a RexxBlock
    named count=1
        A3 : 3


r = .myclass~myrun(.methods["MYFLOATINGMETHOD"], "I", 1, a2:2, a3:3){}
    positional count=2 size=2
        1 : 1
        2 : a RexxBlock
    named count=2
        A2 : 2
        A3 : 3


r = .myclass~myrun(.methods["MYFLOATINGMETHOD"], "A", .array~new)
    positional count=0 size=0
    named count=0


r = .myclass~myrun(.methods["MYFLOATINGMETHOD"], "A", (1, 2, 3))
    positional count=3 size=3
        1 : 1
        2 : 2
        3 : 3
    named count=0


r = .myclass~myrun(.methods["MYFLOATINGMETHOD"], "A", (1, 2), namedArguments:.directory~of(a3:3))
    positional count=2 size=2
        1 : 1
        2 : 2
    named count=1
        A3 : 3


r = .myclass~myrun(.methods["MYFLOATINGMETHOD"], "A", .array~of(1), namedArguments:.directory~of(a2:2, a3:3))
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


r = .myclass~myrun(.methods["MYFLOATINGMETHOD"], "A", .array~of(1), namedArguments:.directory~of(a2:(2*5/4)**5, a3:.array~new(3,3)))
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 97.65625
        A3 : an Array


r = .myclass~myrun(.methods["MYFLOATINGMETHOD"], "A", ( , , 3, ,))
    positional count=1 size=5
        3 : 3
    named count=0


r = .myclass~myrun(.methods["MYFLOATINGMETHOD"], "A", ( , , 3, ,), namedArguments:.directory~of(a5:5))
    positional count=1 size=5
        3 : 3
    named count=1
        A5 : 5


********************************************************************************
*                         Call a method using sendWith                         *
********************************************************************************

r = .myclass~sendWith("mymethod", .array~new)
    positional count=0 size=0
    named count=0


r = .myclass~sendWith("mymethod", (1, 2, 3))
    positional count=3 size=3
        1 : 1
        2 : 2
        3 : 3
    named count=0


r = .myclass~sendWith("mymethod", (1, 2), namedArguments:.directory~of(a3:3))
    positional count=2 size=2
        1 : 1
        2 : 2
    named count=1
        A3 : 3


r = .myclass~sendWith("mymethod", .array~of(1), namedArguments:.directory~of(a2:2, a3:3))
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


r = .myclass~sendWith("mymethod", .array~of(1), namedArguments:.directory~of(a2:(2*5/4)**5, a3:.array~new(3,3)))
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 97.65625
        A3 : an Array


r = .myclass~sendWith("mymethod", ( , , 3, ,))
    positional count=1 size=5
        3 : 3
    named count=0


r = .myclass~sendWith("mymethod", ( , , 3, ,), namedArguments:.directory~of(a5:5))
    positional count=1 size=5
        3 : 3
    named count=1
        A5 : 5


r = .myclass~sendWith("mymethod", (1, 2, 3, {}))
    positional count=4 size=4
        1 : 1
        2 : 2
        3 : 3
        4 : a RexxBlock
    named count=0


r = .myclass~sendWith("mymethod", (1, 2, {}), namedArguments:.directory~of(a3:3))
    positional count=3 size=3
        1 : 1
        2 : 2
        3 : a RexxBlock
    named count=1
        A3 : 3


r = .myclass~sendWith("mymethod", (1, {}), namedArguments:.directory~of(a2:2, a3:3))
    positional count=2 size=2
        1 : 1
        2 : a RexxBlock
    named count=2
        A2 : 2
        A3 : 3


********************************************************************************
*                             Change the arguments                             *
********************************************************************************

Initial arguments
    positional count=0 size=0
    named count=0
INTERPRET call sayArg .context
    positional count=0 size=0
    named count=0

.context~setArgs(.array~of(1,2))
    positional count=2 size=2
        1 : 1
        2 : 2
    named count=0
INTERPRET call sayArg .context
    positional count=2 size=2
        1 : 1
        2 : 2
    named count=0
use arg a1, a2; say "a1="a1 "a2="a2
a1=1 a2=2
INTERPRET say "a1="arg(1) "a2="arg(2)
a1=1 a2=2

.context~setArgs(.array~of(1,2), namedArguments:.directory~of(n1:1, n2:2))
    positional count=2 size=2
        1 : 1
        2 : 2
    named count=2
        N1 : 1
        N2 : 2
INTERPRET call sayArg .context
    positional count=2 size=2
        1 : 1
        2 : 2
    named count=2
        N1 : 1
        N2 : 2
use arg a1, a2; say "a1="a1 "a2="a2
a1=1 a2=2
INTERPRET say "a1="arg(1) "a2="arg(2)
a1=1 a2=2
use named arg n1, n2; say "n1="n1 "n2="n2
n1=1 n2=2


.myclass~reply(.array~of(1, 2), namedArguments:.directory~of(n1:1, n2:2))
    On entry in the method
    positional count=1 size=1
        1 : an Array
    named count=1
        NAMEDARGUMENTS : a Directory

    After setArgs
    positional count=2 size=2
        1 : 1
        2 : 2
    named count=2
        N1 : 1
        N2 : 2
    
On entry in the thread (migrated arguments)

    positional count=2 size=2
        1 : 1
        2 : 2
    named count=2
        N1 : 1
        N2 : 2
    After setArgs in thread
    positional count=3 size=3
        1 : 1
        2 : 2
        3 : 3
    named count=3
        N1 : 1
        N2 : 2
        N3 : 3


********************************************************************************
*                                 Call a block                                 *
********************************************************************************

{call sayArg .context}~rawExecutable~call
    positional count=0 size=0
    named count=0


{call sayArg .context}~rawExecutable~call()
    positional count=0 size=0
    named count=0


{call sayArg .context}~rawExecutable~call(1, 2, 3)
    positional count=3 size=3
        1 : 1
        2 : 2
        3 : 3
    named count=0


{call sayArg .context}~rawExecutable~call(1, 2, a3:3)
    positional count=2 size=2
        1 : 1
        2 : 2
    named count=1
        A3 : 3


{call sayArg .context}~rawExecutable~call(1, a2:2, a3:3)
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 2
        A3 : 3


{call sayArg .context}~rawExecutable~call(1, a2:(2*5/4)**5, a3:.array~new(3,3))
    positional count=1 size=1
        1 : 1
    named count=2
        A2 : 97.65625
        A3 : an Array


{call sayArg .context}~rawExecutable~call( , , 3, ,)
    positional count=1 size=5
        3 : 3
    named count=0


{call sayArg .context}~rawExecutable~call( , , 3, , a5:5)
    positional count=1 size=4
        3 : 3
    named count=1
        A5 : 5


{call sayArg .context}~rawExecutable~call(1, 2, 3){}
    positional count=4 size=4
        1 : 1
        2 : 2
        3 : 3
        4 : a RexxBlock
    named count=0


{call sayArg .context}~rawExecutable~call(1, 2, a3:3){}
    positional count=3 size=3
        1 : 1
        2 : 2
        3 : a RexxBlock
    named count=1
        A3 : 3


{call sayArg .context}~rawExecutable~call(1, a2:2, a3:3){}
    positional count=2 size=2
        1 : 1
        2 : a RexxBlock
    named count=2
        A2 : 2
        A3 : 3


********************************************************************************
*                           Trapped expected errors                            *
********************************************************************************

call myprocedure , , 3, , a5:5,
    positional count=1 size=4
        3 : 3
    named count=1
        A5 : 5
Expected: Should raise an error because of the trailing comma (TODO)


call myroutine , , 3, , a5:5,
    positional count=1 size=4
        3 : 3
    named count=1
        A5 : 5
Expected: Should raise an error because of the trailing comma (TODO)


call myprocedure .envSymbol:1
    [trapped] Incorrect expression detected at ":"
    [trapped] Code= 35.1
Expected: Error 31.003 Variable symbol must not start with a '.'; found '.envSymbol'


call myprocedure 3:1
    [trapped] Incorrect expression detected at ":"
    [trapped] Code= 35.1
Expected: Error 35.1:  Incorrect expression detected at ":"


call myprocedure 1, a2:2, 3
    [trapped] Variable symbol must not start with a number; found "3"
    [trapped] Code= 31.2
Expected: Error 31.2:  Variable symbol must not start with a number; found "3


call myprocedure 1.2:1
    [trapped] Incorrect expression detected at ":"
    [trapped] Code= 35.1
Expected: Error 35.1: Incorrect expression detected at ":"


call myprocedure 1.2.3:1
    [trapped] Incorrect expression detected at ":"
    [trapped] Code= 35.1
Expected: Error 35.1: Incorrect expression detected at ":"


call myprocedure 1, a2:2, a3:
    [trapped] Named argument: expected expression after colon
    [trapped] Code= 35.900
Expected: Error 35.900:  Named argument: expected expression after colon


call myprocedure a1:1, a1:2 Error 35.900:  Named argument: the name "A1" is passed more than once
    [trapped] Named argument: The name "A1" is passed more than once
    [trapped] Code= 35.900


call myprocedure a1:1, , a3:3
    [trapped] Named argument: expected symbol followed by colon
    [trapped] Code= 35.900
Expected: Error 35.900: Named argument: expected symbol followed by colon


call myprocedure instance~method:1
    [trapped] Symbol expected after superclass colon (:)
    [trapped] Code= 20.917
Expected: Error 20.917: Symbol expected after superclass colon (:)


r = .myclass~sendWith("mymethod")
    [trapped] Missing positional argument in method; argument 2 is required
    [trapped] Code= 93.903
Expected: Error 93.903: Missing argument in method; argument 2 is required


r = .myclass~sendWith("mymethod", .object /* not an array */, namedArguments:.directory~of(a3:3))
    [trapped] positional argument 2 must have a single-dimensional array value; found "The Object class"
    [trapped] Code= 88.913
Expected: Error 88.913: positional argument 2 must have a single-dimensional array value; found "The Object class"


r = .myclass~sendWith("mymethod", (1, 2), namedArguments: "not a directory")
    [trapped] SENDWITH namedArguments must be a directory or NIL
    [trapped] Code= 98.900
Expected: Error 98.900: sendWith: The value of NAMEDARGUMENTS must be a directory or NIL


{}~rawExecutable~callwith(.array~of(), n:.directory~of(""))
    [trapped] Expected a symbol for the named argument name; found ""
    [trapped] Code= 20.900
Expected: Error 20.900: Expected a symbol for the named argument name; found ""


{}~rawExecutable~callwith(.array~of(), n:.directory~of("1"))
    [trapped] Expected a symbol for the named argument name; found "1"
    [trapped] Code= 20.900
Expected: Error 20.900: Expected a symbol for the named argument name; found "1"


{}~rawExecutable~callwith(.array~of(), n:.directory~of("a 1"))
    [trapped] Expected a symbol for the named argument name; found "a 1"
    [trapped] Code= 20.900
Expected: Error 20.900: Expected a symbol for the named argument name; found "a 1"


{}~rawExecutable~callwith(.array~of(), n:.directory~of(".a"))
    [trapped] Expected a symbol for the named argument name; found ".a"
    [trapped] Code= 20.900
Expected: Error 20.900: Expected a symbol for the named argument name; found ".a"


m = .method~new("", 'forward message "mymethod" namedArguments continue')
    [trapped] Incorrect expression detected at "CONTINUE"
    [trapped] Code= 35.1
Expected: Error 35.1:    Incorrect expression detected at "CONTINUE"


m = .method~new("", 'forward message "mymethod" namedArguments')
    [trapped] Missing expression following NAMEDARGUMENTS keyword of a FORWARD instruction
    [trapped] Code= 35.900
Expected: Error 35.900:  Missing expression following NAMEDARGUMENTS keyword of a FORWARD instruction


m = .method~new("", 'forward message "mymethod" array ( 10, 20, 30, a1:40, a2:50 ) namedArguments (.directory~of(a1:1, a2:2) continue')
    [trapped] Duplicate [NAMED]ARGUMENTS or ARRAY keyword found
    [trapped] Code= 25.918
Expected: Error 25.918: Duplicate [NAMED]ARGUMENTS or ARRAY keyword found


r = .myclass~forwardNamedArgumentsNotDirectory
    forward message "mymethod" namedArguments ("not a directory") continue
    [trapped] FORWARD namedArguments must be a directory or NIL
    [trapped] Code= 98.900
Expected: Error 98.900: FORWARD: The value of 'NAMEDARGUMENTS' must be a directory or NIL


r = .myclass~myrun(.methods["MYFLOATINGMETHOD"], "A", (1, 2, 3)){}
    [trapped] Too many positional arguments in invocation of method; 3 expected
    [trapped] Code= 93.902
Expected: Error 93.902: Too many positional arguments in invocation of method; 3 expected


r = .myclass~myrun(.methods["MYFLOATINGMETHOD"], "A", (1, 2), namedArguments:.directory~of(a3:3)){}
    [trapped] Too many positional arguments in invocation of method; 3 expected
    [trapped] Code= 93.902
Expected: Error 93.902: Too many positional arguments in invocation of method; 3 expected


r = .myclass~myrun(.methods["MYFLOATINGMETHOD"], "A", .array~of(1), namedArguments:.directory~of(a2:2, a3:3)){}
    [trapped] Too many positional arguments in invocation of method; 3 expected
    [trapped] Code= 93.902
Expected: Error 93.902: Too many positional arguments in invocation of method; 3 expected


call useNamed_EnvironmentSymbolNotAllowed
    use named arg .envSymbol
    [trapped] Variable symbol must not start with a "."; found ".ENVSYMBOL"
    [trapped] Code= 31.3
Expected: Error 31.3: Variable symbol must not start with a "."; found ".ENVSYMBOL"


call useNamed_MessageTermNotAllowed
    use named arg instance~method
    [trapped] The USE NAMED instruction requires a comma-separated list of variable symbols
    [trapped] Code= 87.2
Expected: Error 87.2: The USE NAMED instruction requires a comma-separated list of variable symbols


call useNamed_SkippedArgumentNotAllowed
    use named arg n1,,n3
    [trapped] Skipped variables are not allowed by the USE NAMED instruction
    [trapped] Code= 87.1
Expected: Error 87.1: Skipped variables are not allowed by the USE NAMED instruction


call useStrictZeroNamed a1:1
    positional count=0 size=0
    named count=1
        A1 : 1
    use strict named arg
    [trapped] Too many named arguments in invocation of USESTRICTZERONAMED; maximum expected is 0
    [trapped] Code= 40.4
Expected: Error 40.4: Too many named arguments in invocation of USESTRICTZERONAMED; maximum expected is 0


call useStrictOneNamed_NoDefault
    positional count=0 size=0
    named count=0
    use strict named arg a1
    [trapped] Not enough named arguments in invocation of USESTRICTONENAMED_NODEFAULT; minimum expected is 1
    [trapped] Code= 40.3
Expected: Error 40.3: Not enough named arguments in invocation of USESTRICTONENAMED_NODEFAULT; minimum expected is 1


call useStrictOneNamed_NoDefault b1:1
    positional count=0 size=0
    named count=1
        B1 : 1
    use strict named arg a1
    [trapped] named argument B1 is not an expected argument name
    [trapped] Code= 88.917
Expected: Error 88.917: named argument B1 is not an expected argument name


call useStrictOneNamed_NoDefault b1:1, b2:2
    positional count=0 size=0
    named count=2
        B1 : 1
        B2 : 2
    use strict named arg a1
    [trapped] Too many named arguments in invocation of USESTRICTONENAMED_NODEFAULT; maximum expected is 1
    [trapped] Code= 40.4
Expected: Error 40.4: Too many named arguments in invocation of USESTRICTONENAMED_NODEFAULT; maximum expected is 1


call useStrictOneNamed_WithDefault b2:2
    positional count=0 size=0
    named count=1
        B2 : 2
    use strict named arg a1=1
    [trapped] named argument B2 is not an expected argument name
    [trapped] Code= 88.917
Expected: Error 88.917: named argument B2 is not an expected argument name


call useStrictOneNamed_WithDefaultExpression b2:2
    positional count=0 size=0
    named count=1
        B2 : 2
    use strict named arg a1=(1+0)
    [trapped] named argument B2 is not an expected argument name
    [trapped] Code= 88.917
Expected: Error 88.917: named argument B2 is not an expected argument name


call useStrictAutoNamed_WithoutEllipse
    [trapped] STRICT AUTO requires the "..." argument marker at the end of the argument list
    [trapped] Code= 99.900
Expected: Error 99.900: STRICT AUTO requires the "..." argument marker at the end of the argument list


{use named arg n()}
    [trapped] Named argument minimum length must be a positive whole number
    [trapped] Code= 26.900
Expected: Error 26.900: Named argument minimum length must be a positive whole number


{use named arg n(0)}
    [trapped] Named argument minimum length must be a positive whole number
    [trapped] Code= 26.900
Expected: Error 26.900: Named argument minimum length must be a positive whole number


{use named arg command, commands(7)}
    [trapped] The named argument names are not unique, or their abbreviation is not distinctive enough
    [trapped] Code= 99.900
Expected: Error 99.900: The named argument names are not unique, or their abbreviation is not distinctive enough


{use named arg command(1), commands(7)}
    [trapped] The named argument names are not unique, or their abbreviation is not distinctive enough
    [trapped] Code= 99.900
Expected: Error 99.900: The named argument names are not unique, or their abbreviation is not distinctive enough


{use named arg n, n}
    [trapped] The named argument names are not unique, or their abbreviation is not distinctive enough
    [trapped] Code= 99.900
Expected: Error 99.900: The named argument names are not unique, or their abbreviation is not distinctive enough


{use named arg item(1), index(1)}
    [trapped] The named argument names are not unique, or their abbreviation is not distinctive enough
    [trapped] Code= 99.900
Expected: Error 99.900: The named argument names are not unique, or their abbreviation is not distinctive enough


.context~setArgs
    [trapped] Missing positional argument in method; argument 1 is required
    [trapped] Code= 93.903
Expected: Error 93.903: Missing positional argument in method; argument 1 is required


.context~setArgs(.nil)
    [trapped] positional argument 1 must have a single-dimensional array value; found "The NIL object"
    [trapped] Code= 88.913
Expected: Error 88.913: positional argument 1 must have a single-dimensional array value; found "The NIL object"


.context~setArgs(,)
    [trapped] Too many positional arguments in invocation of method; 1 expected
    [trapped] Code= 93.902
Expected: Error 93.902: Too many positional arguments in invocation of method; 1 expected


.context~setArgs(,,)
    [trapped] Too many positional arguments in invocation of method; 1 expected
    [trapped] Code= 93.902
Expected: Error 93.902: Too many positional arguments in invocation of method; 1 expected


.context~setArgs(.array~of(1), .directory~of(n1:1))
    [trapped] Too many positional arguments in invocation of method; 1 expected
    [trapped] Code= 93.902
Expected: Error 93.902: Too many positional arguments in invocation of method; 1 expected


.context~setArgs(.array~of(1), namedArguments:"not a directory")
    [trapped] SETARGS namedArguments must be a directory or NIL
    [trapped] Code= 98.900
Expected: Error 98.900: SETARGS namedArguments must be a directory or NIL


.context~setArgs(.array~of(1), NOT_namedArguments:.directory~of(n1:1))
    [trapped] named argument NOT_NAMEDARGUMENTS is not an expected argument name
    [trapped] Code= 88.917
Expected: Error 88.917: named argument NOT_NAMEDARGUMENTS is not an expected argument name


