
-- ----------------------------------------------------------------------------
-- Overview of dataflows
-- ----------------------------------------------------------------------------
--   1          2     3       4
-- +----------+-----+-------+------+
-- | previous | tag | index | item |
-- +----------+-----+-------+------+
--    ^
--    |  +----------+-----+-------+------+
--    +--| previous | tag | index | item |
--       +----------+-----+-------+------+
--          ^
--          |
--          +-- etc...


-- A dataflow is created from a tag, a pair of (item, index), and a previous dataflow (which can be .nil).
-- Representation : the strings (except the strings numbers) are surrounded by quotes.
   df1 = .dataflow~create(.nil, "tag1", "item1", "index1")
   say df1 -- by default, all the fields are included in the representation string.
tag1:'index1','item1'
   say df1~makeString(2) -- show tag
tag1:
   say df1~makeString(23) -- show tag, index
tag1:'index1'
   say df1~makeString(234) -- show tag, index, item
tag1:'index1','item1'


-- A dataflow can be linked to a previous dataflow.
-- Representation : the dataflows are separated by |
   df2 = .dataflow~create(df1, "tag2", "item2", "index2")
   say df2
tag1:'index1','item1' | tag2:'index2','item2'


-- Representation : the objects other than strings are surrounded by round brackets.
   df3 = .dataflow~create(df2, "tag3", .mutableBuffer~new(22222), .file~new("my file"))
   say df3
tag1:'index1','item1' | tag2:'index2','item2' | tag3:(my file),(22222)


-- showPool=.true : when an item (other than a number) appears several times then it is replaced by a reference to the first occurence of the item.
-- The references are named v1, v2, etc...
-- The operator == is used for the comparison.
-- Example :
-- "a" and .file~new("my file" are entered in the pool, because there is more than one occurence of them.
-- .mutableBuffer~new(22222) is not entered in the pool, because two distincts instances are never equal, even if their string representation is the same.
   df4 = .dataflow~create(df3, "tag4", .file~new("my file"), "a")
   df5 = .dataflow~create(df4, "tag5", .mutableBuffer~new(22222), "a")
   say df5 ; say df5~makeString(1234, .true)
tag1:'index1','item1' | tag2:'index2','item2' | tag3:(my file),(22222) | tag4:'a',(my file) | tag5:'a',(22222)
tag1:'index1','item1' | tag2:'index2','item2' | tag3:v1=(my file),(22222) | tag4:v2='a',v1 | tag5:v2,(22222)


-- ----------------------------------------------------------------------------
-- Overview of the sources supported by pipes
-- ----------------------------------------------------------------------------

-- Any object can be a source of pipe.
-- When the object does not support the method ~supplier then it's injected as-is.
-- Its associated index is always 1.
   "hello"~pipe(.console)
1 : 'hello'


-- By default, the dataflows are not shown, use the option dataflow.
-- dataflow is interpreted as the string "DATAFLOW" because no value assigned.
-- If dataflow was a variable with an assigned value, then you should use explicitely the string "dataflow" (caseless).
-- Other options supported by .console : index, item
   "hello"~pipe(.console dataflow)
source:1,'hello' 


-- A collection can be a source of pipe : each item of the collection is injected in the pipe.
-- The indexes are those of the collection.
   .array~of(10,20,30)~pipe(.console)
1 : 10
2 : 20
3 : 30
   .array~of(10,20,30)~pipe(.console dataflow)
source:1,10 
source:2,20 
source:3,30 


-- A coactivty can be a source of pipe : each yielded item is injected in the pipe.
-- Example :
-- This coactivity yields two results.
-- The hello outputs are not in the pipeline flow (not displayed by the .console).
   {::coactivity echo hello ; .yield["a"] ; say hello ; .yield["b"] }~doer~pipe(.console)
HELLO
1 : 'a'
HELLO
2 : 'b'
   {::coactivity echo hello ; .yield["a"] ; say hello ; .yield["b"] }~doer~pipe(.console dataflow)
HELLO
source:1,'a' 
HELLO
source:2,'b' 


-- ----------------------------------------------------------------------------
-- Overview of the pipe operators.
-- Reminder of the precedence (highest at the top) :
-- (message send)         : ~ ~~ (not overloaded for pipes)
-- (prefix operators)     : + - \ (not overloaded for pipes)
-- (power)                : ** (not overloaded for pipes)
-- (multiply and divide)  : * / % // (not overloaded for pipes)
-- (add and subtract)     : + - (not overloaded for pipes)
-- (blank) || (abuttal)   : (blank) is overloaded for adding options.
-- (comparison operators) : > >> are overloaded for pipes, the rest is not used : = < == << \= >< <> \> \< \== \>> \<< >= >>= <= <<=
-- (and operator)         : & (not overloaded for pipes).
-- (or, exclusive or)     : | is overloaded, && is not used.
-- ----------------------------------------------------------------------------

-- stage1 | stage2
-- stage1 > stage2
-- | and > share the same implementation...
-- (they connect the primary output of stage1 to the primary input of stage2)
   "hello"~pipe(.left[2] | .upper | .console)
1 : 'HE'

-- Same pipeline as previous, but with methods only
   "hello"~pipe(    (.left~new(2) ~append(.upper~new))    ~append(.console~new)    )
1 : 'HE'


-- ...but | and > don't have the same precedence ! No impact here.
   "hello"~pipe(.left[2] | .upper > .console)
1 : 'HE'

-- Same pipeline as previous, but with methods only
   "hello"~pipe(    .left~new(2) ~append(   .upper~new ~append(.console~new)    )    )
1 : 'HE'


-- stage1 >> stage2
-- Connects the secondary output of stage1 to the primary input of stage2
-- Here, the result is not what you expect. You want "LLO", you get "he"...
-- This is because .console is the primary follower of .left, not the primary
-- follower of .upper.
-- Why ? because the pipestage returned by .left[2] >> .upper is .left,
-- and .console is attached to the pipestage found by starting from .left
-- and walking through the 'next' references until a pipestage with no 'next'
-- is found. So .upper is not walked though, because it's a secondary follower.
   "hello"~pipe(.left[2] >> .upper | .console)
1 : 'he'

-- Same pipeline as previous, but with methods only
   "hello"~pipe(    (.left~new(2) ~appendSecondary(.upper~new))    ~append(.console~new)    )
1 : 'he'


-- ...You need additional parentheses to get the expected behavior.
-- Here, .console is the primary follower of .upper.
   "hello"~pipe(.left[2] >> ( .upper | .console ) )
1 : 'LLO'

-- Same pipeline as previous, but with methods only
   "hello"~pipe(    .left~new(2) ~appendSecondary(    .upper~new ~append(.console~new)    )    )
1 : 'LLO'


-- ----------------------------------------------------------------------------
-- Overview of the sorting facilities
-- ----------------------------------------------------------------------------

-- A collection can be sorted by item (default)
   .array~of(b, a, c)~pipe(.sort byItem | .console)
2 : 'A'
1 : 'B'
3 : 'C'


-- ...or by index
   .array~of(b, a, c)~pipe(.sort byIndex | .console)
1 : 'B'
2 : 'A'
3 : 'C'


-- ...ascending (default)
-- The order of options is important : a byItem option is impacted only by the preceding options
-- This is because several byItem options can be specified, and a sort is made for each.
   .array~of(b, a, c)~pipe(.sort ascending byItem | .console)
2 : 'A'
1 : 'B'
3 : 'C'


-- ...descending
   .array~of(b, a, c)~pipe(.sort descending byItem | .console)
3 : 'C'
1 : 'B'
2 : 'A'


-- ...by index descending
-- The order of options is important : a byIndex option is impacted only by the preceding options.
-- This is because several byIndex options can be specified, and a sort is made for each.
   .array~of(b, a, c)~pipe(.sort descending byIndex | .console)
3 : 'C'
2 : 'A'
1 : 'B'


-- ...caseless (stable by default)
   .array~of("bb", "AA", "bB", "Aa", "Bb", "aA", "BB", "aa")~pipe(.sort caseless byItem | .console)
2 : 'AA'
4 : 'Aa'
6 : 'aA'
8 : 'aa'
1 : 'bb'
3 : 'bB'
5 : 'Bb'
7 : 'BB'


-- ...caseless quickSort (unstable)
-- No difference bewteen stable and unstable ? yes, see commit 6275 in interpreter/memory/setup.cpp :
--  // there have been some problems with the quick sort used as the default sort, so map everything
--  // to the stable sort.  The stable sort, in theory, uses more memory, but in practice, this is not true.
--  defineKernelMethod(CHAR_SORT         ,TheArrayBehaviour, CPPM(RexxArray::stableSortRexx), 0);
--  defineKernelMethod(CHAR_SORTWITH     ,TheArrayBehaviour, CPPM(RexxArray::stableSortWithRexx), 1);
--  defineKernelMethod(CHAR_STABLESORT   ,TheArrayBehaviour, CPPM(RexxArray::stableSortRexx), 0);
--  defineKernelMethod(CHAR_STABLESORTWITH ,TheArrayBehaviour, CPPM(RexxArray::stableSortWithRexx), 1);
   .array~of("bb", "AA", "bB", "Aa", "Bb", "aA", "BB", "aa")~pipe(.sort caseless quickSort byItem | .console)
2 : 'AA'
4 : 'Aa'
6 : 'aA'
8 : 'aa'
1 : 'bb'
3 : 'bB'
5 : 'Bb'
7 : 'BB'


-- Sort descending with a comparator.
-- The DescendingComparator use the default CompareTo, which is made on items.
   .array~of(b, a, c)~pipe(.sortWith[.DescendingComparator~new] | .console)
3 : 'C'
1 : 'B'
2 : 'A'


-- Sort by column with a comparator.
   .array~of("c:2", "b:2", "A:2", "c:1", "a:1", "B:1", "C:3")~pipe(,
       .sortWith[.InvertingComparator~new(.CaselessColumnComparator~new(3,1))] |,
       .sortWith[.CaselessColumnComparator~new(1,1)] |,
       .console,
       )
3 : 'A:2'
5 : 'a:1'
2 : 'b:2'
6 : 'B:1'
7 : 'C:3'
1 : 'c:2'
4 : 'c:1'


-- ----------------------------------------------------------------------------
-- Options available on any pipeStage : memorize
-- ----------------------------------------------------------------------------

   "aaaBBBcccDDDeee"~pipe(.reverse memorize | .console dataflow)
source:1,'aaaBBBcccDDDeee' | reverse:1,'eeeDDDcccBBBaaa' 


   "aaaBBBcccDDDeee"~pipe(.upper memorize | .console dataflow)
source:1,'aaaBBBcccDDDeee' | upper:1,'AAABBBCCCDDDEEE' 


   "aaaBBBcccDDDeee"~pipe(.lower memorize | .console dataflow)
source:1,'aaaBBBcccDDDeee' | lower:1,'aaabbbcccdddeee' 


   "aaaBBBcccDDDeee"~pipe(.changeStr["B", "b", 2] memorize | .console dataflow)
source:1,'aaaBBBcccDDDeee' | changeStr:1,'aaabbBcccDDDeee' 


   "aaaBBBcccDDDeee"~pipe(.delStr[4, 9] memorize | .console dataflow)
source:1,'aaaBBBcccDDDeee' | delStr:1,'aaaeee' 


   "aaaBBBcccDDDeee"~pipe(.left[3] memorize >> .console "secondary :" dataflow | .console "primary:" dataflow)
primary: source:1,'aaaBBBcccDDDeee' | left:1,'aaa' 
secondary : source:1,'aaaBBBcccDDDeee' | left:1,'BBBcccDDDeee' 


   "aaaBBBcccDDDeee"~pipe(.right[3] memorize >> .console "secondary :" dataflow | .console "primary:" dataflow)
primary: source:1,'aaaBBBcccDDDeee' | right:1,'eee' 
secondary : source:1,'aaaBBBcccDDDeee' | right:1,'aaaBBBcccDDD' 


   "aaaBBBcccDDDeee"~pipe(.insert["---", 3] memorize | .console dataflow)
source:1,'aaaBBBcccDDDeee' | insert:1,'aaa---BBBcccDDDeee' 


   "aaaBBBcccDDDeee"~pipe(.overlay["---", 3] memorize | .console dataflow)
source:1,'aaaBBBcccDDDeee' | overlay:1,'aa---BcccDDDeee' 


   "48656c6c6f"~pipe(.x2c memorize | .console dataflow)
source:1,'48656c6c6f' | x2c:1,'Hello' 


   .array~of("a", "", "b", , "c", , "", "d")~pipe(.dropNull memorize | .console dataflow)
source:1,v1='a' | dropNull:1,v1 
source:3,v1='b' | dropNull:3,v1 
source:5,v1='c' | dropNull:5,v1 
source:8,v1='d' | dropNull:8,v1 


   .array~of("header", 1, 2 ,3 , "footer")~pipe(,
       .drop first memorize >> .console "secondary of drop first :" dataflow |,
       .drop last memorize >> .console "secondary of drop last :" dataflow |,
       .console "primary:" dataflow) -- Remove header and footer
secondary of drop first : source:1,v1='header' | drop:1,v1 
primary: source:2,1 | drop:2,1 | drop:2,1 
primary: source:3,2 | drop:3,2 | drop:3,2 
primary: source:4,3 | drop:4,3 | drop:4,3 
secondary of drop last : source:5,v1='footer' | drop:5,v1 | drop:5,v1 


-- ----------------------------------------------------------------------------
-- .do and .inject pipeStages
-- ----------------------------------------------------------------------------

-- .do is action-oriented, whereas .inject is function-oriented.
-- Both support the same options.
-- .do {"echo" item} -- no implicit return, this is a command
-- .inject {"echo" item} -- implicit return, commands are disabled

-- Do something for each item (no returned value, so no value passed to .console).
   .array~of(1, , 2, , 3)~pipe(.do {say 'item='item 'dataflow='dataflow} | .console)
item=1 dataflow=source:1,1
item=2 dataflow=source:3,2
item=3 dataflow=source:5,3


-- Do something for each item (the returned result replaces the item's value).
-- Here, only one result is calculated for an item, so resultIndex is always 1.
   .array~of(1, , 2, , 3)~pipe(.do {return 2*item} memorize | .console)
1 : 2
3 : 4
5 : 6


-- Inject a value for each item (the returned value is injected after the input item).
   .array~of(1, , 2, , 3)~pipe(.inject after {item*10} memorize | .console dataflow)
source:1,1 | inject:1,1 
source:1,1 | inject:1,10 
source:3,2 | inject:1,2 
source:3,2 | inject:3,20 
source:5,3 | inject:1,3 
source:5,3 | inject:5,30 


-- Inject two values for each item (each item of the returned collection is written in the pipe).
-- Note the "iterateAfter" option : using this option, when the result of .inject is an object which
-- understands "supplier" then each pair (item, index) returned by the supplier is injected in the pipe.
   .array~of(1, , 2, , 3)~pipe(.inject after {.array~of(item*10, item*20)} iterateAfter memorize | .console dataflow)
source:1,1 | inject:1,1 
source:1,1 | inject:1,10 
source:1,1 | inject:2,20 
source:3,2 | inject:1,2 
source:3,2 | inject:1,20 
source:3,2 | inject:2,40 
source:5,3 | inject:1,3 
source:5,3 | inject:1,30 
source:5,3 | inject:2,60 


-- Each injected value can be used as input to inject a new value, recursively.
-- The default order is depth-first.
-- If the recursion is infinite, must specify a limit (here 0, 1 and 2).
-- The options 'before' and 'after' are not used, so the initial item is discarded.
   .array~of(1, , 2, , 3)~pipe(.inject {item*10} recursive.0 | .console dataflow "item =" item)
source:1,1 item = 10 
source:3,2 item = 20 
source:5,3 item = 30 
   .array~of(1, , 2, , 3)~pipe(.inject {item*20} recursive.1 | .console dataflow "item =" item)
source:1,1 item = 20 
source:1,1 item = 400 
source:3,2 item = 40 
source:3,2 item = 800 
source:5,3 item = 60 
source:5,3 item = 1200 
   .array~of(1, , 2, , 3)~pipe(.inject {item*30} recursive.2 | .console dataflow "item =" item)
source:1,1 item = 30 
source:1,1 item = 900 
source:1,1 item = 27000 
source:3,2 item = 60 
source:3,2 item = 1800 
source:3,2 item = 54000 
source:5,3 item = 90 
source:5,3 item = 2700 
source:5,3 item = 81000 


-- Same as previous example, but here, the recursive.memorize option is used.
-- The dataflow is like a call stack.
-- Ex : the last line is
-- source:5,3 | inject:1,90 | inject:1,2700 | inject:1,81000 item = 81000 
-- The item at index 5 in input array has injected 3 "inject" dataflows by recursion.
   .array~of(1, , 2, , 3)~pipe(.inject {item*10} recursive.0.memorize | .console dataflow "item =" item)
source:1,1 | inject:1,10 item = 10 
source:3,2 | inject:3,20 item = 20 
source:5,3 | inject:5,30 item = 30 
   .array~of(1, , 2, , 3)~pipe(.inject {item*20} recursive.1.memorize | .console dataflow "item =" item)
source:1,1 | inject:1,20 item = 20 
source:1,1 | inject:1,20 | inject:1,400 item = 400 
source:3,2 | inject:3,40 item = 40 
source:3,2 | inject:3,40 | inject:3,800 item = 800 
source:5,3 | inject:5,60 item = 60 
source:5,3 | inject:5,60 | inject:5,1200 item = 1200 
   .array~of(1, , 2, , 3)~pipe(.inject {item*30} recursive.2.memorize | .console dataflow "item =" item)
source:1,1 | inject:1,30 item = 30 
source:1,1 | inject:1,30 | inject:1,900 item = 900 
source:1,1 | inject:1,30 | inject:1,900 | inject:1,27000 item = 27000 
source:3,2 | inject:3,60 item = 60 
source:3,2 | inject:3,60 | inject:3,1800 item = 1800 
source:3,2 | inject:3,60 | inject:3,1800 | inject:3,54000 item = 54000 
source:5,3 | inject:5,90 item = 90 
source:5,3 | inject:5,90 | inject:5,2700 item = 2700 
source:5,3 | inject:5,90 | inject:5,2700 | inject:5,81000 item = 81000 


-- Factorial, no value injected for -1
   .array~of(-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9)~pipe(.inject {
       use arg n
       if n < 0 then return
       if n == 0 then return 1
       return n * .context~executable~call(n - 1)} | .console dataflow item)
source:2,0 1 
source:3,1 1 
source:4,2 2 
source:5,3 6 
source:6,4 24 
source:7,5 120 
source:8,6 720 
source:9,7 5040 
source:10,8 40320 
source:11,9 362880 


-- Another illustration of the "iterateAfter" option.
   10~pipe(.inject {item~times} | .console)
1 : [1,2,3,4,5,6,7,8,9,10]
   10~pipe(.inject {item~times} iterateAfter | .console)
1 : 1
2 : 2
3 : 3
4 : 4
5 : 5
6 : 6
7 : 7
8 : 8
9 : 9
10 : 10
   10~pipe(.inject {item~times.generate} | .console)
1 : (a Coactivity)
   10~pipe(.inject {item~times.generate} iterateAfter | .console)
1 : 1
2 : 2
3 : 3
4 : 4
5 : 5
6 : 6
7 : 7
8 : 8
9 : 9
10 : 10


-- Another illustration of the "iterateAfter" option.
-- In this example, the block passed to .inject returns another block whose doer is a coactivity. 
-- The option "iterateAfter" force to check if the returned value has the "supplier" method.
-- If yes, then .inject iterates over the items returned by the supplier and sends them to the next pipeStage.
-- A block has no "supplier" method, but its doer may have one. This is the case in this example.
-- The method "hasMethod" has been redefined on RexxBlock to return .true if the doer has the method "supplier".
-- The method "supplier" has been defined on RexxBlock to forward to its doer.
-- Note :
-- The pipeStage .take is mandatory because the generator passed to .inject will generate an infinite sequence of numbers.
   1~pipe(.inject {{::closure.coactive expose item ; do forever ; .yield[item] ; item += 1 ; end}} iterateAfter | .take 10 | .console)
1 : 1
2 : 2
3 : 3
4 : 4
5 : 5
6 : 6
7 : 7
8 : 8
9 : 9
10 : 10


-- ----------------------------------------------------------------------------
-- Additional sorting facilities
-- ----------------------------------------------------------------------------

-- Select files in the installation directory, whose path contains "math" , sorted by file size.
-- The "length" message is sent to the item and the returned result is used as a key for sorting.
   .file~new(installdir())~listFiles~pipe(,
       .all["math"] caseless |,
       .sortWith[.MessageComparator~new("length/N")] |,
       .console dataflow {"length="item~length},
       )
source:247,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rxmath.exp) length=886 
source:248,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rxmath.lib) length=1728 
source:250,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rxmath.obj) length=22859 
source:122,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\NumberStringMath2.obj) length=53776 
source:121,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\NumberStringMath.obj) length=56014 
source:249,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rxmath.map) length=76043 
source:246,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rxmath.dll) length=139776 


-- Same as above, but simpler... You can sort directly by length, no need of MessageComparator
   .file~new(installdir())~listFiles~pipe(,
       .all["math"] caseless |,
       .sort {item~length} |,
       .console dataflow {"length="item~length},
       )
source:247,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rxmath.exp) length=886 
source:248,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rxmath.lib) length=1728 
source:250,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rxmath.obj) length=22859 
source:122,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\NumberStringMath2.obj) length=53776 
source:121,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\NumberStringMath.obj) length=56014 
source:249,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rxmath.map) length=76043 
source:246,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rxmath.dll) length=139776 


-- Sort by file size, then by file extension (with only one .sort pipestage)
   .file~new(installdir())~listFiles~pipe(,
       .all["math"] caseless |,
       .sort {item~length} {filespec('e', item~name)} |,
       .console dataflow {"length="item~length},
       )
source:246,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rxmath.dll) length=139776 
source:247,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rxmath.exp) length=886 
source:248,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rxmath.lib) length=1728 
source:249,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rxmath.map) length=76043 
source:250,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rxmath.obj) length=22859 
source:122,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\NumberStringMath2.obj) length=53776 
source:121,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\NumberStringMath.obj) length=56014 


-- ----------------------------------------------------------------------------
-- Various examples with collections and recursive processing
-- Illustration of the depthFirst vs breadthFirst options
-- ----------------------------------------------------------------------------

-- All instance methods of the context.
-- Notice that the default sort by item is useless here... Must sort by index.
   .context~instanceMethods~pipe(.sort byIndex | .console)
'' : (a Method)
' ' : (a Method)
'<>' : (a Method)
'=' : (a Method)
'==' : (a Method)
'><' : (a Method)
'ARGS' : (a Method)
'ARGS=' : (a Method)
'CLASS' : (a Method)
'CONDITION' : (a Method)
'COPY' : (a Method)
'COPY' : (a Method)
'DEFAULTNAME' : (a Method)
'DIGITS' : (a Method)
'DUMP2' : (a Method)
'EXECUTABLE' : (a Method)
'FORM' : (a Method)
'FUZZ' : (a Method)
'GENERATE' : (a Method)
'GENERATEI' : (a Method)
'HASHCODE' : (a Method)
'HASMETHOD' : (a Method)
'IDENTITYHASH' : (a Method)
'INIT' : (a Method)
'INSTANCEMETHOD' : (a Method)
'INSTANCEMETHODS' : (a Method)
'ISA' : (a Method)
'ISINSTANCEOF' : (a Method)
'LINE' : (a Method)
'OBJECTNAME' : (a Method)
'OBJECTNAME=' : (a Method)
'PACKAGE' : (a Method)
'PARENTCONTEXT' : (a Method)
'PIPE' : (a Method)
'PIPE.GENERATE' : (a Method)
'PIPEPROFILE' : (a Method)
'PIPEPROFILE.GENERATE' : (a Method)
'PP2' : (a Method)
'PPINDEX2' : (a Method)
'REQUEST' : (a Method)
'RS' : (a Method)
'RUN' : (a Method)
'SEND' : (a Method)
'SENDWITH' : (a Method)
'SETMETHOD' : (a Method)
'SETMETHOD1' : (a Method)
'START' : (a Method)
'STARTWITH' : (a Method)
'STRING' : (a Method)
'UNSETMETHOD' : (a Method)
'VARIABLES' : (a Method)
'\=' : (a Method)
'\==' : (a Method)
'||' : (a Method)


-- All private methods of the context.
   .context~instanceMethods~pipe(,
       .select {item~isPrivate} |,
       .sort byIndex |,
       .console,
       )
'RUN' : (a Method)
'SETMETHOD' : (a Method)
'UNSETMETHOD' : (a Method)


-- Instance methods of the specified classes (not including those inherited).
-- Each class is written in the pipeline, followed by the returned methods (option 'after').
   .array~of(.RexxContext, .Package, .Method)~pipe(,
       .inject after {item~instanceMethods(item~class)} iterateAfter memorize |,
       .sort byIndex {dataflow["source"]~item} |,
       .console dataflow,
       )
source:3,(The Method class) | inject:'!DEFINE_CLASS_METHOD',(a Method) 
source:3,(The Method class) | inject:'!DEFINE_METHODS',(a Method) 
source:3,(The Method class) | inject:'!REXXDEFINED',(a Method) 
source:3,v1=(The Method class) | inject:1,v1 
source:3,(The Method class) | inject:'<>',(a Method) 
source:3,(The Method class) | inject:'=',(a Method) 
source:3,(The Method class) | inject:'==',(a Method) 
source:3,(The Method class) | inject:'><',(a Method) 
source:3,(The Method class) | inject:'BASECLASS',(a Method) 
source:3,(The Method class) | inject:'DEFAULTNAME',(a Method) 
source:3,(The Method class) | inject:'DEFINE',(a Method) 
source:3,(The Method class) | inject:'DELETE',(a Method) 
source:3,(The Method class) | inject:'ENHANCED',(a Method) 
source:3,(The Method class) | inject:'HASHCODE',(a Method) 
source:3,(The Method class) | inject:'ID',(a Method) 
source:3,(The Method class) | inject:'INHERIT',(a Method) 
source:3,(The Method class) | inject:'ISSUBCLASSOF',(a Method) 
source:3,(The Method class) | inject:'METACLASS',(a Method) 
source:3,(The Method class) | inject:'METHOD',(a Method) 
source:3,(The Method class) | inject:'METHODS',(a Method) 
source:3,(The Method class) | inject:'MIXINCLASS',(a Method) 
source:3,(The Method class) | inject:'QUERYMIXINCLASS',(a Method) 
source:3,(The Method class) | inject:'SUBCLASS',(a Method) 
source:3,(The Method class) | inject:'SUBCLASSES',(a Method) 
source:3,(The Method class) | inject:'SUPERCLASS',(a Method) 
source:3,(The Method class) | inject:'SUPERCLASSES',(a Method) 
source:3,(The Method class) | inject:'UNINHERIT',(a Method) 
source:3,(The Method class) | inject:'\=',(a Method) 
source:3,(The Method class) | inject:'\==',(a Method) 
source:2,v1=(The Package class) | inject:1,v1 
source:2,(The Package class) | inject:'<>',(a Method) 
source:2,(The Package class) | inject:'=',(a Method) 
source:2,(The Package class) | inject:'==',(a Method) 
source:2,(The Package class) | inject:'><',(a Method) 
source:2,(The Package class) | inject:'BASECLASS',(a Method) 
source:2,(The Package class) | inject:'DEFAULTNAME',(a Method) 
source:2,(The Package class) | inject:'DEFINE',(a Method) 
source:2,(The Package class) | inject:'DELETE',(a Method) 
source:2,(The Package class) | inject:'ENHANCED',(a Method) 
source:2,(The Package class) | inject:'HASHCODE',(a Method) 
source:2,(The Package class) | inject:'ID',(a Method) 
source:2,(The Package class) | inject:'INHERIT',(a Method) 
source:2,(The Package class) | inject:'ISSUBCLASSOF',(a Method) 
source:2,(The Package class) | inject:'METACLASS',(a Method) 
source:2,(The Package class) | inject:'METHOD',(a Method) 
source:2,(The Package class) | inject:'METHODS',(a Method) 
source:2,(The Package class) | inject:'MIXINCLASS',(a Method) 
source:2,(The Package class) | inject:'QUERYMIXINCLASS',(a Method) 
source:2,(The Package class) | inject:'SUBCLASS',(a Method) 
source:2,(The Package class) | inject:'SUBCLASSES',(a Method) 
source:2,(The Package class) | inject:'SUPERCLASS',(a Method) 
source:2,(The Package class) | inject:'SUPERCLASSES',(a Method) 
source:2,(The Package class) | inject:'UNINHERIT',(a Method) 
source:2,(The Package class) | inject:'\=',(a Method) 
source:2,(The Package class) | inject:'\==',(a Method) 
source:1,v1=(The RexxContext class) | inject:1,v1 
source:1,(The RexxContext class) | inject:'<>',(a Method) 
source:1,(The RexxContext class) | inject:'=',(a Method) 
source:1,(The RexxContext class) | inject:'==',(a Method) 
source:1,(The RexxContext class) | inject:'><',(a Method) 
source:1,(The RexxContext class) | inject:'BASECLASS',(a Method) 
source:1,(The RexxContext class) | inject:'DEFAULTNAME',(a Method) 
source:1,(The RexxContext class) | inject:'DEFINE',(a Method) 
source:1,(The RexxContext class) | inject:'DELETE',(a Method) 
source:1,(The RexxContext class) | inject:'ENHANCED',(a Method) 
source:1,(The RexxContext class) | inject:'HASHCODE',(a Method) 
source:1,(The RexxContext class) | inject:'ID',(a Method) 
source:1,(The RexxContext class) | inject:'INHERIT',(a Method) 
source:1,(The RexxContext class) | inject:'ISSUBCLASSOF',(a Method) 
source:1,(The RexxContext class) | inject:'METACLASS',(a Method) 
source:1,(The RexxContext class) | inject:'METHOD',(a Method) 
source:1,(The RexxContext class) | inject:'METHODS',(a Method) 
source:1,(The RexxContext class) | inject:'MIXINCLASS',(a Method) 
source:1,(The RexxContext class) | inject:'QUERYMIXINCLASS',(a Method) 
source:1,(The RexxContext class) | inject:'SUBCLASS',(a Method) 
source:1,(The RexxContext class) | inject:'SUBCLASSES',(a Method) 
source:1,(The RexxContext class) | inject:'SUPERCLASS',(a Method) 
source:1,(The RexxContext class) | inject:'SUPERCLASSES',(a Method) 
source:1,(The RexxContext class) | inject:'UNINHERIT',(a Method) 
source:1,(The RexxContext class) | inject:'\=',(a Method) 
source:1,(The RexxContext class) | inject:'\==',(a Method) 


-- Methods (not inherited) of all the classes whose id starts with "R".
   .environment~pipe(,
       .select {item~isA(.class)} |,
       .select {item~id~caselessAbbrev('R') <> 0} |,
       .inject after {item~methods(item)} iterateAfter memorize |,
       .sort byIndex {dataflow["source"]~item} |,
       .console dataflow,
       )
source:'RELATION',v1=(The Relation class) | inject:1,v1 
source:'RELATION',(The Relation class) | inject:'ALLAT',(a Method) 
source:'RELATION',(The Relation class) | inject:'ALLINDEX',(a Method) 
source:'RELATION',(The Relation class) | inject:'ALLINDEXES',(a Method) 
source:'RELATION',(The Relation class) | inject:'ALLITEMS',(a Method) 
source:'RELATION',(The Relation class) | inject:'AT',(a Method) 
source:'RELATION',(The Relation class) | inject:'DIFFERENCE',(a Method) 
source:'RELATION',(The Relation class) | inject:'EMPTY',(a Method) 
source:'RELATION',(The Relation class) | inject:'HASINDEX',(a Method) 
source:'RELATION',(The Relation class) | inject:'HASITEM',(a Method) 
source:'RELATION',(The Relation class) | inject:'INDEX',(a Method) 
source:'RELATION',(The Relation class) | inject:'INTERSECTION',(a Method) 
source:'RELATION',(The Relation class) | inject:'ISEMPTY',(a Method) 
source:'RELATION',(The Relation class) | inject:'ITEMS',(a Method) 
source:'RELATION',(The Relation class) | inject:'MAKEARRAY',(a Method) 
source:'RELATION',(The Relation class) | inject:'PUT',(a Method) 
source:'RELATION',(The Relation class) | inject:'READOBJECT',(a Method) 
source:'RELATION',(The Relation class) | inject:'REMOVE',(a Method) 
source:'RELATION',(The Relation class) | inject:'REMOVEALL',(a Method) 
source:'RELATION',(The Relation class) | inject:'REMOVEITEM',(a Method) 
source:'RELATION',(The Relation class) | inject:'SUBSET',(a Method) 
source:'RELATION',(The Relation class) | inject:'SUPPLIER',(a Method) 
source:'RELATION',(The Relation class) | inject:'UNION',(a Method) 
source:'RELATION',(The Relation class) | inject:'WRITEOBJECT',(a Method) 
source:'RELATION',(The Relation class) | inject:'XOR',(a Method) 
source:'RELATION',(The Relation class) | inject:'[]',(a Method) 
source:'RELATION',(The Relation class) | inject:'[]=',(a Method) 
source:'REXXBLOCK',v1=(The RexxBlock class) | inject:1,v1 
source:'REXXBLOCK',(The RexxBlock class) | inject:'COPY',(a Method) 
source:'REXXBLOCK',(The RexxBlock class) | inject:'EXECUTABLE',(a Method) 
source:'REXXBLOCK',(The RexxBlock class) | inject:'EXECUTABLE=',(a Method) 
source:'REXXBLOCK',(The RexxBlock class) | inject:'KIND',(a Method) 
source:'REXXBLOCK',(The RexxBlock class) | inject:'PACKAGE',(a Method) 
source:'REXXBLOCK',(The RexxBlock class) | inject:'RAWEXECUTABLE',(a Method) 
source:'REXXBLOCK',(The RexxBlock class) | inject:'SOURCE',(a Method) 
source:'REXXBLOCK',(The RexxBlock class) | inject:'VARIABLES',(a Method) 
source:'REXXCONTEXT',v1=(The RexxContext class) | inject:1,v1 
source:'REXXCONTEXT',(The RexxContext class) | inject:'ARGS',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'ARGS=',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'CONDITION',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'COPY',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'DIGITS',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'EXECUTABLE',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'FORM',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'FUZZ',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'LINE',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'PACKAGE',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'PARENTCONTEXT',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'RS',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'VARIABLES',(a Method) 
source:'REXXQUEUE',v1=(The RexxQueue class) | inject:1,v1 
source:'REXXQUEUE',(The RexxQueue class) | inject:'DELETE',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'EMPTY',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'GET',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'INIT',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'LINEIN',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'LINEOUT',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'MAKEARRAY',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'PULL',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'PUSH',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'QUEUE',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'QUEUED',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'SAY',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'SET',(a Method) 
source:'ROUTINE',v1=(The Routine class) | inject:1,v1 
source:'ROUTINE',(The Routine class) | inject:'CALL',(a Method) 
source:'ROUTINE',(The Routine class) | inject:'CALLWITH',(a Method) 
source:'ROUTINE',(The Routine class) | inject:'PACKAGE',(a Method) 
source:'ROUTINE',(The Routine class) | inject:'SETSECURITYMANAGER',(a Method) 
source:'ROUTINE',(The Routine class) | inject:'SOURCE',(a Method) 


-- All packages that are visible from current context, including the current package (source of the pipeline).
   .context~package~pipe(,
       .inject after {item~importedPackages} iterateAfter recursive.memorize.cycle |,
       .console {'  '~copies(dataflow~length)} {.file~new(item~name)~name},
       )
     pipe_extension_test.rex 
     pipe_extension.cls 
       pipe.rex 
         profiling.cls 
       extensions.cls 
         array.cls 
         file.cls 
         string.cls 
         doers.cls 
           coactivity.cls 
         functionals.cls 
           doers.cls 
             coactivity.cls 
         coactivity.cls 
         generator.cls 
           coactivity.cls 
           functionals.cls 
             doers.cls 
               coactivity.cls 
     rgf_util2_wrappers.rex 
       rgf_util2.rex 


-- Same as above, but in breadth-first order
   .context~package~pipe(,
       .inject after {item~importedPackages} iterateAfter recursive.breadthFirst.memorize.cycle |,
       .console {'  '~copies(dataflow~length)} {.file~new(item~name)~name},
       )
     pipe_extension_test.rex 
     pipe_extension.cls 
     rgf_util2_wrappers.rex 
       pipe.rex 
       extensions.cls 
       rgf_util2.rex 
         profiling.cls 
         array.cls 
         file.cls 
         string.cls 
         doers.cls 
         functionals.cls 
         coactivity.cls 
         generator.cls 
           coactivity.cls 
           doers.cls 
           coactivity.cls 
           functionals.cls 
             coactivity.cls 
             doers.cls 
               coactivity.cls 


-- ----------------------------------------------------------------------------
-- .take pipeStage
-- ----------------------------------------------------------------------------

-- The .take pipeStage lets stop the preceding pipeStages when the number of items to take
-- has been reached, whatever its position in the pipeline.
-- Note the "" at the end of the first .console. This is an indicator to not insert a newline.
   supplier = .array~of(1,2,3,4,5,6,7,8,9)~supplier
   supplier~pipe(.console "2*" item "=" "" | .do {return 2*item} | .take 2 | .console item)
2* 1 =  2 
2* 2 =  4 
   say supplier~index -- this is the index of the last processed item
2
   supplier~next -- skip the last processed item
   supplier~pipe(.console "4*" item "=" "" | .do {return 4*item} | .take 4 | .console item)
4* 3 =  12 
4* 4 =  16 
4* 5 =  20 
4* 6 =  24 
   say supplier~index
6


-- Display the 4 first sorted items
   .array~of(5, 8, 1, 3, 6, 2)~pipe(.sort | .take 4 | .console)
3 : 1
6 : 2
4 : 3
1 : 5


-- Sort the 4 first items
   .array~of(5, 8, 1, 3, 6, 2)~pipe(.take 4 | .sort | .console)
3 : 1
4 : 3
1 : 5
2 : 8


-- Select files in the installation directory, whose name contains "rexx".
-- Note : the .select is not equivalent to .all["rexx"], because .select tests only the name,
-- whereas .all tests the string representation of the item, which is the absolute path.
-- Take the 15 firsts.
   .file~new(installdir())~listFiles~pipe(,
       .select {item~name~caselessPos('rexx') <> 0} |,
       .take 15 |,
       .console,
       )
154 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\orexxole.cls)
155 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\orexxole.dll)
156 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\orexxole.exp)
157 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\orexxole.lib)
158 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\orexxole.map)
159 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\orexxole.obj)
187 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rexx.dll)
188 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rexx.exe)
189 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rexx.exp)
190 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rexx.img)
191 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rexx.lib)
192 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rexx.map)
193 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rexx.obj)
194 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rexx.res)
195 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\RexxActivation.obj)


-- ----------------------------------------------------------------------------
-- .append pipeStage
-- ----------------------------------------------------------------------------

-- The .append pipeStage copies items from its primary input to its primary output, and then invokes
-- the producer passed as argument and writes the items produced by that producer to its primary output.
-- If the producer is a doer, then the producer is executed to get the effective producer.
-- If the effective producer understands the message "supplier" then each pair (item, index)
-- returned by the supplier is appended.
-- Otherwise, the effective producer is appended as-is (single object) with local index 1.
   supplier1 = .array~of(1,2,3,4,5,6,7,8,9)~supplier
   supplier2 = .array~of(10,11,12,13,14,15,16,17,18,19)~supplier
-- The first .take limits supplier1 to 2 items.
-- The second .take sees the two items produced by supplier1, so only 3 items are accepted from supplier2.
   supplier1~pipe(.take 2 | .append supplier2 | .take 5 | .console)
1 : 1
2 : 2
1 : 10
2 : 11
3 : 12
   say supplier1~index
2
   say supplier2~index
3
   supplier1~next
   supplier2~next
   supplier1~pipe(.take 4 | .append supplier2 | .take 9 | .console)
3 : 3
4 : 4
5 : 5
6 : 6
4 : 13
5 : 14
6 : 15
7 : 16
8 : 17
   say supplier1~index
6
   say supplier2~index
8


-- ----------------------------------------------------------------------------
-- pipeStages which support partitions
-- ----------------------------------------------------------------------------

-- Drop the first item
   .array~of(1,1,1,2,2,2,3,3,3,1,1,1)~pipe(.drop | .console)
2 : 1
3 : 1
4 : 2
5 : 2
6 : 2
7 : 3
8 : 3
9 : 3
10 : 1
11 : 1
12 : 1


-- Drop the first item of each partition
   .array~of(1,1,1,2,2,2,3,3,3,1,1,1)~pipe(.drop {item} | .console)
2 : 1
3 : 1
5 : 2
6 : 2
8 : 3
9 : 3
11 : 1
12 : 1


-- Drop the last item
   .array~of(1,1,1,2,2,2,3,3,3,1,1,1)~pipe(.drop last | .console)
1 : 1
2 : 1
3 : 1
4 : 2
5 : 2
6 : 2
7 : 3
8 : 3
9 : 3
10 : 1
11 : 1


-- Drop the last item of each partition
   .array~of(1,1,1,2,2,2,3,3,3,1,1,1)~pipe(.drop last {item} | .console)
1 : 1
2 : 1
4 : 2
5 : 2
7 : 3
8 : 3
10 : 1
11 : 1


   datas = .directory~new
   datas["key1"] = .array~of("header", 1, 2, "footer")
   datas["key2"] = .array~of("header", 5, 3, -9, 12, "footer")
   datas["key3"] = .array~of("header", 4, 6, 5, "footer")


-- The whole datas, including headers and footers
   datas~pipe(.inject {item} iterateBefore memorize | .console)
1 : 'header'
2 : 1
3 : 2
4 : 'footer'
1 : 'header'
2 : 5
3 : 3
4 : -9
5 : 12
6 : 'footer'
1 : 'header'
2 : 4
3 : 6
4 : 5
5 : 'footer'


-- The datas without the headers and footers
   datas~pipe(.inject {item} iterateBefore memorize | .drop first {dataflow["source"]~item } | .drop last {dataflow["source"]~item } | .console)
2 : 1
3 : 2
2 : 5
3 : 3
4 : -9
5 : 12
2 : 4
3 : 6
4 : 5


-- No partition here, so the whole set of words is written twice, separated by "==="
   .array~of("one two three","un deux trois")~pipe(.words | .buffer[2, "==="] | .console)
1 : 'one'
2 : 'two'
3 : 'three'
1 : 'un'
2 : 'deux'
3 : 'trois'
1 : '==='
1 : 'one'
2 : 'two'
3 : 'three'
1 : 'un'
2 : 'deux'
3 : 'trois'


-- There is a partition on the source items, so there is a separator "===" between each set of words extracted from each string
   .array~of("one two three","un deux trois")~pipe(.words memorize | .buffer[2, "==="] {dataflow["source"]~item} | .console)
1 : 'one'
2 : 'two'
3 : 'three'
1 : '==='
1 : 'one'
2 : 'two'
3 : 'three'
1 : '==='
1 : 'un'
2 : 'deux'
3 : 'trois'
1 : '==='
1 : 'un'
2 : 'deux'
3 : 'trois'


-- ----------------------------------------------------------------------------
-- .fanout, .fanin, .merge pipeStages
-- ----------------------------------------------------------------------------

-- Here, only the output from fanout1 is sent to console.
   fanout1 = .left[3]  memorize | .lower memorize
   fanout2 = .right[3] memorize | .upper memorize | .inject after {"my_"item}
   .array~of("aaaBBB", "CCCddd", "eEeFfF")~pipe(.fanout memorize >> fanout2 > fanout1 | .console dataflow item)
source:1,v1='aaaBBB' | fanout:1,v1 | left:1,v2='aaa' | lower:1,v2 'aaa' 
source:2,v1='CCCddd' | fanout:2,v1 | left:1,'CCC' | lower:1,'ccc' 'ccc' 
source:3,v1='eEeFfF' | fanout:3,v1 | left:1,'eEe' | lower:1,'eee' 'eee' 


-- Here, each branch of the fanout remains separated. Each branch has its own console.
   fanout1 = .left[3]  memorize | .lower memorize | .console dataflow item
   fanout2 = .right[3] memorize | .upper memorize | .inject after {"my_"item} | .console dataflow item
   .array~of("aaaBBB", "CCCddd", "eEeFfF")~pipe(.fanout memorize >> fanout2 > fanout1)
source:1,v1='aaaBBB' | fanout:1,v1 | left:1,v2='aaa' | lower:1,v2 'aaa' 
source:1,v1='aaaBBB' | fanout:1,v1 | right:1,v2='BBB' | upper:1,v2 'BBB' 
source:1,v1='aaaBBB' | fanout:1,v1 | right:1,v2='BBB' | upper:1,v2 'my_BBB' 
source:2,v1='CCCddd' | fanout:2,v1 | left:1,'CCC' | lower:1,'ccc' 'ccc' 
source:2,v1='CCCddd' | fanout:2,v1 | right:1,'ddd' | upper:1,'DDD' 'DDD' 
source:2,v1='CCCddd' | fanout:2,v1 | right:1,'ddd' | upper:1,'DDD' 'my_DDD' 
source:3,v1='eEeFfF' | fanout:3,v1 | left:1,'eEe' | lower:1,'eee' 'eee' 
source:3,v1='eEeFfF' | fanout:3,v1 | right:1,'FfF' | upper:1,'FFF' 'FFF' 
source:3,v1='eEeFfF' | fanout:3,v1 | right:1,'FfF' | upper:1,'FFF' 'my_FFF' 


-- Here, a fanin is used to serialize the branches of the fanout.
-- The output from fanout1 is sent to console, then the output from fanout2 (delayed)
   fanin = .fanin memorize | .console dataflow item
   fanout1 = .left[3]  memorize | .lower memorize | fanin  -- not bufferized
   fanout2 = .right[3] memorize | .upper memorize | .inject after {"my_"item} | .secondaryConnector | fanin -- bufferized until fanout1 is eof
   .array~of("aaaBBB", "CCCddd", "eEeFfF")~pipe(.fanout memorize >> fanout2 > fanout1)
source:1,v1='aaaBBB' | fanout:1,v1 | left:1,v2='aaa' | lower:1,v2 | fanin:1,v2 'aaa' 
source:2,v1='CCCddd' | fanout:2,v1 | left:1,'CCC' | lower:1,v2='ccc' | fanin:1,v2 'ccc' 
source:3,v1='eEeFfF' | fanout:3,v1 | left:1,'eEe' | lower:1,v2='eee' | fanin:1,v2 'eee' 
source:1,v1='aaaBBB' | fanout:1,v1 | right:1,v2='BBB' | upper:1,v2 | fanin:1,v2 'BBB' 
source:1,v1='aaaBBB' | fanout:1,v1 | right:1,v2='BBB' | upper:1,v2 | fanin:1,'my_BBB' 'my_BBB' 
source:2,v1='CCCddd' | fanout:2,v1 | right:1,'ddd' | upper:1,v2='DDD' | fanin:1,v2 'DDD' 
source:2,v1='CCCddd' | fanout:2,v1 | right:1,'ddd' | upper:1,'DDD' | fanin:1,'my_DDD' 'my_DDD' 
source:3,v1='eEeFfF' | fanout:3,v1 | right:1,'FfF' | upper:1,v2='FFF' | fanin:1,v2 'FFF' 
source:3,v1='eEeFfF' | fanout:3,v1 | right:1,'FfF' | upper:1,'FFF' | fanin:1,'my_FFF' 'my_FFF' 

-- Here, a merge is used to serialize the branches of the fanout.
-- There is no specific order (no delay).
   merge = .merge memorize | .console dataflow item
   fanout1 = .left[3]  memorize | .lower memorize | merge  -- not bufferized
   fanout2 = .right[3] memorize | .upper memorize | .inject after {"my_"item} | .secondaryConnector | merge -- not bufferized
   .array~of("aaaBBB", "CCCddd", "eEeFfF")~pipe(.fanout memorize >> fanout2 > fanout1)
source:1,v1='aaaBBB' | fanout:1,v1 | left:1,v2='aaa' | lower:1,v2 | merge:1,v2 'aaa' 
source:1,v1='aaaBBB' | fanout:1,v1 | right:1,v2='BBB' | upper:1,v2 | merge:1,v2 'BBB' 
source:1,v1='aaaBBB' | fanout:1,v1 | right:1,v2='BBB' | upper:1,v2 | merge:1,'my_BBB' 'my_BBB' 
source:2,v1='CCCddd' | fanout:2,v1 | left:1,'CCC' | lower:1,v2='ccc' | merge:1,v2 'ccc' 
source:2,v1='CCCddd' | fanout:2,v1 | right:1,'ddd' | upper:1,v2='DDD' | merge:1,v2 'DDD' 
source:2,v1='CCCddd' | fanout:2,v1 | right:1,'ddd' | upper:1,'DDD' | merge:1,'my_DDD' 'my_DDD' 
source:3,v1='eEeFfF' | fanout:3,v1 | left:1,'eEe' | lower:1,v2='eee' | merge:1,v2 'eee' 
source:3,v1='eEeFfF' | fanout:3,v1 | right:1,'FfF' | upper:1,v2='FFF' | merge:1,v2 'FFF' 
source:3,v1='eEeFfF' | fanout:3,v1 | right:1,'FfF' | upper:1,'FFF' | merge:1,'my_FFF' 'my_FFF' 


-- ----------------------------------------------------------------------------
-- .fileTree pipeStage
-- ----------------------------------------------------------------------------

-- The *.cls files of ooRexx
   installdir()~pipe(,
       .fileTree recursive |,
       .endsWith[".cls"] |,
       .console,
       )
33 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\csvStream.cls)
116 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\mime.cls)
134 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\ooDialog.cls)
145 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\oodPlain.cls)
152 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\oodWin32.cls)
154 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\orexxole.cls)
245 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rxftp.cls)
254 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\rxregexp.cls)
282 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\smtp.cls)
283 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\socket.cls)
291 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\streamsocket.cls)
9 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\wchar\ooDialog.cls)
19 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\wchar\oodPlain.cls)
26 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\wchar\oodWin32.cls)
337 : (d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\winsystm.cls)


-- Total number of lines in the *.cls files of ooRexx
   installdir()~pipe(,
       .fileTree recursive |,
       .endsWith[".cls"] |,
       .fileLines | .lineCount |,
       .console,
       )
1 : 23605


-- Number of lines in each *.cls files of ooRexx
   installdir()~pipe(,
       .fileTree recursive memorize.file |,
       .endsWith[".cls"] |,
       .fileLines | .lineCount {dataflow["file"]~item} |,
       .console,
       )
1 : 490
1 : 236
1 : 9343
1 : 39
1 : 39
1 : 208
1 : 1971
1 : 56
1 : 416
1 : 887
1 : 409
1 : 8325
1 : 39
1 : 39
1 : 1108


-- Total number of words in the *.cls files of ooRexx
   installdir()~pipe(,
       .fileTree recursive |,
       .endsWith[".cls"] |,
       .fileLines | .wordCount |,
       .console,
       )
1 : 106320


-- Number of words in each *.cls files of ooRexx
   installdir()~pipe(,
       .fileTree recursive memorize.file |,
       .endsWith[".cls"] |,
       .fileLines | .wordCount {dataflow["file"]~item} |,
       .console,
       )
1 : 2105
1 : 955
1 : 42038
1 : 337
1 : 337
1 : 875
1 : 7489
1 : 397
1 : 1665
1 : 4598
1 : 1660
1 : 38007
1 : 337
1 : 337
1 : 5183


-- Total number of characters in the *.cls files of ooRexx (not counting the newline characters)
   installdir()~pipe(,
       .fileTree recursive |,
       .endsWith[".cls"] |,
       .fileLines | .charCount |,
       .console,
       )
1 : 887774


-- Number of characters in each *.cls files of ooRexx (not counting the newline characters)
   installdir()~pipe(,
       .fileTree recursive memorize.file |,
       .endsWith[".cls"] |,
       .fileLines | .charCount {dataflow["file"]~item} |,
       .console,
       )
1 : 24470
1 : 11208
1 : 346535
1 : 2985
1 : 2985
1 : 7948
1 : 62044
1 : 3433
1 : 18255
1 : 43999
1 : 18066
1 : 304785
1 : 2985
1 : 2985
1 : 35091


-- Alphanumeric words of 16+ chars found in the *.cls files of ooRexx.
-- Only the first two words per file are taken :
--     .take 2 {dataflow["file"]~item}
-- Here, the partition expression returns the current file object produced by the pipeStage "fileTree".
-- Exemple of result :
-- source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:338,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\winsystm.cls) | fileLines:250,'::method DeleteDesktopIcon' | words:2,'DeleteDesktopIcon' 'DeleteDesktopIcon' 
-- "DeleteDesktopIcon" is the 2nd word of the 250th line of the file
-- "d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32dbg\winsystm.cls"
-- which is the 338th file/directory of the directory
-- "d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/"
--
-- To investigate : I get sometimes a crash in the sort.
--
   call time('r') -- to see how long this takes
   installdir()~pipe(,
       .fileTree recursive memorize.file |,
       .endsWith[".cls"] |,
       .fileLines memorize | .words memorize | .select {item~datatype('a') & item~length >= 16} |,
       .take 2 {dataflow["file"]~item} | .sort caseless | .console dataflow item,
       )
source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:337,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\winsystm.cls) | fileLines:250,'::method DeleteDesktopIcon' | words:2,'DeleteDesktopIcon' 'DeleteDesktopIcon' 
source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:154,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\orexxole.cls) | fileLines:70,'::METHOD disconnectEvents EXTERNAL "LIBRARY OREXXOLE OLEObject_disconnectEvents"' | words:2,'disconnectEvents' 'disconnectEvents' 
source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:9,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\wchar\ooDialog.cls) | fileLines:71,'::method getSystemMetrics class external "LIBRARY oodialog dlgutil_getSystemMetrics_cls"' | words:2,'getSystemMetrics' 'getSystemMetrics' 
source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:33,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\csvStream.cls) | fileLines:64,'::Attribute headerLineAbsent      private -- headersexist but absent' | words:2,'headerLineAbsent' 'headerLineAbsent' 
source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:291,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\streamsocket.cls) | fileLines:52,'::class 'StreamSocket' public subclass InputOutputStream' | words:5,'InputOutputStream' 'InputOutputStream' 
source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:9,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\wchar\ooDialog.cls) | fileLines:94,'::method isAtLeastWindows7 class external "LIBRARY oodialog os_isVersion"' | words:2,'isAtLeastWindows7' 'isAtLeastWindows7' 
source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:33,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\csvStream.cls) | fileLines:63,'::Attribute originalRawHeaders    private -- for comparison' | words:2,'originalRawHeaders' 'originalRawHeaders' 
source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:134,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\ooDialog.cls) | fileLines:68,'::method parseIncludeFile' | words:2,'parseIncludeFile' 'parseIncludeFile' 
source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:154,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\orexxole.cls) | fileLines:71,'::METHOD removeEventHandler EXTERNAL "LIBRARY OREXXOLE OLEObject_removeEventHandler"' | words:2,'removeEventHandler' 'removeEventHandler' 
source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:134,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\ooDialog.cls) | fileLines:109,'::method skipThroughIfDefs private' | words:2,'skipThroughIfDefs' 'skipThroughIfDefs' 
source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:337,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\winsystm.cls) | fileLines:188,'/*********************************** WindowsProgramManager ****************************************/' | words:2,'WindowsProgramManager' 'WindowsProgramManager' 
   say "duration="time('e') -- elapsed duration
duration=4.969000


-- From here, some methods of the pipeline classes are instrumented to let profiling.
-- The performances are impacted because the profiled methods are instrumented with an additional forward.
   .pipeProfiler~instrument("start", "process", "eof", "isEOP")


-- Same as above, but with profiling
   call time('r') -- to see how long this takes
   installdir()~pipeProfile(,
       .fileTree recursive memorize.file |,
       .endsWith[".cls"] |,
       .fileLines memorize | .words memorize | .select {item~datatype('a') & item~length >= 16} |,
       .take 2 {dataflow["file"]~item} | .sort caseless | .console dataflow item,
       )
source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:337,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\winsystm.cls) | fileLines:250,'::method DeleteDesktopIcon' | words:2,'DeleteDesktopIcon' 'DeleteDesktopIcon' 
source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:154,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\orexxole.cls) | fileLines:70,'::METHOD disconnectEvents EXTERNAL "LIBRARY OREXXOLE OLEObject_disconnectEvents"' | words:2,'disconnectEvents' 'disconnectEvents' 
source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:9,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\wchar\ooDialog.cls) | fileLines:71,'::method getSystemMetrics class external "LIBRARY oodialog dlgutil_getSystemMetrics_cls"' | words:2,'getSystemMetrics' 'getSystemMetrics' 
source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:33,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\csvStream.cls) | fileLines:64,'::Attribute headerLineAbsent      private -- headersexist but absent' | words:2,'headerLineAbsent' 'headerLineAbsent' 
source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:291,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\streamsocket.cls) | fileLines:52,'::class 'StreamSocket' public subclass InputOutputStream' | words:5,'InputOutputStream' 'InputOutputStream' 
source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:9,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\wchar\ooDialog.cls) | fileLines:94,'::method isAtLeastWindows7 class external "LIBRARY oodialog os_isVersion"' | words:2,'isAtLeastWindows7' 'isAtLeastWindows7' 
source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:33,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\csvStream.cls) | fileLines:63,'::Attribute originalRawHeaders    private -- for comparison' | words:2,'originalRawHeaders' 'originalRawHeaders' 
source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:134,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\ooDialog.cls) | fileLines:68,'::method parseIncludeFile' | words:2,'parseIncludeFile' 'parseIncludeFile' 
source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:154,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\orexxole.cls) | fileLines:71,'::METHOD removeEventHandler EXTERNAL "LIBRARY OREXXOLE OLEObject_removeEventHandler"' | words:2,'removeEventHandler' 'removeEventHandler' 
source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:134,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\ooDialog.cls) | fileLines:109,'::method skipThroughIfDefs private' | words:2,'skipThroughIfDefs' 'skipThroughIfDefs' 
source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:337,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\winsystm.cls) | fileLines:188,'/*********************************** WindowsProgramManager ****************************************/' | words:2,'WindowsProgramManager' 'WindowsProgramManager' 
----------------------------------------
.fileTree~go
  .fileTree~EOF count=1 duration=0.047000
    .endsWith~EOF count=1 duration=0.047000
      .fileLines~EOF count=1 duration=0.047000
        .words~EOF count=1 duration=0.047000
          .select~EOF count=1 duration=0.047000
            .take~EOF count=1 duration=0.047000
              .sort~EOF count=1 duration=0.047000
                .console~EOF count=1 duration=0
                .console~ISEOP count=22 duration=0
                .console~PROCESS count=11 duration=0.031000
  .fileTree~PROCESS count=1 duration=22.140000
    .endsWith~ISEOP count=1300 duration=0
    .endsWith~PROCESS count=650 duration=21.282000
      .fileLines~ISEOP count=665 duration=0
      .fileLines~PROCESS count=15 duration=21.251000
        .words~ISEOP count=47240 duration=0.031000
        .words~PROCESS count=23605 duration=19.273000
          .select~ISEOP count=236245 duration=0.235000
          .select~PROCESS count=106320 duration=8.920000
            .take~ISEOP count=107073 duration=0.172000
            .take~PROCESS count=753 duration=0.125000
              .sort~ISEOP count=764 duration=0
              .sort~PROCESS count=11 duration=0
  .fileTree~START count=1 duration=0
    .endsWith~START count=1 duration=0
      .fileLines~START count=1 duration=0
        .words~START count=1 duration=0
          .select~START count=1 duration=0
            .take~START count=1 duration=0
              .sort~START count=1 duration=0
                .console~START count=1 duration=0
duration=22.187000
----------------------------------------
   say "duration="time('e') -- elapsed duration
duration=22.469000


   say installdir() ; say
d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/


Ended coactivities: 0
