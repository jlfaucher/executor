
-- ----------------------------------------------------------------------------
-- Overview of dataflows
-- ----------------------------------------------------------------------------
--   1          2     3       4
-- +----------+-----+-------+------+
-- | previous | tag | index | item |
-- +----------+-----+-------+------+
--    ^
--    |  +----------+-----+-------+------+
--    +--| previous | tag | index | item |
--       +----------+-----+-------+------+
--          ^
--          |
--          +-- etc...


-- A dataflow is created from a tag, a pair of (item, index), and a previous dataflow (which can be .nil).
-- Representation : the strings (except the strings numbers) are surrounded by quotes.
   df1 = .dataflow~create(.nil, "tag1", "item1", "index1")
   say df1 -- by default, all the fields are included in the representation string.
tag1:'index1','item1'
   say df1~makeString(2) -- show tag
tag1:
   say df1~makeString(23) -- show tag, index
tag1:'index1'
   say df1~makeString(234) -- show tag, index, item
tag1:'index1','item1'


-- A dataflow can be linked to a previous dataflow.
-- Representation : the dataflows are separated by |
   df2 = .dataflow~create(df1, "tag2", "item2", "index2")
   say df2
tag1:'index1','item1' | tag2:'index2','item2'


-- Representation : the objects other than strings are surrounded by round brackets.
   df3 = .dataflow~create(df2, "tag3", .mutableBuffer~new(22222), .file~new("my file"))
   say df3
tag1:'index1','item1' | tag2:'index2','item2' | tag3:(my file),(22222)


-- showPool=.true : when an item (other than a number) appears several times then it is replaced by a reference to the first occurence of the item.
-- The references are named v1, v2, etc...
-- The operator == is used for the comparison.
-- Example :
-- "a" and .file~new("my file" are entered in the pool, because there is more than one occurence of them.
-- .mutableBuffer~new(22222) is not entered in the pool, because two distincts instances are never equal, even if their string representation is the same.
   df4 = .dataflow~create(df3, "tag4", .file~new("my file"), "a")
   df5 = .dataflow~create(df4, "tag5", .mutableBuffer~new(22222), "a")
   say df5 ; say df5~makeString(1234, .true)
tag1:'index1','item1' | tag2:'index2','item2' | tag3:(my file),(22222) | tag4:'a',(my file) | tag5:'a',(22222)
tag1:'index1','item1' | tag2:'index2','item2' | tag3:v1=(my file),(22222) | tag4:v2='a',*v1 | tag5:*v2,(22222)


-- ----------------------------------------------------------------------------
-- Overview of the sources supported by pipes
-- ----------------------------------------------------------------------------

-- Any object can be a source of pipe.
-- When the object does not support the method ~supplier then it's injected as-is.
-- Its associated index is always 1.
   "hello"~pipe(.console)
1 : 'hello'


-- By default, the dataflows are not shown, use the option dataflow.
-- dataflow is interpreted as the string "DATAFLOW" because no value assigned.
-- If dataflow was a variable with an assigned value, then you should use explicitely the string "dataflow" (caseless).
-- Other options supported by .console : index, item
   "hello"~pipe(.console dataflow)
source:1,'hello' 


-- A collection can be a source of pipe : each item of the collection is injected in the pipe.
-- The indexes are those of the collection.
   .array~of(10,20,30)~pipe(.console)
1 : 10
2 : 20
3 : 30
   .array~of(10,20,30)~pipe(.console dataflow)
source:1,10 
source:2,20 
source:3,30 


-- A coactivty can be a source of pipe : each yielded item is injected in the pipe.
-- Example :
-- This coactivity yields two results.
-- The hello outputs are not in the pipeline flow (not displayed by the .console).
-- 07/10/2019 : now the RexxBlock are always with implicit return. Must add options "COMMANDS".
   {::coactivity options "COMMANDS"; echo hello ; .yield["a"] ; say hello ; .yield["b"] }~doer~pipe(.console)
HELLO
1 : 'a'
HELLO
2 : 'b'
   {::coactivity options "COMMANDS"; echo hello ; .yield["a"] ; say hello ; .yield["b"] }~doer~pipe(.console dataflow)
HELLO
source:1,'a' 
HELLO
source:2,'b' 


-- ----------------------------------------------------------------------------
-- Overview of the pipe operators.
-- Reminder of the precedence (highest at the top) :
-- (message send)         : ~ ~~ (not overloaded for pipes)
-- (prefix operators)     : + - \ (not overloaded for pipes)
-- (power)                : ** (not overloaded for pipes)
-- (multiply and divide)  : * / % // (not overloaded for pipes)
-- (add and subtract)     : + - (not overloaded for pipes)
-- (blank) || (abuttal)   : (blank) is overloaded for adding options.
-- (comparison operators) : > >> are overloaded for pipes, the rest is not used : = < == << \= >< <> \> \< \== \>> \<< >= >>= <= <<=
-- (and operator)         : & (not overloaded for pipes).
-- (or, exclusive or)     : | is overloaded, && is not used.
-- ----------------------------------------------------------------------------

-- stage1 | stage2
-- stage1 > stage2
-- | and > share the same implementation...
-- (they connect the primary output of stage1 to the primary input of stage2)
   "hello"~pipe(.left[2] | .upper | .console)
1 : 'HE'

-- Same pipeline as previous, but with methods only
   "hello"~pipe(    (.left~new(2) ~append(.upper~new))    ~append(.console~new)    )
1 : 'HE'


-- ...but | and > don't have the same precedence ! No impact here.
   "hello"~pipe(.left[2] | .upper > .console)
1 : 'HE'

-- Same pipeline as previous, but with methods only
   "hello"~pipe(    .left~new(2) ~append(   .upper~new ~append(.console~new)    )    )
1 : 'HE'


-- stage1 >> stage2
-- Connects the secondary output of stage1 to the primary input of stage2
-- Here, the result is not what you expect. You want "LLO", you get "he"...
-- This is because .console is the primary follower of .left, not the primary
-- follower of .upper.
-- Why ? because the pipestage returned by .left[2] >> .upper is .left,
-- and .console is attached to the pipestage found by starting from .left
-- and walking through the 'next' references until a pipestage with no 'next'
-- is found. So .upper is not walked though, because it's a secondary follower.
   "hello"~pipe(.left[2] >> .upper | .console)
1 : 'he'

-- Same pipeline as previous, but with methods only
   "hello"~pipe(    (.left~new(2) ~appendSecondary(.upper~new))    ~append(.console~new)    )
1 : 'he'


-- ...You need additional parentheses to get the expected behavior.
-- Here, .console is the primary follower of .upper.
   "hello"~pipe(.left[2] >> ( .upper | .console ) )
1 : 'LLO'

-- Same pipeline as previous, but with methods only
   "hello"~pipe(    .left~new(2) ~appendSecondary(    .upper~new ~append(.console~new)    )    )
1 : 'LLO'


-- ----------------------------------------------------------------------------
-- Overview of the sorting facilities
-- ----------------------------------------------------------------------------

-- A collection can be sorted by item (default)
   .array~of(b, a, c)~pipe(.sort byItem | .console)
2 : 'A'
1 : 'B'
3 : 'C'


-- ...or by index
   .array~of(b, a, c)~pipe(.sort byIndex | .console)
1 : 'B'
2 : 'A'
3 : 'C'


-- ...ascending (default)
-- The order of options is important : a byItem option is impacted only by the preceding options
-- This is because several byItem options can be specified, and a sort is made for each.
   .array~of(b, a, c)~pipe(.sort ascending byItem | .console)
2 : 'A'
1 : 'B'
3 : 'C'


-- ...descending
   .array~of(b, a, c)~pipe(.sort descending byItem | .console)
3 : 'C'
1 : 'B'
2 : 'A'


-- ...by index descending
-- The order of options is important : a byIndex option is impacted only by the preceding options.
-- This is because several byIndex options can be specified, and a sort is made for each.
   .array~of(b, a, c)~pipe(.sort descending byIndex | .console)
3 : 'C'
2 : 'A'
1 : 'B'


-- ...caseless (stable by default)
   .array~of("bb", "AA", "bB", "Aa", "Bb", "aA", "BB", "aa")~pipe(.sort caseless byItem | .console)
2 : 'AA'
4 : 'Aa'
6 : 'aA'
8 : 'aa'
1 : 'bb'
3 : 'bB'
5 : 'Bb'
7 : 'BB'


-- ...caseless quickSort (unstable)
-- No difference bewteen stable and unstable ? yes, see commit 6275 in interpreter/memory/setup.cpp :
--  // there have been some problems with the quick sort used as the default sort, so map everything
--  // to the stable sort.  The stable sort, in theory, uses more memory, but in practice, this is not true.
--  defineKernelMethod(CHAR_SORT         ,TheArrayBehaviour, CPPM(RexxArray::stableSortRexx), 0);
--  defineKernelMethod(CHAR_SORTWITH     ,TheArrayBehaviour, CPPM(RexxArray::stableSortWithRexx), 1);
--  defineKernelMethod(CHAR_STABLESORT   ,TheArrayBehaviour, CPPM(RexxArray::stableSortRexx), 0);
--  defineKernelMethod(CHAR_STABLESORTWITH ,TheArrayBehaviour, CPPM(RexxArray::stableSortWithRexx), 1);
   .array~of("bb", "AA", "bB", "Aa", "Bb", "aA", "BB", "aa")~pipe(.sort caseless quickSort byItem | .console)
2 : 'AA'
4 : 'Aa'
6 : 'aA'
8 : 'aa'
1 : 'bb'
3 : 'bB'
5 : 'Bb'
7 : 'BB'


-- Sort descending with a comparator.
-- The DescendingComparator use the default CompareTo, which is made on items.
   .array~of(b, a, c)~pipe(.sortWith[.DescendingComparator~new] | .console)
3 : 'C'
1 : 'B'
2 : 'A'


-- Sort by column with a comparator.
   .array~of("c:2", "b:2", "A:2", "c:1", "a:1", "B:1", "C:3")~pipe(,
       .sortWith[.InvertingComparator~new(.CaselessColumnComparator~new(3,1))] |,
       .sortWith[.CaselessColumnComparator~new(1,1)] |,
       .console,
       )
3 : 'A:2'
5 : 'a:1'
2 : 'b:2'
6 : 'B:1'
7 : 'C:3'
1 : 'c:2'
4 : 'c:1'


-- ----------------------------------------------------------------------------
-- Options available on any pipeStage : memorize
-- ----------------------------------------------------------------------------

   "aaaBBBcccDDDeee"~pipe(.reverse memorize | .console dataflow)
source:1,'aaaBBBcccDDDeee' | reverse:1,'eeeDDDcccBBBaaa' 


   "aaaBBBcccDDDeee"~pipe(.upper memorize | .console dataflow)
source:1,'aaaBBBcccDDDeee' | upper:1,'AAABBBCCCDDDEEE' 


   "aaaBBBcccDDDeee"~pipe(.lower memorize | .console dataflow)
source:1,'aaaBBBcccDDDeee' | lower:1,'aaabbbcccdddeee' 


   "aaaBBBcccDDDeee"~pipe(.changeStr["B", "b", 2] memorize | .console dataflow)
source:1,'aaaBBBcccDDDeee' | changeStr:1,'aaabbBcccDDDeee' 


   "aaaBBBcccDDDeee"~pipe(.delStr[4, 9] memorize | .console dataflow)
source:1,'aaaBBBcccDDDeee' | delStr:1,'aaaeee' 


   "aaaBBBcccDDDeee"~pipe(.left[3] memorize >> .console "secondary :" dataflow | .console "primary:" dataflow)
primary: source:1,'aaaBBBcccDDDeee' | left:1,'aaa' 
secondary : source:1,'aaaBBBcccDDDeee' | left:1,'BBBcccDDDeee' 


   "aaaBBBcccDDDeee"~pipe(.right[3] memorize >> .console "secondary :" dataflow | .console "primary:" dataflow)
primary: source:1,'aaaBBBcccDDDeee' | right:1,'eee' 
secondary : source:1,'aaaBBBcccDDDeee' | right:1,'aaaBBBcccDDD' 


   "aaaBBBcccDDDeee"~pipe(.insert["---", 3] memorize | .console dataflow)
source:1,'aaaBBBcccDDDeee' | insert:1,'aaa---BBBcccDDDeee' 


   "aaaBBBcccDDDeee"~pipe(.overlay["---", 3] memorize | .console dataflow)
source:1,'aaaBBBcccDDDeee' | overlay:1,'aa---BcccDDDeee' 


   "48656c6c6f"~pipe(.x2c memorize | .console dataflow)
source:1,'48656c6c6f' | x2c:1,'Hello' 


   .array~of("a", "", "b", , "c", , "", "d")~pipe(.dropNull memorize | .console dataflow)
source:1,v1='a' | dropNull:1,*v1 
source:3,v1='b' | dropNull:3,*v1 
source:5,v1='c' | dropNull:5,*v1 
source:8,v1='d' | dropNull:8,*v1 


   .array~of("header", 1, 2 ,3 , "footer")~pipe(,
       .drop first memorize >> .console "secondary of drop first :" dataflow |,
       .drop last memorize >> .console "secondary of drop last :" dataflow |,
       .console "primary:" dataflow) -- Remove header and footer
secondary of drop first : source:1,v1='header' | drop:1,*v1 
primary: source:2,1 | drop:2,1 | drop:2,1 
primary: source:3,2 | drop:3,2 | drop:3,2 
primary: source:4,3 | drop:4,3 | drop:4,3 
secondary of drop last : source:5,v1='footer' | drop:5,*v1 | drop:5,*v1 


-- ----------------------------------------------------------------------------
-- .do and .inject pipeStages
-- ----------------------------------------------------------------------------

-- .do is a synonym of .inject.
-- Sometimes, the name '.do' is better than the name '.inject'.
-- Both support the same options and have the same behavior.


-- Do something for each item (no returned value, so no value passed to .console).
   .array~of(1, , 2, , 3)~pipe(.do {say 'item='item 'dataflow='dataflow~makeString} | .console)
item=1 dataflow=source:1,1
item=2 dataflow=source:3,2
item=3 dataflow=source:5,3


-- Do something for each item (the returned result replaces the item's value).
-- Here, only one result is calculated for an item, so resultIndex is always 1.
   .array~of(1, , 2, , 3)~pipe(.do {return 2*item} memorize | .console)
1 : 2
3 : 4
5 : 6


-- Inject a value for each item (the returned value is injected after the input item).
   .array~of(1, , 2, , 3)~pipe(.inject after {item*10} memorize | .console dataflow)
source:1,1 | inject:1,1 
source:1,1 | inject:1,10 
source:3,2 | inject:1,2 
source:3,2 | inject:3,20 
source:5,3 | inject:1,3 
source:5,3 | inject:5,30 


-- Inject two values for each item (each item of the returned collection is written in the pipe).
-- Note the "iterateAfter" option : using this option, when the result of .inject is an object which
-- understands "supplier" then each pair (item, index) returned by the supplier is injected in the pipe.
   .array~of(1, , 2, , 3)~pipe(.inject after {.array~of(item*10, item*20)} iterateAfter memorize | .console dataflow)
source:1,1 | inject:1,1 
source:1,1 | inject:1,10 
source:1,1 | inject:2,20 
source:3,2 | inject:1,2 
source:3,2 | inject:1,20 
source:3,2 | inject:2,40 
source:5,3 | inject:1,3 
source:5,3 | inject:1,30 
source:5,3 | inject:2,60 


-- Each injected value can be used as input to inject a new value, recursively.
-- The default order is depth-first.
-- If the recursion is infinite, must specify a limit (here 0, 1 and 2).
-- The options 'before' and 'after' are not used, so the initial item is discarded.
   .array~of(1, , 2, , 3)~pipe(.inject {item*10} recursive.0 | .console dataflow "item =" item)
source:1,1 item = 10 
source:3,2 item = 20 
source:5,3 item = 30 
   .array~of(1, , 2, , 3)~pipe(.inject {item*20} recursive.1 | .console dataflow "item =" item)
source:1,1 item = 20 
source:1,1 item = 400 
source:3,2 item = 40 
source:3,2 item = 800 
source:5,3 item = 60 
source:5,3 item = 1200 
   .array~of(1, , 2, , 3)~pipe(.inject {item*30} recursive.2 | .console dataflow "item =" item)
source:1,1 item = 30 
source:1,1 item = 900 
source:1,1 item = 27000 
source:3,2 item = 60 
source:3,2 item = 1800 
source:3,2 item = 54000 
source:5,3 item = 90 
source:5,3 item = 2700 
source:5,3 item = 81000 


-- Same as previous example, but here, the recursive.memorize option is used.
-- The dataflow is like a call stack.
-- Ex : the last line is
-- source:5,3 | inject:1,90 | inject:1,2700 | inject:1,81000 item = 81000
-- The item at index 5 in input array has injected 3 "inject" dataflows by recursion.
   .array~of(1, , 2, , 3)~pipe(.inject {item*10} recursive.0.memorize | .console dataflow "item =" item)
source:1,1 | inject:1,10 item = 10 
source:3,2 | inject:3,20 item = 20 
source:5,3 | inject:5,30 item = 30 
   .array~of(1, , 2, , 3)~pipe(.inject {item*20} recursive.1.memorize | .console dataflow "item =" item)
source:1,1 | inject:1,20 item = 20 
source:1,1 | inject:1,20 | inject:1,400 item = 400 
source:3,2 | inject:3,40 item = 40 
source:3,2 | inject:3,40 | inject:3,800 item = 800 
source:5,3 | inject:5,60 item = 60 
source:5,3 | inject:5,60 | inject:5,1200 item = 1200 
   .array~of(1, , 2, , 3)~pipe(.inject {item*30} recursive.2.memorize | .console dataflow "item =" item)
source:1,1 | inject:1,30 item = 30 
source:1,1 | inject:1,30 | inject:1,900 item = 900 
source:1,1 | inject:1,30 | inject:1,900 | inject:1,27000 item = 27000 
source:3,2 | inject:3,60 item = 60 
source:3,2 | inject:3,60 | inject:3,1800 item = 1800 
source:3,2 | inject:3,60 | inject:3,1800 | inject:3,54000 item = 54000 
source:5,3 | inject:5,90 item = 90 
source:5,3 | inject:5,90 | inject:5,2700 item = 2700 
source:5,3 | inject:5,90 | inject:5,2700 | inject:5,81000 item = 81000 


-- Factorial, no value injected for -1
   .array~of(-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9)~pipe(.inject {
       use arg n
       if n < 0 then return
       if n == 0 then return 1
       return n * .context~executable~call(n - 1)} | .console dataflow item)
source:2,0 1 
source:3,1 1 
source:4,2 2 
source:5,3 6 
source:6,4 24 
source:7,5 120 
source:8,6 720 
source:9,7 5040 
source:10,8 40320 
source:11,9 362880 


-- Another illustration of the "iterateAfter" option.
   10~pipe(.inject {item~times} | .console)
1 : [1,2,3,4,5,6,7,8,9,10]
   10~pipe(.inject {item~times} iterateAfter | .console)
1 : 1
2 : 2
3 : 3
4 : 4
5 : 5
6 : 6
7 : 7
8 : 8
9 : 9
10 : 10
   10~pipe(.inject {item~times.generate} | .console)
1 : (a Coactivity)
   10~pipe(.inject {item~times.generate} iterateAfter | .console)
1 : 1
2 : 2
3 : 3
4 : 4
5 : 5
6 : 6
7 : 7
8 : 8
9 : 9
10 : 10


-- Another illustration of the "iterateAfter" option.
-- In this example, the block passed to .inject returns another block whose doer is a coactivity.
-- The option "iterateAfter" force to check if the returned value has the "supplier" method.
-- If yes, then .inject iterates over the items returned by the supplier and sends them to the next pipeStage.
-- A block has no "supplier" method, but its doer may have one. This is the case in this example.
-- The method "hasMethod" has been redefined on RexxBlock to return .true if the doer has the method "supplier".
-- The method "supplier" has been defined on RexxBlock to forward to its doer.
-- Note :
-- The pipeStage .take is mandatory because the generator passed to .inject will generate an infinite sequence of numbers.
   1~pipe(.inject {{::coactivity expose item ; do forever ; .yield[item] ; item += 1 ; end}} iterateAfter | .take 10 | .console)
1 : 1
2 : 2
3 : 3
4 : 4
5 : 5
6 : 6
7 : 7
8 : 8
9 : 9
10 : 10


-- ----------------------------------------------------------------------------
-- Additional sorting facilities
-- ----------------------------------------------------------------------------

-- Select files in the installation directory, whose path contains "math" , sorted by file size.
-- The "length" message is sent to the item and the returned result is used as a key for sorting.
   .file~new(installdir())~listFiles~pipe(,
       .all["math"] caseless |,
       .sortWith[.MessageComparator~new("length/N")] |,
       .console dataflow {"length="item~length},
       )
source:23,(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\rxmath.dll) length=165376 


-- Same as above, but simpler... You can sort directly by length, no need of MessageComparator
   .file~new(installdir())~listFiles~pipe(,
       .all["math"] caseless |,
       .sort {item~length} |,
       .console dataflow {"length="item~length},
       )
source:23,(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\rxmath.dll) length=165376 


-- Sort by file size, then by file extension (with only one .sort pipestage)
   .file~new(installdir())~listFiles~pipe(,
       .all["math"] caseless |,
       .sort {item~length} {filespec('e', item~name)} |,
       .console dataflow {"length="item~length},
       )
source:23,(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\rxmath.dll) length=165376 


-- ----------------------------------------------------------------------------
-- Various examples with collections and recursive processing
-- Illustration of the depthFirst vs breadthFirst options
-- ----------------------------------------------------------------------------

-- All instance methods of the context.
-- Notice that the default sort by item is useless here... Must sort by index.
   .context~instanceMethods~pipe(.sort byIndex | .console)
'' : (a Method)
' ' : (a Method)
'<>' : (a Method)
'=' : (a Method)
'==' : (a Method)
'><' : (a Method)
'ARGS' : (a Method)
'CLASS' : (a Method)
'COACTIVEPIPE' : (a Method)
'COACTIVEPIPEPROFILE' : (a Method)
'CONDITION' : (a Method)
'COPY' : (a Method)
'COPY' : (a Method)
'DEFAULTNAME' : (a Method)
'DEPTH' : (a Method)
'DIGITS' : (a Method)
'DISCLOSE' : (a Method)
'DUMP2' : (a Method)
'EACH' : (a Method)
'ENCLOSE' : (a Method)
'EXECUTABLE' : (a Method)
'FORM' : (a Method)
'FUZZ' : (a Method)
'GENERATE' : (a Method)
'GENERATEI' : (a Method)
'GETUSERDATA' : (a Method)
'HASHCODE' : (a Method)
'HASMETHOD' : (a Method)
'IDENTITYHASH' : (a Method)
'INIT' : (a Method)
'INSTANCEMETHOD' : (a Method)
'INSTANCEMETHODS' : (a Method)
'ISA' : (a Method)
'ISINSTANCEOF' : (a Method)
'LINE' : (a Method)
'NAME' : (a Method)
'NAMEDARGS' : (a Method)
'OBJECTNAME' : (a Method)
'OBJECTNAME=' : (a Method)
'PACKAGE' : (a Method)
'PARENTCONTEXT' : (a Method)
'PIPE' : (a Method)
'PIPEPROFILE' : (a Method)
'PP2' : (a Method)
'PPINDEX2' : (a Method)
'PPSTRING' : (a Method)
'RANK' : (a Method)
'REQUEST' : (a Method)
'RESHAPE' : (a Method)
'RS' : (a Method)
'RUN' : (a Method)
'SEND' : (a Method)
'SENDWITH' : (a Method)
'SETARGS' : (a Method)
'SETMETHOD' : (a Method)
'SETMETHOD1' : (a Method)
'SETUSERDATA' : (a Method)
'SHAPE' : (a Method)
'SHAPETOSTRING' : (a Method)
'STACKFRAMES' : (a Method)
'START' : (a Method)
'STARTWITH' : (a Method)
'STRING' : (a Method)
'UNKNOWN' : (a Method)
'UNSETMETHOD' : (a Method)
'VARIABLES' : (a Method)
'\=' : (a Method)
'\==' : (a Method)
'||' : (a Method)


-- All private methods of the context.
   .context~instanceMethods~pipe(,
       .select {item~isPrivate} |,
       .sort byIndex |,
       .console,
       )
'RUN' : (a Method)
'SETMETHOD' : (a Method)
'UNSETMETHOD' : (a Method)


-- Instance methods of the specified classes (not including those inherited).
-- Each class is written in the pipeline, followed by the returned methods (option 'after').
   .array~of(.RexxContext, .Package, .Method)~pipe(,
       .inject after {item~instanceMethods(item~class)} iterateAfter memorize |,
       .sort byIndex {dataflow["source"]~item} |,
       .console dataflow,
       )
source:3,(The Method class) | inject:'!DEFINE_CLASS_METHOD',(a Method) 
source:3,(The Method class) | inject:'!DEFINE_METHODS',(a Method) 
source:3,(The Method class) | inject:'!REXXDEFINED',(a Method) 
source:3,v1=(The Method class) | inject:1,*v1 
source:3,(The Method class) | inject:'<>',(a Method) 
source:3,(The Method class) | inject:'=',(a Method) 
source:3,(The Method class) | inject:'==',(a Method) 
source:3,(The Method class) | inject:'><',(a Method) 
source:3,(The Method class) | inject:'ACTIVATE',(a Method) 
source:3,(The Method class) | inject:'BASECLASS',(a Method) 
source:3,(The Method class) | inject:'DEFAULTNAME',(a Method) 
source:3,(The Method class) | inject:'DEFINE',(a Method) 
source:3,(The Method class) | inject:'DELETE',(a Method) 
source:3,(The Method class) | inject:'ENHANCED',(a Method) 
source:3,(The Method class) | inject:'HASHCODE',(a Method) 
source:3,(The Method class) | inject:'ID',(a Method) 
source:3,(The Method class) | inject:'INHERIT',(a Method) 
source:3,(The Method class) | inject:'ISSUBCLASSOF',(a Method) 
source:3,(The Method class) | inject:'METACLASS',(a Method) 
source:3,(The Method class) | inject:'METHOD',(a Method) 
source:3,(The Method class) | inject:'METHODS',(a Method) 
source:3,(The Method class) | inject:'MIXINCLASS',(a Method) 
source:3,(The Method class) | inject:'QUERYMIXINCLASS',(a Method) 
source:3,(The Method class) | inject:'SUBCLASS',(a Method) 
source:3,(The Method class) | inject:'SUBCLASSES',(a Method) 
source:3,(The Method class) | inject:'SUPERCLASS',(a Method) 
source:3,(The Method class) | inject:'SUPERCLASSES',(a Method) 
source:3,(The Method class) | inject:'UNINHERIT',(a Method) 
source:3,(The Method class) | inject:'\=',(a Method) 
source:3,(The Method class) | inject:'\==',(a Method) 
source:2,v1=(The Package class) | inject:1,*v1 
source:2,(The Package class) | inject:'<>',(a Method) 
source:2,(The Package class) | inject:'=',(a Method) 
source:2,(The Package class) | inject:'==',(a Method) 
source:2,(The Package class) | inject:'><',(a Method) 
source:2,(The Package class) | inject:'ACTIVATE',(a Method) 
source:2,(The Package class) | inject:'BASECLASS',(a Method) 
source:2,(The Package class) | inject:'DEFAULTNAME',(a Method) 
source:2,(The Package class) | inject:'DEFINE',(a Method) 
source:2,(The Package class) | inject:'DELETE',(a Method) 
source:2,(The Package class) | inject:'ENHANCED',(a Method) 
source:2,(The Package class) | inject:'HASHCODE',(a Method) 
source:2,(The Package class) | inject:'ID',(a Method) 
source:2,(The Package class) | inject:'INHERIT',(a Method) 
source:2,(The Package class) | inject:'ISSUBCLASSOF',(a Method) 
source:2,(The Package class) | inject:'METACLASS',(a Method) 
source:2,(The Package class) | inject:'METHOD',(a Method) 
source:2,(The Package class) | inject:'METHODS',(a Method) 
source:2,(The Package class) | inject:'MIXINCLASS',(a Method) 
source:2,(The Package class) | inject:'QUERYMIXINCLASS',(a Method) 
source:2,(The Package class) | inject:'SUBCLASS',(a Method) 
source:2,(The Package class) | inject:'SUBCLASSES',(a Method) 
source:2,(The Package class) | inject:'SUPERCLASS',(a Method) 
source:2,(The Package class) | inject:'SUPERCLASSES',(a Method) 
source:2,(The Package class) | inject:'UNINHERIT',(a Method) 
source:2,(The Package class) | inject:'\=',(a Method) 
source:2,(The Package class) | inject:'\==',(a Method) 
source:1,v1=(The RexxContext class) | inject:1,*v1 
source:1,(The RexxContext class) | inject:'<>',(a Method) 
source:1,(The RexxContext class) | inject:'=',(a Method) 
source:1,(The RexxContext class) | inject:'==',(a Method) 
source:1,(The RexxContext class) | inject:'><',(a Method) 
source:1,(The RexxContext class) | inject:'ACTIVATE',(a Method) 
source:1,(The RexxContext class) | inject:'BASECLASS',(a Method) 
source:1,(The RexxContext class) | inject:'DEFAULTNAME',(a Method) 
source:1,(The RexxContext class) | inject:'DEFINE',(a Method) 
source:1,(The RexxContext class) | inject:'DELETE',(a Method) 
source:1,(The RexxContext class) | inject:'ENHANCED',(a Method) 
source:1,(The RexxContext class) | inject:'HASHCODE',(a Method) 
source:1,(The RexxContext class) | inject:'ID',(a Method) 
source:1,(The RexxContext class) | inject:'INHERIT',(a Method) 
source:1,(The RexxContext class) | inject:'ISSUBCLASSOF',(a Method) 
source:1,(The RexxContext class) | inject:'METACLASS',(a Method) 
source:1,(The RexxContext class) | inject:'METHOD',(a Method) 
source:1,(The RexxContext class) | inject:'METHODS',(a Method) 
source:1,(The RexxContext class) | inject:'MIXINCLASS',(a Method) 
source:1,(The RexxContext class) | inject:'QUERYMIXINCLASS',(a Method) 
source:1,(The RexxContext class) | inject:'SUBCLASS',(a Method) 
source:1,(The RexxContext class) | inject:'SUBCLASSES',(a Method) 
source:1,(The RexxContext class) | inject:'SUPERCLASS',(a Method) 
source:1,(The RexxContext class) | inject:'SUPERCLASSES',(a Method) 
source:1,(The RexxContext class) | inject:'UNINHERIT',(a Method) 
source:1,(The RexxContext class) | inject:'\=',(a Method) 
source:1,(The RexxContext class) | inject:'\==',(a Method) 


-- Methods (not inherited) of all the classes whose id starts with "R".
   .environment~pipe(,
       .select {item~isA(.class)} |,
       .select {item~id~caselessAbbrev('R') <> 0} |,
       .inject after {item~methods(item)} iterateAfter memorize |,
       .sort byIndex {dataflow["source"]~item} |,
       .console dataflow,
       )
source:'RELATION',v1=(The Relation class) | inject:1,*v1 
source:'RELATION',(The Relation class) | inject:'ALLAT',(a Method) 
source:'RELATION',(The Relation class) | inject:'ALLINDEX',(a Method) 
source:'RELATION',(The Relation class) | inject:'ALLINDEXES',(a Method) 
source:'RELATION',(The Relation class) | inject:'ALLITEMS',(a Method) 
source:'RELATION',(The Relation class) | inject:'AT',(a Method) 
source:'RELATION',(The Relation class) | inject:'DIFFERENCE',(a Method) 
source:'RELATION',(The Relation class) | inject:'EMPTY',(a Method) 
source:'RELATION',(The Relation class) | inject:'HASINDEX',(a Method) 
source:'RELATION',(The Relation class) | inject:'HASITEM',(a Method) 
source:'RELATION',(The Relation class) | inject:'INDEX',(a Method) 
source:'RELATION',(The Relation class) | inject:'INTERSECTION',(a Method) 
source:'RELATION',(The Relation class) | inject:'ISEMPTY',(a Method) 
source:'RELATION',(The Relation class) | inject:'ITEMS',(a Method) 
source:'RELATION',(The Relation class) | inject:'MAKEARRAY',(a Method) 
source:'RELATION',(The Relation class) | inject:'PUT',(a Method) 
source:'RELATION',(The Relation class) | inject:'READOBJECT',(a Method) 
source:'RELATION',(The Relation class) | inject:'REMOVE',(a Method) 
source:'RELATION',(The Relation class) | inject:'REMOVEALL',(a Method) 
source:'RELATION',(The Relation class) | inject:'REMOVEITEM',(a Method) 
source:'RELATION',(The Relation class) | inject:'SUBSET',(a Method) 
source:'RELATION',(The Relation class) | inject:'SUPPLIER',(a Method) 
source:'RELATION',(The Relation class) | inject:'UNION',(a Method) 
source:'RELATION',(The Relation class) | inject:'UNIQUEINDEXES',(a Method) 
source:'RELATION',(The Relation class) | inject:'WRITEOBJECT',(a Method) 
source:'RELATION',(The Relation class) | inject:'XOR',(a Method) 
source:'RELATION',(The Relation class) | inject:'[]',(a Method) 
source:'RELATION',(The Relation class) | inject:'[]=',(a Method) 
source:'REXXBLOCK',v1=(The RexxBlock class) | inject:1,*v1 
source:'REXXBLOCK',(The RexxBlock class) | inject:'COPY',(a Method) 
source:'REXXBLOCK',(The RexxBlock class) | inject:'KIND',(a Method) 
source:'REXXBLOCK',(The RexxBlock class) | inject:'PACKAGE',(a Method) 
source:'REXXBLOCK',(The RexxBlock class) | inject:'RAWEXECUTABLE',(a Method) 
source:'REXXBLOCK',(The RexxBlock class) | inject:'SOURCE',(a Method) 
source:'REXXBLOCK',(The RexxBlock class) | inject:'VARIABLES',(a Method) 
source:'REXXCONTEXT',v1=(The RexxContext class) | inject:1,*v1 
source:'REXXCONTEXT',(The RexxContext class) | inject:'ARGS',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'CONDITION',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'COPY',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'DIGITS',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'EXECUTABLE',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'FORM',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'FUZZ',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'LINE',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'NAME',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'NAMEDARGS',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'PACKAGE',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'PARENTCONTEXT',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'RS',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'SETARGS',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'STACKFRAMES',(a Method) 
source:'REXXCONTEXT',(The RexxContext class) | inject:'VARIABLES',(a Method) 
source:'REXXQUEUE',v1=(The RexxQueue class) | inject:1,*v1 
source:'REXXQUEUE',(The RexxQueue class) | inject:'DELETE',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'EMPTY',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'GET',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'INIT',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'LINEIN',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'LINEOUT',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'MAKEARRAY',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'PULL',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'PUSH',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'QUEUE',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'QUEUED',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'SAY',(a Method) 
source:'REXXQUEUE',(The RexxQueue class) | inject:'SET',(a Method) 
source:'REXXTEXT',v1=(The RexxText class) | inject:1,*v1 
source:'ROUTINE',v1=(The Routine class) | inject:1,*v1 
source:'ROUTINE',(The Routine class) | inject:'CALL',(a Method) 
source:'ROUTINE',(The Routine class) | inject:'CALLWITH',(a Method) 
source:'ROUTINE',(The Routine class) | inject:'PACKAGE',(a Method) 
source:'ROUTINE',(The Routine class) | inject:'SETSECURITYMANAGER',(a Method) 
source:'ROUTINE',(The Routine class) | inject:'SOURCE',(a Method) 


-- All packages that are visible from current context, including the current package (source of the pipeline).
   .context~package~pipe(,
       .inject after {item~importedPackages} iterateAfter recursive.memorize.cycle |,
       .console {'  '~copies(dataflow~length)} {.file~new(item~name)~name},
       )
     pipe_extension_test.rex 
     pipe_extension.cls 
       pipe.rex 
         profiling.cls 
       extensions.cls 
         coactivity.cls 
         generator.cls 
           coactivity.cls 
           functionals.cls 
             doers.cls 
               coactivity.cls 
         array.cls 
           infinity.cls 
             indeterminate.cls 
               novalue.cls 
             novalue.cls 
         collection.cls 
           array.cls 
             infinity.cls 
               indeterminate.cls 
                 novalue.cls 
               novalue.cls 
         complex.cls 
           novalue.cls 
         doers.cls 
           coactivity.cls 
         file.cls 
         indeterminate.cls 
           novalue.cls 
         infinity.cls 
           indeterminate.cls 
             novalue.cls 
           novalue.cls 
         string.cls 
         functionals.cls 
           doers.cls 
             coactivity.cls 
         logical.cls 
           doers.cls 
             coactivity.cls 
     rgf_util2_wrappers.rex 
       rgf_util2.rex 


-- Same as above, but in breadth-first order
   .context~package~pipe(,
       .inject after {item~importedPackages} iterateAfter recursive.breadthFirst.memorize.cycle |,
       .console {'  '~copies(dataflow~length)} {.file~new(item~name)~name},
       )
     pipe_extension_test.rex 
     pipe_extension.cls 
     rgf_util2_wrappers.rex 
       pipe.rex 
       extensions.cls 
       rgf_util2.rex 
         profiling.cls 
         coactivity.cls 
         generator.cls 
         array.cls 
         collection.cls 
         complex.cls 
         doers.cls 
         file.cls 
         indeterminate.cls 
         infinity.cls 
         string.cls 
         functionals.cls 
         logical.cls 
           coactivity.cls 
           functionals.cls 
           infinity.cls 
           array.cls 
           novalue.cls 
           coactivity.cls 
           novalue.cls 
           indeterminate.cls 
           novalue.cls 
           doers.cls 
           doers.cls 
             doers.cls 
             indeterminate.cls 
             novalue.cls 
             infinity.cls 
             novalue.cls 
             coactivity.cls 
             coactivity.cls 
               coactivity.cls 
               novalue.cls 
               indeterminate.cls 
               novalue.cls 
                 novalue.cls 


-- ----------------------------------------------------------------------------
-- .take pipeStage
-- ----------------------------------------------------------------------------

-- The .take pipeStage lets stop the preceding pipeStages when the number of items to take
-- has been reached, whatever its position in the pipeline.
-- Note the "" at the end of the first .console. This is an indicator to not insert a newline.
   supplier = .array~of(1,2,3,4,5,6,7,8,9)~supplier
   supplier~pipe(.console "2*" item "=" "" | .do {return 2*item} | .take 2 | .console item)
2* 1 =  2 
2* 2 =  4 
   say supplier~index -- this is the index of the last processed item
2
   supplier~next -- skip the last processed item
   supplier~pipe(.console "4*" item "=" "" | .do {return 4*item} | .take 4 | .console item)
4* 3 =  12 
4* 4 =  16 
4* 5 =  20 
4* 6 =  24 
   say supplier~index
6


-- Display the 4 first sorted items
   .array~of(5, 8, 1, 3, 6, 2)~pipe(.sort | .take 4 | .console)
3 : 1
6 : 2
4 : 3
1 : 5


-- Sort the 4 first items
   .array~of(5, 8, 1, 3, 6, 2)~pipe(.take 4 | .sort | .console)
3 : 1
4 : 3
1 : 5
2 : 8


-- Select files in the installation directory, whose name contains "rexx".
-- Note : the .select is not equivalent to .all["rexx"], because .select tests only the name,
-- whereas .all tests the string representation of the item, which is the absolute path.
-- Take the 15 firsts.
   .file~new(installdir())~listFiles~pipe(,
       .select {item~name~caselessPos('rexx') <> 0} |,
       .take 15 |,
       .console,
       )
10 : (C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\orexxole.dll)
11 : (C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\rexx.dll)
12 : (C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\rexx.exe)
13 : (C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\rexx.ico)
14 : (C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\rexx.img)
15 : (C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\rexxapi.dll)
16 : (C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\rexxc.exe)
17 : (C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\rexxhide.exe)
18 : (C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\rexxpaws.exe)
19 : (C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\rexxtry.rex)
20 : (C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\rexxutil.dll)


-- ----------------------------------------------------------------------------
-- .append pipeStage
-- ----------------------------------------------------------------------------

-- The .append pipeStage copies items from its primary input to its primary output, and then invokes
-- the producer passed as argument and writes the items produced by that producer to its primary output.
-- If the producer is a doer, then the producer is executed to get the effective producer.
-- If the effective producer understands the message "supplier" then each pair (item, index)
-- returned by the supplier is appended.
-- Otherwise, the effective producer is appended as-is (single object) with local index 1.
   supplier1 = .array~of(1,2,3,4,5,6,7,8,9)~supplier
   supplier2 = .array~of(10,11,12,13,14,15,16,17,18,19)~supplier
-- The first .take limits supplier1 to 2 items.
-- The second .take sees the two items produced by supplier1, so only 3 items are accepted from supplier2.
   supplier1~pipe(.take 2 | .append supplier2 iterate | .take 5 | .console)
1 : 1
2 : 2
1 : 10
2 : 11
3 : 12
   say supplier1~index
2
   say supplier2~index
3
   supplier1~next
   supplier2~next
   supplier1~pipe(.take 4 | .append supplier2 iterate | .take 9 | .console)
3 : 3
4 : 4
5 : 5
6 : 6
4 : 13
5 : 14
6 : 15
7 : 16
8 : 17
   say supplier1~index
6
   say supplier2~index
8


-- ----------------------------------------------------------------------------
-- pipeStages which support partitions
-- ----------------------------------------------------------------------------

-- Drop the first item
   .array~of(1,1,1,2,2,2,3,3,3,1,1,1)~pipe(.drop | .console)
2 : 1
3 : 1
4 : 2
5 : 2
6 : 2
7 : 3
8 : 3
9 : 3
10 : 1
11 : 1
12 : 1


-- Drop the first item of each partition
   .array~of(1,1,1,2,2,2,3,3,3,1,1,1)~pipe(.drop {item} | .console)
2 : 1
3 : 1
5 : 2
6 : 2
8 : 3
9 : 3
11 : 1
12 : 1


-- Drop the last item
   .array~of(1,1,1,2,2,2,3,3,3,1,1,1)~pipe(.drop last | .console)
1 : 1
2 : 1
3 : 1
4 : 2
5 : 2
6 : 2
7 : 3
8 : 3
9 : 3
10 : 1
11 : 1


-- Drop the last item of each partition
   .array~of(1,1,1,2,2,2,3,3,3,1,1,1)~pipe(.drop last {item} | .console)
1 : 1
2 : 1
4 : 2
5 : 2
7 : 3
8 : 3
10 : 1
11 : 1


   datas = .directory~new
   datas["key1"] = .array~of("header", 1, 2, "footer")
   datas["key2"] = .array~of("header", 5, 3, -9, 12, "footer")
   datas["key3"] = .array~of("header", 4, 6, 5, "footer")


-- The whole datas, including headers and footers
   datas~pipe(.inject {item} iterateBefore memorize | .console)
1 : 'header'
2 : 1
3 : 2
4 : 'footer'
1 : 'header'
2 : 5
3 : 3
4 : -9
5 : 12
6 : 'footer'
1 : 'header'
2 : 4
3 : 6
4 : 5
5 : 'footer'


-- The datas without the headers and footers
   datas~pipe(.inject {item} iterateBefore memorize | .drop first {dataflow["source"]~item } | .drop last {dataflow["source"]~item } | .console)
2 : 1
3 : 2
2 : 5
3 : 3
4 : -9
5 : 12
2 : 4
3 : 6
4 : 5


-- No partition here, so the whole set of words is written twice, separated by "==="
   .array~of("one two three","un deux trois")~pipe(.words | .buffer[2, "==="] | .console)
1 : 'one'
2 : 'two'
3 : 'three'
1 : 'un'
2 : 'deux'
3 : 'trois'
1 : '==='
1 : 'one'
2 : 'two'
3 : 'three'
1 : 'un'
2 : 'deux'
3 : 'trois'


-- There is a partition on the source items, so there is a separator "===" between each set of words extracted from each string
   .array~of("one two three","un deux trois")~pipe(.words memorize | .buffer[2, "==="] {dataflow["source"]~item} | .console)
1 : 'one'
2 : 'two'
3 : 'three'
1 : '==='
1 : 'one'
2 : 'two'
3 : 'three'
1 : '==='
1 : 'un'
2 : 'deux'
3 : 'trois'
1 : '==='
1 : 'un'
2 : 'deux'
3 : 'trois'


-- ----------------------------------------------------------------------------
-- .fanout, .fanin, .merge pipeStages
-- ----------------------------------------------------------------------------

-- Here, only the output from fanout1 is sent to console.
   fanout1 = .left[3]  memorize | .lower memorize
   fanout2 = .right[3] memorize | .upper memorize | .inject after {"my_"item}
   .array~of("aaaBBB", "CCCddd", "eEeFfF")~pipe(.fanout memorize >> fanout2 > fanout1 | .console dataflow item)
source:1,v1='aaaBBB' | fanout:1,*v1 | left:1,v2='aaa' | lower:1,*v2 'aaa' 
source:2,v1='CCCddd' | fanout:2,*v1 | left:1,'CCC' | lower:1,'ccc' 'ccc' 
source:3,v1='eEeFfF' | fanout:3,*v1 | left:1,'eEe' | lower:1,'eee' 'eee' 


-- Here, each branch of the fanout remains separated. Each branch has its own console.
   fanout1 = .left[3]  memorize | .lower memorize | .console dataflow item
   fanout2 = .right[3] memorize | .upper memorize | .inject after {"my_"item} | .console dataflow item
   .array~of("aaaBBB", "CCCddd", "eEeFfF")~pipe(.fanout memorize >> fanout2 > fanout1)
source:1,v1='aaaBBB' | fanout:1,*v1 | left:1,v2='aaa' | lower:1,*v2 'aaa' 
source:1,v1='aaaBBB' | fanout:1,*v1 | right:1,v2='BBB' | upper:1,*v2 'BBB' 
source:1,v1='aaaBBB' | fanout:1,*v1 | right:1,v2='BBB' | upper:1,*v2 'my_BBB' 
source:2,v1='CCCddd' | fanout:2,*v1 | left:1,'CCC' | lower:1,'ccc' 'ccc' 
source:2,v1='CCCddd' | fanout:2,*v1 | right:1,'ddd' | upper:1,'DDD' 'DDD' 
source:2,v1='CCCddd' | fanout:2,*v1 | right:1,'ddd' | upper:1,'DDD' 'my_DDD' 
source:3,v1='eEeFfF' | fanout:3,*v1 | left:1,'eEe' | lower:1,'eee' 'eee' 
source:3,v1='eEeFfF' | fanout:3,*v1 | right:1,'FfF' | upper:1,'FFF' 'FFF' 
source:3,v1='eEeFfF' | fanout:3,*v1 | right:1,'FfF' | upper:1,'FFF' 'my_FFF' 


-- Here, a fanin is used to serialize the branches of the fanout.
-- The output from fanout1 is sent to console, then the output from fanout2 (delayed)
   fanin = .fanin memorize | .console dataflow item
   fanout1 = .left[3]  memorize | .lower memorize | fanin  -- not bufferized
   fanout2 = .right[3] memorize | .upper memorize | .inject after {"my_"item} | .secondaryConnector | fanin -- bufferized until fanout1 is eof
   .array~of("aaaBBB", "CCCddd", "eEeFfF")~pipe(.fanout memorize >> fanout2 > fanout1)
source:1,v1='aaaBBB' | fanout:1,*v1 | left:1,v2='aaa' | lower:1,*v2 | fanin:1,*v2 'aaa' 
source:2,v1='CCCddd' | fanout:2,*v1 | left:1,'CCC' | lower:1,v2='ccc' | fanin:1,*v2 'ccc' 
source:3,v1='eEeFfF' | fanout:3,*v1 | left:1,'eEe' | lower:1,v2='eee' | fanin:1,*v2 'eee' 
source:1,v1='aaaBBB' | fanout:1,*v1 | right:1,v2='BBB' | upper:1,*v2 | fanin:1,*v2 'BBB' 
source:1,v1='aaaBBB' | fanout:1,*v1 | right:1,v2='BBB' | upper:1,*v2 | fanin:1,'my_BBB' 'my_BBB' 
source:2,v1='CCCddd' | fanout:2,*v1 | right:1,'ddd' | upper:1,v2='DDD' | fanin:1,*v2 'DDD' 
source:2,v1='CCCddd' | fanout:2,*v1 | right:1,'ddd' | upper:1,'DDD' | fanin:1,'my_DDD' 'my_DDD' 
source:3,v1='eEeFfF' | fanout:3,*v1 | right:1,'FfF' | upper:1,v2='FFF' | fanin:1,*v2 'FFF' 
source:3,v1='eEeFfF' | fanout:3,*v1 | right:1,'FfF' | upper:1,'FFF' | fanin:1,'my_FFF' 'my_FFF' 

-- Here, a merge is used to serialize the branches of the fanout.
-- There is no specific order (no delay).
   merge = .merge memorize | .console dataflow item
   fanout1 = .left[3]  memorize | .lower memorize | merge  -- not bufferized
   fanout2 = .right[3] memorize | .upper memorize | .inject after {"my_"item} | .secondaryConnector | merge -- not bufferized
   .array~of("aaaBBB", "CCCddd", "eEeFfF")~pipe(.fanout memorize >> fanout2 > fanout1)
source:1,v1='aaaBBB' | fanout:1,*v1 | left:1,v2='aaa' | lower:1,*v2 | merge:1,*v2 'aaa' 
source:1,v1='aaaBBB' | fanout:1,*v1 | right:1,v2='BBB' | upper:1,*v2 | merge:1,*v2 'BBB' 
source:1,v1='aaaBBB' | fanout:1,*v1 | right:1,v2='BBB' | upper:1,*v2 | merge:1,'my_BBB' 'my_BBB' 
source:2,v1='CCCddd' | fanout:2,*v1 | left:1,'CCC' | lower:1,v2='ccc' | merge:1,*v2 'ccc' 
source:2,v1='CCCddd' | fanout:2,*v1 | right:1,'ddd' | upper:1,v2='DDD' | merge:1,*v2 'DDD' 
source:2,v1='CCCddd' | fanout:2,*v1 | right:1,'ddd' | upper:1,'DDD' | merge:1,'my_DDD' 'my_DDD' 
source:3,v1='eEeFfF' | fanout:3,*v1 | left:1,'eEe' | lower:1,v2='eee' | merge:1,*v2 'eee' 
source:3,v1='eEeFfF' | fanout:3,*v1 | right:1,'FfF' | upper:1,v2='FFF' | merge:1,*v2 'FFF' 
source:3,v1='eEeFfF' | fanout:3,*v1 | right:1,'FfF' | upper:1,'FFF' | merge:1,'my_FFF' 'my_FFF' 


-- ----------------------------------------------------------------------------
-- .fileTree pipeStage
-- ----------------------------------------------------------------------------

-- The *.cls files of ooRexx
   installdir()~pipe(,
       .fileTree recursive |,
       .endsWith[".cls"] |,
       .console,
       )
3 : (C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\csvStream.cls)
8 : (C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\json.cls)
9 : (C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\mime.cls)
22 : (C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\rxftp.cls)
25 : (C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\rxregexp.cls)
2 : (C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\samples\ole\methinfo\methinfo.cls)
31 : (C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\smtp.cls)
32 : (C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\socket.cls)
33 : (C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\streamsocket.cls)
34 : (C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\winsystm.cls)


-- Total number of lines in the *.cls files of ooRexx
   installdir()~pipe(,
       .fileTree recursive |,
       .endsWith[".cls"] |,
       .fileLines | .lineCount |,
       .console,
       )
(The NIL object) : 6124


-- Number of lines in each *.cls files of ooRexx
   installdir()~pipe(,
       .fileTree recursive memorize.file |,
       .endsWith[".cls"] |,
       .fileLines | .lineCount {dataflow["file"]~item} |,
       .console,
       )
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\csvStream.cls) : 490
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\json.cls) : 423
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\mime.cls) : 236
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\rxftp.cls) : 2028
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\rxregexp.cls) : 56
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\samples\ole\methinfo\methinfo.cls) : 71
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\smtp.cls) : 416
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\socket.cls) : 887
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\streamsocket.cls) : 409
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\winsystm.cls) : 1108


-- Total number of words in the *.cls files of ooRexx
   installdir()~pipe(,
       .fileTree recursive |,
       .endsWith[".cls"] |,
       .fileLines | .wordCount |,
       .console,
       )
(The NIL object) : 26226


-- Number of words in each *.cls files of ooRexx
   installdir()~pipe(,
       .fileTree recursive memorize.file |,
       .endsWith[".cls"] |,
       .fileLines | .wordCount {dataflow["file"]~item} |,
       .console,
       )
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\csvStream.cls) : 2105
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\json.cls) : 1481
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\mime.cls) : 955
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\rxftp.cls) : 7721
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\rxregexp.cls) : 397
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\samples\ole\methinfo\methinfo.cls) : 461
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\smtp.cls) : 1665
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\socket.cls) : 4598
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\streamsocket.cls) : 1660
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\winsystm.cls) : 5183


-- Total number of characters in the *.cls files of ooRexx (not counting the newline characters)
   installdir()~pipe(,
       .fileTree recursive |,
       .endsWith[".cls"] |,
       .fileLines | .charCount |,
       .console,
       )
(The NIL object) : 235726


-- Number of characters in each *.cls files of ooRexx (not counting the newline characters)
   installdir()~pipe(,
       .fileTree recursive memorize.file |,
       .endsWith[".cls"] |,
       .fileLines | .charCount {dataflow["file"]~item} |,
       .console,
       )
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\csvStream.cls) : 24470
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\json.cls) : 13111
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\mime.cls) : 11208
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\rxftp.cls) : 63947
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\rxregexp.cls) : 3433
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\samples\ole\methinfo\methinfo.cls) : 4146
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\smtp.cls) : 18255
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\socket.cls) : 43999
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\streamsocket.cls) : 18066
(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\winsystm.cls) : 35091


-- Alphanumeric words of 16+ chars found in the *.cls files of ooRexx.
-- Only the first two words per file are taken :
--     .take 2 {dataflow["file"]~item}
-- Here, the partition expression returns the current file object produced by the pipeStage "fileTree".
-- Exemple of result :
-- source:1,'d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/' | FILE:338,(d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32rel\winsystm.cls) | fileLines:250,'::method DeleteDesktopIcon' | words:2,'DeleteDesktopIcon' 'DeleteDesktopIcon'
-- "DeleteDesktopIcon" is the 2nd word of the 250th line of the file
-- "d:\local\Rexx\ooRexx\svn\sandbox\jlf\trunk\Win32dbg\winsystm.cls"
-- which is the 338th file/directory of the directory
-- "d:/local/Rexx/ooRexx/svn/sandbox/jlf/trunk/Win32rel/"
--
-- To investigate : I get sometimes a crash in the sort.
--
   call time('r') -- to see how long this takes
   installdir()~pipe(,
       .fileTree recursive memorize.file |,
       .endsWith[".cls"] |,
       .fileLines memorize | .words memorize | .select {item~datatype('a') & item~length >= 16} |,
       .take 2 {dataflow["file"]~item} | .sort caseless | .console dataflow item,
       )
source:1,'C:/jlf/local/rexx/oorexx/build/executor.master/sandbox/jlf/trunk/win/cl/release/64/delivery/' | FILE:34,(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\winsystm.cls) | fileLines:250,'::method DeleteDesktopIcon' | words:2,'DeleteDesktopIcon' 'DeleteDesktopIcon' 
source:1,'C:/jlf/local/rexx/oorexx/build/executor.master/sandbox/jlf/trunk/win/cl/release/64/delivery/' | FILE:3,(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\csvStream.cls) | fileLines:64,'::Attribute headerLineAbsent      private -- headersexist but absent' | words:2,'headerLineAbsent' 'headerLineAbsent' 
source:1,'C:/jlf/local/rexx/oorexx/build/executor.master/sandbox/jlf/trunk/win/cl/release/64/delivery/' | FILE:33,(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\streamsocket.cls) | fileLines:52,'::class 'StreamSocket' public subclass InputOutputStream' | words:5,'InputOutputStream' 'InputOutputStream' 
source:1,'C:/jlf/local/rexx/oorexx/build/executor.master/sandbox/jlf/trunk/win/cl/release/64/delivery/' | FILE:8,(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\json.cls) | fileLines:174,'    expose jsonString jsonPos jsonStringLength' | words:4,'jsonStringLength' 'jsonStringLength' 
source:1,'C:/jlf/local/rexx/oorexx/build/executor.master/sandbox/jlf/trunk/win/cl/release/64/delivery/' | FILE:3,(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\csvStream.cls) | fileLines:63,'::Attribute originalRawHeaders    private -- for comparison' | words:2,'originalRawHeaders' 'originalRawHeaders' 
source:1,'C:/jlf/local/rexx/oorexx/build/executor.master/sandbox/jlf/trunk/win/cl/release/64/delivery/' | FILE:8,(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\json.cls) | fileLines:130,'::method parseRexxDirectory private' | words:2,'parseRexxDirectory' 'parseRexxDirectory' 
source:1,'C:/jlf/local/rexx/oorexx/build/executor.master/sandbox/jlf/trunk/win/cl/release/64/delivery/' | FILE:34,(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\winsystm.cls) | fileLines:188,'/*********************************** WindowsProgramManager ****************************************/' | words:2,'WindowsProgramManager' 'WindowsProgramManager' 
   say "duration="time('e') -- elapsed duration
duration=1.045000


-- From here, some methods of the pipeline classes are instrumented to let profiling.
-- The performances are impacted because the profiled methods are instrumented with an additional forward.
   .pipeProfiler~instrument("start", "process", "eof", "isEOP")


-- Same as above, but with profiling
   call time('r') -- to see how long this takes
   installdir()~pipeProfile(,
       .fileTree recursive memorize.file |,
       .endsWith[".cls"] |,
       .fileLines memorize | .words memorize | .select {item~datatype('a') & item~length >= 16} |,
       .take 2 {dataflow["file"]~item} | .sort caseless | .console dataflow item,
       )
source:1,'C:/jlf/local/rexx/oorexx/build/executor.master/sandbox/jlf/trunk/win/cl/release/64/delivery/' | FILE:34,(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\winsystm.cls) | fileLines:250,'::method DeleteDesktopIcon' | words:2,'DeleteDesktopIcon' 'DeleteDesktopIcon' 
source:1,'C:/jlf/local/rexx/oorexx/build/executor.master/sandbox/jlf/trunk/win/cl/release/64/delivery/' | FILE:3,(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\csvStream.cls) | fileLines:64,'::Attribute headerLineAbsent      private -- headersexist but absent' | words:2,'headerLineAbsent' 'headerLineAbsent' 
source:1,'C:/jlf/local/rexx/oorexx/build/executor.master/sandbox/jlf/trunk/win/cl/release/64/delivery/' | FILE:33,(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\streamsocket.cls) | fileLines:52,'::class 'StreamSocket' public subclass InputOutputStream' | words:5,'InputOutputStream' 'InputOutputStream' 
source:1,'C:/jlf/local/rexx/oorexx/build/executor.master/sandbox/jlf/trunk/win/cl/release/64/delivery/' | FILE:8,(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\json.cls) | fileLines:174,'    expose jsonString jsonPos jsonStringLength' | words:4,'jsonStringLength' 'jsonStringLength' 
source:1,'C:/jlf/local/rexx/oorexx/build/executor.master/sandbox/jlf/trunk/win/cl/release/64/delivery/' | FILE:3,(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\csvStream.cls) | fileLines:63,'::Attribute originalRawHeaders    private -- for comparison' | words:2,'originalRawHeaders' 'originalRawHeaders' 
source:1,'C:/jlf/local/rexx/oorexx/build/executor.master/sandbox/jlf/trunk/win/cl/release/64/delivery/' | FILE:8,(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\json.cls) | fileLines:130,'::method parseRexxDirectory private' | words:2,'parseRexxDirectory' 'parseRexxDirectory' 
source:1,'C:/jlf/local/rexx/oorexx/build/executor.master/sandbox/jlf/trunk/win/cl/release/64/delivery/' | FILE:34,(C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\winsystm.cls) | fileLines:188,'/*********************************** WindowsProgramManager ****************************************/' | words:2,'WindowsProgramManager' 'WindowsProgramManager' 
----------------------------------------
.fileTree~go
  .fileTree~PROCESS count=1 duration=2.920000
    .endsWith~ISEOP count=334 duration=0.001000
    .endsWith~PROCESS count=167 duration=2.842000
      .fileLines~ISEOP count=177 duration=0
      .fileLines~PROCESS count=10 duration=2.837000
        .words~ISEOP count=12268 duration=0.015000
        .words~PROCESS count=6124 duration=2.478000
          .select~ISEOP count=58576 duration=0.075000
          .select~PROCESS count=26226 duration=0.999000
            .take~ISEOP count=26258 duration=0.024000
            .take~PROCESS count=32 duration=0.005000
              .sort~ISEOP count=39 duration=0
              .sort~PROCESS count=7 duration=0
  .fileTree~START count=1 duration=0
    .endsWith~START count=1 duration=0
      .fileLines~START count=1 duration=0
        .words~START count=1 duration=0
          .select~START count=1 duration=0
            .take~START count=1 duration=0
              .sort~START count=1 duration=0
                .console~START count=1 duration=0
  .endsWith~EOF count=1 duration=0.010000
    .fileLines~EOF count=1 duration=0.010000
      .words~EOF count=1 duration=0.010000
        .select~EOF count=1 duration=0.010000
          .take~EOF count=1 duration=0.010000
            .sort~EOF count=1 duration=0.010000
              .console~EOF count=1 duration=0
              .console~ISEOP count=14 duration=0
              .console~PROCESS count=7 duration=0.009000
duration=2.930000
----------------------------------------
   say "duration="time('e') -- elapsed duration
duration=3.071000


   say installdir() ; say
C:/jlf/local/rexx/oorexx/build/executor.master/sandbox/jlf/trunk/win/cl/release/64/delivery/


Ended coactivities: 0
