
-- The coactivity yields two results.
-- The hello outputs are not in the pipeline flow (not displayed by the .displayer).
.coactivity~new{echo hello ; .yield[a] ; say hello ; .yield[b]}~pipe(.upper|.displayer)
HELLO
1 : A
HELLO
2 : B


-- A collection can be sorted by value (default)
.array~of(b, a, c)~pipe(.sort byValue | .displayer)
2 : A
1 : B
3 : C


-- ...or by index
.array~of(b, a, c)~pipe(.sort byIndex | .displayer)
1 : B
2 : A
3 : C


-- ...ascending (default)
-- The order of options is important : a value option is impacted only by the preceding options
-- This is because several value options can be specified, and a sort is made for each.
.array~of(b, a, c)~pipe(.sort ascending byValue | .displayer)
2 : A
1 : B
3 : C


-- ...descending
.array~of(b, a, c)~pipe(.sort descending byValue | .displayer)
3 : C
1 : B
2 : A


-- ...by index descending
-- The order of options is important : an index option is impacted only by the preceding options.
-- This is because several index options can be specified, and a sort is made for each.
.array~of(b, a, c)~pipe(.sort descending byIndex | .displayer)
3 : C
2 : A
1 : B


-- ...caseless (stable by default)
.array~of("bb", "AA", "bB", "Aa", "Bb", "aA", "BB", "aa")~pipe(.sort caseless byValue | .displayer)
2 : AA
4 : Aa
6 : aA
8 : aa
1 : bb
3 : bB
5 : Bb
7 : BB


-- ...caseless quickSort (unstable)
.array~of("bb", "AA", "bB", "Aa", "Bb", "aA", "BB", "aa")~pipe(.sort caseless quickSort byValue | .displayer)
2 : AA
4 : Aa
6 : aA
8 : aa
1 : bb
3 : bB
5 : Bb
7 : BB


-- Sort descending with a comparator.
-- The DescendingComparator use the default CompareTo, which is made on values.
.array~of(b, a, c)~pipe(.sortWith[.DescendingComparator~new] | .displayer)
3 : C
1 : B
2 : A


-- Sort by column with a comparator.
.array~of("c:2", "b:2", "A:2", "c:1", "a:1", "B:1", "C:3")~pipe(,
    .sortWith[.InvertingComparator~new(.CaselessColumnComparator~new(3,1))] |,
    .sortWith[.CaselessColumnComparator~new(1,1)] |,
    .displayer,
    )
3 : A:2
5 : a:1
2 : b:2
6 : B:1
7 : C:3
1 : c:2
4 : c:1


-- Do something for each item (no returned value).
.array~of(1, 2, 3)~pipe(.do {say 'value='value 'index='index} | .displayer)
value=1 index=an Array
1 : 1
value=2 index=an Array
2 : 2
value=3 index=an Array
3 : 3


-- Do something for each item (the returned result replaces the item's value).
.array~of(1, 2, 3)~pipe(.do {return 2*value} | .displayer)
1 : 2
2 : 4
3 : 6


-- Inject a value for each item (the returned value is appended). 
-- The index of the injected value is pushed on the current index.
.array~of(1, 2, 3)~pipe(.inject {value*10} pushIndex append | .displayer)
1 : 1
1|1 : 10
2 : 2
2|1 : 20
3 : 3
3|1 : 30


-- Inject two values for each item (each item of the returned collection is written in the pipe).
.array~of(1, 2, 3)~pipe(.inject {.array~of(value*10, value*20)} pushIndex append | .displayer)
1 : 1
1|1 : 10
1|2 : 20
2 : 2
2|1 : 20
2|2 : 40
3 : 3
3|1 : 30
3|2 : 60


-- Each injected value can be used as input to inject a new value, recursively.
-- The default order is depth-first.
-- If the recursion is infinite, must specify a limit (here 0, 1 and 2).
-- The option 'append' is not used, so the initial value is discarded.
.array~of(1, 2, 3)~pipe(.inject {value*10} pushIndex recursive.0 | .displayer)
1|1 : 10
2|1 : 20
3|1 : 30
.array~of(1, 2, 3)~pipe(.inject {value*20} pushIndex recursive.1| .displayer)
1|1 : 20
1|1|1 : 400
2|1 : 40
2|1|1 : 800
3|1 : 60
3|1|1 : 1200
.array~of(1, 2, 3)~pipe(.inject {value*30} pushIndex recursive.2 | .displayer)
1|1 : 30
1|1|1 : 900
1|1|1|1 : 27000
2|1 : 60
2|1|1 : 1800
2|1|1|1 : 54000
3|1 : 90
3|1|1 : 2700
3|1|1|1 : 81000


-- Factorial, no value injected for -1
-- The option 'pushIndex' is not used, so the index remains made of one value.
.array~of(-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9)~pipe(.inject {
    use arg n
    if n < 0 then return
    if n == 0 then return 1
    return n * .context~executable~call(n - 1)} | .displayer)
2 : 1
3 : 1
4 : 2
5 : 6
6 : 24
7 : 120
8 : 720
9 : 5040
10 : 40320
11 : 362880


-- Select files whose name contains "rexx" in c:\program files\oorexx
.file~new("c:\program files\oorexx")~listFiles~pipe(,
    .select {value~name~caselessPos('rexx') <> 0} |,
    .displayer,
    )
11 : c:\program files\oorexx\ooRexxTry.rex
12 : c:\program files\oorexx\orexxole.cls
13 : c:\program files\oorexx\orexxole.dll
14 : c:\program files\oorexx\rexx.dll
15 : c:\program files\oorexx\rexx.exe
16 : c:\program files\oorexx\rexx.ico
17 : c:\program files\oorexx\rexx.img
18 : c:\program files\oorexx\rexxapi.dll
19 : c:\program files\oorexx\rexxc.exe
20 : c:\program files\oorexx\rexxhide.exe
21 : c:\program files\oorexx\rexxpaws.exe
22 : c:\program files\oorexx\rexxtry.rex
23 : c:\program files\oorexx\rexxutil.dll


-- Select files whose name contains "rexx" in c:\program files\oorexx, sorted by file size.
-- The "length" message is sent to the value.
.file~new("c:\program files\oorexx")~listFiles~pipe(,
    .select {value~name~caselessPos('rexx') <> 0} |,
    .sortWith[.MessageComparator~new("length/N")] |,
    .displayer,
    )
16 : c:\program files\oorexx\rexx.ico
12 : c:\program files\oorexx\orexxole.cls
22 : c:\program files\oorexx\rexxtry.rex
11 : c:\program files\oorexx\ooRexxTry.rex
20 : c:\program files\oorexx\rexxhide.exe
19 : c:\program files\oorexx\rexxc.exe
15 : c:\program files\oorexx\rexx.exe
21 : c:\program files\oorexx\rexxpaws.exe
13 : c:\program files\oorexx\orexxole.dll
18 : c:\program files\oorexx\rexxapi.dll
23 : c:\program files\oorexx\rexxutil.dll
17 : c:\program files\oorexx\rexx.img
14 : c:\program files\oorexx\rexx.dll


-- Same as above, but simpler... You can sort directly by length, no need of MessageComparator
.file~new("c:\program files\oorexx")~listFiles~pipe(,
    .select {value~name~caselessPos('rexx') <> 0} |,
    .sort {value~length} |,
    .displayer,
    )
16 : c:\program files\oorexx\rexx.ico
12 : c:\program files\oorexx\orexxole.cls
22 : c:\program files\oorexx\rexxtry.rex
11 : c:\program files\oorexx\ooRexxTry.rex
20 : c:\program files\oorexx\rexxhide.exe
19 : c:\program files\oorexx\rexxc.exe
15 : c:\program files\oorexx\rexx.exe
21 : c:\program files\oorexx\rexxpaws.exe
13 : c:\program files\oorexx\orexxole.dll
18 : c:\program files\oorexx\rexxapi.dll
23 : c:\program files\oorexx\rexxutil.dll
17 : c:\program files\oorexx\rexx.img
14 : c:\program files\oorexx\rexx.dll


-- Sort by file size, then by file extension (with only one .sort pipestage)
.file~new("c:\program files\oorexx")~listFiles~pipe(,
    .select {value~name~caselessPos('rexx') <> 0} |,
    .sort {value~length} {filespec('e', value~name)} |,
    .displayer,
    )
12 : c:\program files\oorexx\orexxole.cls
13 : c:\program files\oorexx\orexxole.dll
18 : c:\program files\oorexx\rexxapi.dll
23 : c:\program files\oorexx\rexxutil.dll
14 : c:\program files\oorexx\rexx.dll
20 : c:\program files\oorexx\rexxhide.exe
19 : c:\program files\oorexx\rexxc.exe
15 : c:\program files\oorexx\rexx.exe
21 : c:\program files\oorexx\rexxpaws.exe
16 : c:\program files\oorexx\rexx.ico
17 : c:\program files\oorexx\rexx.img
22 : c:\program files\oorexx\rexxtry.rex
11 : c:\program files\oorexx\ooRexxTry.rex


-- All instance methods of the context.
-- Notice that the default sort by value is useless here... Must sort by index.
.context~instanceMethods~pipe(.sort byIndex | .displayer)
 : a Method
  : a Method
<> : a Method
= : a Method
== : a Method
>< : a Method
ARGS : a Method
CLASS : a Method
CONDITION : a Method
COPY : a Method
COPY : a Method
DEFAULTNAME : a Method
DIGITS : a Method
DUMP2 : a Method
EXECUTABLE : a Method
FORM : a Method
FUZZ : a Method
HASHCODE : a Method
HASMETHOD : a Method
IDENTITYHASH : a Method
INIT : a Method
INSTANCEMETHOD : a Method
INSTANCEMETHODS : a Method
ISA : a Method
ISINSTANCEOF : a Method
LINE : a Method
OBJECTNAME : a Method
OBJECTNAME= : a Method
PACKAGE : a Method
PIPE : a Method
PP2 : a Method
PPINDEX2 : a Method
REQUEST : a Method
RS : a Method
RUN : a Method
SEND : a Method
SENDWITH : a Method
SETMETHOD : a Method
START : a Method
STARTWITH : a Method
STRING : a Method
UNSETMETHOD : a Method
VARIABLES : a Method
\= : a Method
\== : a Method
|| : a Method


-- All private methods of the context.
.context~instanceMethods~pipe(,
    .select {value~isPrivate} |,
    .sort byIndex |,
    .displayer,
    )
RUN : a Method
SETMETHOD : a Method
UNSETMETHOD : a Method


-- Instance methods of the specified classes (not including those inherited).
-- Each class is written in the pipeline (option append), followed by the returned methods.
-- The option pushIndex lets have the name of the method in the index.
.array~of(.RexxContext, .Package, .Method)~pipe(,
    .inject {value~instanceMethods(value~class)} append pushIndex |,
    .sort byIndex |,
    .displayer,
    )
1 : The RexxContext class
1|<> : a Method
1|= : a Method
1|== : a Method
1|>< : a Method
1|BASECLASS : a Method
1|DEFAULTNAME : a Method
1|DEFINE : a Method
1|DELETE : a Method
1|ENHANCED : a Method
1|HASHCODE : a Method
1|ID : a Method
1|INHERIT : a Method
1|ISSUBCLASSOF : a Method
1|METACLASS : a Method
1|METHOD : a Method
1|METHODS : a Method
1|MIXINCLASS : a Method
1|QUERYMIXINCLASS : a Method
1|SUBCLASS : a Method
1|SUBCLASSES : a Method
1|SUPERCLASS : a Method
1|SUPERCLASSES : a Method
1|UNINHERIT : a Method
1|\= : a Method
1|\== : a Method
2 : The Package class
2|<> : a Method
2|= : a Method
2|== : a Method
2|>< : a Method
2|BASECLASS : a Method
2|DEFAULTNAME : a Method
2|DEFINE : a Method
2|DELETE : a Method
2|ENHANCED : a Method
2|HASHCODE : a Method
2|ID : a Method
2|INHERIT : a Method
2|ISSUBCLASSOF : a Method
2|METACLASS : a Method
2|METHOD : a Method
2|METHODS : a Method
2|MIXINCLASS : a Method
2|QUERYMIXINCLASS : a Method
2|SUBCLASS : a Method
2|SUBCLASSES : a Method
2|SUPERCLASS : a Method
2|SUPERCLASSES : a Method
2|UNINHERIT : a Method
2|\= : a Method
2|\== : a Method
3 : The Method class
3|!DEFINE_CLASS_METHOD : a Method
3|!DEFINE_METHODS : a Method
3|!REXXDEFINED : a Method
3|<> : a Method
3|= : a Method
3|== : a Method
3|>< : a Method
3|BASECLASS : a Method
3|DEFAULTNAME : a Method
3|DEFINE : a Method
3|DELETE : a Method
3|ENHANCED : a Method
3|HASHCODE : a Method
3|ID : a Method
3|INHERIT : a Method
3|ISSUBCLASSOF : a Method
3|METACLASS : a Method
3|METHOD : a Method
3|METHODS : a Method
3|MIXINCLASS : a Method
3|QUERYMIXINCLASS : a Method
3|SUBCLASS : a Method
3|SUBCLASSES : a Method
3|SUPERCLASS : a Method
3|SUPERCLASSES : a Method
3|UNINHERIT : a Method
3|\= : a Method
3|\== : a Method


-- Methods (not inherited) of all the classes whose id starts with "R".
.environment~pipe(,
    .select {value~isA(.class)} |,
    .select {value~id~caselessAbbrev('R') <> 0} |,
    .inject {value~methods(value)} append pushIndex |,
    .sort byIndex |,
    .displayer,
    )
RELATION : The Relation class
RELATION|ALLAT : a Method
RELATION|ALLINDEX : a Method
RELATION|ALLINDEXES : a Method
RELATION|ALLITEMS : a Method
RELATION|AT : a Method
RELATION|DIFFERENCE : a Method
RELATION|EMPTY : a Method
RELATION|HASINDEX : a Method
RELATION|HASITEM : a Method
RELATION|INDEX : a Method
RELATION|INTERSECTION : a Method
RELATION|ISEMPTY : a Method
RELATION|ITEMS : a Method
RELATION|MAKEARRAY : a Method
RELATION|PUT : a Method
RELATION|READOBJECT : a Method
RELATION|REMOVE : a Method
RELATION|REMOVEALL : a Method
RELATION|REMOVEITEM : a Method
RELATION|SUBSET : a Method
RELATION|SUPPLIER : a Method
RELATION|UNION : a Method
RELATION|WRITEOBJECT : a Method
RELATION|XOR : a Method
RELATION|[] : a Method
RELATION|[]= : a Method
REXXCONTEXT : The RexxContext class
REXXCONTEXT|ARGS : a Method
REXXCONTEXT|CONDITION : a Method
REXXCONTEXT|COPY : a Method
REXXCONTEXT|DIGITS : a Method
REXXCONTEXT|EXECUTABLE : a Method
REXXCONTEXT|FORM : a Method
REXXCONTEXT|FUZZ : a Method
REXXCONTEXT|LINE : a Method
REXXCONTEXT|PACKAGE : a Method
REXXCONTEXT|RS : a Method
REXXCONTEXT|VARIABLES : a Method
REXXCONTEXTUALSOURCE : The RexxContextualSource class
REXXCONTEXTUALSOURCE|CONTEXT : a Method
REXXCONTEXTUALSOURCE|COPY : a Method
REXXCONTEXTUALSOURCE|PACKAGE : a Method
REXXCONTEXTUALSOURCE|SOURCE : a Method
REXXCONTEXTUALSOURCE|SOURCE= : a Method
REXXQUEUE : The RexxQueue class
REXXQUEUE|DELETE : a Method
REXXQUEUE|EMPTY : a Method
REXXQUEUE|GET : a Method
REXXQUEUE|INIT : a Method
REXXQUEUE|LINEIN : a Method
REXXQUEUE|LINEOUT : a Method
REXXQUEUE|MAKEARRAY : a Method
REXXQUEUE|PULL : a Method
REXXQUEUE|PUSH : a Method
REXXQUEUE|QUEUE : a Method
REXXQUEUE|QUEUED : a Method
REXXQUEUE|SAY : a Method
REXXQUEUE|SET : a Method
ROUTINE : The Routine class
ROUTINE|CALL : a Method
ROUTINE|CALLWITH : a Method
ROUTINE|PACKAGE : a Method
ROUTINE|SETSECURITYMANAGER : a Method
ROUTINE|SOURCE : a Method


-- All packages that are visible from current context, including the current package (source of the pipeline).
.context~package~pipe(,
    .inject {value~importedPackages} recursive append pushIndex |,
    .displayer index.15,
               {'    '~copies(index~items)},
               {.file~new(value~name)~name},
               newline,
    )
1                  pipe_extension_test.rex
1|1                    extensions.cls
1|1|1                      doers.cls
1|1|2                      functionals.cls
1|1|2|1                        doers.cls
1|2                    coactivity.cls
1|2|1                      activity.cls
1|3                    pipe_extension.cls
1|3|1                      pipe.rex
1|3|2                      doers.cls
1|3|3                      coactivity.cls
1|3|3|1                        activity.cls
1|3|4                      rgf_util2_wrappers.rex
1|3|4|1                        rgf_util2.rex
1|4                    rgf_util2_wrappers.rex
1|4|1                      rgf_util2.rex


-- Same as above, but in breadth-first order
.context~package~pipe(,
    .inject {value~importedPackages} recursive.breadthFirst append pushIndex |,
    .displayer index.15,
               {'    '~copies(index~items)},
               {.file~new(value~name)~name},
               newline,
    )
1                  pipe_extension_test.rex
1|1                    extensions.cls
1|2                    coactivity.cls
1|3                    pipe_extension.cls
1|4                    rgf_util2_wrappers.rex
1|1|1                      doers.cls
1|1|2                      functionals.cls
1|2|1                      activity.cls
1|3|1                      pipe.rex
1|3|2                      doers.cls
1|3|3                      coactivity.cls
1|3|4                      rgf_util2_wrappers.rex
1|4|1                      rgf_util2.rex
1|1|2|1                        doers.cls
1|3|3|1                        activity.cls
1|3|4|1                        rgf_util2.rex


-- The .take pipeStage lets stop the preceding pipeStages when the number of items to take
-- has been reached, whatever its position in the pipeline.
supplier = .array~of(1,2,3,4,5,6,7,8,9)~supplier
supplier~pipe(.displayer "2*" value "=" | .do {return 2*value} | .take 2 | .displayer value newline)
2*1=2
2*2=4
say supplier~index
3
supplier~pipe(.displayer "4*" value "=" | .do {return 4*value} | .take 4 | .displayer value newline)
4*3=12
4*4=16
4*5=20
4*6=24
say supplier~index
7


-- Display the 4 first sorted items
.array~of(5, 8, 1, 3, 6, 2)~pipe(.sort | .take 4 | .displayer)
3 : 1
6 : 2
4 : 3
1 : 5


-- Sort the 4 first items
.array~of(5, 8, 1, 3, 6, 2)~pipe(.take 4 | .sort | .displayer)
3 : 1
4 : 3
1 : 5
2 : 8


-- The .append pipeStage copies items from its primary input to its primary output, and then invokes
-- the supplier passed as argument and writes the items produced by that supplier to its primary output.
supplier1 = .array~of(1,2,3,4,5,6,7,8,9)~supplier
supplier2 = .array~of(10,11,12,13,14,15,16,17,18,19)~supplier
-- The first .take limits supplier1 to 2 items.
-- The second .take sees the two items produced by supplier1, so only 3 items are accepted from supplier2.
supplier1~pipe(.take 2 | .append supplier2 | .take 5 | .displayer)
1 : 1
2 : 2
1 : 10
2 : 11
3 : 12
say supplier1~index
3
say supplier2~index
4
supplier1~pipe(.take 4 | .append supplier2 | .take 9 | .displayer)
3 : 3
4 : 4
5 : 5
6 : 6
4 : 13
5 : 14
6 : 15
7 : 16
8 : 17
say supplier1~index
7
say supplier2~index
9


-- Remove header and footer
.array~of("header", 1, 2 ,3 , "footer")~pipe(.drop first | .drop last | .displayer)
2 : 1
3 : 2
4 : 3


-- The *.txt files of ooRexx
"c:\program files\oorexx"~pipe(,
    .fileTree recursive |,
    .select {filespec('e', value~name) == 'txt'} |,
    .displayer,
    )
1 : c:\program files\oorexx\CPLv1.0.txt
1 : c:\program files\oorexx\doc\CHANGES.txt
1 : c:\program files\oorexx\doc\ReleaseNotes.txt
1 : c:\program files\oorexx\samples\api\readme.txt
1 : c:\program files\oorexx\samples\api\wpipe\readme.txt
1 : c:\program files\oorexx\samples\ole\oleinfo\help.txt
1 : c:\program files\oorexx\samples\oodialog\examples\readme.txt
1 : c:\program files\oorexx\samples\oodialog\wav\readme.txt


-- Alphanumeric words of 15+ chars found in the *.txt files of ooRexx.
--
-- Exemple of result :
-- 1|c:\program files\oorexx\CPLv1.0.txt|149|8 : appropriateness
-- "appropriateness" is the 8th word of the 149th line of the file  
-- "c:\program files\oorexx\CPLv1.0.txt"
--
-- To investigate : I get sometimes a crash in the sort.
--
"c:\program files\oorexx"~pipe(,
    .fileTree recursive |,
    .select {filespec('e', value~name) == 'txt'} |,
    .getFiles | .words | .select {value~datatype('a') & value~length >= 15} |,
    .sort caseless | .displayer,
    )
1|c:\program files\oorexx\CPLv1.0.txt|149|8 : appropriateness
1|c:\program files\oorexx\samples\ole\oleinfo\help.txt|56|10 : GetKnownMethods
1|c:\program files\oorexx\samples\ole\oleinfo\help.txt|60|1 : GetKnownMethods
1|c:\program files\oorexx\doc\ReleaseNotes.txt|146|1 : isCaseSensitive
1|c:\program files\oorexx\doc\ReleaseNotes.txt|162|1 : isCaseSensitive
1|c:\program files\oorexx\CPLv1.0.txt|84|8 : merchantability
1|c:\program files\oorexx\CPLv1.0.txt|148|2 : MERCHANTABILITY
1|c:\program files\oorexx\samples\api\readme.txt|27|8 : MERCHANTABILITY
1|c:\program files\oorexx\samples\api\wpipe\readme.txt|27|8 : MERCHANTABILITY
1|c:\program files\oorexx\samples\ole\oleinfo\help.txt|27|8 : MERCHANTABILITY
1|c:\program files\oorexx\samples\oodialog\examples\readme.txt|26|8 : MERCHANTABILITY
1|c:\program files\oorexx\samples\oodialog\wav\readme.txt|27|8 : MERCHANTABILITY
1|c:\program files\oorexx\samples\api\readme.txt|15|2 : Redistributions
1|c:\program files\oorexx\samples\api\readme.txt|17|2 : Redistributions
1|c:\program files\oorexx\samples\api\wpipe\readme.txt|15|2 : Redistributions
1|c:\program files\oorexx\samples\api\wpipe\readme.txt|17|2 : Redistributions
1|c:\program files\oorexx\samples\ole\oleinfo\help.txt|15|2 : Redistributions
1|c:\program files\oorexx\samples\ole\oleinfo\help.txt|17|2 : Redistributions
1|c:\program files\oorexx\samples\oodialog\examples\readme.txt|14|2 : Redistributions
1|c:\program files\oorexx\samples\oodialog\examples\readme.txt|16|2 : Redistributions
1|c:\program files\oorexx\samples\oodialog\wav\readme.txt|15|2 : Redistributions
1|c:\program files\oorexx\samples\oodialog\wav\readme.txt|17|2 : Redistributions
1|c:\program files\oorexx\CPLv1.0.txt|113|8 : responsibilities
1|c:\program files\oorexx\doc\CHANGES.txt|79|3 : RexxRegisterFunctionDLL
1|c:\program files\oorexx\doc\ReleaseNotes.txt|234|1 : SysGetservbyname
1|c:\program files\oorexx\doc\ReleaseNotes.txt|235|1 : SysGetservbyport
1|c:\program files\oorexx\doc\ReleaseNotes.txt|237|1 : SysGetsizeofptr
1|c:\program files\oorexx\samples\ole\oleinfo\help.txt|98|5 : VersionIndependentProgID
