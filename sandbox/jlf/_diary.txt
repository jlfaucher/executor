Sandbox for experimental work, some ideas to investigate :

Try to understand the internal locks.
--> added some dbgprintf (Windows and Linux), now must analyze...

Allow extension of the predefined ooRexx classes to get something similar to C# extension methods (but more powerful).
--> unlock the define method : see samples/functional for an example of use.
    unlock the inherit method
    added ::extension directive
    >>-::EXTENSION--classname----+-------------------+-----------------><
                                 +-INHERIT--iclasses-+

Add the "in" keyword to the DO repetitor : Similar to "over" but calls the method "supplier" instead of "makearray".
See if a thread could return more than one result and become a generator when synchronized with : do i in generator ...

Export the classes instantiated by the parser and make expression instances available from an ooRexx script. 
Inspired by C# LINQ and the expression tree API.
See if that can be used to write macros (i.e. transform expression tree), user directives, DSL...

Named parameters (by opposition to positional parameters). 
In C#, they say it's useful for calling COM services. 
I have some Excel macros that would be simpler to call with that.

Deferred evaluation of parameters. 
Let the routine/method decide which parameters must be evaluated, ex : iif(cond, iftrue, ifalse)

Investigate the Activation stack (reify ? closure ? continuation ?)

Unicode ?
--> added support for wide-chars in oodialog.


===============================================================================
2010 july 3

Continue Unicode review : added notes about Falcon.

Adapted ooRexxTry to use utf8 encoding and Arial Unicode MS.
Preloads all the main components (math, ftp, socket, bsf, hostemu, ...).


===============================================================================
2010 july 3

Debug crash in gc
RexxMemory::markObjectsMain
    markObject->live(liveMark);

0x003d2b8c                                          --> this is 0x7eee1ac0->behaviour
Access violation reading location 0x44414550        --> this is the vfptr of the behaviour of a string

((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*markObject))))).__vfptr


RexxMemory::mark(RexxObject *markObject)
    pushLiveStack((RexxObject *)markObject->behaviour);
markObject = 0x7eee1ac0                             --> see below, this is the 30th element of string array
    [RexxString]
               if tmp<2 then         -- start at first char
           
called by RexxArray::live(size_t liveMark)      ArrayClass.cpp
where this = 0x7f30ed70
this->objects = 7f30ed98
arrayPtr=7f30ee0c
0x7f30ee0c - 0x7f30ed98 = 116 = 29 * 4 --> this is the 30th element

element 1 to 13 : not a string... but doesn't be a problem
+		(*(RexxString*)this->get(14)).stringData	0x7eee36a4 "  len1=length(arg1string)        -- get length of string"	char [4]
+		(*(RexxString*)this->get(15)).stringData	0x7eee3704 "  newArr=.array~new        -- create new array for the arguments"	char [4]
+		(*(RexxString*)this->get(16)).stringData	0x7eee376c "  newArr[1]=new1string     -- "new"-string"	char [4]
+		(*(RexxString*)this->get(18)).stringData	0x7eee37e4 "  prepend=""               -- optional prepend string (if positioning before start!)"	char [4]
+		(*(RexxString*)this->get(20)).stringData	0x7eee388c "  arg2startori=arg2start         -- save passed-in value, if any"	char [4]
+		(*(RexxString*)this->get(21)).stringData	0x7eee38f4 "  if arg4pad=="" then arg4pad=" "-- define blank as the default pad char"	char [4]
+		(*(RexxString*)this->get(23)).stringData	0x7eee398c "  if arg(3,"Exists") then  -- start in "target"-string"	char [4]
+		(*(RexxString*)this->get(24)).stringData	0x7eee2dfc "  do"	char [4]
+		(*(RexxString*)this->get(25)).stringData	0x7eee2e2c "     if datatype(arg2start,"W") then"	char [4]
+		(*(RexxString*)this->get(26)).stringData	0x7eee2e7c "     do"	char [4]
+		(*(RexxString*)this->get(27)).stringData	0x7eee2eac "        if arg2start<0 then      -- negative, start from right"	char [4]
+		(*(RexxString*)this->get(28)).stringData	0x7eee2f14 "        do"	char [4]
+		(*(RexxString*)this->get(29)).stringData	0x7eee2f44 "           tmp=len1+arg2start+1  -- get starting position"	char [4]
+		(*(RexxString*)this->get(30)).stringData	0x7eee1ae4 "           if tmp<2 then         -- start at first char"	char [4]
+		(*(RexxString*)this->get(31)).stringData	0x7eee1b44 "           do"	char [4]
+		(*(RexxString*)this->get(32)).stringData	0x7eee1b7c "              if tmp<0 then"	char [4]

The behaviour of the 30th element is broken :
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(28))))).behaviour)))))).__vfptr	0x003aa62c const RexxBehaviour::`vftable'	*
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(29))))).behaviour)))))).__vfptr	0x003aa62c const RexxBehaviour::`vftable'	*
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(30))))).behaviour)))))).__vfptr	0x44414548	*
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(31))))).behaviour)))))).__vfptr	0x003aa62c const RexxBehaviour::`vftable'	*
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(32))))).behaviour)))))).__vfptr	0x003aa62c const RexxBehaviour::`vftable'	*

the behaviour of 30th element is stored at 0x7eee1acc


called by RexxMemory::markObjectsMain(RexxObject *rootObject)
where rootObject = 
+		rootObject	0x003d2a90 class RexxMemory memoryObject {markWord=1 markReason=1 variableCache=0x7f5b55a8 ...}	RexxObject *

called by RexxMemory::markObjects()

called by RexxMemory::collect()

objectclass.hpp
inline void   setBehaviour(RexxBehaviour *b) { behaviour = b; }         <-- this method is called to assign the behavior of type 22 (T_String)
>	rexx.dll!RexxInternalObject::setBehaviour(RexxBehaviour * b)  Line 265 + 0x10 bytes	C++
 	rexx.dll!RexxObject::initializeNewObject(unsigned int mark, void * vft, RexxBehaviour * b)  Line 362	C++
 	rexx.dll!RexxMemory::newObject(unsigned int requestLength, unsigned int type)  Line 1134	C++
 	rexx.dll!new_object(unsigned int s, unsigned int t)  Line 422 + 0x1e bytes	C++
 	rexx.dll!RexxString::newString(const char * string, unsigned int length)  Line 1894 + 0xd bytes	C++
 	rexx.dll!new_string(const char * s, unsigned int l)  Line 521	C++
 	rexx.dll!RexxSource::get(unsigned int _position)  Line 838 + 0x1d bytes	C++
 	rexx.dll!RexxSource::extractSource(SourceLocation & location)  Line 1119 + 0x10 bytes	C++                 <-- counter = 735
 	rexx.dll!RexxCode::getSource()  Line 199	C++
 	rexx.dll!BaseExecutable::source()  Line 149	C++
 	rexx.dll!CPPCode::run(RexxActivity * activity, RexxMethod * method, RexxObject * receiver, RexxString * messageName, RexxObject * * argPtr, unsigned int count, ProtectedObject & result)  Line 144 + 0x6 bytes	C++
 	rexx.dll!RexxMethod::run(RexxActivity * activity, RexxObject * receiver, RexxString * msgname, RexxObject * * argPtr, unsigned int count, ProtectedObject & result)  Line 325	C++
 	rexx.dll!RexxObject::messageSend(RexxString * msgname, RexxObject * * arguments, unsigned int count, ProtectedObject & result)  Line 793	C++
 	rexx.dll!RexxExpressionStack::send(RexxString * message, unsigned int count, ProtectedObject & result)  Line 74 + 0x33 bytes	C++
 	rexx.dll!RexxExpressionMessage::evaluate(RexxActivation * context, RexxExpressionStack * stack)  Line 139	C++
 	rexx.dll!RexxExpressionMessage::evaluate(RexxActivation * context, RexxExpressionStack * stack)  Line 123 + 0x23 bytes	C++
 	rexx.dll!RexxInstructionAssignment::execute(RexxActivation * context, RexxExpressionStack * stack)  Line 122 + 0x1d bytes	C++
 	rexx.dll!RexxActivation::run(RexxObject * _receiver, RexxString * msgname, RexxObject * * _arglist, unsigned int _argcount, RexxInstruction * start, ProtectedObject & resultObj)  Line 522	C++
 	rexx.dll!RexxCode::call(RexxActivity * activity, RoutineClass * routine, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, RexxString * calltype, RexxString * environment, int context, ProtectedObject & result)  Line 116	C++
 	rexx.dll!RexxCode::call(RexxActivity * activity, RoutineClass * routine, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, ProtectedObject & result)  Line 92	C++
 	rexx.dll!RoutineClass::call(RexxActivity * activity, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, ProtectedObject & result)  Line 234	C++
 	rexx.dll!InterpreterInstance::runRequires(RexxActivity * activity, RexxString * name, RoutineClass * code)  Line 877	C++
 	rexx.dll!InterpreterInstance::loadRequires(RexxActivity * activity, RexxString * shortName, RexxString * fullName)  Line 932	C++
 	rexx.dll!RexxSource::loadRequires(RexxActivity * activity, RexxString * target)  Line 6082 + 0x14 bytes	C++
 	rexx.dll!PackageClass::loadPackage(RexxString * name, RexxArray * s)  Line 366 + 0x16 bytes	C++             <-- rgf_util2.rex


The previous behaviour is overwritten by
inline void insertAfter(DeadObject *newDead)            DeadObject.hpp
where newDead = 7eee1ac0
 	rexx.dll!DeadObject::insertAfter(DeadObject * newDead)  Line 89	C++
 	rexx.dll!DeadObjectPool::add(DeadObject * obj)  Line 165	C++
>	rexx.dll!NormalSegmentSet::addDeadObject(char * object, unsigned int length)  Line 461	C++
 	rexx.dll!MemorySegmentSet::sweep()  Line 1170	C++
 	rexx.dll!RexxMemory::collect()  Line 1038	C++
 	rexx.dll!NormalSegmentSet::handleAllocationFailure(unsigned int allocationLength)  Line 1272	C++
 	rexx.dll!RexxMemory::newObject(unsigned int requestLength, unsigned int type)  Line 1117 + 0x12 bytes	C++ <-- length = 48, we are in "small object" part (lesser than LargeBlockThreshold 4096)
 	rexx.dll!new_object(unsigned int s, unsigned int t)  Line 422 + 0x1e bytes	C++
 	rexx.dll!RexxString::newString(const char * string, unsigned int length)  Line 1894 + 0xd bytes	C++
 	rexx.dll!new_string(const char * s, unsigned int l)  Line 521	C++
 	rexx.dll!new_string(const char * s, unsigned int l)  Line 521	C++
 	rexx.dll!RexxSource::get(unsigned int _position)  Line 838 + 0x1d bytes	C++
 	rexx.dll!RexxSource::extractSource(SourceLocation & location)  Line 1119 + 0x10 bytes	C++                 <-- counter = 754
 	rexx.dll!RexxCode::getSource()  Line 199	C++
 	rexx.dll!BaseExecutable::source()  Line 149	C++
 	rexx.dll!CPPCode::run(RexxActivity * activity, RexxMethod * method, RexxObject * receiver, RexxString * messageName, RexxObject * * argPtr, unsigned int count, ProtectedObject & result)  Line 144 + 0x6 bytes	C++
 	rexx.dll!RexxMethod::run(RexxActivity * activity, RexxObject * receiver, RexxString * msgname, RexxObject * * argPtr, unsigned int count, ProtectedObject & result)  Line 325	C++
 	rexx.dll!RexxObject::messageSend(RexxString * msgname, RexxObject * * arguments, unsigned int count, ProtectedObject & result)  Line 793	C++
 	rexx.dll!RexxExpressionStack::send(RexxString * message, unsigned int count, ProtectedObject & result)  Line 74 + 0x33 bytes	C++
 	rexx.dll!RexxExpressionMessage::evaluate(RexxActivation * context, RexxExpressionStack * stack)  Line 139	C++
 	rexx.dll!RexxExpressionMessage::evaluate(RexxActivation * context, RexxExpressionStack * stack)  Line 123 + 0x23 bytes	C++
 	rexx.dll!RexxInstructionAssignment::execute(RexxActivation * context, RexxExpressionStack * stack)  Line 122 + 0x1d bytes	C++
 	rexx.dll!RexxActivation::run(RexxObject * _receiver, RexxString * msgname, RexxObject * * _arglist, unsigned int _argcount, RexxInstruction * start, ProtectedObject & resultObj)  Line 522	C++
 	rexx.dll!RexxCode::call(RexxActivity * activity, RoutineClass * routine, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, RexxString * calltype, RexxString * environment, int context, ProtectedObject & result)  Line 116	C++
 	rexx.dll!RexxCode::call(RexxActivity * activity, RoutineClass * routine, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, ProtectedObject & result)  Line 92	C++
 	rexx.dll!RoutineClass::call(RexxActivity * activity, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, ProtectedObject & result)  Line 234	C++
 	rexx.dll!InterpreterInstance::runRequires(RexxActivity * activity, RexxString * name, RoutineClass * code)  Line 877	C++
 	rexx.dll!InterpreterInstance::loadRequires(RexxActivity * activity, RexxString * shortName, RexxString * fullName)  Line 932	C++
 	rexx.dll!RexxSource::loadRequires(RexxActivity * activity, RexxString * target)  Line 6082 + 0x14 bytes	C++
 	rexx.dll!PackageClass::loadPackage(RexxString * name, RexxArray * s)  Line 366 + 0x16 bytes	C++             <-- rgf_util2.rex
    while loading rgf_util2.rex
    
Why is 0x7eee1ac0 a dead object ? 
In RexxSource::extractSource, the array "source" is created, but is not a ProtectedObject.


===============================================================================
2010 may 15

Fix build under Windows for dbgprintf (link error).

Changed the build for "oodialog" target :
Builds both oodialogA and oodialogW (and not just oodialogA as before)
Ex :
makeorx BOTH oodialog clean --> cleans the debug & release files of oodialogA and oodialogW
makeorx BOTH oodialog       --> builds the debug & release files of oodialogA and oodialogW

Made a review of the conversions and removed those unneeded.
opts can remain byte-char.
strdupupr and strdupupr_nospace can remain byte-char.
setControlData can remain byte-char. The conversion is done internally.
putUnicodeText converts to wide-char, so no need to convert byte-char to wide-char before calling it (but keep the wide-char signature)


===============================================================================
2010 may 15

Added the function dbgprintf to write debug strings. 
Under Windows, it calls OutputDebugString.
Under Linux, it calls syslog.

Remember, typical debug session under Linux:
Open a console : 
    syslogd -S -C
    logread -f
    The output of syslog is displayed by logread in this console (lock management, on client and server side).
Open a console, launch rxapi. 
    Has been compiled to stay as a foreground process. 
    It sends debug strings to stderr, more easy to follow in this console (messages between client and server).
Open a console, run the rexx command. The two other consoles are updated with debug infos.


===============================================================================
2010 may 14

More work on wide-chars in oodialog.

Fixed a crash in the conversion A2W and W2A : The length must be asked to the Windows service,
and not calculated with bad assumptions as I did.


Something not clear to me : 
In oodMessaging.cpp, there is a message queue implemented as a string. 
Each element is separated by a special character 0xFF.
This message queue is declared rxcharT, so it's a wide-char string when building the wide-char configuration.
Several methods have a rexxMethod parameter, and I declared it rxcharT.
But normally, a method name is always a byte-char string, there is no need to convert it to wide-char...
Problem : if I declare it as rxcharA, then what should I do with the pMessageQueue ?
Can I declare it rxcharA ? in this case, I must encode wide-char to byte-char each time a message is added
Or is it better to keep it rxcharW ? Currently addDialogMessage takes two wide-char arguments...
It's a matter of conversion boundary...


The japanese characters are not properly displayed by MessageBox (i.e. InfoDialog).
It seems that under XP, one must install files for complex scripts.
Not needed under Vista.
--> go to the "Regional and Language Options" control panel, go to the "Languages" tab, 
and select "Install filesfor complex script...".
You need to reboot :-(
--> good, after reboot it works...


===============================================================================
2010 may 13

More work on wide-chars in oodialog.

New configuration names : oodialogA and oodialogW.
No longer needed to pass "WCHAR=1" to build the wide-char configuration.
makeorx DEBUG                   builds both configurations
makeorx DEBUG oodialogA         builds the byte-char configuration
makeorx DEBUG oodialogA clean   cleans the byte-char configuration
makeorx DEBUG oodialogW         builds the wide-char configuration
makeorx DEBUG oodialogW clean   cleans the wide-char configuration
makeorx DEBUG oodialog          like oodialogA

byte-char and wide-char configurations of oodialog are working, tested with oodialog examples.
There are some problems, but I have the same problems in trunk, so I assume there are some work in progress there...

Test of wide-char configuration :
It's not enough to put win32dbg/wchar in fromt of %PATH%, you must also rename
or remove win32dbg/oodialog.dll because it's this DLL which is loaded by default.
See unicode/ooRexx/oodtree.png for a screenshot with french, german, hebrew, russian, greek, etc...

Summary of the changes made to the oodtree example :
oodtree.rex, added : call setCodePage 65001 -- UTF-8
oodtree.rc, changed : FONT 8, "Arial Unicode MS"
oodtree.inp, added UTF-8 strings for demo


===============================================================================
2010 may 9

Added support for wide-chars in oodialog.
Currently, the "A" Windows API is called, and the conversion occurs there, inside Windows, based on the current locale.
When compiling ooDialog with wide chars UTF-16, the "W" API is called directly, making the dialogs Unicode-enabled.
GTK+ uses UTF-8 internally. Most of  the Unix-style operating systems use UTF-8 internally. 
So it's natural to use multi-byte chars in ooRexx instead of wide chars, and to provide string services which supports UTF-8.
But the case of ooDialog is different : 
This is a Windows-only sub-system, and for better integration with Windows, it must use UTF-16 chars internally. 
The conversion to UTF-16 is under the responsability of ooDialog, which lets support code pages that are different 
from the system's default code page. Typically, we can pass UTF-8 string to ooDialog which convert them to UTF-16 strings 
before calling the Windows "W" API.

By default, the byte-char configuration is built when buildling the whole interpreter :
makeorx DEBUG

To build the byte-char configuration only, enter :
makeorx DEBUG oodialog
or
makeorx DEBUG oodialog "WCHAR=0"


To clean the byte-char configuration, enter :
makeorx DEBUG oodialog clean
or
makeorx DEBUG oodialog clean "WCHAR=0"

To build the wide-char configuration, enter :
makeorx DEBUG oodialog "WCHAR=1"
The output files are generated in the subdirectory win32dbg\wchar

To clean the wide-char configuration, enter :
makeorx DEBUG oodialog clean "WCHAR=1"


===============================================================================
2010 april 28

rgf_util2 wrappers to make the services of Rony available as methods on predefined classes.
For proof of concept... For a real library of methods, rgf_util2 should be rewritten to use
the variable "self" where appropriate, instead of passing the object as first parameter.



===============================================================================
2010 april 25

Add ::extension directive
todo : Limit the extension to new methods, raise an error if redefining a predefined method
(but keep ~define unlocked for investigation).

todo : I don't manage dependencies on ExtensionDirective
See RexxSource::resolveDependencies, there is maybe something to do there.
Currently, if the same method is extended several times, then it's the "last" extension who wins...
The definition of "last" depends on the order of resolution of ::requires
See samples\extension\test_extension_order.rex

Remember : 
Unlike ::class, you can have several ::extension in the same source for the same class. 
So the current check for duplicate method in an ExtensionDirective is not very useful. 
The interpreter will complain for that :
::extension object
::method m
::method m
but not for that :
::extension object
::method m
::extension object
::method m


===============================================================================
2010 april 24

Unlock ~define


Creation of sandbox :
cd D:\local\Rexx\ooRexx\svn\sandbox
mkdir jlf
svn add jlf
svn commit jlf
svn copy https://oorexx.svn.sourceforge.net/svnroot/oorexx/main/trunk https://oorexx.svn.sourceforge.net/svnroot/oorexx/sandbox/jlf
svn update jlf

rev 5812
merge 5812-5835 from main/trunk
merge 5835-5957 from main/trunk
merge 5957-5988 from main/trunk