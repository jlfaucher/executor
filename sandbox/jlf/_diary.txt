Sandbox for experimental work, some ideas to investigate :

Try to understand the internal locks.
--> added some dbgprintf (Windows and Linux), now must analyze...

Allow extension of the predefined ooRexx classes to get something similar to C# extension methods (but more powerful).
--> unlock the define method : see samples/functional for an example of use.
    unlock the inherit method
    added ::extension directive
    >>-::EXTENSION--classname----+-------------------+-----------------><
                                 +-INHERIT--iclasses-+

Add the "in" keyword to the DO repetitor : Similar to "over" but calls the method "supplier" instead of "makearray".

See if a thread could return more than one result and become a generator when synchronized with : do i in generator ...
--> done with .Coactivity

Export the classes instantiated by the parser and make expression instances available from an ooRexx script. 
Inspired by C# LINQ and the expression tree API.
See if that can be used to write macros (i.e. transform expression tree), user directives, DSL...

Named parameters (by opposition to positional parameters). 
In C#, they say it's useful for calling COM services. 
I have some Excel macros that would be simpler to call with that.
--> I started to think about that, but it appears that the ooRexx arguments are not easy to manage by name.
It's because the arguments are not declared in a single place at the begining of a procedure/routine/method.
They can be declared several times, and complex expressions can be used (stem, instance's attribute, ...).
Moreover, named arguments can be passed in any order, and that's a problem with current management by array.
So, I give up...

Deferred evaluation of parameters. 
Let the routine/method decide which parameters must be evaluated, ex : iif(cond, iftrue, ifalse)

Investigate the Activation stack (reify ? closure ? continuation ?)

Unicode ?
--> added support for wide-chars in oodialog.
--> in progress : m17n (but this is not the way proposed by Rick)

Extension of the message term : keyword and multiple dispatch.
http://atomo-lang.org/
http://slatelanguage.org/

Tracer todo :
Add support for classic trace (without multithread infos).
The CSV format can be useful for classic trace, because each line has the name of the current executable.

Pipes todo :
.inject in breadthFirst mode is not limited by the ooRexx callstack size.
Do the same for depthFirst mode.
1~pipe(.inject {2*value} rec.869 | .take last | .console) is ok, but if you do one more recursion, 
you get the error "Insufficient control stack space; cannot continue execution"
No such problem in breadthFirst mode :
1~pipe(.inject {2*value} rec.b.100000 | .take last | .console) --> last result is 1.99800307E+30103

Pipes todo :
Add partition support to .stemCollector, .arrayCollector
For .arrayCollector, the collected values will be arrays.
For .stemCollector, I don't know.
Is .stemCollector really needed ? I don't see the added value, compared to .arrayCollector

Pipes todo (maybe)
.index_value~of and .value_index~of returns a table of user-defined indexed values.
But a table is not an ordered collection, so the indexed values injected in the pipeline are
not necessarily in the order given by the user. 
Could fix that by returning an array of .IndexedValue.

Coactivity todo :
The arguments passed to the coactivity with resume should be available like traditional
arguments (use arg...). Currently they are returned by yield as an array.

Extension todo :
Review the extension mechanisms :
- An extension made on .Object is not available on a class.
  There is a workaround in pipe_extensions.cls.
- An extension made on .Object is not available on the .nil object.
  No workaround so far.


===============================================================================
2011 nov 07

[coactivity]
The LazyCoactivitySupplier no longer needs an unit method.


[GC]
Added testcase2.rex for uninit which covers both cases :
step 1 : call only predefined functions/methods --> no uninit called during the loop
step 2 : call only user-defined procedures/routines/methods --> uninit called during the loop


===============================================================================
2011 nov 06

[coactivity]

By default, a coactivity is no longer started when created.
Now automatically started by the first resume, if not yet started.

Spent several hours for nothing, trying to use WeakReferences for the global cache
of coactivities. I was hopping to get an automatic end of coactivity when this
coactivity is no longer referenced by a client. But the tests demonstrated that a
started coactivity can't be GC'ed, even if no longer referenced by a client. I suppose
it's because of the method ~start which is running on its own thread, and the self
variable references the coactivity, thus keeping it alive...

There is a way to auto-end a coactivity : just use a wrapper object whose sole
responsibility is to end the coactivity when itself is GC'ed. This is what is already
doing LazyCoactivitySupplier, and that works as expected.
Now using two distinct classes :
- .Coactivity for the wrapper instance.
- .CoactivityObj for the wrapped instance.
Maybe I could use only one class (.Coactivity) to create both the wrapper and the
wrapped instances. Will see, but for the moment, I think the code is more clear
with two classes (despite the forwarding methods on .Coactivity).
Examples of auto-ending coactivies (to test from ooRexxShell) :
    .coactivity~new{i=0; do forever; i+=1; .yield[i]; end}~makeArray(5)=
        # 1: index=[1] -> item=[1]
        # 2: index=[2] -> item=[2]
        # 3: index=[3] -> item=[3]
        # 4: index=[4] -> item=[4]
        # 5: index=[5] -> item=[5]
    #Coactivities: 1                -- still active but no longer reachable, not yet GC'ed
    .coactivity~new{i=0; do forever; i+=1; .yield[i]; end}~pipe(.take 5 | .console)
        (a Coactivity),1 : 1
        (a Coactivity),2 : 2
        (a Coactivity),3 : 3
        (a Coactivity),4 : 4
        (a Coactivity),5 : 5
    #Coactivities: 2                -- still active but no longer reachable, not yet GC'ed
    do 10000 ; .object~new ; end    -- force a GC
    #Coactivities: 0                -- both coactivities have been ended by uninit


[GC]
The work on WeakReferences showed that the calls to uninit methods are impacted by
the use of a security manager (was detected from ooRexxShell which has a security
manager) : more "reactive", i.e. the uninit methods are called during the execution
and not just when the interpreter is halting.
Added samples/gc/testcase1 and several outputs.
Added internals/notes/uninit.txt (code review and various notes)
Added some verbose messages in the interpreter to trace the calls to uninit.
(remember : in trunk/lib/orxwin32.mak, add /DVERBOSE_GC at the end of cflags_common)


[functional]
Modified the ~each methods to always return an array, even if no result collected
(in this case, the returned array is empty). This is more consistent for the caller,
no need to test if a result was returned or not.


===============================================================================
2011 nov 04

[coactivity]

Fixed a deadlock.
(see concurrency/deadlock3.rex for the description of the test case)
The minimal fix was to declare .RoutineDoer~do and ~doWith unguarded.
But I declared unguarded all the methods in doers.cls and functional.cls that don't
modify the state of the self object. I hope this is the right strategy to follow...

According to my tests, a predefined method which is declared guarded is never locked.
But a user-defined method which is declared guarded is locked, as expected.
See :
concurrency/guarded_predefined_method_are_not_locked.rex
concurrency/guarded_user-defined_method_are_locked.rex


Changed the behaviour of ~makeArray, now working like the pipestage .take :
c = 1000~times.yield
c~makeArray(5)
    # 1: index=[1] -> item=[1]
    # 2: index=[2] -> item=[2]
    # 3: index=[3] -> item=[3]
    # 4: index=[4] -> item=[4]
    # 5: index=[5] -> item=[5]
c~makeArray(5)
    # 1: index=[1] -> item=[6]
    # 2: index=[2] -> item=[7]
    # 3: index=[3] -> item=[8]
    # 4: index=[4] -> item=[9]
    # 5: index=[5] -> item=[10]
etc...


[pipes]
I see a loss of performance (twice longer) in the profiled pipeline at the end of
pipe_extension_test.output.txt, and I can't find why...
    7048    20.485   dbg (ok, dbg config is slower due to semaphores tracing)
    7078     8.281   rel
    7086     8.781   rel
    7112     8.531   rel
    7139     8.265   rel
    7154     8.828   rel
    7172     8.953   rel
    7246     8.953   rel
    current 17.936   rel
Made a rebuild of the binaries at revision 7123 : same loss of performance.
Made a test with samples at revision 7048 : no longer adapted to current binaries
(RexxContextualSource source is no longer a string, but an array).
Made a test with samples at revision 7080 : same loss of performance (using current
binaries or rev 7123).
Added a non-profiled version of the same pipeline, with duration, to detect if a similar
loss of performance happens in the future with non-profiled code.


===============================================================================
2011 oct 30

Each call to an external function (like SysXxx functions) triggers a communication 
with the rxapi server through a socket (QUERY_MACRO, to test is the function is
defined in the macrospace).
This has a major impact on performance !
Example with .yield[] which calls SysGetTid() or SysQueryProcess("TID") at each call :
    10000 calls to .yield[] with macrospace enabled  : 2.1312
    10000 calls to .yield[] with macrospace disabled : 0.4531
(samples/benchmark/doers-benchmark-output.txt)
So I decided to add an option to control the use of macrospace :
    ::options MACROSPACE
    ::options NOMACROSPACE
    options "MACROSPACE"
    options "NOMACROSPACE"
By default, the macrospace is queried, according to the rules described in rexxref
section "7.2.1 Search order".
When using the option NOMACROSPACE, the macrospace is not queried.


Yet something to investigate (no relation with rxapi) : Under WinXP, a call to a routine
is much slower than a run of a method (sandbox or main - same results) :
    10000 calls of an empty routine by name : 0.2422
    10000 calls of an empty routine object  : 0.2437
    10000 runs of an empty method           : 0.0141
Under MacOsX, no such difference :
    10000 calls of an empty routine by name : 0.0103
    10000 calls of an empty routine object  : 0.0104
    10000 runs of an empty method           : 0.0087
(samples/benchmark/call-benchmark.rexx)
 

===============================================================================
2011 oct 26

Fixed a crash in relation with RexxContextualSource and GC :
Must mark objectVariables.

Fixed a crash in hostemu for Windows platform :
Must add RexxEntry in the declaration of GrxHost.


===============================================================================
2011 oct 23

[doers]

Currently {::coactivity ...} always create a routine from the source literal.
But a method can be also a coactivty.
Assuming 'coactive' is like an option for the directives ::method and ::routine,
I added the following tags :
::routine myRoutine coactive  --> tag = ::r[outine][.c[oactive]]
::method myMethod coactive    --> tag = ::m[ethod][.c[oactive]]

The following declarations are equivalent :
{::c[oactivity] ...}
{::r[outine].c[oactive] ...}

Example of coactive method :
c={::m.c self~each{.yield[arg(1)]}}~doer(.array~of(1,2,3))
c~do -- returns 1
c~do -- returns 2
c~do -- returns 3
The object is the array.
The method is {::m self~each{.yield[arg(1)]}} where self is the array.

Something to think about :
When the doer is a method, the object on which the method is applied is passed as
first argument of ~do. And the rest of the arguments are passed to the method in
arg(1), arg(2), ...
    {::m say self~class ":" arg(1)}~doer~do(.array~new, "2nd arg") -- The Array class : 2nd arg
is implemented by
    .array~new~run(doer, "i", "2nd arg")
When the doer is a coactive method, the object on which the method is applied is
passed using ~doer and memorized by the coactivity. That makes sense since the method
can yield several result, and it's the same object which is used at each resume.
But then, the ~do method has less arguments.
    {::m.c say self~class ":" arg(1)}~doer(.array~new)~do("1st arg") -- The Array class : 1st arg
Internally, the call to the method is the same as a normal method, but with this test that I have
only in coactivity (for the moment) :
    if doer~needsObject then doer~doWith(object, arguments) -- object needed (message, method)
    else doer~doWith(arguments) -- no object needed (routine)
I could modify .MethodDoer~doer to pass the object with ~doer. But that breaks a lot of code.
And I would need to do the same for StringDoer~doer (a .Message is sent to an object,
the object is passed as first argument of ~do).
    say "+"~doer~do(1,2) -- here, 1 is the object : 1~send("+", 2)
Will see on usage if this difference of parameters between a method and a coactive method
is effectively a problem or not...


[functional]

Simplification :
I follow the same approach than for pipes, by transforming the source literals
to add the parameters value and index.
For reduce, three parameters are passed : accu, value, index.
A difference with pipes, when calling the doer~do method, I pass the index only if
~functionDoer exists on the doer. That lets use messages like "+" with reduce.
The current pipe implementation does not support doers of type message (and will
never do), because strings are recognized as options, not as doers.

Consequence :
reduceI, reduceCI, reduceWI, mapI, mapCI, mapWI, mapRI, mapCRI, mapWRI, eachI, eachCI, eachWI : removed
eachII, eachCII, eachWII : renamed respectively eachI, eachCI, eachWI


===============================================================================
2011 oct 18

I just discovered that I have a conflict on the ~doer method for .Coactivity :
In coactivity.cls, "doer" is a private attribute
In doers.cls, "doer" is a public method on CoactivityDoer.

After thoughts, I find that using ::attribute for a private object variable is probably
a wrong decision. With expose, no risk of such conflict.
-->
Now using expose.


Added the method 'executable' to give access to the routine or method controlled by the
coactivity.


===============================================================================
2011 oct 16


[functional]

Refactoring of ~reduce, ~map and ~each :
- Since a parameter "options" is supported by ~reduce and ~map, I could remove
  ~reduceChar ~reduceWord ~mapChar ~mapWord, and pass an option "char" or "word"
  to the methods ~reduce and ~map.
  After experimentation, I think it's not a good idea. More verbose to write, and
  sometimes must omit parameters.
  The reading of http://en.wikipedia.org/wiki/Fold_(higher-order_function) convinced
  me to have different methods names, using one letter for each option, including the
  "indexed" and "inplace" options, "inplace" being renamed "replace".
  Consequence : the parameter "options" is removed.
- ~map allowed to update in-place, but the design decisions was not good... I limited
  this option to collections which understand ~append, because I wanted to support 
  deletion (filtering) of items. But that's a bad idea, better to not allow deletion
  and use []= for assignment. That will work with any collection, including multi-
  dimensional arrays.
- String and MutableBuffer are a special case, where ~append is more appropriate for
  implementing ~map. Filtering is supported.
- ~map and ~each had overlapping features. Now, these methods have distinct usage :
  The result returned by ~map has the same type as the self object.
  The result returned by ~each is either an array or no result (if procedural action).
  ~map can be in-place, ~each is never in-place.
  ~map can't filter collections, ~each can filter collections.
- ~each must be available on String and MutableBuffer. The result is an array or no result.
  
In summary :
(update JLF 23 oct 2011 : the xxxI methods have been removed, the xxxII methods have been renamed xxxI)
                reduce   reduceC   reduceW   map   mapC   mapW   mapR   mapCR   mapWR   each    eachC    eachW
                reduceI  reduceCI  reduceWI  mapI  mapCI  mapWI  mapRI  mapCRI  mapWRI  eachI   eachCI   eachWI
                                                                                        eachII  eachCII  eachWII
.String         ............X.........X..............X......X......................................X........X...
.MutableBuffer  ............X.........X..............X......X.............X.......X................X........X...
.Array          ...X..........................X....................X......................X.....................
.Bag            ...X..........................X....................X......................X.....................
.CircularQueue  ...X..........................X....................X......................X.....................
.Directory      ...X..........................X....................X......................X.....................
.List           ...X..........................X....................X......................X.....................
.Properties     ...X..........................X....................X......................X.....................
.Queue          ...X..........................X....................X......................X.....................
.Relation       ...X..........................X....................X......................X.....................
.Set            ...X..........................X....................X......................X.....................
.Stem           ...X..........................X....................X......................X.....................
.Table          ...X..........................X....................X......................X.....................
.IdentityTable  ...X..........................X....................X......................X.....................
.Supplier       ...X......................................................................X.....................
.Coactivity     ...X......................................................................X.....................

Reduce on non-ordered collections will give good results only with commutative operations.
Ex : any collection can be reduced with "+", but only ordered collections should be reduced with "-".

Experimental : I search my way to implement lazy iterators using coactivities.
I created additional methods like 
    ~times.yield
    ~yield.upto
    ~yield.downto
They work as expected, but having to create a new method to manage the coactivity sounds not good.
Especially if I want to do the same for the ~each methods (21 methods to add...).
So far, I see these possibilities :
    1~yield.upto(10){arg(1)}   -- Current implementation, with a distinct method which creates the coactivity and delegates to ~upto which yields each value.
    1~upto(10, .true){arg(1)}  -- Pass a boolean to ask for a coactivity. The coactivity and the yield are managed by ~upto.
    1~upto(10){.yield[arg(1)]} -- The yield is done by the doer. Problem : ~upto has no way to know that a coactivity must be created...
                               -- ...unless the doer "knows" it contains a yield, and ~upto can test that...
According to what I see in Python, the interpreter automatically creates a generator when a yield is in the code of a function.
At the first call of the function, the generator object is returned.
    def countdown(n):
        print "Counting down from", n
        while n > 0:
            yield n
            n -= 1
    >>> x = countdown(10)
    >>> x
    <generator object at 0x58490>
    >>>
So it looks similar to the third solution. Except that in the Python example, the loop and the yield are in the same function.
In the case of ~upto, the loop and the yield are not in the same routine. 


===============================================================================
2011 oct 02

{ooRexx parser]

For good or bad reason, arg(1) at the begining of a clause is recognized as an
instruction, because arg is a keyword instruction.
I often use source literals like {arg(1)...} where I want arg(1) to be interpreted
as a function call. So I decided to change the behavior of the parser to interpret
as a function call any symbol followed immediatly by a left paren, even if the
symbol is a keyword instruction.

With implicit return, such an expression is quite common when filtering : value==1
    .array~of(1,2,1)~pipe(.select {value==1} | .console)
but the parser raises an error to protect the user against a potential typo error,
assuming the user wanted to enter : value=1.
I deactivated this control, now the expression above is ok.
Yes, it remains a problem (no syntax error, but it's an assignment, not a test) : 
    .array~of(1,2,1)~pipe(.select {value=1} | .console)
good point, the lack of returned value is detected, must surround by parentheses
to make it a real expression.
    .array~of(1,2,1)~pipe(.select {(value=1)} | .console)
(an Array),1 : 1
(an Array),3 : 1


[functional]

reduce : added optional initial value
123~reduceChar("+")                    -- initial value is the first char (default), returns 6
123~reduceChar(100, "+")               -- initial value is 100, returns 106
"10 20 30"~reduceWord("+")             -- initial value is the first word (default), returns 60
"10 20 30"~reduceWord(100, "+")        -- initial value is 100, returns 160
.array~of(10, 20, 30)~reduce("+")      -- initial value is the first item (default), returns 60
.array~of(10, 20, 30)~reduce(100, "+") -- initial value is 100, returns 160

(update JLF 16 oct 2011 : 'option' parameter removed)
reduce : added option "ind[exed]"
    arg(1) : accumulated result
    arg(2) : current item of collection
    arg(3) : current index of collection, passed only if option "ind[exed]" is specified
"10 20 30"~reduceWord(, "ind"){arg(1) + arg(2) + arg(3)}         -- initial value is the first word (default), index passed as 3rd argument, returns 10 + 20+2 + 30+3 = 65
"10 20 30"~reduceWord(0, "ind"){arg(1) + arg(2) + arg(3)}        -- initial value is 0, index passed as 3rd argument, returns 0 + 10+1 + 20+2 + 30+3 = 66
.array~of(10, 20, 30)~reduce(, "ind"){arg(1) + arg(2) + arg(3)}  -- initial value is the first item (default), index passed as 3rd argument, returns 10 + 20+2 + 30+3 = 65
.array~of(10, 20, 30)~reduce(0, "ind"){arg(1) + arg(2) + arg(3)} -- initial value is 0, index passed as 3rd argument, returns 0 + 10+1 + 20+2 + 30+3 = 66

map : can act as a filter.
"one two three"~mapWord{if arg(1)~length == 3 then arg(1)} -- returns "one two"

(update JLF 16 oct 2011 : 'option' parameter removed)
map : added option "ind[exed]".
    arg(1) : current item of collection
    arg(2) : current index of collection, passed only if option "ind[exed]" is specified
"one two three"~mapWord("ind"){arg(2)":"arg(1)} -- returns "1:one 2:two 3:three"

(update JLF 16 oct 2011 : no result instead of .nil when nothing returned)
(update JLF 16 oct 2011 : no longer raise an error if no action : default is {arg(1)})
times : now can act as an array generator.
3~times{0}          -- returns .array~of(0,0,0)
3~times{arg(1)}     -- returns .array~of(1,2,3)
3~times{say arg(1)} -- returns .nil : no resulting array because no result returned during the iteration
3~times             -- raise an error because the parameter action is mandatory

(update JLF 16 oct 2011 : no result instead of .nil when nothing returned)
upto and downto : now can act as an array generator.
11~upto(13)             -- returns .array~of(11,12,13) because the default action is {arg(1)}
(-1)~upto(3)            -- returns .array~of(-1,0,1,2,3) -- Note that -1 MUST be surrounded by paren or quotes
11~upto(13){2*arg(1)}   -- returns .array~of(22,24,26)
11~upto(13){say arg(1)} -- returns .nil : no resulting array because no result returned during the iteration

(update JLF 16 oct 2011 : now, ~each always return an array)
each : can act as a collection generator and a filter.
The type of generated collection depends on the type of itererated source :
    collection --> same type of collection
    supplier --> array
    coactivity --> array
.array~of(1,2,3)~each{2*arg(1)}                       -- returns .array~of(2,4,6)
.set~of(1,2,3)~each{2*arg(1)}                         -- returns .set~of(2,4,6)
.set~of(1,2,3)~supplier~each{2*arg(1)}                -- returns .array~of(2,4,6)
{::c do i=1 to 3; .yield[i]; end}~doer~each{2*arg(1)} -- returns .array~of(2,4,6)
1~upto(20){if arg(1) // 3 == 0 then arg(1)}           -- returns .array~of(3,6,9,12,15,18) -- filter

[pipes]

pipeIndex representation : When using the option 'showTags', a tag class#id is
inserted before the representation of objects. The id is a short id (starts from 1,
incremented for each new instance of the same class in the index).
before : tag1['a',1,2,3,4]|tag2['a',1,2]|tag3[(22222),(my file)]
now    : tag1['a',1,2,3,4]|tag2['a',1,2]|tag3[MutableBuffer#1(22222),File#1(my file)]

pipeIndex representation : ~makeString takes two additional parameters :
localMask : which local indexes to include ("" means all). Ex : "2 3".
showNested : if .false then the nested index is not included.

Added two scripts to illustrate how a pipeline can be used for real scripts :
grep_sources.rex
trailing_whitespaces.rex


[profiling]

Added support for class methods.
But that won't work with standard ooRexx, because depends on ~setMethod which is private.


[array programming]

Currently investigating this area from several languages : APL, J, F-Script.
A first consequence was the modification of ~times ~upto ~downto and ~each to make them
generators of array.

Work in progress in extension/array.cls


===============================================================================
2011 sep 18

[pipes]

.startsWith now accepts a variable number of arguments (like .all and .notAll).
The value is selected if it starts with one of the strings passed as argument.

New pipeStage .endsWith, useful to test the suffix of files.
"c:\"~pipe(.fileTree | .endsWith["sys", "bat"] caseless | .console)

Added partition support to pipeStages that delay their output :
.drop, .take, .buffer, .lineCount, .charCount, .wordCount
(.take had already partition support for 'first' but not for 'last').

New management of indexes.
A pipeIndex is an array of variable length :
array[1] : tag (generally the id of the pipeStage class, or "source" for the initial index)
array[2] : nested pipeIndex (received from previous pipeStage)
array[3] : optional local index1
array[4] : optional local index2
etc...
When a pipeStage receives an index and a value, it applies transformations or
filters on the value. When a value is forwarded to a following pipeStage, it can
be accompanied by a new index that encapsulates the received index and add a tag
and local indexes. See option 'memorizeIndex' below.
Conventions followed in this pipeline implementation :
- The received value becomes the first local index (you have a call stack with arguments).
- If the pipeStage generates several values from the received value, then a second
  local index is added, which gives the position of the current generated value.
- If the pipeStage lets create a user-defined index (ex : .inject), then this index
  becomes the third (and following) local index. 

The creation of the pipe indexes is controlled by the option 'memorizeIndex' (abbrev 'mem').
This option is available from any pipeStage.
By default, the pipe indexes are not created, except for the source of the pipeline.

.inject : adaptation of the behaviour to the new management of indexes.
Two options are available : 'memorizeIndex' and 'recursive.memorizeIndex'.
By default, no index is memorized by .inject. 
In the example below, the first column is the source index (always memorized)
1~pipe(.inject {value+1} recursive.2 | .console)
1,1 : 2
1,1 : 3
1,1 : 4
Here, the last index calculated by .inject during recursive calls is memorized.
1~pipe(.inject {value+1} recursive.2 mem | .console)
1,1|1,1 : 2
1,1|2,1 : 3
1,1|3,1 : 4
Here, the intermediate indexes calculated by .inject during recursive calls are memorized.
No need to specify the stand-alone 'memorizeIndex' option, because 'recursive.memorizeIndex'
includes its functionality (but you can if you wish, it's just redundant).
1~pipe(.inject {value+1} recursive.2.mem | .console)
1,1|1,1 : 2
1,1|1,1|2,1 : 3
1,1|1,1|2,1|3,1 : 4

A memorized index can be retrieved by tag.
Example :
This pipeline iterates over all the files in the ooRexx install directory.
For each file, iterates over its contents, line by line.
Selects the lines which contain '::class'.
The .take pipeStage takes only one line per file.
'C:\Program Files\ooRexx\'~pipe(.fileTree recursive | .getFiles memorize | .all['::class'] | .take 1 {index~get('getFiles')~value} | .console)
Example of output :
'C:\Program Files\ooRexx\',1|(C:\Program Files\ooRexx\csvStream.cls),55 : ::class CsvStream subclass Stream Public
'C:\Program Files\ooRexx\',1|(C:\Program Files\ooRexx\mime.cls),49 : ::class mimepart public
'C:\Program Files\ooRexx\',1|(C:\Program Files\ooRexx\OODIALOG.CLS),54 : ::class 'DialogExtensions' public MIXINCLASS object
...

The class pipeIndex has a specific 'makeString' method which accepts two arguments :
- showTags (default .false) : when .true, the tags are inserted in the representation string.
- showPool (default .false) : when .true, a value which appears several times is replaced by
  a reference to the first occurence of the value.
Strings are surrounded by quotes, except string numbers.
To make a distinction between a real string and other objects, the representation
of instances of objects other than strings are surrounded by round brackets.
Example :
i1 = .pipeIndex~create("tag1", .nil, 1)                   -- 1
i2 = .pipeIndex~create("tag2", i1, "a")                   -- 1|'a'
i3 = .pipeIndex~create("tag3", i2, .mutableBuffer~new(2)) -- 1|'a'|(2)
i4 = .pipeIndex~create("tag4", i3, .file~new("c:\"))      -- 1|'a'|(2)|(c:)
i5 = .pipeIndex~create("tag5", i4, .file~new("c:\"))      -- 1|'a'|(2)|(c:)|(c:)
say i5~makeString(.true)                                  -- tag1[1]|tag2['a']|tag3[(2)]|tag4[(c:)]|tag5[(c:)]
say i5~makeString(.false, .true)                          -- 1|'a'|(2)|i1=(c:)|i1

.console :
- By default, the tags of the pipe indexes are not displayed by .console.
  Use the option 'showTags' to see them.
- .console always use showPool=.true.
- By default, .console writes a newline at the end of the text.
  If the last expression is an empty string "" then no newline is written.


===============================================================================
2011 sep 04

[pipes]

Standardization of doers usage : 
    try first ~functionDoer,
    then ~actionDoer (if candidate), 
    then ~doer.
The goal is to accept traditional routines or methods everywhere a functionDoer is
accepted. Currently, only RexxContextualSourceDoer has the methods ~functionDoer
and ~actionDoer.
Ex :
.sort myRoutine
where myRoutine is a routine which returns a result that is used as key for sorting.
Before, only .sort {my source literal} was accepted.

The .system pipeStage now manages a private queue for each execution of command.

The .inject pipeStage now accepts the options 'before' and 'after'.
When using 'before', the new values generated from the current value by .inject
are written to the pipe before writing the current value :
    new_values value.
When using 'after', the new values generated from the current value by .inject
are written to the pipe after writing the current value :
    value new_values.
You can specify both 'before' and 'after'. In this case, you will have the sequence
    value new_values value
The option 'append' has been removed, since equivalent to 'after'.
The option 'replace' has been removed, because useless (just don't use 'before'
and 'after' to get the same effect).


[source literal]
Fixed a crash in relation with line adjustment.


===============================================================================
2011 aug 21

Refinement of tokens 'subclass' attribute (for analysis) :
The scanner splits a source file in clauses, and decompose each clause in tokens.
Then the parser creates an AST from the tokens. 
The tokens were not annotated by the parser to attach semantic information found
during parsing. After a discussion with Rony about syntax coloring, I decided to
see which informations could be added to the tokens. I found that the attribute
'subclass' of the tokens could hold informations like that :
IS_KEYWORD
IS_SUBKEY
IS_DIRECTIVE
IS_SUBDIRECTIVE
IS_CONDITION
IS_BUILTIN
There is no impact on the interpreter, as far as I can tell... Except maybe the
tokenized files ? did not check.

For the moment, there is no access to the clauses/tokens from an ooRexx script.
If the environment variable RXTRACE_PARSING=ON then the clauses and tokens are
dumped to the debug output (Windows) or the log (Unix) using dbgprintf.
See samples/parsing for an example of dump.

Interesting to watch :
http://ibm-netrexx.215625.n3.nabble.com/NetRexx-Eclipse-status-video-td3271843.html


===============================================================================
2011 aug 16

Fixed a crash in relation with source literals and GC.
Two problems :
1) Forgot to replace RexxDirectory by RexxList when disabling the optimization
for source literals (was a copy-paste of optimization done for string literals). 
2) The constructor RexxSourceLiteral::RexxSourceLiteral can trigger a GC. Must protect
'this'.


Remember1:
----------
When the crash occurs during GC (ex : in ObjectHeader::isObjectMarked), it's possible
to see which ooRexx object is corrupted. Here the object is 0x7eeff200
 	rexx.dll!ObjectHeader::isObjectMarked(unsigned int mark)  Line 106 + 0xa bytes	C++
 	rexx.dll!RexxInternalObject::isObjectMarked(unsigned int markword)  Line 247 + 0x16 bytes	C++
 	rexx.dll!RexxListTable::live(unsigned int liveMark)  Line 55 + 0x26 bytes	C++
>	rexx.dll!RexxMemory::markObjectsMain(RexxObject * rootObject)  Line 374	C++                 <-- markObject = 0x7eeff200 {size=2129676696 elements=0x7eeff214 }  RexxListTable with OVERWRITTEN size !!!
 	rexx.dll!RexxMemory::markObjects()  Line 645	C++
 	rexx.dll!RexxMemory::collect()  Line 1022	C++

A conditional break "newObj == 0x7eeff200" on the last line of RexxMemory::newObject (RexxMemory.cpp)
lets stop the execution when the object is created. If too long, then modify the source :
    if (newObj == (RexxObject*)0x7eeff200)
    {
        int dummy=0;    //  <-- put breakpoint here
    }
    return newObj;
Once the interpreter is stopped here, it's relatively easy to do a code review of the methods
in the call stack, to check if an intermediate object must be protected.

If needed, a data breakpoint can be set on the part of memory which is overwritten
(here the 'size' attribute). In my case, was triggered when the object was inserted
in the list of dead objects.


Remember2:
----------
Occurences of new_directory, not protected (no crash so far, except for createConditionObject) :
DirectoryClass.cpp, RexxDirectory::newRexx
ExceptionClass.cpp, ExceptionClass::getCondition
RexxActivation.cpp, RexxActivation::raise
RexxActivity.cpp, RexxActivity::createConditionObject (fixed in sandbox)

Other potential problems. A fresh created object is not protected, and some calls are made that could trigger GC.
RexxBehaviour.cpp, RexxBehaviour::copy : newBehaviour is not protected.
RexxBehaviour.cpp, RexxBehaviour::addScope : this->scopes->allAt(TheNilObject) creates an object which is not protected.
RexxCollection.cpp, RexxHashTableCollection::copy : newObj is not protected. 
    Should be protected only if ActivityManager::currentActivity != NULL, otherwise crash in implementation of ProtectedObject's methods 
    (RexxHashTableCollection::copy is called during interpreter initialization, and at this time, ActivityManager::currentActivity == NULL).
ArrayClass.cpp, RexxArray::copy : newArray is not protected.
ClassClass.cpp, RexxClass::defineMethod : method_name and method_object are not protected.
ClassClass.cpp, RexxClass::methodDictionaryCreate : method_name is not protected.
DirectoryClass.cpp, RexxDirectory::copy : newObj is not protected.
ListClass.cpp, RexxList::copy : newList is not protected.
ObjectClass.cpp, RexxObject::copy : newObj is not protected.
ObjectClass.cpp, RexxObject::defMethod : msgname and methcopy are not protected.
InstructionParser.cpp, RexxSource::signalNew : newObject is not protected.
SourceFile.cpp, RexxSource::translateBlock : _instruction is not protected.


===============================================================================
2011 aug 14

[doers]

Modified functionDoer : Try first the source as-is, and in case of error try
the 'clause transformed to expression'.
Before this change :
    say {if .true then 2}~functionDoer~do 
    -- display : "IF 1 THEN 2"
    -- because the clause has been transformed to an expression.
    say {if .true then 2}~functionDoer~source~tostring
    -- display :
    -- options "NOCOMMANDS" ; ( if .true then 2 )
    --  ; if var("result") then return result    
Now :
    say {if .true then 2}~functionDoer~do 
    -- display : "2"
    -- because the clause remains as-is :
    -- options "NOCOMMANDS" ; if .true then 2
    --  ; if var("result") then return result    


[pipes]

New pipeStages :
.superClasses    : equivalent to .inject {value~superClasses}
.subClasses      : equivalent to .inject {value~subClasses}
.methods         : equivalent to .inject {value~methods}
.instanceMethods : equivalent to .inject {value~instanceMethods}
.system          : to execute a system command and get the contents of its stdout line by line

The index created by .inject is now a pair (value, resultIndex) where
- value is the processed value.
- resultIndex is the index of the current result calculated with value.
When doing recursive calculations and using the pushIndex option, the index
is like a call stack with intermediate results : you get one pair 
(value, resultIndex) for each level of recursion.
Ex :
.stream~pipe(.superclasses recursive pushIndex | .console)
1|The Stream class|1 : The InputOutputStream class
1|The Stream class|1|The InputOutputStream class|1 : The Object class
1|The Stream class|1|The InputOutputStream class|2 : The InputStream class
1|The Stream class|1|The InputOutputStream class|2|The InputStream class|1 : The Object class
1|The Stream class|1|The InputOutputStream class|3 : The OutputStream class
1|The Stream class|1|The InputOutputStream class|3|The OutputStream class|1 : The Object class

New option 'unique' added to .inject.
When used, a value that has been already processed will not be processed again.
No need of having sorted values, a list of all previously processed values is kept.
This option is different from 'cycles' which lets stop infinite recursion (use
also a list, but the list is limited to the call stack).
Ex :
.stream~pipe(.superclasses recursive pushIndex unique | .console)
1|The Stream class|1 : The InputOutputStream class
1|The Stream class|1|The InputOutputStream class|1 : The Object class
1|The Stream class|1|The InputOutputStream class|2 : The InputStream class
1|The Stream class|1|The InputOutputStream class|3 : The OutputStream class


===============================================================================
2011 aug 14

Fixed a crash that occured after GC : in RexxActivity::createConditionObject),
the value returned by new_directory() must be protected.


[source literal]

Fixed a crash which occurred when running
    interpret "{"
where interpret is on line 2 or above.

I need a line adjustment (similar to what's done for interpret) for error reporting.
- The line adjustment is made only in case of immediate parsing.
- The current name 'interpret_adjust' is not adapted to source literals...
  Renamed 'line_adjust'.
- Same remark for RexxSource::interpretLine, renamed RexxSource::adjustLine.
- To support this line adjustment for source literals, I had to deactivate this
  optimization :
      case TOKEN_SOURCE_LITERAL:
          retriever = this->sourceLiterals->fastAt(name);
  Was a copy-paste of the optimization done for the string literals.
  Using this optimization, when the same source literal was used at different places
  in the package's source, only one instance of RexxSourceLiteral was created, and so
  only one routine object was created.
  Not sure it was a useful optimization for source literals.


===============================================================================
2011 july 31

[doers]

ClauseSupplier renamed Clauser because it does not follow the semantics of a supplier.
New implementation which is derived from the ooRexx scanner : the comments and
continuations are correctly supported.
The multiline clauses are flattened to get only monoline clauses (more easy to transform).

New kind of doers : coactivity

The tag can be abbreviated like that :
    ::m[ethod]
    ::c[oactivity]
    :[:routine]
    : (defaults to routine)

Exemple :
    doer = {::coactivity
            say "hello" arg(1)
            arg = .yield[]
            say "good bye" arg[1]
           }~doer
    say doer~class -- The Coactivity class
    doer~do("John") -- hello John
    doer~do("Kathie") -- good bye Kathie
    doer~do("Keith") -- <nothing done, the coactivity is ended>

    doer = {::c
            do i=1 to 10000000
                call charout ,"yield["i"] "
                .yield[i]
            end}~doer
    doer~pipe(.take 3 | .console)
    doer~pipe(.take 4 | .console)
    .coactivity~endAll
    ----------
    Output :
    yield[1] 1 : 1
    yield[2] 2 : 2
    yield[3] 3 : 3
    yield[4] 1 : 4
    yield[5] 2 : 5
    yield[6] 3 : 6
    yield[7] 4 : 7


[functional]

Make use of functionDoer to emulate pure expressions, but the current emulation shows its limits.
    arg(1) * 2 --> Incorrect PARSE template detected at "*"
If I change the expression to : 
    2 * arg(1)
then it's ok.
That gave me the idea to modify functionDoer to surround the first clause other than "expose" and
"use [strict] arg" by round brackets. An error is raised if a clause other than "return" is found
after the surrounded clause. So the pattern is :
    [expose some variables]
    * point of insertion of clauseBefore
    [use [strict] arg some arguments]
    [a clause candidate to expression] --> if present then will be surrounded by round brackets
    [return something]
    * point of insertion of clauseAfter
In case of syntax error, the so-called 'clause candidate to expression' is used as-is.
Will see on usage if that works effectively...


===============================================================================
2011 july 31

The parsing of a source literal is now immediate when the first character is not ':'.
A routine is created and attached to the source literal.
This routine is accessible using the method RexxContextualSource~executable.
    routine = {say arg(1)+1}~executable
    routine~call(99) -- 100
For convenience, this routine is callable using the method RexxContextualSource~call.
    {say arg(1)+1}~call(99) -- 100
    say {return arg(1)+1}~call(99) -- 100

A source literal starting with ':' is not parsed immediately (deferred parsing).
In this case, no routine is attached to the source literal.
    {:say arg(1)+1}~executable -- .nil
    {:say arg(1)+1}~call(99) -- Error : Incorrect call to routine
Such a source literal can be handled by the package extensions.cls :
    {:say arg(1)+1}~doer~do(99) -- 100
    ::requires "extension/extensions.cls"


===============================================================================
2011 july 25

[pipe]
.displayer renamed .console, to be closer to CMS pipeline.


[pipe extensions]
Refactoring of makeFunctionDoer and makeActionDoer : now implemented in doers.cls
as methods functionDoer and actionDoer on RexxContextualSource.


[doers]
New class ClauseSupplier which lets iterate over the clauses of a source and replace
a clause by a new clause.

New method sourceDoer which lets transform the source before creating a doer from it.
This method is used by functionDoer and actionDoer .
Ex :
    {if value==0 then "infinity" ; else 1/value}~functionDoer("use arg value")
returns a routine built using this transformed source
    {use arg value                            -- optional source fragment passed as parameter to functionDoer
     option "NOCOMMANDS"                      -- added by functionDoer : expressions are not commands in functions
     if value==0 then "infinity" else 1/value -- original source literal, unchanged
     if var("result") then return result}     -- added by functionDoer : returns the result of the last evaluated expression


===============================================================================
2011 july 21

[expression evaluation]
Added an option to control execution of commands :
    ::options COMMANDS
    ::options NOCOMMANDS
    options "COMMANDS"
    options "NOCOMMANDS"
By default, a clause consisting of an expression only is interpreted as a command string.
When using the option NOCOMMANDS, the value of the expression is stored in the
variable RESULT, and not interpreted as a command string.


[source literal]
Removed method RexxSourceLiteral::setSource
Removed method RexxContextualSource::setSource
Removed method RexxContextualSource~"source="
This assignment of source is not needed, and moreover was buggy (overwriting directly
the literal source in the directory of literals).


[source literal]
Now RexxSourceLiteral::getSource returns an array of strings, no longer a monoline string.
The monoline string was buggy, because continuation characters were not supported correctly.
And that's how the sources are managed everywhere else.


[source literal]
To investigate...
When a routine or method is created, a new RexxSource is created. So all the settings
defined on the package level (i.e. RexxSource) have the default values.
It's possible to pass a context from which a RexxSource is taken (called parentSource)
which allows the created routine/method to inherit class and routine lookup scope from
another source. Nothing else is inherited.
    [inherited from context]
        routines
        merged_public_routines
        installed_classes
        merged_public_classes
    [currently never inherited from context]
        digits
        fuzz
        form
        trace
        enableCommands
See RoutineClass::newRoutineObject and RexxMethod::newMethodObject, there is a call to
getSourceObject()->inheritSourceContext(parentSource).
This chained context is managed in the following methods :
    RexxSource::findLocalRoutine   (search in routines)
    RexxSource::findPublicRoutine  (search in merged_public_routines)
    RexxSource::findInstalledClass (search in installed_classes)
    RexxSource::findPublicClass    (search in merged_public_classes)
A source literal is somewhat special, because it's supposed to have all the settings of
the package in which it's defined (well, I suppose...). So, should find a way to
initialize the RexxSource of the source literal with the settings of the package.
Then, I have the same need for the settings of the RexxActivation in which the executable
created from the RexxContextualSource will run. I think that the closure will be the right
place to manage that, since the closure is a snapshot of the RexxActivation in which the
RexxContextualSource is created.


===============================================================================
2011 july 11

More work on pipe.

.inject : the detection of cycles has a runtime cost. This detection is no longer
active by default, must pass the option "cycles" to activate it.


.inject : it's now possible to replace completely the current index by a new index,
using .index_value or .value_index.
.array~of(10,20,30)~pipe(.displayer)
1 : 10
2 : 20
3 : 30
.array~of(10,20,30)~pipe(.inject {.index_value[value, 2*value]} | .displayer)
10 : 20
20 : 40
30 : 60


.inject : with option 'pushIndex', it's now possible to pass an array of indexes.
.array~of(10,20,30)~pipe(.inject {
    .index_value[ .array~of(value-1, value+1), 2*value ]
    } push | .displayer)
1|9|11 : 20
2|19|21 : 40
3|29|31 : 60


Made .do a subclass of .inject, because I realized that .do is really like .inject,
except for the execution of commands : with .do, you can execute address commands,
with .inject, it's not allowed.


.take : added support for partition expression, to take the specified number of
elements in the partition. When the partition key changes, the counter is reset.
.array~of(1,1,1,2,2,2,2,3,3,3,3,3,1,1,1)~pipe(.take 2 {value} | .displayer)
1 : 1
2 : 1
4 : 2
5 : 2
8 : 3
9 : 3
13 : 1
14 : 1


Added profiling of pipeline :
.array~of(b, a, c)~pipeProfile(.sort byValue | .displayer)
2 : A
1 : B
3 : C
----------------------------------------
.SORT~go
  .SORT~EOF count=1 duration=0
    .DISPLAYER~EOF count=1 duration=0
    .DISPLAYER~ISEOP count=6 duration=0
    .DISPLAYER~PROCESS count=3 duration=0
  .SORT~ISEOP count=3 duration=0
  .SORT~PROCESS count=3 duration=0
  .SORT~START count=1 duration=0
    .DISPLAYER~START count=1 duration=0
duration=0
----------------------------------------
The pipeline's methods to profile must be instrumented.
    ::method myMethod
    my code here...

    is instrumented to become :
    
    ::method myMethod protected        <-- will be intercepted
    forward message("myMethod_unprotected")

    ::method myMethod_unprotected      <-- the security manager will forward this message
    my code here...
The profiling has an impact on the performances, but the durations should keep their
proportions.


===============================================================================
2011 july 06

Adapted the package doers.cls to source literals.
The class String is no longer used to hold routine's source or method's source.
Now RexxContextualSource is used for that.
    doer = {use arg name; say "hello" name}~doer
    say doer~class -- The Routine class
    doer~do("John") -- hello John
    
    doer = {::method say "hello" self}~doer
    say doer~class -- The Method class
    doer~do("John") -- hello John
Strings are still used for doers of type Message.
    doer = "length"~doer
    say doer~class -- The String class
    say doer~do("John") -- 4


Adapted the samples in extension, concurrency, pipeline :
- No longer need to call Doers.AddVisibilityFrom(.context).
- Source fragments are no longer strings, but source literals.
- Use abbreviated syntax when passing source literals


===============================================================================
2011 july 06

When a source literal was evaluated by an interpret instruction, the package associated
to the RexxContextualSource (at parse time) was not holding the right informations
for class & routine lookup scope. 
Symptom (assuming .myclass is visible from the current package, thanks to a ::requires) :
    {say .myclass}~doer~do             --> display The MYCLASS class (good)
    interpret "{say .myclass}~doer~do" --> display .MYCLASS          (not good)
Fixed by using the package associated to the RexxActivation in which the interpret is parsed.


I get "Error 49:  Interpretation error" when running
    rexx -e "v={}"
This is because SourceLiteral is currently a transient class, and I reach this code
in RexxEnvelope.cpp :
        // transient classes should never be flattened.  This is a problem if we encounter one
        if (newObj->behaviour->isTransientClass())
        {
            reportException(Error_Interpretation);
        }
Fixed by making the class SourceLiteral an internal class.


Added support for abbreviated syntax of arguments list (similar to Groovy syntax for closures) :
    f{...} is equivalent to f({...})
    f(a1,a2,...){...} is equivalent to f(a1,a2,...,{...})
Example :
    10~times{call charout , arg(1)}  -- 12345678910
    4~upto(7){call charout , arg(1)} -- 4567

New method on class RexxContextualSource :
::method "source=" -- lets assign an updated source, while keeping all the contextual infos.
I need that for the pipe stages which accept source literals used as expression.
.select {value~isPrivate} --> the source of the RexxContextualSource is transformed to :
"use arg value, index; return value~isPrivate"
See makeFunctionDoer in pipeline/pipe_extension.cls.


===============================================================================
2011 june 27

Added support for source literals.
Currently, a source literal is surrounded by curly braces, which is probably heretical,
but my main focus is not on the syntax.
My needs :
- I need to make a distinction between a "real" string and a source literal. 
  (will be useful for the pipeStage .Displayer)
- I need the context of the source literal's definer. Thay way, I no longer need to call
  Doers.AddVisibilityFrom.
- I need sometimes to transform the source (see pipelines : add arguments, add return),
  so must not be parsed too early because the initial source is not always valid ooRexx.
  I prefer to have the source as a single string, instead of an array of lines.
  (this transformation of source must be reworked, because current implementation is not
  very robust, especially for the insertion of return).
- I want to keep the current functionalities of doers. The source literal is passed
  as argument to .Method~new or .Routine~new, or used as a message when containing
  only one word.
In the current implementation, a source literal is a multiline string whose scanning is
aware of the ooRexx tokens. Curly braces in comments or in string are properly supported.
For the parser, a source literal is a token, which is translated to a RexxSourceLiteral
(transient class). When evaluated, a RexxSourceLiteral returns a RexxContextualSource
(exported class).

New class available from an ooRexx script :
::class RexxContextualSource
::method package -- the package where the source literal is defined.
::method context -- the context of the execution environment from which the source literal was evaluated.
::method source -- the text inside the curly braces, where '\n' has been replaced by ';'

Example of use : 
The source literal can be assigned to a variable and passed as argument to a routine.

-- package1.rex
function = {use arg n
            return doubler(n)}
do v over map(.array~of(1,2,3,4), function)
    say v
end
::routine doubler
return 2*arg(1)
::requires package2.rex

-- package2.rex
::routine map public
use strict arg array, contextualSource
say contextualSource~source
-- parse only once, before iteration
routine = .routine~new("", contextualSource~source, contextualSource~package)
value = .array~new(array~items)
do v over array
    value~append(routine~call(v)) -- 'doubler', which is defined in package1, is visible
end
return value

Output :
use arg n;            return doubler(n)
2
4
6
8


===============================================================================
2011 june 25

More work on pipe.

.inject : added options 'append', 'pushIndex'.
The option 'recursive' has two new sub-options : 'depthFirst', 'breadthFirst'.

.fileTree : new pipeStage
Get the childrens (files or directories) of a file instance.

.fileText : new pipeStage
Get the contents of a text file line by line.

.words : new pipeStage
Get the words of the current value.

.characters : new pipeStage
Get the characters of the current value.


===============================================================================
2011 june 20

More work on pipe.

.sort : the doers are parsed as soon as possible (during initOptions)

.all, .startsWith, .notall, .between, .after, .before : added option 'caseLess'

.displayer : added options 'index', 'value', 'space', newline', expression

Added support for end of process (EOP). The idea comes from
CMS Pipeline Telecourse (http://www.vm.ibm.com/download/packages/descript.cgi?TCVM2)
<<
pipe < big file a | take 5 | console
The TAKE stage take the first 5 records passing through the pipe (in this case
coming from the disk-read stage). After having seen 5 records go by, the TAKE stage
tells the PIPE dispatcher "I've done my job, I don't need anything more...", and the
dispatcher in turn informs the previous stage that there isn't anybody listening
anymore to its output, so it can stop also.
So, a pipeline can suddenly collapse when one stage decides to stop
>>
There is no dispatcher in current implementation, but the idea of end of process is
very interesting. In particular with infinite coactivities :
.coactivity~new("i=0; do forever; i+=1; .yield[i]; end")~pipe(.take 5 | .displayer)
Also interesting with big files, when only the n first lines must be processed...

.drop : replace both .dropFirst and .dropLast

.take : replace both .takeFirst and .takeLast

.append : new pipeStage
Copy items from its primary input to its primary output, and then invoke the supplier
passed as argument and write the items produced by that supplier to its primary output.


===============================================================================
2011 june 13

More work on pipe.

.sort : refactoring of the internal helpers.
Now a single indexedValueComparator handles all the kinds of comparisons
(by value, by index, by expression).

.sort : added option 'strict'

.sort : can sort on several criteria.
The order in which the options are passed is the order in which they are executed.
A 'value' or 'index' or expression option is impacted only by the preceding options.

.inject : a limit can be specified with option recursive : recursive.10


===============================================================================
2011 june 09

More work on pipe.rex.

Added support to pass options to a pipeStage (use the blank operator) :
    .myStage[arg1, arg2, ...] option1 option2 ...

.sort : added options byValue, byIndex, ascending, descending, caseless, quickSort.

.sortWith : added option quickSort.

.inject : added option recursive.
In case of infinite recursion, the recursion is stopped. This is detected
by keeping a stack of items already processed.


===============================================================================
2011 june 09

The alternate syntax [] for pipeStage gave me the idea to do the same for the yield
method of the coactivity class.
    .yield[value]
    is equivalent to (and more compact than)
    .Coactivity~yield(value)
Remember : the blank operator would be still more compact,
    .yield value
but unfortunately a result is mandatory (an operator is not a message instruction),
and that triggers a command if the result is not used... So forget this syntax.


Side note : I start to find this triggering of commands seriously annoying !
Too easy to trigger a command accidentaly. Yes, I could use a security manager, but
would be tedious to put it *everywhere*.
To investigate : a message instruction can trigger a command only if surrounded by ().
Not possible to apply this rule all the time, including expressions ?
rm "*".lst --> the string "rm *.lst" would be assigned to the variable RESULT.
(rm "*".lst) --> the string "rm *.lst" would be submitted as a command to the external environment.
That way, the programmer controls explicitely where a command can be triggered.
Code review :
    SourceFile.cpp
        RexxSource::instruction
            this->messageNew
                RexxSource::messageNew
                    new RexxInstructionMessage
            this->commandNew
                RexxSource::commandNew
                    _expression = this->expression(TERM_EOC)
                        RexxSource::expression
                            this->subExpression(terminators)
                    new RexxInstructionCommand
    InstructionParser.cpp
        RexxInstructionCommand
        RexxSource::commandNew
            expression = this->expression(TERM_EOC)
    MessageInstruction.cpp
        RexxInstructionMessage::execute (assign the RESULT variable)
    CommandInstruction.cpp
        RexxInstructionCommand::execute
            RexxObject *result = this->expression->evaluate(context, stack);
                ***HERE*** could decide to assign result to RESULT instead of triggering command
            RexxString *command = REQUEST_STRING(result);    /* force to string form              */
            context->command(context->getAddress(), command);


Side note :
A message term can have one of the following forms :
    receiver~messagename:symbol(expression, ...)
    receiver~~messagename:symbol(expression, ...)
    receiver[expression, ...]
The receiver is a term.
Would it make sense to add that ?
    receiver(expression, ...)
Probably not, according to my tests :
    .c~"()"    -- the method "()" is called
    .c()       -- could not find routine ".C"
    ::class c
    ::method "()" class
A function call is a term in an expression calling a routine.
    function_name(expression, ...)
The function_name is a literal string or a single symbol, which is taken to be a constant.
So no way to have something similar to the C++ operator().


===============================================================================
2011 may 29

Modified pipe.rex to keep the index information of the collection passed as argument to ~go.
Useful when working with a collection of methods, where the name of the methods is available
only through the indexes.

Added the extension ~pipe to all objects.
myObject~pipe(myPipeline)

Added extensions to pipe.rex, to benefit from doers :
inject
do
select

Added the extension ~each to all the collections.

Added the extensions ~each and ~reduce to the suppliers.

Fixed a bug in rgf_util2 :
dump2 was not working with suppliers, because ~items was called.

Concurrency trace : report information about ovd, even if not yet assigned to the RexxActivation.
See getReserveCount and getVariableDictionary in RexxActivation.hpp.

Debug of semaphores : the variable name was overwritten, fixed.


===============================================================================
2011 may 29

Adaptation of concurrency trace to support 64 bits pointers.

Now, concurrency trace is displayed only when env variable RXTRACE_CONCURRENCY=ON

The debug messages for semaphores and mutexes are very costly : about 400 times
slower than main/trunk... Now, those messages are controlled by conditional
compilation, and activated only in debug configuration.

Slow learning curve of xcode4 under MacOsX, experimentation of several configurations : 
gcc/debug
    $oorexx_src_dir/configure --prefix=$oorexx_delivery CFLAGS="-g -O0 -D_DEBUG" CXXFLAGS="-g -O0 -D_DEBUG"
gcc/default : 
    $oorexx_src_dir/configure --prefix=$oorexx_delivery
gcc/release
    $oorexx_src_dir/configure --prefix=$oorexx_delivery CFLAGS="-g -O3" CXXFLAGS="-g -O3"
Currently using gcc only, but plan to test llvmgcc.
Each configuration is initialized by running a shell script located in the appropriate delivery folder.
If debug from xcode4 is needed, then must launch xcode4 from the config's shell : open -a xcode4
The directory layout is like that :
oorexx
    build
        main
            trunk
                gcc
                    default : run configure here
        sandbox
            jlf
                trunk
                    gcc
                        debug : run configure here
                        default : run configure here
                        release : run configure here
    delivery
        main
            trunk
                gcc
                    default : setenv.sh to declare config variables
        sandbox
            jlf
                trunk
                    gcc
                        debug : setenv.sh to declare config variables
                        default : setenv.sh to declare config variables
                        release : setenv.sh to declare config variables
    svn
        main
            trunk
        sandbox
            jlf
                trunk

===============================================================================
2011 mar 18

Added an early traceEntry for proper diagnostic in case of deadlock of guarded method.
See test cases in samples/concurrency :
deadlock1.rex
deadlock2.rex

Fixed in RexxActivation::run


===============================================================================
2011 mar 17

I have a small problem with doers : 
Any routine/method created by StringDoer will have a lookup scope limited to the
doers package, because the routines/methods are created from the doers package,
not from the caller's package.
StringDoer~doer accepts a context parameter to let the caller pass its own lookup scope,
but this is tedious to pass it explicitely at each call.
Example from oorexxshell :
say .color                     -- The COLOR class
"say .color"~doer~do           -- .COLOR because the COLOR class is not visible from doers
"say .color"~doer(.context)~do -- The COLOR class

I provide the convenience routine "Doers.AddVisibilityFrom" which lets see from doers
the same packages/methods/routines as the caller.
Usage from caller's package :
call Doers.AddVisibilityFrom(.context)
::requires "extension/doers.cls"
With this sequence, no need to pass explicitely the .Context when creating a doer :
"say .color"~doer~do           -- The COLOR class

This problem would not exist if we had support for first-class expressions/instructions
that are parsed in place, instead of being parsed by StringDoer.
https://sourceforge.net/mailarchive/message.php?msg_id=19911593
https://sourceforge.net/mailarchive/message.php?msg_id=19912031
The proposed syntax [expr] lets defer the evaluation of expr, but is not supposed to
support instructions (why not ?).
Maybe
    c = .Coactivity~new("do i = 1 to 10 ; .Coactivity~yield(i) ; end")
could become 
    c = .Coactivity~new([do i = 1 to 10 ; .Coactivity~yield(i) ; end])
In this case, the context is the "good" context, i.e. the context of the place from where
the block is parsed. The distinction expression/instructions is similar to the distinction
eval/apply in Lisp : You evaluate an expression, you apply a method/routine to a list of
arguments.


===============================================================================
2011 mar 17

m17n : 
Don't use strong types by default, because gcc can't compile as-is.
Fixed compilation errors under Linux.


===============================================================================
2011 mar 16

I learned recently that ooRexx manages nested guard conditions...
So, I added new informations in the trace output :
- variable dictionary id (3rd column)
- nesting counter (4th column)

Raw trace, generated by rexx :
00004fec 7efc0fb0 7efc10f0 00001*     79 *-* if start 
00004fec 7efc0fb0 7efc10f0 00001*        >V>   START => "1"
00004fec 7efc0fb0 7efc10f0 00001*        >>>   "1"
00004fec 7efc0fb0 7efc10f0 00001*     79 *-*   then
00004fec 7efc0fb0 7efc10f0 00001*     79 *-*     self~start
00004fec 7efc0fb0 7efc10f0 00001*        >V>       SELF => "a Coactivity"
00004fec 7efc9918 7efc10f0 00002*        >I> Method START with scope "The Coactivity class" in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\concurrency\coactivity.cls
...
00004fec 7efc9918 7efc10f0 00002*     93 *-* reply self
00004fec 7efc9918 7efc10f0 00002*        >V>   SELF => "a Coactivity"
00004fec 7efc9918 7efc10f0 00002*        >>>   "a Coactivity"
00004fec 7efc0fb0 7efc10f0 00001*        >>>       "a Coactivity"
00004fec 7eee9be8 00000000 00000         >M>   "NEW" => "a Coactivity"
0000478c 7efc9918 7efc10f0 00001*        >I> Method START with scope "The Coactivity class" in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\concurrency\coactivity.cls
00004fec 7eee9be8 00000000 00000         >>>   "a Coactivity"
0000478c 7efc9918 7efc10f0 00001*     94 *-* .Activity~local~empty


Human readable trace, generated by rexx trace/tracer using raw trace as input :
T1   A4     V2      1*     79 *-* if start 
T1   A4     V2      1*        >V>   START => "1"
T1   A4     V2      1*        >>>   "1"
T1   A4     V2      1*     79 *-*   then
T1   A4     V2      1*     79 *-*     self~start
T1   A4     V2      1*        >V>       SELF => "a Coactivity"
T1   A5     V2      2*        >I> Method START with scope "The Coactivity class" in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\concurrency\coactivity.cls
...
T1   A5     V2      2*     93 *-* reply self
T1   A5     V2      2*        >V>   SELF => "a Coactivity"
T1   A5     V2      2*        >>>   "a Coactivity"
T1   A4     V2      1*        >>>       "a Coactivity"
T1   A3                       >M>   "NEW" => "a Coactivity"
T2   A5     V2      1*        >I> Method START with scope "The Coactivity class" in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\concurrency\coactivity.cls
T1   A3                       >>>   "a Coactivity"
T2   A5     V2      1*     94 *-* .Activity~local~empty


===============================================================================
2011 mar 10

Implemented an emulation of coroutine, named "coactivity" to follow the ooRexx
vocabulary. This is not a "real" coroutine implementation, because it's based on
ooRexx threads and synchronization. But at least you have all the functionalities
of a stackful asymmetric coroutine (resume + yield). All is in place to support
symmetric coroutines (yield only), but the scheduler remains to implement.

For a better support of coactivity, I'm thinking to modify the interpreter :
Arguments can be passed by the consumer when he resumes a coactivity.
For the first resume, the traditional arguments declaration can be used on the producer side.
But for the following resumes, it's less declarative : you get only an array returned by yield.
I'd like to use the traditional arguments declaration everywhere...
    consumer : res = coactivity~resume(arg1, arg2)
               res = coactivity~resume(arg1, arg2)
               ...
    producer : use strict arg arg1, arg2
               res = f(arg1, arg2)...
               args = coactivity~yield(res) --> returns an array of arguments
               use strict arg arg1, arg2   --> but this array of arguments can't be read that way
               ...

For an example of coroutine implementation for the HotSpot JVM, see :
http://ssw.jku.at/Research/Papers/Stadler11Master
I found the reading interesting because :
- Java, like ooRexx, has synchronized threads.
- Java, like ooRexx, doesn't support real coroutines.
- With the proposed implementation for JVM, operations on coroutines implicitly always
  operate on the current thread. This allows the system to assume that only a minimal amount
  of synchronization is necessary.


===============================================================================
2011 mar 10

For all scripts under jlf/sandbox/samples, use path relative to samples in requires,
assuming the path to samples will be in the PATH.


Refactoring of extension :
- Separation between code for standard ooRexx (in subdirectory std), and sandbox.
- Removed factory.rex : can be replaced by ~enhanced
- When ~enhanced can't be used then use delegation

Current pattern for standard ooRexx, to extend a predefined class, assuming that
the name of the predefined class is "ClassName", and the name of the extension
is "Extension" (no need of that with ::extension) :

::class ClassNameExtension mixinclass Object public

::method init
    expose className -- optional : an encapsulated instance of the predefined class
    use arg className=.nil

::method myMethod
    expose className
    if var("className"), className <> .nil then self = className -- delegates to the encapsulated instance
    -- here your extension code which depends on self

::class ExtendedClassName subclass ClassName public inherit ClassNameExtension1 ClassNameExtension2 ...

The level of integration brougth by extension/std is poor compared to the integration with ::extension !
Most of the time, you will create instances of your extended class.
Ex : .ExtendedString~new("say 2*arg(1)")~doer~do(10) -- display 20
But sometimes, you must work with instances returned by the interpreter, and you can't create an instance 
of your extended class. In this case, you create an instance of your extension mixin which encapsulates the
instance returned by the interpreter.
Ex : routine = .context~package~findRoutine("multiply_by_2")
     doer = .RoutineDoer~new(routine)
     doer~do(10) -- display 20

     ::routine multiply_by_2
     say 2*arg(1)


===============================================================================
2011 mar 09

Send the trace output to the debug output.
Made the debug output of SysSemaphore and SysMutex compatible with trace output.
Now I get the trace lines and the interpreter locks in the same stream, and I can
parse them with tracer.rex (could be faster, but...).

0001eab4 7eff0af8 *     89 *-* reply self
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.release : before ReleaseMutex(0x1fb4) from ActivityManager::unlockKernel (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.release : after ReleaseMutex(0x1fb4) from ActivityManager::unlockKernel (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.requestImmediate : before WaitForSingleObject(0x1fb4) from ActivityManager::lockKernelImmediate (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.requestImmediate : after WaitForSingleObject(0x1fb4) from ActivityManager::lockKernelImmediate (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.release : before ReleaseMutex(0x1fb4) from ActivityManager::unlockKernel (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.release : after ReleaseMutex(0x1fb4) from ActivityManager::unlockKernel (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.requestImmediate : before WaitForSingleObject(0x1fb4) from ActivityManager::lockKernelImmediate (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.requestImmediate : after WaitForSingleObject(0x1fb4) from ActivityManager::lockKernelImmediate (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.release : before ReleaseMutex(0x1fb4) from ActivityManager::unlockKernel (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.release : after ReleaseMutex(0x1fb4) from ActivityManager::unlockKernel (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.requestImmediate : before WaitForSingleObject(0x1fb4) from ActivityManager::lockKernelImmediate (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.requestImmediate : after WaitForSingleObject(0x1fb4) from ActivityManager::lockKernelImmediate (0x55dec0)
0001eab4 7eff0af8 *        >V>   SELF => "a COACTIVITY"


===============================================================================
2011 feb 27

Implemented the script samples\trace\tracer.rex.
This script lets :
- replace hexadecimal values by more human-readable values like T1, A1.
- generate a CSV file, for further analysis with your favorite tool.

Can be used as a pipe filter (reads from stdin) :
rexx my_traced_script.rex 2>&1 | rexx tracer

or can read from a file :
rexx tracer -csv my_trace_file.txt


===============================================================================
2011 feb 24

Added thread id, activation id and lock flag in the lines printed by trace.
Should help to analyze the traces of a multithreaded script.

Not sure yet to have covered all the cases, since I modified only this method :
RexxActivity::traceOutput
But looks good on my first tests.

The extract below illustrates quite well the problem of interleaved traces.
See after the reply, two threads are running concurrently.

coroutine~start -- guarded
coroutine~resume -- unguarded

0000ccac 7efcae78 *        >I> Method START with scope "The COROUTINE class" in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\generator\coroutine.cls
...<snip>...
0000ccac 7efcae78 *     92 *-* status = .Coroutine~suspended
0000ccac 7efcae78 *        >E>   .COROUTINE => "The COROUTINE class"
0000ccac 7efcae78 *        >M>   "SUSPENDED" => "1"
0000ccac 7efcae78 *        >>>   "1"
0000ccac 7efcae78 *        >=>   STATUS <= "1"
0000ccac 7efcae78 *     93 *-* guard off
0000ccac 7efcae78       94 *-* reply self
0000ccac 7efcae78          >V>   SELF => "a COROUTINE"
0000ccac 7efcae78          >>>   "a COROUTINE"
0000c8dc 7efcae78          >I> Method START with scope "The COROUTINE class" in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\generator\coroutine.cls
0000ccac 7efd0968          >I> Method RESUME with scope "The COROUTINE class" in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\generator\coroutine.cls
0000c8dc 7efcae78       95 *-* signal on any 
0000ccac 7efd0968      162 *-* expose status yieldValue
0000c8dc 7efcae78       96 *-* guard on when status <> .Coroutine~suspended
0000ccac 7efd0968      163 *-* if status == .Coroutine~notStarted 
0000c8dc 7efcae78 *        >V>   STATUS => "1"
0000ccac 7efd0968          >V>   STATUS => "1"

If you redirect the stderr to a file, and open it with Excel, then you can filter by thread and/or by activation.


===============================================================================
2010 nov 14

I have reached a state where the interpreter is no longer broken by m17n.
The most difficult bugs were because of the default constructor of rxStringSize.
By assigning 0 (a good practice for me), I had nasty bugs in the parser.
Solved by leaving the attribute uninitialized...
Remember :

RexxSource::sayNew
    RexxObject *_expression = this->expression(TERM_EOC);
    RexxInstruction *newObject = new_instruction(SAY, Say);     <-- location is copied from this->clause by RexxSource::sourceNewObject
    new ((void *)newObject) RexxInstructionSay(_expression);    <-- boom ! location is overwritten by default constructor of rxStringSize

inline RexxBuffer *new_buffer(sizeB_t s) { return new (size_v(s)) RexxBuffer; }     <-- bufferSize and dataLength were always 0 !
void *RexxBuffer::operator new(size_t size, size_t _length)
    newBuffer->bufferSize = _length;    <-- initialized here, *before* the execution of default constructor
    newBuffer->dataLength = _length;    <-- same problem

    
Now, the next step is probably to change the signature of the methods in StringUtil,
to pass a IRexxString parameter, instead of a couple (char*, size_t) which are the 
internal attributes stringData and length.


===============================================================================
2010 oct 10

rexx.h
Defined strong types to detect misuse between 'size in bytes' and 'size in chars'.
When changing the sources for m17n, I activate the strong types.
Otherwise I use the weak types.
See rxStringSize.


===============================================================================
2010 sept 24

Started a review of the NetRexx specification, in unicode/_readme.odt.
The goal is to see how the issues reported by Rick are covered by NetRexx.


===============================================================================
2010 sept 20

Fixed the build of m17n under Linux.
Had to rename all the *.c files to *.cpp, because .c source files are not correctly
built by Makefile.am.


Note about Parrot :
The charset/encoding merge has been moved in Parrot's trunk.
I will probably apply this merge.


===============================================================================
2010 sep 05

Found a bug, fixed in sandbox, to fix in trunk.
.mutablebuffer~new('abcdef')~replaceat('XXX', 1, 16)
makes the interpreter crash.


Parrot charset/encoding merge :
http://lists.parrot.org/pipermail/parrot-dev/2010-September/004678.html
I will wait for the move in Parrot's trunk before analysing that.


===============================================================================
2010 aug 28

Added encoding to RexxString (m17n) : I borrowed the Parrot's implementation
(the overall design is kept, but a lot of things has been adapted to ooRexx).

For the moment, I have three sources of inspiration : Parrot, Ruby, Falcon
I choosed Parrot to start, because it uses ICU if available at compile-time. 
It's a minimal use, but at least I can put my hands on ICU through a concrete work.
One pointer for charset and one pointer for encoding is probably too much, but this is
how Parrot is implemented... And a third pointer is coming, for NFG.
[2010 aug 25] New, there is an RFC to merge charsets and encodings :
http://lists.parrot.org/pipermail/parrot-dev/2010-August/004633.html

Ruby's m17n is more complete than Parrot's, but seems more difficult to apprehend.
The encoding is stored as a 16 bits index.

Falcon is not like Parrot or Ruby, its internal charset is Unicode only. 
I'm interested by its "string polymorphism".
The string manager (ako encoding) is stored as a pointer.

See unicode/_readme.odt for more details.


To build with ICU under Windows :
    set HAVE_ICU=1      <-- assign 0 or put this line in comment if you don't want to build with ICU
    set icu_dir=D:\local\Unicode\ICU\icu4c-4_4_1-Win32-msvc9
    set PATH=%icu_dir%\bin;%PATH%
    set INCLUDE=%icu_dir%\include;%INCLUDE%
    set LIB=%icu_dir%\lib;%LIB%

The environment variable HAVE_ICU is tested in buildorx.bat :
    set ICU_OPTION=
    if defined HAVE_ICU set ICU_OPTION="HAVE_ICU=%HAVE_ICU%"
    NMAKE /F INTERPRETER.MAK %ICU_OPTION%
    
interpreter.mak :
    !IFNDEF HAVE_ICU
    HAVE_ICU=0
    !ENDIF

    !IF "$(HAVE_ICU)" == "0"
    ICU_OPTIONS=
    !ELSE
    ICU_OPTIONS=/DHAVE_ICU
    !ENDIF


Careful if building from Visual Studio (no problem when building from Cmd shell) :
The INCLUDE environment variable is redefined by Visual Studio, and because of that,
the ICU headers are not found. You must launch Visual Studio like that :
    vcexpress /useenv
See makeorx_verbose.bat for more details to build from Visual Studio.


===============================================================================
2010 july 3

Continue Unicode review : added notes about Falcon.

Adapted ooRexxTry to use utf8 encoding and Arial Unicode MS.
Preloads all the main components (math, ftp, socket, bsf, hostemu, ...).


===============================================================================
2010 july 3

Debug crash in gc
RexxMemory::markObjectsMain
    markObject->live(liveMark);

0x003d2b8c                                          --> this is 0x7eee1ac0->behaviour
Access violation reading location 0x44414550        --> this is the vfptr of the behaviour of a string

((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*markObject))))).__vfptr


RexxMemory::mark(RexxObject *markObject)
    pushLiveStack((RexxObject *)markObject->behaviour);
markObject = 0x7eee1ac0                             --> see below, this is the 30th element of string array
    [RexxString]
               if tmp<2 then         -- start at first char
           
called by RexxArray::live(size_t liveMark)      ArrayClass.cpp
where this = 0x7f30ed70
this->objects = 7f30ed98
arrayPtr=7f30ee0c
0x7f30ee0c - 0x7f30ed98 = 116 = 29 * 4 --> this is the 30th element

element 1 to 13 : not a string... but doesn't be a problem
+		(*(RexxString*)this->get(14)).stringData	0x7eee36a4 "  len1=length(arg1string)        -- get length of string"	char [4]
+		(*(RexxString*)this->get(15)).stringData	0x7eee3704 "  newArr=.array~new        -- create new array for the arguments"	char [4]
+		(*(RexxString*)this->get(16)).stringData	0x7eee376c "  newArr[1]=new1string     -- "new"-string"	char [4]
+		(*(RexxString*)this->get(18)).stringData	0x7eee37e4 "  prepend=""               -- optional prepend string (if positioning before start!)"	char [4]
+		(*(RexxString*)this->get(20)).stringData	0x7eee388c "  arg2startori=arg2start         -- save passed-in value, if any"	char [4]
+		(*(RexxString*)this->get(21)).stringData	0x7eee38f4 "  if arg4pad=="" then arg4pad=" "-- define blank as the default pad char"	char [4]
+		(*(RexxString*)this->get(23)).stringData	0x7eee398c "  if arg(3,"Exists") then  -- start in "target"-string"	char [4]
+		(*(RexxString*)this->get(24)).stringData	0x7eee2dfc "  do"	char [4]
+		(*(RexxString*)this->get(25)).stringData	0x7eee2e2c "     if datatype(arg2start,"W") then"	char [4]
+		(*(RexxString*)this->get(26)).stringData	0x7eee2e7c "     do"	char [4]
+		(*(RexxString*)this->get(27)).stringData	0x7eee2eac "        if arg2start<0 then      -- negative, start from right"	char [4]
+		(*(RexxString*)this->get(28)).stringData	0x7eee2f14 "        do"	char [4]
+		(*(RexxString*)this->get(29)).stringData	0x7eee2f44 "           tmp=len1+arg2start+1  -- get starting position"	char [4]
+		(*(RexxString*)this->get(30)).stringData	0x7eee1ae4 "           if tmp<2 then         -- start at first char"	char [4]
+		(*(RexxString*)this->get(31)).stringData	0x7eee1b44 "           do"	char [4]
+		(*(RexxString*)this->get(32)).stringData	0x7eee1b7c "              if tmp<0 then"	char [4]

The behaviour of the 30th element is broken :
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(28))))).behaviour)))))).__vfptr	0x003aa62c const RexxBehaviour::`vftable'	*
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(29))))).behaviour)))))).__vfptr	0x003aa62c const RexxBehaviour::`vftable'	*
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(30))))).behaviour)))))).__vfptr	0x44414548	*
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(31))))).behaviour)))))).__vfptr	0x003aa62c const RexxBehaviour::`vftable'	*
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(32))))).behaviour)))))).__vfptr	0x003aa62c const RexxBehaviour::`vftable'	*

the behaviour of 30th element is stored at 0x7eee1acc


called by RexxMemory::markObjectsMain(RexxObject *rootObject)
where rootObject = 
+		rootObject	0x003d2a90 class RexxMemory memoryObject {markWord=1 markReason=1 variableCache=0x7f5b55a8 ...}	RexxObject *

called by RexxMemory::markObjects()

called by RexxMemory::collect()

objectclass.hpp
inline void   setBehaviour(RexxBehaviour *b) { behaviour = b; }         <-- this method is called to assign the behavior of type 22 (T_String)
>	rexx.dll!RexxInternalObject::setBehaviour(RexxBehaviour * b)  Line 265 + 0x10 bytes	C++
 	rexx.dll!RexxObject::initializeNewObject(unsigned int mark, void * vft, RexxBehaviour * b)  Line 362	C++
 	rexx.dll!RexxMemory::newObject(unsigned int requestLength, unsigned int type)  Line 1134	C++
 	rexx.dll!new_object(unsigned int s, unsigned int t)  Line 422 + 0x1e bytes	C++
 	rexx.dll!RexxString::newString(const char * string, unsigned int length)  Line 1894 + 0xd bytes	C++
 	rexx.dll!new_string(const char * s, unsigned int l)  Line 521	C++
 	rexx.dll!RexxSource::get(unsigned int _position)  Line 838 + 0x1d bytes	C++
 	rexx.dll!RexxSource::extractSource(SourceLocation & location)  Line 1119 + 0x10 bytes	C++                 <-- counter = 735
 	rexx.dll!RexxCode::getSource()  Line 199	C++
 	rexx.dll!BaseExecutable::source()  Line 149	C++
 	rexx.dll!CPPCode::run(RexxActivity * activity, RexxMethod * method, RexxObject * receiver, RexxString * messageName, RexxObject * * argPtr, unsigned int count, ProtectedObject & result)  Line 144 + 0x6 bytes	C++
 	rexx.dll!RexxMethod::run(RexxActivity * activity, RexxObject * receiver, RexxString * msgname, RexxObject * * argPtr, unsigned int count, ProtectedObject & result)  Line 325	C++
 	rexx.dll!RexxObject::messageSend(RexxString * msgname, RexxObject * * arguments, unsigned int count, ProtectedObject & result)  Line 793	C++
 	rexx.dll!RexxExpressionStack::send(RexxString * message, unsigned int count, ProtectedObject & result)  Line 74 + 0x33 bytes	C++
 	rexx.dll!RexxExpressionMessage::evaluate(RexxActivation * context, RexxExpressionStack * stack)  Line 139	C++
 	rexx.dll!RexxExpressionMessage::evaluate(RexxActivation * context, RexxExpressionStack * stack)  Line 123 + 0x23 bytes	C++
 	rexx.dll!RexxInstructionAssignment::execute(RexxActivation * context, RexxExpressionStack * stack)  Line 122 + 0x1d bytes	C++
 	rexx.dll!RexxActivation::run(RexxObject * _receiver, RexxString * msgname, RexxObject * * _arglist, unsigned int _argcount, RexxInstruction * start, ProtectedObject & resultObj)  Line 522	C++
 	rexx.dll!RexxCode::call(RexxActivity * activity, RoutineClass * routine, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, RexxString * calltype, RexxString * environment, int context, ProtectedObject & result)  Line 116	C++
 	rexx.dll!RexxCode::call(RexxActivity * activity, RoutineClass * routine, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, ProtectedObject & result)  Line 92	C++
 	rexx.dll!RoutineClass::call(RexxActivity * activity, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, ProtectedObject & result)  Line 234	C++
 	rexx.dll!InterpreterInstance::runRequires(RexxActivity * activity, RexxString * name, RoutineClass * code)  Line 877	C++
 	rexx.dll!InterpreterInstance::loadRequires(RexxActivity * activity, RexxString * shortName, RexxString * fullName)  Line 932	C++
 	rexx.dll!RexxSource::loadRequires(RexxActivity * activity, RexxString * target)  Line 6082 + 0x14 bytes	C++
 	rexx.dll!PackageClass::loadPackage(RexxString * name, RexxArray * s)  Line 366 + 0x16 bytes	C++             <-- rgf_util2.rex


The previous behaviour is overwritten by
inline void insertAfter(DeadObject *newDead)            DeadObject.hpp
where newDead = 7eee1ac0
 	rexx.dll!DeadObject::insertAfter(DeadObject * newDead)  Line 89	C++
 	rexx.dll!DeadObjectPool::add(DeadObject * obj)  Line 165	C++
>	rexx.dll!NormalSegmentSet::addDeadObject(char * object, unsigned int length)  Line 461	C++
 	rexx.dll!MemorySegmentSet::sweep()  Line 1170	C++
 	rexx.dll!RexxMemory::collect()  Line 1038	C++
 	rexx.dll!NormalSegmentSet::handleAllocationFailure(unsigned int allocationLength)  Line 1272	C++
 	rexx.dll!RexxMemory::newObject(unsigned int requestLength, unsigned int type)  Line 1117 + 0x12 bytes	C++ <-- length = 48, we are in "small object" part (lesser than LargeBlockThreshold 4096)
 	rexx.dll!new_object(unsigned int s, unsigned int t)  Line 422 + 0x1e bytes	C++
 	rexx.dll!RexxString::newString(const char * string, unsigned int length)  Line 1894 + 0xd bytes	C++
 	rexx.dll!new_string(const char * s, unsigned int l)  Line 521	C++
 	rexx.dll!new_string(const char * s, unsigned int l)  Line 521	C++
 	rexx.dll!RexxSource::get(unsigned int _position)  Line 838 + 0x1d bytes	C++
 	rexx.dll!RexxSource::extractSource(SourceLocation & location)  Line 1119 + 0x10 bytes	C++                 <-- counter = 754
 	rexx.dll!RexxCode::getSource()  Line 199	C++
 	rexx.dll!BaseExecutable::source()  Line 149	C++
 	rexx.dll!CPPCode::run(RexxActivity * activity, RexxMethod * method, RexxObject * receiver, RexxString * messageName, RexxObject * * argPtr, unsigned int count, ProtectedObject & result)  Line 144 + 0x6 bytes	C++
 	rexx.dll!RexxMethod::run(RexxActivity * activity, RexxObject * receiver, RexxString * msgname, RexxObject * * argPtr, unsigned int count, ProtectedObject & result)  Line 325	C++
 	rexx.dll!RexxObject::messageSend(RexxString * msgname, RexxObject * * arguments, unsigned int count, ProtectedObject & result)  Line 793	C++
 	rexx.dll!RexxExpressionStack::send(RexxString * message, unsigned int count, ProtectedObject & result)  Line 74 + 0x33 bytes	C++
 	rexx.dll!RexxExpressionMessage::evaluate(RexxActivation * context, RexxExpressionStack * stack)  Line 139	C++
 	rexx.dll!RexxExpressionMessage::evaluate(RexxActivation * context, RexxExpressionStack * stack)  Line 123 + 0x23 bytes	C++
 	rexx.dll!RexxInstructionAssignment::execute(RexxActivation * context, RexxExpressionStack * stack)  Line 122 + 0x1d bytes	C++
 	rexx.dll!RexxActivation::run(RexxObject * _receiver, RexxString * msgname, RexxObject * * _arglist, unsigned int _argcount, RexxInstruction * start, ProtectedObject & resultObj)  Line 522	C++
 	rexx.dll!RexxCode::call(RexxActivity * activity, RoutineClass * routine, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, RexxString * calltype, RexxString * environment, int context, ProtectedObject & result)  Line 116	C++
 	rexx.dll!RexxCode::call(RexxActivity * activity, RoutineClass * routine, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, ProtectedObject & result)  Line 92	C++
 	rexx.dll!RoutineClass::call(RexxActivity * activity, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, ProtectedObject & result)  Line 234	C++
 	rexx.dll!InterpreterInstance::runRequires(RexxActivity * activity, RexxString * name, RoutineClass * code)  Line 877	C++
 	rexx.dll!InterpreterInstance::loadRequires(RexxActivity * activity, RexxString * shortName, RexxString * fullName)  Line 932	C++
 	rexx.dll!RexxSource::loadRequires(RexxActivity * activity, RexxString * target)  Line 6082 + 0x14 bytes	C++
 	rexx.dll!PackageClass::loadPackage(RexxString * name, RexxArray * s)  Line 366 + 0x16 bytes	C++             <-- rgf_util2.rex
    while loading rgf_util2.rex
    
Why is 0x7eee1ac0 a dead object ? 
In RexxSource::extractSource, the array "source" is created, but is not a ProtectedObject.


===============================================================================
2010 may 15

Fix build under Windows for dbgprintf (link error).

Changed the build for "oodialog" target :
Builds both oodialogA and oodialogW (and not just oodialogA as before)
Ex :
makeorx BOTH oodialog clean --> cleans the debug & release files of oodialogA and oodialogW
makeorx BOTH oodialog       --> builds the debug & release files of oodialogA and oodialogW

Made a review of the conversions and removed those unneeded.
opts can remain byte-char.
strdupupr and strdupupr_nospace can remain byte-char.
setControlData can remain byte-char. The conversion is done internally.
putUnicodeText converts to wide-char, so no need to convert byte-char to wide-char before calling it (but keep the wide-char signature)


===============================================================================
2010 may 15

Added the function dbgprintf to write debug strings. 
Under Windows, it calls OutputDebugString.
Under Linux, it calls syslog.

Remember, typical debug session under PuppyLinux (with busybox) :
Open a console : 
    syslogd -S -C   # -S Smaller loggin output. -C Log to share mem buffer (read it using logred).
    logread -f
    The output of syslog is displayed by logread in this console (lock management, on client and server side).
Open a console, launch rxapi. 
    Has been compiled to stay as a foreground process. 
    It sends debug strings to stderr, more easy to follow in this console (messages between client and server).
Open a console, run the rexx command. The two other consoles are updated with debug infos.


[2011 apr 25 update]
Under MacOsX, I see this message in console : process exceeded 500 log messages per second limit.
To bypass this limit :
Edit /System/Library/LaunchDaemons/com.apple.syslogd.plist with xcode (binary format)
Search for : <string>/usr/sbin/syslogd</string>
Add these lines to the program arguments section :
<string>-mps_limit</string>
<string>0</string>
A value of 0 disables the limit. The default is 500 messages per second.
Restart the syslog daemon with:
sudo launchctl unload /System/Library/LaunchDaemons/com.apple.syslogd.plist
sudo launchctl load /System/Library/LaunchDaemons/com.apple.syslogd.plist
-----
LOG_DEBUG messages still not visible in console...
Probably because of /etc/asl.conf :
    # save everything from emergency to notice
    ? [<= Level notice] store
Remember :
    Emergency     (level 0)
    Alert         (level 1)
    Critical      (level 2)
    Error         (level 3)
    Warning       (level 4)
    Notice        (level 5)
    Info          (level 6)
    Debug         (level 7)
-----
Create the file /var/log/debug.log : 
sudo touch /var/log/debug.log
Add this line to /etc/syslog.conf to get the debug messages in /var/log/debug.log :
*.debug   /var/log/debug.log
then restart the syslogd daemon as explained above.


===============================================================================
2010 may 14

More work on wide-chars in oodialog.

Fixed a crash in the conversion A2W and W2A : The length must be asked to the Windows service,
and not calculated with bad assumptions as I did.


Something not clear to me : 
In oodMessaging.cpp, there is a message queue implemented as a string. 
Each element is separated by a special character 0xFF.
This message queue is declared rxcharT, so it's a wide-char string when building the wide-char configuration.
Several methods have a rexxMethod parameter, and I declared it rxcharT.
But normally, a method name is always a byte-char string, there is no need to convert it to wide-char...
Problem : if I declare it as rxcharA, then what should I do with the pMessageQueue ?
Can I declare it rxcharA ? in this case, I must encode wide-char to byte-char each time a message is added
Or is it better to keep it rxcharW ? Currently addDialogMessage takes two wide-char arguments...
It's a matter of conversion boundary...


The japanese characters are not properly displayed by MessageBox (i.e. InfoDialog).
It seems that under XP, one must install files for complex scripts.
Not needed under Vista.
--> go to the "Regional and Language Options" control panel, go to the "Languages" tab, 
and select "Install filesfor complex script...".
You need to reboot :-(
--> good, after reboot it works...


===============================================================================
2010 may 13

More work on wide-chars in oodialog.

New configuration names : oodialogA and oodialogW.
No longer needed to pass "WCHAR=1" to build the wide-char configuration.
makeorx DEBUG                   builds both configurations
makeorx DEBUG oodialogA         builds the byte-char configuration
makeorx DEBUG oodialogA clean   cleans the byte-char configuration
makeorx DEBUG oodialogW         builds the wide-char configuration
makeorx DEBUG oodialogW clean   cleans the wide-char configuration
makeorx DEBUG oodialog          like oodialogA

byte-char and wide-char configurations of oodialog are working, tested with oodialog examples.
There are some problems, but I have the same problems in trunk, so I assume there are some work in progress there...

Test of wide-char configuration :
It's not enough to put win32dbg/wchar in fromt of %PATH%, you must also rename
or remove win32dbg/oodialog.dll because it's this DLL which is loaded by default.
See unicode/ooRexx/oodtree.png for a screenshot with french, german, hebrew, russian, greek, etc...

Summary of the changes made to the oodtree example :
oodtree.rex, added : call setCodePage 65001 -- UTF-8
oodtree.rc, changed : FONT 8, "Arial Unicode MS"
oodtree.inp, added UTF-8 strings for demo


===============================================================================
2010 may 9

Added support for wide-chars in oodialog.
Currently, the "A" Windows API is called, and the conversion occurs there, inside Windows, based on the current locale.
When compiling ooDialog with wide chars UTF-16, the "W" API is called directly, making the dialogs Unicode-enabled.
GTK+ uses UTF-8 internally. Most of  the Unix-style operating systems use UTF-8 internally. 
So it's natural to use multi-byte chars in ooRexx instead of wide chars, and to provide string services which supports UTF-8.
But the case of ooDialog is different : 
This is a Windows-only sub-system, and for better integration with Windows, it must use UTF-16 chars internally. 
The conversion to UTF-16 is under the responsability of ooDialog, which lets support code pages that are different 
from the system's default code page. Typically, we can pass UTF-8 string to ooDialog which convert them to UTF-16 strings 
before calling the Windows "W" API.

By default, the byte-char configuration is built when buildling the whole interpreter :
makeorx DEBUG

To build the byte-char configuration only, enter :
makeorx DEBUG oodialog
or
makeorx DEBUG oodialog "WCHAR=0"


To clean the byte-char configuration, enter :
makeorx DEBUG oodialog clean
or
makeorx DEBUG oodialog clean "WCHAR=0"

To build the wide-char configuration, enter :
makeorx DEBUG oodialog "WCHAR=1"
The output files are generated in the subdirectory win32dbg\wchar

To clean the wide-char configuration, enter :
makeorx DEBUG oodialog clean "WCHAR=1"


===============================================================================
2010 april 28

rgf_util2 wrappers to make the services of Rony available as methods on predefined classes.
For proof of concept... For a real library of methods, rgf_util2 should be rewritten to use
the variable "self" where appropriate, instead of passing the object as first parameter.



===============================================================================
2010 april 25

Add ::extension directive
todo : Limit the extension to new methods, raise an error if redefining a predefined method
(but keep ~define unlocked for investigation).

todo : I don't manage dependencies on ExtensionDirective
See RexxSource::resolveDependencies, there is maybe something to do there.
Currently, if the same method is extended several times, then it's the "last" extension who wins...
The definition of "last" depends on the order of resolution of ::requires
See samples\extension\test_extension_order.rex

Remember : 
Unlike ::class, you can have several ::extension in the same source for the same class. 
So the current check for duplicate method in an ExtensionDirective is not very useful. 
The interpreter will complain for that :
::extension object
::method m
::method m
but not for that :
::extension object
::method m
::extension object
::method m


===============================================================================
2010 april 24

Unlock ~define


Creation of sandbox :
cd D:\local\Rexx\ooRexx\svn\sandbox
mkdir jlf
svn add jlf
svn commit jlf
svn copy https://oorexx.svn.sourceforge.net/svnroot/oorexx/main/trunk https://oorexx.svn.sourceforge.net/svnroot/oorexx/sandbox/jlf
svn update jlf

rev 5812
merge 5812-5835 from main/trunk
merge 5835-5957 from main/trunk
merge 5957-5988 from main/trunk
merge 5988-6048 from main/trunk
merge 6048-6142 from main/trunk
merge 6142-6189 from main/trunk
merge 6189-6500 from main/trunk
merge 6500-6784 from
    main/trunk/api
    main/trunk/extension/hostemu
    main/trunk/interpreter
    main/trunk/platform
    main/trunk/rexxapi
merge 6784-6976 from
    main/trunk/configure.ac (except oodialog)
    main/trunk/Makefile.am
    main/trunk/makeorx.bat
    main/trunk/extensions/platform/unix
    main/trunk/extensions/rexxutil
    main/trunk/extensions/rxsock
    main/trunk/interpreter
    main/trunk/platform/unix
    main/trunk/rexxapi

Remember todo : 
    merge 6500-xxxx from main/trunk/extensions/platform/windows/oodialog
    merge 6500-xxxx from main/trunk/samples
    merge 6784-xxxx from main/trunk/platform/windows
