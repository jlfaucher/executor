Sandbox for experimental work, some ideas to investigate :

Try to understand the internal locks.
--> added some dbgprintf (Windows and Linux), now must analyze...

Allow extension of the predefined ooRexx classes to get something similar to C# extension methods (but more powerful).
done.
--> unlock the define method : see samples/functional for an example of use.
    unlock the inherit method
    added ::extension directive
    >>-::EXTENSION--classname----+-------------------+-----------------><
                                 +-INHERIT--iclasses-+

Add the "in" keyword to the DO repetitor : Similar to "over" but calls the method "supplier" instead of "makearray".
[2015 Jul 12] : no longer needed to work on that, ooRexx5 supports DO WITH index ITEM item OVER supplier

See if a thread could return more than one result and become a generator when synchronized with : do i in generator ...
--> done with .Coactivity

Export the classes instantiated by the parser and make expression instances available from an ooRexx script.
Inspired by C# LINQ and the expression tree API.
See if that can be used to write macros (i.e. transform expression tree), user directives, DSL...
todo...

Named parameters (by opposition to positional parameters).
In C#, they say it's useful for calling COM services.
I have some Excel macros that would be simpler to call with that.
--> I started to think about that, but it appears that the ooRexx arguments are not easy to manage by name.
It's because the arguments are not declared in a single place at the begining of a procedure/routine/method.
They can be declared several times, and complex expressions can be used (stem, instance's attribute, ...).
Moreover, named arguments can be passed in any order, and that's a problem with current management by array.
So, I give up...
[2015 mar 8]
I reopen the subject... Named arguments can be managed separately from the array of arguments.
"123 456 789"~reduceW(100, "+")
could become
"123 456 789"~reduce("+") by:"word" initial:100
The named parameters don't impact the array of arguments, nor the declaration of arguments.
They could be provided in a directory returned by .context~namedArgs.
They could be optionally be declared with the 'use' instruction :
use strict named args by, initial=.nil

Deferred evaluation of parameters.
Let the routine/method decide which parameters must be evaluated, ex : iif(cond, iftrue, iffalse)
todo
--> See routine if(aLogical, whenTrue, whenFalse).
    It's up to the caller to freeze the evaluation, by passing explicitely a doer.
    So the goal is not reached... I want the callee to have full control of the evaluation.
According to
http://www.nhplace.com/kent/Papers/Special-Forms.html
fexpr must be avoided. Macros are better.

Investigate the Activation stack (reify ? closure ? continuation ?)
--> closure by value : done

Unicode ?
--> added support for wide-chars in oodialog. [now deprecated]
--> frozen : m17n (this is not the way proposed by Rick)

Extension of the message term : keyword and multiple dispatch.
http://atomo-lang.org/
http://slatelanguage.org/
todo...

Tracer todo :
Add support for classic trace (without multithread infos).
The CSV format can be useful for classic trace, because each line has the name of the current executable.

Pipes todo :
.inject in breadthFirst mode is not limited by the ooRexx callstack size.
Do the same for depthFirst mode.
1~pipe(.inject {2*item} rec.506 | .take last | .console) is ok, but if you do one more recursion,
you get the error "Insufficient control stack space; cannot continue execution"
No such problem in breadthFirst mode :
1~pipe(.inject {2*item} rec.b.100000 | .take last | .console) --> last result is 1.99800307E+30103

Pipes todo :
Add partition support to .stemCollector, .arrayCollector
For .arrayCollector, the collected values will be arrays.
For .stemCollector, I don't know.
Is .stemCollector really needed ? I don't see the added value, compared to .arrayCollector

Extension todo :
During parsing, the extensions methods of an ::extension directive are accumulated in a table.
Must use an ordered collection because the order of declaration is important.

Extension todo :
Forbids to replace a predefined method. The goal is to extend, not to alter the behavior.
Maybe not so easy to do for 'inherit'.

Extension todo :
Add the parameters "unlock=.false, propagate=.false" to the methods .class~define and .class~inherit.

Extension todo :
Review the extension mechanisms :
- An extension made on .Object is not available on a class.
  There is a workaround in pipe_extensions.cls.
- An extension made on .Object is not available on the .nil object.
  No workaround so far.
- The class .stream doesn't have the methods ~pipe, ~generate.
  Problem of propagation ?
    ----- Generate the list of all classes and the list of classes having the method ~pipe
    allClasses = .object~generate("subClasses")~iterateAfter~recursive~once
    classesWithPipe = .object~generate("subClasses")~iterateAfter~recursive~once~select{item~hasMethod("pipe")}
    ----- Print difference between the two lists
    set1 = allClasses~reduce(.set~new, "put")
    set2 = classesWithPipe~reduce(.set~new, "put")
    difference = set1~difference(set2)
    difference~pipe(.sort caseless | .console item)
    -----
    Result :
        (The CircularQueue class)
        (The CoactivitySupplierForGeneration class)
        (The CoactivitySupplierForGenerationFilter class)
        (The CoactivitySupplierForGenerationIterator class)
        (The DescendingComparator class)
        (The do class)
        (The lineCount class)
        (The OrderedCollection class)
        (The pipeProfiler class)
        (The Properties class)
        (The secondaryConnector class)
        (The Set class)
        (The Stream class)
        (The StreamSupplier class)
        (The WeakProxy class)
    What's the problem with these classes ???
- Similar problem with the ~help method, but the list of classes is different.
  The pipeStage classes don't have the problem of missing method ~help, why ?
  This method ~help is not redefined in the pipe framework...
        (The CircularQueue class)
        (The Class class)
        (The CoactivitySupplierForGeneration class)
        (The CoactivitySupplierForGenerationFilter class)
        (The CoactivitySupplierForGenerationIterator class)
        (The DescendingComparator class)
        (The OrderedCollection class)
        (The Properties class)
        (The Set class)
        (The Stream class)
        (The StreamSupplier class)
        (The WeakProxy class)

Profiler todo :
Error "does not understand message XXX_UNPROTECTED" when the method XXX is private.

Clauser todo :
Keep the multi-line source literals as-is (multi-line), for better error report.
That makes the transformation of clauses more difficult, since a clause can be
multi-line.
Remember : a multi-line source literal is flattened only if a transformation is
made on the clause which contains it.


===============================================================================
2016 oct 09

Generator : don't yield when no result if this is the last yield before end.
This is similar to the behavior of Coactivity, see yieldLast.

This decision was taken while playing with executor to see how to split a string in substrings of 3 characters.
The string below, when encoded in UTF-8, is made of 3 bytes per character.
'こんにちは世界'~generate{if depth==0 then item; else do; item = item~substr(4); if item <> "" then item; end}~recursive~each{item~left(3)}~iterator~each=
'こんにちは世界'~pipe{{::co expose item; loop while item <> "";call yield item~left(3); item=item~substr(4);end}}~iterator~each=
Both one-liners return ['こ','ん','に','ち','は','世','界']


===============================================================================
2016 may 29

Summary of the changes made since the previous entry.

ooRexxShell
-----------

Bypass a bug in official ooRexx which delegates to system() when the passed address is bash.
The bug is that system() delegates to /bin/sh, and should be called only when the passed address is sh.
Because of this bug, the readline procedure (which depends on bash) is not working and must be deactivated
when the interpreter is the official ooRexx.

Security manager: optimization
It's no longer mandatory to implement all the methods of a security manager.
When a check is not needed, just don't provide the corresponding method.
That can reduce drastically the number of security checkpoint messages sent by the interpreter.
Example:
do 1000000;x=.true;end   -- 5.440 sec (before the optimization)
do 1000000;x=.true;end   -- 0.300 sec (now, with the optimization)
It's possible to still do better, that will be the next optimization to apply to ExpressionDotVariable.
Should be as fast as
do 1000000;x=1;end       -- 0.080 sec
by calculating at parse-time the value of the predefined variables like .true, .false, .nil
and the value of the predefined classes like .object, .class, .string, etc...

Predefined queries allow to get the list of classes, methods, packages.
A first level of filtering is done when specifying class names or method names.
If the package regex.cls is available, then the names are regular expressions.
Otherwise the names are just string patterns.
A second level of filtering is possible at output line level.


Complex numbers
---------------

Use request("complex") instead of .complex~convert.
This is the technique recommended by the ooRexx reference documentation.
But... it doesn't work when added by extension to the class String:
    1~makeComplex returns a complex (good)
    1~hasmethod("makecomplex")= returns .true (good)
    1~request("complex") doesn't work, returns .nil (not good --> fixed).
The implementation of RexxObject::requestRexx has been modified.
    old: RexxMethod *method = this->behaviour->methodLookup(make_method);
    now: RexxMethod *method = this->instanceMethod(make_method);
Behind the scene, "1" is an instance of RexxInteger. The method "makecomplex"
added by extension on String does not exist in the behaviour table of RexxInteger.
When using instanceMethod, the interpreter automatically forward to the string
representation when a method is not found :
return stringValue()->instanceMethod(method_name);


Infinity
--------

Added support for calculations.
1 + infinity = infinity (first need for the array~depth method).
infinity < 1 = .false (first need for depth of element-wise operations).
And other arithmetic operators...


Multiple extensions of operators on String
------------------------------------------

Both Complex and Infinity define extensions on String.
The interpreter send messages for alternative operators to String.
The dispatching to Complex & Infinity is hardcoded in string.cls.
Example:
::method "+op:right"
    forward continue class (.complexString)
    if var("result") then return result
    forward class (.infinityString)
Initially, I wanted to put the dispatching inside the interpreter, by iterating
over the mixin classes inherited by String.
But after thoughts, I realize it's better to keep the dispatching in the user code.
Currently, String inherit from more than 10 mixin classes :
    StringDoer
    StringFilter
    StringIterator
    StringReducer
    StringGenerator
    StringMapper
    StringHelpers
    RepeaterCollector
    RepeaterGenerator
    LogicalExtension
    EncodedString
    OperatorDispatcher : mixin providing an extension of operators for dispatching.
    ComplexString : mixin providing an extension of operators for complex numbers.
    InfinityString : mixin providing an extension of operators for infinity.
Dispatching to all these mixin classes would be costly.
Dispatching to only 2 mixin classes is better.


Alternative operators for comparisons
-------------------------------------

In short :
A message for alternative comparison can be sent when two strings are compared.
A string can be a RexxInteger or a RexxNumber or a RexxString.
This message is sent BEFORE a string comparison happens (i.e. before a number or
an object is converted to a string).
If no alternative operator, or no result returned then do a string comparison.
integer op integer      not impacted                    1 < 10
integer op number       not impacted                    1 < 1e20
integer op other        try alternative operator        1 < infinity            -- "INFINITY"~"<OP:RIGHT(1)
number op number        not impacted                    1e20 < 1e19
number op other         try alternative operator        1e20 < infinity         -- "INFINITY"~"<OP:RIGHT(1E20)
string op number        try alternative operator        infinity < 1            -- 1~"<OP:RIGHT"("INFINITY")
string op string        not impacted                    infinity < pi           -- true (yes... string comparison)
string op other         try alternativeOperator         infinity < -infinity    -- (The negative infinity)~"<OP:RIGHT("INFINITY")

Modification of the following methods to give a chance for an alternative operator
before promoting the first argument from an integer|number to a string,
or before requesting a string:
    RexxInteger::comp               RexxNumberString::comp              RexxString::comp
    RexxInteger::equal              RexxNumberString::equal             RexxString::equal               non-strict =
    RexxInteger::notEqual           RexxNumberString::notEqual          RexxString::notEqual            non-strict \=
    RexxInteger::isGreaterThan      RexxNumberString::isGreaterThan     RexxString::isGreaterThan       non-strict >
    RexxInteger::isLessThan         RexxNumberString::isLessThan        RexxString::isLessThan          non-strict <
    RexxInteger::isGreaterOrEqua    RexxNumberString::isGreaterOrEqual  RexxString::isGreaterOrEqual    non-scrict >=
    RexxInteger::isLessOrEqual      RexxNumberString::isLessOrEqual     RexxString::isLessOrEqual       non-strict <=

Evaluation of the expression (1 > -infinity) :
    1 is a RexxInteger.
    -infinity is evaluated as .infinity~negative.
    RexxInteger::comp
        Since .infinity~negative is not a RexxInteger, 1 is promoted to a RexxNumberString.
    RexxNumber::comp
        Since .infinity~negative is not a RexxNumberString, 1 is promoted to a RexxString.
    RexxString::comp
        A string comparison would return .false: "1" > "The negative infinity".
        But thanks to the alternative operator, the result is correct:
        .infinity~negative~">op:right"(1)= -- .true

Evaluation of the expression (infinity > 0) :
    infinity is a RexxString.
    1 is a RexxInteger.
    RexxString::comp (standard ooRexx)
        If both arguments can be converted to a number then do a numeric comparison
        otherwise do a string comparison.
        -->
        A string comparison would be done: "infinity" > "1"
    RexxString::comp (executor)
        Try the alternative operator
        when only one of the arguments can be converted to a number.
        when none of the arguments can be converted to a number and the right argument is not a string.
        -->
        An alternative operator is used: 1~">OP:RIGHT("INFINITY")


Array programming
-----------------

Methods added to Object:

rank
    APL R←⍴⍴Y
    An array may have 0 or more axes or dimensions.
    The number of axes of an array is known as its rank.
    An array with 0 axes (rank 0) is called a scalar
    An array with 1 axis (rank 1) is called a vector.
    An array with 2 axes (rank 2) is called a matrix or table.
    An array with 3 axes (rank 3) is called a cube.
    An array with more than 2 axes is called a multi-dimensional array

    ooRexx:
    Any object other than an array is a scalar.
    In particular, a string is a scalar, not an array as in APL.
    Special case which does not exist in APL : The rank of an array with no dimension yet assigned is -1.

shape
    APL R←⍴Y (Rho)
    The shape of a scalar is an empty vector []
    The shape of an array is an array which gives the size of each dimension.
    The display of the shape has been reworked: no longer NxMx... because was not adapted to the case rank=0.
    .array~new  -- an Array (no shape, 0 items)                 rank=-1
    a()         -- an Array (shape [], 0 items)         scalar  rank=0
    a(0)        -- an Array (shape [0], 0 items)        vector  rank=1
    a(3,2)      -- an Array (shape [3,2], 0 items)      matrix  rank=2
    a(3,2,1)    -- an Array (shape [3,2,1], 0 items)    cube    rank=3

reshape
    APL R←X⍴Y (Rho)
    args : new dimension(s)

depth
    APL R←≡Y (Equal Underbar)
    Depth (≡) indicates the degree of nesting within an array.
    It returns a non-negative integer which defines the maximum number of levels
    of structure to be penetrated in order to get to a simple scalar where simple means non-nested.
    The depth of an array is 1 greater than that of its most deeply nested item.
    Returns "infinity" when the array is self-referencing.

enclose
    (this method replaces ~isBoxed which is removed)
    APL R←⊂Y (Left Shoe)
    If Y is a simple scalar, R is the simple scalar unchanged.
    Otherwise, R has a depth whose magnitude is one greater than the magnitude of the depth of Y.

disclose
    APL R←⊃Y (Right Shoe)
    Disclose is the inverse of Enclose.

Element wise calculations can be limited to a given depth.

Examples:
v1=v(1,2)
v2=v(3,4)
v3=v(3,4,5)
v1+v2=                  -- [4,6]
v1+v3=                  -- error: Shapes are not equal
v1~enclose+v2=          -- [<[4,5]>,<[5,6]>]
v1~enclose+v3=          -- [<[4,5]>,<[5,6]>,<[6,7]>]
v1+v2~enclose=          -- <[4,5]>,<[5,6]>]
v1+v3~enclose=          -- [<[4,5,6]>,<[5,6,7]>]
v1~enclose+v2~enclose=  -- error Element-wise operation does not support two enclosed arrays
                        -- (probably to support, Dyalog APL supports it)


===============================================================================
2015 dec 21

RexxBlock: The removal of {::method...} allows more simplifications.

Remove tag ::closure.
The existence of an expose clause is enough to know that the block is a closure.
{::closure expose ...} --> {expose ...}

Remove option .coactive.
{::routine.coactive ...}        --> {::coactivity ...}
{::closure.coactive expose ...} --> {::coactivity expose ...}


===============================================================================
2015 dec 6

Add by extension the method "unknown" to the class .Object:
::extension Object
::method unknown unguarded
    use arg msg, args
    raise syntax 97.1 array(self, msg)

With this extension, I can forward the message "unknown" to the class (super).
Without this extension, I have a stack overflow.

First needed for the implementation of 1~10 --> 1~upTo(10):
::class RepeaterCollector
::method unknown unguarded
    use arg msg, args
    if self~dataType("N"), msg~dataType("N") then do
        if msg >= self then return self~sendWith("upto", args~~insert(msg, .nil))
        else return self~sendWith("downto", args~~insert(msg, .nil))
    end
    forward class (super)


===============================================================================
2015 dec 5

Remove support of {::method...}
After 4 years, I never needed a method as a block.

The decision has been taken after investigating how to remove the source transformation
at run-time (functionDoer). I will probably add support for implicit arguments, whose
name is given by the caller. The instruction "use implicit" will be injected at parse-time
in all block sources. Since the callee has no control over the names given by
the caller, there was a risk to break encapsulation when the callee is a method
which exposes some attributes. The caller could assign a value to any exposed
variable, just by passing the variable name as implicit name.


===============================================================================
2015 nov 15

More work on ~upTo ~downTo

When the count is negative then only the last -count elements are generated.
Ex :
0.3~4.3(0.7, -5)=  -- [1.0,1.7,2.4,3.1,3.8]

The setting of numeric digits is adjusted to ensure a correct progression.
Algoritm:
    loop
        if from + step - from = step & limit + step - limit = step then leave
        numeric digits digits() + digits() % 2
    end
Ex:
1~20000000000(0.000000127, 3)=     -- [1,1.000000127,1.000000254]
1~20000000000(0.000000127, -3)=    -- [19999999999.999999681,19999999999.999999808,19999999999.999999935]

The value of digits() is passed as argument digits to the doer.
That allows to declare the same setting in the context of the doer, if needed.
Reminder: by default, the setting of numeric digits is 9 inside the doer (standard ooRexx setting).
Ex:
do i=10 to 100 by 10; n="1e"i; n~upto(n,,1){say "digits="digits "item+0="item+0 "item="item}; end
digits=13 item+0=1E+10 item=10000000000
digits=28 item+0=1E+20 item=100000000000000000000
digits=42 item+0=1E+30 item=1000000000000000000000000000000
digits=42 item+0=1E+40 item=10000000000000000000000000000000000000000
digits=63 item+0=1E+50 item=100000000000000000000000000000000000000000000000000
digits=63 item+0=1E+60 item=1000000000000000000000000000000000000000000000000000000000000
digits=94 item+0=1E+70 item=10000000000000000000000000000000000000000000000000000000000000000000000
digits=94 item+0=1E+80 item=100000000000000000000000000000000000000000000000000000000000000000000000000000000
digits=94 item+0=1E+90 item=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
digits=141 item+0=1E+100 item=10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000


===============================================================================
2015 nov 15

.array~of(1,2,3,4)~~insert(0,.nil)=
Crash --> fixed.


.numberString~upTo
.numberString~downTo
.numberString~numberString
Modified to support all the possibilities of controlled loop:
r=.array~new; loop i=0.3 to 4.3 by 0.7 for 5; r~append(i); end; r= -- [0.3,1.0,1.7,2.4,3.1]
The same loop:
0.3~upTo(4.3, 0.7, 5)=  -- [0.3,1.0,1.7,2.4,3.1]
0.3~4.3(0.7, 5)=        -- [0.3,1.0,1.7,2.4,3.1]


Complex numbers:
Add support for notation a+bi where a and b are numbers.
i+1 did not trigger the execution of "+op:right"
It's because 1 is a RexxIntegerClass whose behaviour can't be extended with ::extension.
By sending the alternative message "+op:right" to the string associated to the RexxIntegerClass then it works.
This is already what's done by the interpreter for the unknown message.

Complex numbers:
Add support for unary operator + -
The message "+op:right" can't be sent because there is no right operand.
+i --> the message "+op:left" is sent by the interpreter.
-i --> the message "-op:left" is sent by the interpreter.


===============================================================================
2015 nov 12

Optimize the method .array~of (instance level).
No longer support the APL-like notation.
Benchmark array initializer

do 10000; a(9)~fill(1); end
0.04

do 10000; a(3,3)~fill(1); end
0.04

do 10000; a(9)~of(1); end
0.12s (0.095 after removing the support of space-separated list)

do 10000; a(3,3)~of(1); end
0.12s (0.095 after removing the support of space-separated list)

do 10000; a(9)~of(1,2,3); end
0.37s

do 10000; a(3,3)~of(1,2,3); end
7.5s (strange... sometimes 10s)
0.89 after removing the blocks...
The fact I call directly blocks in this method is a problem for this kind of benchmark...
I have in project to transform the block sources at parse-time...


===============================================================================
2015 nov 11

Array programming:

Helper to create a vector: v(e1, e2, ..., eN)
v(1,"text", 1.5, v(),,v(-4,3) )=    -- [1,'text',1.5,(an Array 0),..,[-4,3]]

Helper to create an empty dimensionned array: a(d1, ..., dN).
a(3)        -- [..]
a(3,2)      -- type: The Array class: (shape 3x2, 0 items)
a(3,2,1)    -- type: The Array class: (shape 3x2x1, 0 items)

Array initializer: Renamed the implicit parameters passed to a doer.
"integerIndex" --> "item"
"arrayIndex"   --> "index"
When the rank is 1, the index is an integer.
    Invariant: index == item.
    Example:
    a(10)~of{item}=     -- [1,2,3,4,5,6,7,8,9,10]
    a(10)~of{index}=    -- [1,2,3,4,5,6,7,8,9,10]
When the rank is > 1, the index is an array [i1,i2,...,iRank].
    Invariant:  1 + rank**(rank-1)*(i1-1) + rank**(rank-2)*(i2-1) + ... + rank**(0)*(iRank-1) == item
    Example:
    The reduce calculates 2 values for each index.
    The 1st value is the expression as a string.
    The 2nd value is the calculation of the expression.
    a(2,2,3)~of{index~reduce(v("1",1)){::closure expose array ; r=array~rank ; e=r-index ; v(accu[1] "+" "("r"**"e")*("item"-1)", accu[2] + (r**e)*(item-1))}}
        type: The Array class: (shape 2x2x3, 12 items)
        [1,1,1] : ['1 + (3**2)*(1-1) + (3**1)*(1-1) + (3**0)*(1-1)',1]
        [1,1,2] : ['1 + (3**2)*(1-1) + (3**1)*(1-1) + (3**0)*(2-1)',2]
        [1,1,3] : ['1 + (3**2)*(1-1) + (3**1)*(1-1) + (3**0)*(3-1)',3]
        [1,2,1] : ['1 + (3**2)*(1-1) + (3**1)*(2-1) + (3**0)*(1-1)',4]
        [1,2,2] : ['1 + (3**2)*(1-1) + (3**1)*(2-1) + (3**0)*(2-1)',5]
        [1,2,3] : ['1 + (3**2)*(1-1) + (3**1)*(2-1) + (3**0)*(3-1)',6]
        [2,1,1] : ['1 + (3**2)*(2-1) + (3**1)*(1-1) + (3**0)*(1-1)',10]
        [2,1,2] : ['1 + (3**2)*(2-1) + (3**1)*(1-1) + (3**0)*(2-1)',11]
        [2,1,3] : ['1 + (3**2)*(2-1) + (3**1)*(1-1) + (3**0)*(3-1)',12]
        [2,2,1] : ['1 + (3**2)*(2-1) + (3**1)*(2-1) + (3**0)*(1-1)',13]
        [2,2,2] : ['1 + (3**2)*(2-1) + (3**1)*(2-1) + (3**0)*(2-1)',14]
        [2,2,3] : ['1 + (3**2)*(2-1) + (3**1)*(2-1) + (3**0)*(3-1)',15]


.array~lefElementWise: supports doers of any kind, not just messages.

===============================================================================
2015 nov 08

Shorter notation for upTo and downTo:
1~10 -- same as 1~upTo(10)      [1,2,3,4,5,6,7,8,9,10]
10~1 -- same as 10~downTo(1)    [10,9,8,7,6,5,4,3,2,1]
An action can be specified:
100.5~103.6{value item}= -- ['VALUE 100.5','VALUE 101.5','VALUE 102.5','VALUE 103.5']

Array programming:
Fix the representation of sparse array (a final '..' was inserted when not needed).
Fix the calls to rightElementWise. There is no parameter letfArgIsProvided.


===============================================================================
2015 oct 23

Array operators:
All the operators support recursive arrays.
An array can be declared boxed.
A boxed array is handled as a whole when the other argument of a binary operator is also an array.

Ex:
a = .array~of(1,2,3)
b = .array~of(10,20,30)
a+b= -- [11,22,33]
b~isBoxed = .true
a+b= -- [[11,21,31],[12,22,32],[13,23,33]]


===============================================================================
2015 oct 22

Array operators:
Add support for recursive arrays.
Work in progress... Only "+" and "-" have been adapted.

Ex:
a = .array~of(1,2)
a~append(a)
a=     -- [1,2,*0]
-a=    -- [-1,-2,*0]
a+1=   -- [2,3,*0]
1+a=   -- [2,3,*0]


===============================================================================
2015 oct 20

Sparse arrays in condensed mode: display .. when a section is empty.
.array~new(1)= -- [..]
.array~new(10)= -- [..]
.array~new(20)~of{if integerIndex // 2 == 0 then integerIndex}= -- [..,2,..,4,..,6,..,8,..,10,..,12,..,14,..,16,..,18,..,20]
.array~new(20)~of{if integerIndex // 3 == 0 then integerIndex}= -- [..,3,..,6,..,9,..,12,..,15,..,18,..]
.array~new(20)~of{if integerIndex // 4 == 0 then integerIndex}= -- [..,4,..,8,..,12,..,16,..,20]


pipe.rex
dataflow_representation now supports only array of dimension 1.
Arrays with 2 dimensions or more are represented as an object Array : "an Array 2x3"


===============================================================================
2015 sept 13

GC review
stringArgument can return a new string
which should be protected
--> review all the calls of stringArgument : done

idem optionalStringArgument : done
idem ->requiredString : done
idem requiredStringArg : no problem, stored in expression stack
idem required_string : no problem, stored in expression stack
idem requestArray : done
idem REQUEST_ARRAY : done
idem makeArray : done


===============================================================================
2015 may 16

Start working on a prototype for encoded strings.
This prototype will be only Rexx code, there is no need to modify the interpreter.
The changes I made on the interpreter years ago (adding an encoding to the String
class) is not used because I will need more than one encoding per string...
I will manage this additional information with Rexx code, thanks to the extensions
mechanisms.

See "Thoughts on ooRexx and Unicode.odt", in particular the conclusion of the
first chapter, page 5.

Main ideas explored with this prototype :
- No automatic conversion to Unicode by the interpreter.
- The strings crossing the I/O barriers are kept unchanged.
- A string is made of slices, where each slice has its own encoding.
- Supported encodings : byte, utf-8, utf-16.
- When no encoding has been explicitely specified, a default encoding is used.
- Initially, the default encoding is "byte". It can be changed at anytime.
- Strings with different encodings can be concatenated, there is no need of conversion.
- The existing String class is kept unchanged, but its semantic becomes : "byte-oriented".
- The prototype will add a layer of services working at grapheme level, provided by the Text class.
- The Text class works on the bytes managed by the String class.
- String instances are immutable, the same for Text instances.

On my Mac, where locale returns :
    LANG="fr_FR.UTF-8"
    LC_COLLATE="fr_FR.UTF-8"
    LC_CTYPE="fr_FR.UTF-8"
    LC_MESSAGES="fr_FR.UTF-8"
    LC_MONETARY="fr_FR.UTF-8"
    LC_NUMERIC="fr_FR.UTF-8"
    LC_TIME="fr_FR.UTF-8"
    LC_ALL=

I get that under ooRexxShell :
s1 = "é"
s1=                                 -- 'é'
s1~length=                          -- 2
s1~c2x=                             -- C3 A9
combining_acute_accent = "cc81"x
s2 = "e" || combining_acute_accent
s2=                                 -- 'é'
s2~length=                          -- 3
s2~c2x=                             -- 65 CC 81

My goal :
s1~text~length=                     -- 1 grapheme
s1~text~codepoints~length=          -- 1 codepoint
s1~text~string~length=              -- 2 bytes
s2~text~length=                     -- 1 grapheme
s2~text~codepoints~length=          -- 2 codepoints
s2~text~string~length=              -- 3 bytes

For a more complex example of combining characters, see
https://6guts.wordpress.com/2015/04/20/this-week-digging-into-nfg-fixing-use-fatal-and-more/

The ooRexx programmer has the choice :
- working with String at byte level
- working with Text at grapheme level.
- the same instance of String is used in both cases.

myString = "où as tu e" || .UTF8Encoding~character("combining acute accent") || "té ?"
myString=                       -- 'où as tu été ?'
myText = myString~text
myText=                         -- T'où as tu été ?'
myString~text == myText=        -- true, always return the same counterpart
myText~string == myString=      -- true, always return the same counterpart
myString~length=                -- 18
myText~length=                  -- 14

                                -- 1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18
myString~c2x=                   -- 6F C3 B9 20 61 73 20 74 75 20 65 CC 81 74 C3 A9 20 3F
                                -- o. ù....  . a. s.  . t. u.  . e. acute t. é....  . ?.

                                -- 1  2     3  4  5  6  7  8  9  10       11 12    13 14
myText~c2x=                     -- 6F C3B9  20 61 73 20 74 75 20 65 CC81  74 C3A9  20 3F
                                -- o. ù...   . a. s.  . t. u.  . e. acut  t. é...   . ?.


===============================================================================
2015 mar 8

Moved the implementation of the Y combinator from the class Doer to the class
RoutineDoer because, by definition, a combinator is a lambda with no free variable.
So can't be a message (not a lambda), nor a closure or method (can have free variables).
No reason to support the Y combinator on a coactivity, because only one result is
expected. So the only remaining candidate is a routine.


Added the implementation of the Y combinator with memoization.
::class RoutineDoer
::method YM unguarded
    use strict arg verbose=.false
    if verbose then trace i
    f = self -- to be closer to the notation (here, self is the routine to which the Y combinator is applied)
    table = .Table~new
    return {use arg a ; return a~(a)} ~ {
        ::closure expose f verbose table
        if verbose then trace i
        use strict arg x
        return f ~ { ::closure expose x verbose table
                     if verbose then trace i
                     use strict arg v
                     r = table[v]
                     if r <> .nil then return r
                     r = x~(x)~(v)
                     table[v] = r
                     return r}
    }

Application to fibonacci :
fibm = { use arg fib; return {::closure expose fib ; use arg n; if n==0 then return 0; if n==1 then return 1; if n<0 then return fib~(n+2) - fib~(n+1); return fib~(n-2) + fib~(n-1)}}~YM
fibm~(20) is calculated almost instantly,
whereas the not-memoizing version needs almost 30 sec.

Both Y and YM are subject to stack overflow.
But YM can be used by steps, to calculate very big fibonacci numbers, thanks to the memoization :
do i=1 to 100; say "fibm~("i*100")="fibm~(i*100); end
    fibm~(100)=3.54224847E+20
    fibm~(200)=2.80571176E+41
    fibm~(300)=2.22232246E+62
    ...
    fibm~(10000)=3.36447936E+2089
The first execution needs around 2.5 sec.
The following executions need less than 0.01 sec.


Added the method 'variables' to the class Closure,
which returns a directory of the variables captured by the closure.
Illustration after the calculation of fibm~(10000) :
fibm=
    (a RexxBlock)
fibm~executable=
    (a Closure)
fibm~executable~source=
    expose fib; use arg n; if n==0 then return 0; if n==1 then return 1; if n<0 then return fib~(n+2) - fib~(n+1); return fib~(n-2) + fib~(n-1)
fibm~executable~variables=
    type: The Directory class: (1 items)
    # 1: index='FIB' -> item=(a RexxBlock)
fibm~executable~variables["FIB"]~executable=
    (a Closure)
fibm~executable~variables["FIB"]~executable~source~each{say item}
    expose x verbose table
    if verbose then trace i
    use strict arg v
    r = table[v]
    if r <> .nil then return r
    r = x~(x)~(v)
    table[v] = r
    return r
fibm~executable~variables["FIB"]~executable~variables=
    type: The Directory class: (6 items)
    # 1: index='F'       -> item=(a Routine)
    # 2: index='SELF'    -> item=(a Closure)
    # 3: index='SUPER'   -> item=(The Doer class)
    # 4: index='TABLE'   -> item=(a Table (10000 items))
    # 5: index='VERBOSE' -> item=0
    # 6: index='X'       -> item=(a RexxBlock)
fibm~executable~variables["FIB"]~executable~variables["X"]~executable=
    (a Closure)
fibm~executable~variables["FIB"]~executable~variables["X"]~executable~source~each{say item}
    expose f verbose table
    if verbose then trace i
    use strict arg x
    return f ~ { ::closure expose x verbose table
                 if verbose then trace i
                 use strict arg v
                 r = table[v]
                 if r <> .nil then return r
                 r = x~(x)~(v)
                 table[v] = r
                 return r}
fibm~executable~variables["FIB"]~executable~variables["X"]~executable~variables=
    type: The Directory class: (5 items)
    # 1: index='F'       -> item=(a Routine)
    # 2: index='SELF'    -> item=(a Routine)
    # 3: index='SUPER'   -> item=(The Doer class)
    # 4: index='TABLE'   -> item=(a Table (10000 items))
    # 5: index='VERBOSE' -> item=0
fibm~executable~variables["FIB"]~executable~variables["X"]~executable~variables["F"]~source=
    use arg fib; return {::closure expose fib ; use arg n; if n==0 then return 0; if n==1 then return 1; if n<0 then return fib~(n+2) - fib~(n+1); return fib~(n-2) + fib~(n-1)}


===============================================================================
2014 may 29

The reading of https://github.com/raganwald-deprecated/homoiconic
brings interesting ideas to implement :
- Modify the implementation of ~pipe to support the T combinator
  thrush : Txy = yx : reverse evaluation.
  (makes an expression read consistently from left to right)
- Modify the implementation of ~pipe to support the K combinator
  kestrel : Kxy = x : return a constant function.
  (when no result returned by the doer, return the receiver (self))

Example without thrush :

Square (take the numbers from 1 to 100, select the odd ones, and take the sum of those).
{return arg(1) ** 2}~(1~upto(100)~select{item // 2 == 1}~reduce("+"))=
-- return 6250000

Same example with thrush :

Take the numbers from 1 to 100, keep the odd ones, take the sum of those, and then answer the square of that number.
Here, the block benefits from the implicit argument "item" and implicit return.
1~upto(100)~select{item // 2 == 1}~reduce("+")~pipe{item ** 2}=
-- return 6250000

Same example with kestrels, to log intermediate results :

1~upto(100)~select{item // 2 == 1}~pipe{say item~ppRepresentation}~reduce("+")~pipe{say item}~pipe{item ** 2}=
-- display [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63,65,67,69,71,73,75,77,79,81,83,85,87,89,91,93,95,97,99]
-- display 2500
-- return  6250000


===============================================================================
2014 apr 27

Merge revisions 9515-9978 from SourceForge main/trunk

Remove oodialog :
main/trunk/extensions/platform/windows/oodialog
main/trunk/samples/windows/oodialog


===============================================================================
2014 jan 26

[operator]
Finalization of the implementation of alternative operators.

Modification of the following methods to give a chance for an alternative operator
before forcing the second argument to a string :
    RexxInteger::concatBlank
    RexxInteger::concat
    RexxNumberString::concatBlank
    RexxNumberString::concat
    RexxString::concatRexx
    RexxString::concatBlank
If the second argument is not a string, then try the alternative operator before REQUEST_STRING.
    a = .array~of(10,20,30)
    100 a=                  -- ['100 10','100 20','100 30'] instead of '100 an Array'
    a 100=                  -- ['10 100','20 100','30 100']
    100 || a =              -- [10010,10020,10030]          instead of '100an Array'
    a || 100 =              -- [10100,20100,30100]

Modification of the following methods in CoreClasses.orx to give a chance for an alternative operator :
    .DateTime~"-"
    .DateTime~"+"
    .TimeSpan~"-"
    .TimeSpan~"+"
Illustration :
    ts1day = .TimeSpan~fromDays(1)                  -- (1.00:00:00.000000)
    ts1hour = .TimeSpan~fromHours(1)                -- (01:00:00.000000)
    date = .datetime~new(2013,1,10, 12, 30, 10)     -- (2013-01-10T12:30:10.000000)
    date + .array~of(ts1hour, ts1day)=              -- [(2013-01-10T13:30:10.000000),(2013-01-11T12:30:10.000000)]

Got a crash because I don't always return a value from an operator. In my approach of
operator overriding, not returning a value is the way to indicate that the current
implementation doesn't know how to support the current arguments. The lack of result is
managed in the new implementation of the operators, but is not managed in the rest of the
interpreter. The crash was here :
    bool RexxObject::isEqual(RexxObject *other)
    {
        ...
        else
        {
            ProtectedObject result;
            this->sendMessage(OREF_STRICT_EQUAL, other, result);
            return ((RexxObject *)result)->truthValue(Error_Logical_value_method);
        }
    }
result is NULL when the user code doesn't return a result, must be tested.
Review of all the sendMessage used internally by the interpreter, which need a test :
    RexxClass::isEqual
    RexxInteger::isEqual
    RexxNumberString::isEqual
    RexxObject::isEqual
    RexxString::hash
    RexxString::isEqual

Made a review of all my ooRexx scripts to swap the position of .nil in the tests, to
make it the first argument. Since I defined the array operators, I can have an array
as result for operators "=", "==", "<>", etc... when the first argument is an array.
Had to swap .nil in StreamClasses.orx.
Reminder : this technique of putting .nil as first argument is already used in several
places of the interpreter. The reason is explained in rexxref (section Required string
values) :
When comparing a string object with the Nil object, if the NOSTRING condition is being
trapped, then
    if string = .nil
will raise the NOSTRING condition, whereas
    if .nil = string
will not as the Nil object’s "=" method does not expect a string as an argument.

Previous work about swaping the position of .nil is not enough to avoid errors.
I have this case in pipe_extension_test.rex :
    datas = .directory~new
    datas["key1"] = .array~of("header", 1, 2, "footer")
    datas["key2"] = .array~of("header", 5, 3, -9, 12, "footer")
    datas["key3"] = .array~of("header", 4, 6, 5, "footer")
    -- The datas without the headers and footers
    datas~pipe(.inject {item} iterateBefore memorize | .drop first {dataflow["source"]~item } | .drop last {dataflow["source"]~item } | .console)
where the source of the pipe is a directory of arrays.
The code in charge of the partitioning do this test :
    if previousPartitionItem <> partitionItem then do
and an error is raised because the two arguments are array, and the result is an array.
Here, the goal is to test if the two arguments are the same object.
Conclusion :
The operators for array programming should be :
- either activated only when needed, under control of the programmer.
- or deactivated by the interpreter when the context is a scalar context (ex : when calling truthValue).
- or not defined at all when conflicting with the interpreter semantics.
I select the third option : no longer override the operators "=", "\=", "><", "<>", "==", "\==".
I provide the methods ~mapEqual, ~mapNotEqual, ~mapStrictEqual, ~mapStrictNotEqual.

Remember :
When operators for array programming are activated, the only way to use the scalar semantic
is to refer explicitly to the .Object's operators.
    a = .array~of(1,2,3)
    a == a=              -- [1,1,1]
    a~"=="(a)=           -- [1,1,1]
    a~"==":.object(a)=   -- 1 (not possible with ooRexx standard, see [method search order] on 2014 jan 06)

I have no problem with .array~ppRepresentation, whereas there is a test of equality to detect if a
recursive array is printed. Normally should raise an error because of "==" returning an array.
But it seems that 'level = stack~index(val)' is not impacted by the array operator "==".
Verification in the implementation :
    RexxObject *RexxQueue::index(RexxObject *target)
        uses : if (target->equalValue(element->value))
    class RexxObject : public RexxInternalObject {
         bool inline equalValue(RexxObject *other)
         {
             // test first for direct equality, followed by value equality.
             return (this == other) || this->isEqual(other);
         }
    bool RexxObject::isEqual( RexxObject *other )
    {
        if (this->isBaseClass()) return ((RexxObject *)this) == other;
        else  /* return truth value of a compare   */
        {
            ProtectedObject result;
            this->sendMessage(OREF_STRICT_EQUAL, other, result);
            if ((RexxObject *)result == OREF_NULL) reportException(Error_No_result_object_message, OREF_STRICT_EQUAL);
            return ((RexxObject *)result)->truthValue(Error_Logical_value_method);
        }
    }
So we have three cases for this test of equality :
a) If arg1 and arg2 are the same instance, then the equality is true
b) If arg1 is a base class (i.e. not a subclass instance or an enhanced one-off), then
   return true when arg1 and arg2 are the same instance.
c) return arg1~"=="(arg2)
Only a) and b) happen because my test is done with instances of .Array (so a base class).
That explains why I don't have an error...


[functional]
~downTo now always returns an array, like upTo.
The previous behaviour was to not return a result if the array of collected results was empty.


===============================================================================
2014 jan 15

[operator]
Change the naming convention of the alternate operator :
    "+OP:RIGHT"     -- plus
    " OP:RIGHT"     -- space
    "OP:RIGHT"      -- abbutal
    etc...

Add detection of no result : when the alternate operator returns nothing, then
don't complain about that. Behave as if the alternate implementation did not
exist, and raise the exception related to the left argument.

===============================================================================
2014 jan 14

[operator]
I had in mind to catch the exception Error_Conversion_operator raised by the
implementation of an operator, from RexxBinaryOperator::evaluate, and try an alternate
implementation. But that was difficult, because the interpreter unwinds a lot of things,
including the arguments stack. Moreover, raising an exception is costly, and I don't want
to reintroduce a loss of performance...
Finally, there is a more easy approach : if an alternate implementation exists then call it
otherwise raise the exception. That must be done in each implementation of operator.
The two methods Object::messageSend have been modified to let pass an additional parameter
'processUnknown' which is true by default (legacy behavior). When this parameter is false,
and no method is found for the message, then Object::messageSend returns false to indicate
that no implementation exists. There is no processing of the unknown message.
This is an efficient way to test if an alternate implementation exists and call it.

Example of alternative operator :

    ::class "ArrayOperators" mixinclass Object public

    ::method "+"
        if arg() == 0 then return self~map("+")
        use strict arg right
        if right~isA(.array) then do
            if \SameDimensions(self, right) then raise syntax 93.900 array("Dimensions are not equal")
            return self~map{::closure expose right ; item + right[index]}
        end
        return self~map{::closure expose right ; item + right}

    ::method "+op:right" -- JLF 15 jan 2014 : fixed the message name
        use strict arg left
        return self~map{::closure expose left ; left + item}


===============================================================================
2014 jan 12

[operator]
Performances are too bad... I give up the approach by routine overriding.
Two problems :
- must not override the optimized implementation of String (and hidden helper
  classes) operators.
- the search strategy of overriding routines was too costly, and not conform to
  the standard visibility rules of routines.
New approach :
- Use only methods to override operators.
- Modify the interpreter to automatically try b~"op:right"(a) when a~"op"(b) raises an exception


===============================================================================
2014 jan 06

[method search order]
Allow to modify the method search order from anywhere.
Before, was possible only from methods of the target object.
    .c1~new~m
    .c1~new~m:.c2 -- Now it's ok, interpreter modified to no longer raise :
                  -- Message search overrides can be used only from methods of the target object

    ::class c1 inherit c2
    ::method m
    say "c1::m"
    self~m:.c2

    ::class c2 mixinclass object
    ::method m
    say "c2::m"


[block]
Implement the functionality described in Q1 of entry 2013 sept 15 :
    Inherit the toplevel source options settings, when creating a method or routine for a block.
    No longer needed for the option OPERATOR_OVERRIDING_BY_ROUTINE (removed), but useful for the rest.
A new optional parameter isBlock can be passed when creating a method or routine :
    .Method~new("do", sourceArray, context, isBlock)
    .Routine~new("", sourceArray, context, isBlock)
This indicator is used to activate specific behaviour, like inheritance of toplevel source options.


[operator]
Remove the option OPERATOR_OVERRIDING_BY_ROUTINE.
Too complicated to manage that per package, will have to find another way to optimize.
For the moment, the search of overriding routines is done systematically when evaluating
a binary or prefix operator.


[operator]
Add more overloading of operators for array.
But not sure it's a good idea for some of them, like "||", " ", "".
I have an error
    Too many arguments in invocation of method; 0 expected
when running:
    d = .dataflow~create(.nil, "source", source, 1)
    say "dataflow="d
where the traceback is
   720 *-*     string = previous~makeString(mask, showPool, pool, values)" | "
       *-* Compiled method REQUEST with scope "Object"
   426 *-*   say "dataflow=".dataflow~create(.nil, "source", source, 1)
A dataflow is a subclass of array, and here the abbutal operator is used.
If I don't declare the operator "", then no error.
RexxInstructionAssignment::execute
    this->expression :
        RexxBinaryOperator
            this->left_term : RexxExpressionMessage "MAKESTRING", count=4
            this->right_term : RexxString " | "
RexxExpressionMessage::Evaluate
    this->target : RexxParseVariable variableName="PREVIOUS"
    the evaluation returns a RexxString "dataflow=The NIL object"
    and then the message MAKESTRING with 4 arguments is sent to this string
    hence the error... because
        in RexxObject::messageSend
            RexxMethod *method_save = this->behaviour->methodLookup(msgname)
            returns a CPPCode with cppEntry = {rexx.dll!RexxObject::makeStringRexx(void)}
                                   argumentCount = 0
        4 > 0 ==> error
In summary :
We have d = [(The NIL object),'source',1,'SOURCE']
This is an array of 4 items.
The 1st item (previous dataflow) is the .NIL object.
The expression "dataflow="d is evaluated ['dataflow=The NIL object', 'dataflow=source', 'dataflow=1', 'dataflow=SOURCE']
The 1st item is the string 'dataflow=The NIL object'.
The message MAKESTRING with 0 arguments is sent by the interpreter to ['dataflow=The NIL object', 'dataflow=source', 'dataflow=1', 'dataflow=SOURCE']
The implementation for .DataFlow is called.
This implementation do that :
    if previous <> .nil then string = previous~makeString(mask, showPool, pool, values)" | "
Since the previous element is not .NIL, the MAKESTRING with 4 arguments is sent to previous.
Boom!


===============================================================================
2013 dec 31

[functional]
Filtering with ~map ~mapR is now supported for collections.
The non-selected elements are removed, using the ~remove method.
Ex :
.environment~map{if item~class <> .class then item}=
    # 1: index=[ENDOFLINE]   -> item=["0D0A"x]
    # 2: index=[ENVIRONMENT] -> item=[The Environment Directory (66 items)]
    # 3: index=[FALSE]       -> item=[0]
    # 4: index=[LOCAL]       -> item=[The Local Directory (36 items)]
    # 5: index=[NIL]         -> item=[The NIL object]
    # 6: index=[SYSTEM]      -> item=[a Directory (3 items)]
    # 7: index=[TRUE]        -> item=[1]

Ex :
a=.array~new(2,3)~of{integerIndex}
a=
    # 1: index=[1,1] -> item=[1]
    # 2: index=[1,2] -> item=[2]
    # 3: index=[1,3] -> item=[3]
    # 4: index=[2,1] -> item=[4]
    # 5: index=[2,2] -> item=[5]
    # 6: index=[2,3] -> item=[6]
a~mapR{if item//2=0 then item} -- in place
a=
    # 1: index=[1,2] -> item=[2]
    # 2: index=[2,1] -> item=[4]
    # 3: index=[2,3] -> item=[6]


[rgf_util2]
No longer override pp2 in rgf_util2_wrappers.rex.
Better to modify this routine pp2 directly in my copy of rgf_util2.rex


===============================================================================
2013 nov 26

[doers]

~functionDoer and actionDoer have been modified to return directly the cached executable,
when already calculated. This is needed to support correctly this test case :
    g={::coactivity loop i=0; if i//2 == 0 then .yield[i]; else .yield[]; end}
    .array~new(2,3)~of(g)=
        # 1: index=[1,1] -> item=[0]
        # 2: index=[1,3] -> item=[2]
        # 3: index=[2,2] -> item=[4]
    .array~new(2,3)~of(g)=
        # 1: index=[1,1] -> item=[6]
        # 2: index=[1,3] -> item=[8]
        # 3: index=[2,2] -> item=[10]
Before that change, the second array had the same content than the first array, because
a new coactivity was created and stored in the cache when calling ~functionDoer from .array~of.
Note :
When called directly, ~sourceDoer is still applying the source transformations and
returns a new executable. There is no impact on the cached executable.


[rgf_util2]

Added the variable .local~rgf.showIdentityHash to control if the identity hash
is displayed or not.
Default value is false (not displayed).


===============================================================================
2013 nov 23

Add support for option guarded|ungarded in the declaration {::method...}
The need has been discovered while exploring this alternative implementation of
the methods ascendingItems and descendingItems in BinaryTree.cls :
    ::method ascendingItems
        -- return .Coactivity~new("visitAscending", , self~rootNode)
        return {::method.coactive self~rootNode~visitAscending}~doer(self)
    ::method descendingItems
        --return .Coactivity~new("visitDescending", , self~rootNode)
        return {::method.coactive self~rootNode~visitDescending}~doer(self)
With this test case :
    btree = .BinaryTree~of(4, 6, 2, 7, 5, 3, 1)
    ascending = btree~visitAscending
    descending = btree~visitDescending
    do btree~items
        say ascending~()
        say descending~()
    end
There is a deadlock when calling descending~() because the instance btree is locked
by the execution of ascending~().
The solution is to declare the coactive methods unguarded :
    return {::method.unguarded.coactive self~rootNode~visitAscending}~doer(self)

.Array alternative operators
Add implementation for * scalar multiplication.
Add implementation for / scalar division.
Add implementation for % scalar integer division.
Add implementation for // scalar remainder.

.Complex alternative operators
Add implementation for - scalar multiplication.
Add implementation for * scalar multiplication.
Add implementation for / scalar division.
Add implementation for % scalar integer division.
Add implementation for // scalar remainder.


===============================================================================
2013 nov 17

Merge revisions 9423-9515 from SourceForge main/trunk


===============================================================================
2013 sep 15

Merge revisions 8678-9423 from SourceForge main/trunk


===============================================================================
2013 sep 15

Creation of the branch block_closure.

Will be used to optimize the implementation of closures.
Currently, the instance of closure is created by user code in doers.cls.
See the method sourceDoer of RexxBlockDoer.
See the method init of Closure.
This is very inefficient implementation, to replace by a native (C++) implementation.

For the needs of operator overloadings, I have to bring an answer to question Q1 below.
I propose to inherit the options settings, when creating a method or routine for a block.
I will need to add an additional parameter isBlock to the constructor of a method/routine.
This code, currently in ::routine "+" in array.cls :
    return array~map{::closure expose scalar ; options "OPERATOR_OVERRIDING_BY_ROUTINE" ; item + scalar}
will become :
    return array~map{::closure expose scalar ; item + scalar}


Standard ooRexx behavior :
When a routine or method is created, a new RexxSource (i.e. a package) is created.
All the settings defined on the package level (i.e. RexxSource) have the default values.
It's possible to pass a context from which a RexxSource is taken (called parentSource) which
allows the created routine/method to inherit class and routine lookup scope from another source.
Nothing else is inherited.

[inherited from context]
    routines
    merged_public_routines
    installed_classes
    merged_public_classes
[currently never inherited from context]
    digits
    fuzz
    form
    trace
    enableCommands (sandbox only)
    enableMacrospace (sandbox only)
    enableOperatorOverridingByRoutine (sandbox only)
In the sandbox, the raw executable created from a RexxBlock is a routine or a method.
Given the rule explained above, this raw executable has its own RexxSource (i.e. package) :
    say .context~package~identityHash ; {say .context~package~identityHash}~() -- the hashes are different


Q1
Should a RexxBlock inherit the settings of the package in which it's defined ?
If yes, all kinds of RexxBlock or just ::closure RexxBlock ?
Currently, the visibility on routines/classes is inherited, but none of the following options are inherited :
    ::options digits
    ::options form
    ::options fuzz
    ::options trace
    ::options commands (sandbox only)
    ::options nocommands (sandbox only)
    ::options macrospace (sandbox only)
    ::options nomacrospace (sandbox only)
    ::options operator_overriding_by_routine (sandbox only)
    ::options nooperator_overriding_by_routine (sandbox only)
Illustration :
    say 1/3
    {say 1/3}~()
    ::options trace i
    ::options digits 20
    ::requires "extension/extensions.cls"
Output :
     1 *-* say 1/3
       >L>   "1"
       >L>   "3"
       >O>   "/" => "0.33333333333333333333"
       >>>   "0.33333333333333333333"
0.33333333333333333333
     2 *-* {say 1/3}~()
       >L>   "a RexxBlock"
0.333333333


Q2
Same question for the settings of the RexxActivation in which the RexxBlock is evaluated.
Here, only a closure  is supposed to capture its environment.
Should a closure remember the following settings of its defining RexxActivation ?
The goal being to reuse automatically these settings at each execution (so from a different RexxActivation).
Currently, none of the following settings are captured :
    numeric digits
    numeric form
    numeric fuzz
    trace
    options "commands" (sandbox only)
    options "nocommands" (sandbox only)
    options "macrospace" (sandbox only)
    options "nomacrospace" (sandbox only)
    options "operator_overriding_by_routine" (sandbox only)
    options "nooperator_overriding_by_routine" (sandbox only)
Illustration :
    trace i
    numeric digits 20
    say 1/3
    {::closure say 1/3}~()
    ::requires "extension/extensions.cls"
Output :
     2 *-* numeric digits 20
       >L>   "20"
       >>>   "20"
     3 *-* say 1/3
       >L>   "1"
       >L>   "3"
       >O>   "/" => "0.33333333333333333333"
       >>>   "0.33333333333333333333"
0.33333333333333333333
     4 *-* {::closure say 1/3}~()
       >L>   "a RexxBlock"
0.333333333


===============================================================================
2013 sep 07

Implementation of operator overriding was not working for
    .array~of(1,2) + .complex[1,5]
This is because the search was limited to the requires order, which is :
    extensions.cls --requires--> array.cls
    extensions.cls --requires--> complex.cls
The package array.cls provides an implementation of "+", but does not requires complex.cls.
The package complex.cls provides an implementation of "+", but does not requires array.cls.
It was possible to make it work by adding extra requires :
    array.cls --requires--> complex.cls
    complex.cls --requires--> array.cls
but that's clearly not a good solution.

There is no direct call of a specific implementation of "+", we are in a case similar to
CLOS generic methods, or Clojure multimethods : dependency on a polymporphic "+", where
the polymorphism is not limited to the type of the first argument.

To solve this problem, the search strategy is modified :
From current activation, search for the oldest Rexx activation in the call stack.
Get the package of the oldest Rexx activation : oldest package
From the oldest package, search for a local routine having the operator name.
From the oldest package, search for a public imported routine having the operator name, in the requires order.

The execution strategy is unchanged :
iterate over the routines returned by the search strategy.
call the current routine.
if a result is returned then stop the iteration and return this result
otherwise contine the iteration.

Todo :
a) Modify the inheritance of context when creating an executable for a block.
b) Modify the execution strategy to no execute a given method several times.


===============================================================================
2013 sep 02

Operator overriding supports overriding per package.

Illustration :
array.cls defines operators for array and scalar.
complex.cls defines operators for complex number and not-complex number.
1 + .complex[1,5] =  -- 2+5i
.complex[1,5] + 1 =  -- 2+5i
1 + .array~of(1,2) = -- [2,3]
.array~of(1,2) + 1 = -- [2,3]

Todo :
a) Still not working : .array~of(1,2) + .complex[1,5]
   That's because the overriding in complex.cls is not visible from array.cls.
b) When iterating over imported packages, remember the already visited packages to not revisit a visited package.
c) Optimize the search of overriding routines. A table of operator overridings can be managed per package
   (similar to the table of operators managed on ObjectClass, StringClass, NumberStringClass, IntegerClass).
d) I see a strange behavior in relation with findRoutine and merged_public_routines : d::r called instead of c::r
   [later]
   ok, I understand now, the behavior is correct.
   Each package manages its own list of imported packages.
   See RexxSource::addPackage which updates the RexxList loadedPackages.
   When a package P2 is indirectly required by the package P1, then this package P2 is loaded by the interpreter instance,
   but not added to P1's loadedPackage.
   If later this package P2 is directly required by P1 (my test case below), then the interpreter instance returns
   the already loaded package P1 (so, no new elaboration) and the package P2 updates its list loadedPackage. There is also
   an update of the directory merged_public_routines.
e) I think that the fix of bug "#821 ::Routines cannot be called in mixed/lower case " does not respect the documentation.
   call "r" should not succeed in the test case below, because only "R" routines are registered.

----- a.rex -----
say "elaborate a"
call "r"
::requires b
::requires c
::requires d

----- b.rex -----
say "elaborate b"
::requires d
::routine r public
say "b::r"

----- c.rex -----
say "elaborate c"
::requires d
::routine r public
say "c::r"

----- d.rex -----
say "elaborate d"
::routine r public
say "d::r"

----- tests -----
if "requires d" is not used in a.rex :
elaborate d
elaborate b
elaborate c
elaborate a
c::r

if "requires d" is used in a.rex :
elaborate d
elaborate b
elaborate c
elaborate a
d::r               <-- ??? the elaboration order is unchanged, how is that possible to call a different implementation ?
                       [later]
                       The elaboration of a package is managed by the interpreter instance, which takes care to
                       load a package once, and return this same package if required several times.
                       Each package manages its own list of loadedPackage.
                       When a package P2 is indirectly required by the package P1, the list loadedPackage of P1 is not impacted.
                       But if the package P2 is directly required by P1, then the list loadedPackage of P1 is impacted.
                       This is what happens here :
                       - d is indirectly required by b --> elaboration of d
                       - d is directly required by a --> no elaboration because already loaded by the interpreter instance,
                         d is added to the list loadedPackage of a,
                         and the directory merged_public_routines is updated.


===============================================================================
2013 may 04

The overriding of binary operators by routine has an impact on performances.
The class String (behind the scene : StringClass, NumberStringClass, IntegerClass) has
a fast access to operators implementations (see callOperatorMethod and operatorMethods).
The overriding by routine replaces the fast access by a call to a routine, searched by name.
A new option has been added to control the activation of this overriding :
options "OPERATOR_OVERRIDING_BY_ROUTINE"
options "NOOPERATOR_OVERRIDING_BY_ROUTINE"
::options OPERATOR_OVERRIDING_BY_ROUTINE
::options NOOPERATOR_OVERRIDING_BY_ROUTINE
Unary operators can also be overriden by a routine.


===============================================================================
2013 may 03

Start working on alternative binary operators.
The idea is to let override binary operators using a routine which takes
two arguments (left, right) and decide which behavior to support, depending
on the types of both arguments.
Ex :
    1 + .array~of(10,20,30) --> [11, 21, 31]
If no overriding routine then fallback to the classic behaviour :
send message to left arg.


===============================================================================
2013 apr 13

[GC]
Fix crash due to unprotected object.
In ClassClass.cpp
method RexxClass::enhanced : enhanced_instance_mdict must be GC-protected.
method RexxClass::subclass : enhancing_class_methods must be GC-protected.


[build]
Add support for Visual C++ 2012, include debug info in release build.

The file AgtCtl_i.c is no longer delivered with Visual C++ 2012.
This file is needed to compile extensions\platform\windows\ole.
Workaround : copy this file from an older version of VC++, paste it in the ole directory.

Debug infos in release build :
I keep all the optimizations, my goal is just to have a call stack with symbolic names, in case of crash.


[pipe]
No longer return a result at the end of the execution of the following methods :
~pipe
~coactivePipe
~pipeProfile
~coactivePipeProfile
Previously, the returned result was the first pipestage of the pipe.
That was useless, and not well adapted to coactive pipes.
In the case of coactive pipes, several results can be yielded, and it's better
to have no result when the coactive pipe is ended (same behaviour as generators).


===============================================================================
2013 mar 20

Summary of recent changes :

[GC]
GC verbose message : use proper format to avoid negative values

[pipe]
Added a 'yield' pipe stage, to yield the current item.
Works only from a coactive pipe.
This is a convenience pipeStage, equivalent to .do {.yield[item]}
Ex :
    branchGenerator = "git branch -a"~coactivePipe(.system | .yield)
    branchGenerator~()=    -- '  3.2.0'
    branchGenerator~()=    -- '  4.0.1'
    branchGenerator~()=    -- '  4.0beta'
    branchGenerator~()=    --   4.1
    branchGenerator~()=    -- '  4.1.0'
    branchGenerator~()=    -- '  4.1.2'
    branchGenerator~()=    -- '* master'
    etc..
Note about implementation :
The class "yield" existed already, defined in coactivity.cls.
This class has been extended by inheriting from the class "pipeStage", which brings
the operators "[]", "|", ">", ">>" and " ".
The operator "[]" was already defined to do .Coactivity~yield(value), which hides
the 2nd definition.
Summary of possible usages :
.yield[value] : equivalent to .Coactivity.yield[value] which yields immediatly the value.
.yield        : only from a coactive pipe, creates an instance of pipeStage which will
                yield the current item at each execution of the method "process".


===============================================================================
2013 jan 10

[doers]

The 'expose' was not detected correctly in the following code :
{::cl
    expose v
}~functionDoer
The tag ::cl was removed when calling SourceLiteralParser~kind, but the resulting
clause was empty. Fixed by going to the next non-empty clause.

Change the minimal abbreviation of some doers' tag, to follow the ooRexx abbreviation rules :
::c[oactivity]     --> ::co[activity]
:[:routine]        --> ::r[outine]
option .c[oactive] --> .co[active]

The message INIT sent by RexxBlock passed mistakenly two parameters, instead of none.
Fixed.


[unicode]
Activate STRONG_TYPES only when compiling C++ code (otherwise compilation error).


[ooRexxShell & ooRexxTry]
Use condensed representation for arrays of dimension 0.


===============================================================================
2012 dec 14

merge 7771-8678 from main/trunk


SourceFile.cpp, RexxSource::processInstall
I see a change when processing classes :
Each installed class is stored in an array createdClasses.
When all classes have been installed, iterate over createdClasses and send the
message OREF_ACTIVATE.
Should I do the same for extensions ? No...
But maybe a message ACTIVATE_EXTENSION could be useful.
See previous entry : I send the message INIT from native RexxBlock, but this is
not a standard pattern. Moreover, I have no way to intialize each extension separately.


doers-stress.rex : Stack overflow, despite the fix made in trunk...
The crash also occurs in trunk.
If 'signal on syntax' is not used then no crash.


===============================================================================
2012 dec 09

RexxBlock :
Removed the native method "executable" implemented by RexxBlock::getExecutable,
and "executable=" implemented by RexxBlock::setExecutable.
Can be implemented in RexxBlockDoer using a private variable.
Impacted files :
BlockClass.cpp, BlockClass.hpp, CPPCode.cpp, Setup.cpp,RexxConstants.hpp

After first tests, I see I need to initialize the variable "executable" added by extension.
For that, I send the message INIT from native RexxBlock code. But the pattern is not really
standard... Normally this message should be sent from RexxBlock::newRexx, but this method
which implements .RexxBlock~new is not allowed from Rexx code (my decision).
I send the message INIT from RexxBlock::RexxBlock, but I had to do that :
	RexxBehaviour *behaviour = ((RexxClass *)this)->getInstanceBehaviour();
    if (behaviour != NULL) this->setBehaviour(behaviour);
instead of that in the standard pattern :
    this->setBehaviour(((RexxClass *)this)->getInstanceBehaviour());
because the behaviour returned by getInstanceBehaviour is NULL.


===============================================================================
2012 sept 30

[logical]
Routine if(aLogical, whenTrue, whenFalse)
Method aLogical~ifTrue(whenTrue[, whenFalse])
Method aLogical~ifFalse(whenFalse[, whenTrue])
When passing a doer for whenTrue and/or whenFalse, the evaluation is done only when needed.


===============================================================================
2012 aug 01

Now I have win7 and can build a 64bits version for Windows.
But I don't like how the build is managed :
- no separate destination for 32 and 64 bits
- wrong detection of the compiler when a french localized version is installed

Modified makeorx.bat and orxdb.bat to manage correctly the bitness of the compiler.
The detection of the compiler bitness is done by compiling a small cpp file and
parsing its output. The choice of compiler is done by launching the appropriate shell.
Now I can have at the same time these directories :
Win32Dbg
Win32Rel
Win64Dbg
Win64Rel


===============================================================================
2012 june 30

[doers]

Implemented the Y combinator as a method on Doer.
http://en.wikipedia.org/wiki/Fixed-point_combinator#Y_combinator
No practical interest... Inspired by http://mvanier.livejournal.com/2897.html
Example (to run from ooRexxTry) :
fact = {
           use strict arg f
           return {
                      ::closure expose f
                      use strict arg n
                      if n==0 then
                          return 1
                      else
                          return n * f~(n-1)
                  }
       }~Y          -- ~Y(.true) for verbose mode
fact~(10)=          -- 3628800

ooRexx supports anonymous recursive functions, so no need of the Y combinator...
fact = {
    use strict arg n
    if n==0 then
        return 1
    else
        return n * .context~executable~(n-1)
}
fact~(10)=          -- 3628800


===============================================================================
2012 june 12


Finished the implementation of an APL-like array initializer.
See doc in the file extension/array.cls.


In the various shells, the condensed output for arrays is now used only for array having one dimension.
Exception : In the pipelines, the condensed output is still used for any kind of array.


rgf_util2_wrappers.rex  : Overloaded the pretty-printing made by the routine pp2.
Since I pretty-print arrays using square brackets, I prefer to avoid square brackets
for pretty-printing strings. Now using quotes, when not a number.
Other change : the objects other than strings and collections are surrounded by
round brackets, instead of square brackets.


generator.cls : added "use strict arg -- none" everywhere appropriate to ensure
that no argument is passed when resuming a generator.


coactivity.cls : the automatic termination of gc'ed coactivities was not working
as expected. Some coactivities were never gc'ed and I suppose it's because of
the coactive closures which keep a reference to other coactivities.
By explicitely assigning .nil where appropriate, I increase the chances to have
more GC'ed objects. But that's not normal to have to do that !
Clearly, I see a problem with CoactivityObj : the uninit method is *rarely* called
by the interpreter, whereas the uninit method of Coactivity is called as expected.


Pipe stage .append : new option "iterate"
By default, there is no iteration, except for coactivities.


===============================================================================
2012 may 05

[pipes]
Method pipe.generate renamed coactivePipe.
Method pipeProfile.generate renamed coactivePipeProfile.
The old names were not good, because a generator takes in charge the yields.
This is not the case here, where the yields must be explicitely inserted in the pipe.


[coactivity]
For convenience, ~isEnded returns .true when the coactivity has been killed.


[ooRexxTry.rex & ooRexxTry.rxj]
Added the routine updatePackageEnvironment which creates the same environment as
oorexxshell (list of imported packages).


===============================================================================
2012 apr 22

merge 7736-7771 from main/trunk

Adaptation of ooRexxTry.rex :
- set default code page to UTF-8 when using wide-char oodialog.
- support omitted arguments.
- display elapsed time.
- when using extended ooRexx :
    manage the '=' shortcut at the end of each clause.
    display the number of coactivities.

Prepare files for a new delivery in my dropbox.


===============================================================================
2012 mar 23

merge 7691-7736 from main/trunk


Adaptation of ooRexxTry.rxj :
Preloads all the main components (math, ftp, socket, bsf, hostemu, ...).
The '=' shortcut is managed at the end of each clause.
Now, it's possible to write that :
    dir;rc=;unknown;rc=
The transformed command is :
    dir;
    options "NOCOMMANDS";
    rc ;
    call dumpResult;
    options "COMMANDS";
    unknown;
    options "NOCOMMANDS";
    rc ;
    call dumpResult;
    options "COMMANDS"


[pipes]
Fixed a deadlock.
The methods ~pipe, ~pipe.generate, pipeProfile and pipeProfile.generate must be unguarded.


[coactivity]
Added support for onStart and onTerminate at the class level.
Needed to attach/detach properly to/from the Java thread in ooRexxTry.rxj.
10/06/2015 : removed, no longer needed.


[parser]
Fixed a bug in .Clauser.
When parsing a multi-line source literal, a single line is created by concatenating each line.
A ';' was missing to delimitate the clauses.
Probably to rework : should keep the source literal as-is (multi-line) to have good line numbers
in case of error.


===============================================================================
2012 mar 23

merge 7390-7647 from main/trunk
merge 7647-7688 from main/trunk
merge 7688-7691 from main/trunk

Remember :
GC crash while running functional-test.rex :
The list of protected objects was corrupted, because of that :
In RexxExpressionMessage::evaluate (ExpressionMessage.cpp), I declared _target as a protected object.
The assignment result = _target, which was supposed to store the RexxObject target in the protected
object result, corrupted the list of protected objects because the default operator= stored a copy of
all the attributes of _target onto the protected object result, overwriting the next attribute.
Fixed by declaring these methods private :
    ProtectedObject(const ProtectedObject&);
    ProtectedObject &operator=(const ProtectedObject&);
Now the compiler forces to cast like that :
result = (RexxObject*)_target
[later]
I think I don't need to protect the intermediate objects returned by ->evaluate, because they should
be protected by the stack. I keep the changes made to ProtectedObject.


===============================================================================
2012 mar 06

Another GC crash
 	rexx.dll!RexxMemory::markObjectsMain(RexxObject * rootObject)  Line 373 + 0xc bytes	C++
 	rexx.dll!RexxMemory::markObjects()  Line 653	C++
 	rexx.dll!RexxMemory::collect()  Line 1030	C++
 	rexx.dll!NormalSegmentSet::handleAllocationFailure(unsigned int allocationLength)  Line 1272	C++
 	rexx.dll!RexxMemory::newObject(unsigned int requestLength, unsigned int type)  Line 1110 + 0x12 bytes	C++
 	rexx.dll!new_object(unsigned int s, unsigned int t)  Line 426 + 0x1e bytes	C++
 	rexx.dll!RexxListTable::operator new(unsigned int size, unsigned int initialSize)  Line 94 + 0x16 bytes	C++
 	rexx.dll!RexxList::getFree()  Line 123 + 0x12 bytes	C++
 	rexx.dll!RexxList::insert(RexxObject * _value, RexxObject * _index)  Line 556 + 0x8 bytes	C++
 	rexx.dll!RexxList::append(RexxObject * _value)  Line 542	C++
 	rexx.dll!RexxActivity::generateProgramInformation(RexxDirectory * exobj)  Line 941	C++
 	rexx.dll!RexxActivity::createExceptionObject(long errcode, RexxString * description, RexxArray * additional, RexxObject * result)  Line 894	C++
 	rexx.dll!RexxActivity::raiseException(long errcode, RexxString * description, RexxArray * additional, RexxObject * result)  Line 774 + 0x18 bytes	C++
 	rexx.dll!RexxActivation::raise(RexxString * condition, RexxObject * rc, RexxString * description, RexxObject * additional, RexxObject * resultObj, RexxDirectory * conditionobj)  Line 1639	C++
 	rexx.dll!RexxActivation::raiseExit(RexxString * condition, RexxObject * rc, RexxString * description, RexxObject * additional, RexxObject * resultObj, RexxDirectory * conditionobj)  Line 1544	C++
>	rexx.dll!RexxInstructionRaise::execute(RexxActivation * context, RexxExpressionStack * stack)  Line 280	C++
 	rexx.dll!RexxActivation::run(RexxObject * _receiver, RexxString * msgname, RexxObject * * _arglist, unsigned int _argcount, RexxInstruction * start, ProtectedObject & resultObj)  Line 544	C++
----------
Review of RexxInstructionRaise::execute
    _result to protect (done)
    _description to protect (done)
    _additional to protect (done)
Review of RexxActivation::raise
    _conditionObj to protect if not a propagation, because new directory created (done)


Previous protection are not enough... Crash again.
Now using /DCHECKOREFS
 	rexx.dll!RexxInternalObject::getObjectTypeNumber()  Line 2045 + 0x3 bytes	C++
 	rexx.dll!RexxInternalObject::isObjectType(unsigned int t)  Line 263 + 0xf bytes	C++
 	rexx.dll!RexxMemory::objectReferenceOK(RexxObject * o)  Line 339 + 0xa bytes	C++
 	rexx.dll!RexxMemory::orphanCheckMark(RexxObject * markObject, RexxObject * * pMarkObject)  Line 1565 + 0xc bytes	C++
 	rexx.dll!RexxMemory::markGeneral(void * obj)  Line 1471	C++
 	rexx.dll!StackFrameClass::liveGeneral(int reason)  Line 143	C++
 	rexx.dll!RexxMemory::killOrphans(RexxObject * rootObject)  Line 440	C++
 	rexx.dll!RexxMemory::markObjects()  Line 641	C++
 	rexx.dll!RexxMemory::collect()  Line 1030	C++
 	rexx.dll!NormalSegmentSet::handleAllocationFailure(unsigned int allocationLength)  Line 1272	C++
 	rexx.dll!RexxMemory::newObject(unsigned int requestLength, unsigned int type)  Line 1110 + 0x12 bytes	C++
 	rexx.dll!new_object(unsigned int s, unsigned int t)  Line 426 + 0x1e bytes	C++
 	rexx.dll!RexxListTable::operator new(unsigned int size, unsigned int initialSize)  Line 94 + 0x16 bytes	C++
 	rexx.dll!RexxList::getFree()  Line 123 + 0x12 bytes	C++
 	rexx.dll!RexxList::insert(RexxObject * _value, RexxObject * _index)  Line 556 + 0x8 bytes	C++
 	rexx.dll!RexxList::append(RexxObject * _value)  Line 542	C++
 	rexx.dll!RexxActivity::generateProgramInformation(RexxDirectory * exobj)  Line 941	C++
 	rexx.dll!RexxActivity::createExceptionObject(long errcode, RexxString * description, RexxArray * additional, RexxObject * result)  Line 894	C++
 	rexx.dll!RexxActivity::raiseException(long errcode, RexxString * description, RexxArray * additional, RexxObject * result)  Line 774 + 0x18 bytes	C++
 	rexx.dll!RexxActivation::raise(RexxString * condition, RexxObject * rc, RexxString * description, RexxObject * additional, RexxObject * resultObj, RexxDirectory * conditionobj)  Line 1641	C++
 	rexx.dll!RexxActivation::raiseExit(RexxString * condition, RexxObject * rc, RexxString * description, RexxObject * additional, RexxObject * resultObj, RexxDirectory * conditionobj)  Line 1544	C++
 	rexx.dll!RexxInstructionRaise::execute(RexxActivation * context, RexxExpressionStack * stack)  Line 289	C++
 	rexx.dll!RexxActivation::run(RexxObject * _receiver, RexxString * msgname, RexxObject * * _arglist, unsigned int _argcount, RexxInstruction * start, ProtectedObject & resultObj)  Line 544	C++
 	rexx.dll!RexxCode::run(RexxActivity * activity, RexxMethod * method, RexxObject * receiver, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, ProtectedObject & result)  Line 136	C++
 	rexx.dll!RexxMethod::run(RexxActivity * activity, RexxObject * receiver, RexxString * msgname, RexxObject * * argPtr, unsigned int count, ProtectedObject & result)  Line 325	C++
>	rexx.dll!RexxObject::messageSend(RexxString * msgname, RexxObject * * arguments, unsigned int count, ProtectedObject & result)  Line 793	C++             // JLF : "yield"
----------
objectReferenceOK :
o = 0x7f23f050 {objectVariables=0x00000000 operatorMethods=0x00558920 classInstance=0x7fcc0a50 }
    objectSize = 6
    instanceClass.id = "Object"
    RexxBehaviour *type = o->getObjectType();       // JLF : NULL
StackFrameClass::liveGeneral :
    memory_mark_general(this->name);                // JLF this->name = 0x7f23f050
        this = 0x7de6d440 {type=0x0052ee64 "METHOD" name=0x7f23f050 executable=0x7fcc2e90 ...}
So we have a problem with the argument 'name' passed to the StackFrameClass constructor.
RexxActivation::createStackFrame
    pass getMessageName() : I don't see a problem here, because returns this->settings.msgname which is protected.
    The name stored in settings.msgname comes from the method RexActivation::run, I don't think there is a problem here.
    But I see a potential problem with the local variable 'arguments' : receives a new array returned by getArguments() --> must be protected (done)
RexxNativeActivation::createStackFrame
    pass getMessageName() : I don't see a problem here, because returns this->msgname which is protected.
    The names comes from :
        RexxNativeActivation::run : _msgname
        RexxNativeActivation::callNativeRoutine : functionName
            RexxNativeRoutine::call : functionName
        RexxNativeActivation::callRegisteredRoutine : functionName
            RegisteredRoutine::call : functionName
RexxSource::createStackFrame
    pass programName : I don't see a problem here
    The programName comes from :
        RexxSource::RexxSource
PackageManager::callNativeRoutine
    Maybe a problem here : name = name->upper(); --> to protect (done)
SystemInterpreter::invokeExternalFunction : target
    RexxActivation::externalCall : target
        RexxInstructionCall::execute --> I see a problem here : _name = REQUEST_STRING(result) --> to protect (done)
RexxActivation::callExternalRexx : target


review of risky code :
->upper
    RexxBehaviour::methodObject : no risk ?
    RexxClass::defineMethod : done
    RexxClass::defineClassMethod : done
    RexxClass::deleteMethod : done
    RexxClass::method : done
    RexxClass::methodDictionaryCreate : done
    RexxDirectory::setEntry : done
    RexxDirectory::remove : no risk ?
    RexxDirectory::setMethod : done
    RexxObject::instanceMethod : to protect because of reportException (done)
    RexxObject::setMethod : done
    RexxObject::unsetMethod : done
    RexxObject::requestRexx : two variables to protect (done)
    RexxObject::decodeMessageName : no risk ?
    RexxObject::defMethods : done
    RexxObject::defMethod : done
    RexxStem::request : done
    RexxNativeActivation::stemSort : incomplete protection (fixed)
    RexxVariableDictionary::getVariableRetriever : done
    BUILTIN(VALUE) : to protect (done, the code has been slightly rewritten)
    RexxInstructionForward::execute : done
    PackageManager::createRegisteredRoutine : done
    PackageManager::dropRegisteredRoutine : done
    PackageManager::queryRegisteredRoutine : done
    PackageManager::callNativeRoutine : done
    RexxSource::findClass : done
    RexxSource::classDirective : done
    RexxSource::extensionDirective : done
    RexxSource::methodDirective : done
    RexxSource::attributeDirective : done
    RexxSource::constantDirective : done
    RexxSource::words : done
    Interpreter::findClass : I think it must be protected because a method could be attached to the environment, no ? (done)
    InterpreterInstance::resolveCommandHandler : done
    SystemInterpreter::valueFunction : no risk, I think
    SystemInterpreter::valueFunction : I think it's ok, SystemInterpreter::allocateResultMemory has no relation with GC
REQUEST_STRING (requestString)
    RexxClass::methodDictionaryMerge : done
    RexxClass::methodDictionaryCreate : already done
    RexxInteger::concatBlank : to protect, I think (done)
    RexxInteger::concat : to protect, I think (done)
    RexxObject::copyIntoTail : done
    RexxObject::concatRexx : done
    RexxObject::concatBlank : done
    RexxStem::sort : is there a risk of GC in array->put(nextValue, j + bounds) ? (NOT done)
    StringClass.cpp : I hope it's ok ! did not investigate
    RexxActivity::display : done, but really not sure if I need to do that
    RexxActivity::displayDebug :  done, but really not sure if I need to do that
    RexxActivity::callFunctionExit : nothing done, I don't understand the code with temp
    RexxInstructionDo::execute : done
    RexxInstructionDo::controlSetup : done
    RexxInstructionForward::execute : done
    RexxInstructionInterpret::execute : done
    RexxInstructionOptions::execute : done
    RexxInstructionQueue::execute : done
    RexxInstructionRaise::execute : done
    RexxInstructionSay::execute : done
    RexxInstructionSignal::execute : done
    RexxInstructionTrace::execute : done
requestString
    RexxMethod::newRexx : I think protection is needed (done)
    RexxNativeActivation::processArguments : is ok, according to the comment
    RexxExpressionStack::requiredStringArg : done
    RexxExpressionStack::optionalStringArg : done
makeString
    RexxMethod::newMethodObject : done
    RoutineClass::newRoutineObject : done
    RoutineClass::newRoutineObject : done
    RexxCompoundTable::findEntry : done
arrayArgument (requestArray)
    RexxObject::sendWith : for me, protection is needed, no ? (done)
    RexxObject::startWith : for me, protection is needed, no ? (done)
    RexxObject::decodeMessageName : for me, protection is needed, no ? (done)
    PackageClass::loadPackage : for me, protection is needed, no ? (done)
    PackageClass::newRexx :  for me, protection is needed, no ? (done)
    RoutineClass::callWithRexx : for me, protection is needed, no ? (done)
    RexxNativeActivation::processArguments : is ok, according to the comment
    RexxNativeActivation::objectToValue : is ok, according to the comment
requestArray (makeArray)
    RexxMethod::newMethodObject : already protected
    RoutineClass::newRoutineObject : already protected
makeArray
    RexxArray::toString : already protected
    RexxList::supplier : done
    RexxQueue::supplier : done
    RexxActivity::display : already protected
    RexxInstructionDo::execute : is ok, assigned to this
    RexxSource::getGuard : is ok, assigned to this
->request
    Nothing new to protect (requestString and requestArray already reviewed)
required_string (macro, requiredStringArg)
    requiredStringArg already reviewed
optional_string (macro, optionalStringArg)
    optionalStringArg already reviewed
decodeMessageName : the string returned in messageName is not protected, see what's done by the caller
    RexxObject::sendWith : for me, protection needed, no ? (done)
    RexxObject::send : for me, protection needed, no ? (done)
    RexxObject::startCommon : for me, protection needed, no ? (done)
    RexxMessage::newRexx : for me, protection needed, no ? (done)
->concat
    RexxObject::requestRexx : I think it's ok, methodLookup should not trigger a GC, right ?
    RexxActivity::messageSubstitution : done
    RexxActivity::traceOutput : done
    RexxSource::commonString : no "->concat" inside, but while looking for "->concat", I saw a lot of calls to commonString where the passed parameter is not protected. Now the parameter string is protected.
    RexxSource::callNew : done
    RexxSource::raiseNew : done
    RexxSource::signalNew : done
    RexxSource::extract : done
    RexxSource::methodDirective : done
    RexxSource::attributeDirective : done
->evaluate
    RexxActivation::evaluateLocalCompoundVariable : done --> cancelled
    <to continue...> --> not needed, the objects should be protected by the stack
decodeExternalMethod
    RexxSource::methodDirective : done
    RexxSource::attributeDirective : done


===============================================================================
2012 mar 04

Fixed a GC crash.
RexxActivity::generateProgramInformation calls createStackFrame.
In RexxActivation::createStackFrame, the last line is
    return new StackFrameClass(type, getMessageName(), (BaseExecutable *)getExecutableObject(), target, arguments, getTraceBack(), getContextLineNumber());
The operator 'new' of StackFrameClass is overloaded and returns a new object before the constructor is called.
This object is not protected.
The call to getTraceBack triggered a GC and the new object was put on the list of dead objects.
The object is returned to generateProgramInformation which puts it in the stackFrames list.
Later, crash because the behaviour pointer of the stack frame is NULL.
Fixed by passing a ProtectedObject to the 'new' operator of StackFrameClass.
Applied the same fix to :
RexxSource::createStackFrame
RexxNativeActivation::createStackFrame


Fixed another GC crash, but less sure I identified the real problem...
A crash occured while searching the method ~available on a supplier. The behaviour was NULL.
I have a subclass of Supplier (CoactivitySupplier) whose init method creates an empty array.
That could explain the problem : in case of GC during init, the supplier is put on the list of dead objects.
After modifying RexxSupplierClass::newRexx to protect newObj before sending the message "init",
no more crash (for the moment).


Remember :
Fix done in RexxSupplierClass::newRexx also done in :
(search for OREF_INIT in interpreter source files)
RexxDirectory::newRexx
RexxIdentityTable::newRexx
RexxList::newRexx
RexxMessage::newRexx
PackageClass::newRexx
RexxQueue::newRexx
RexxRelation::newRexx
RexxStem::newRexx
RexxString::newRexx
RexxSupplierClass::newRexx
RexxTable::newRexx
WeakReference::newRexx


ContextClass : mark this->objectVariables.
It's an exported class, so better to do that... (done)


Remember :
To activate the GC diagnostics, add these definitions in RexxCore.h :
    #define CHECKOREFS
    #define MEMPROFILE
    #define VERBOSE_GC
or better : could be added in lib/orxwin32.mak to my_cdebug, when debug mode.
    /DCHECKOREFS /DMEMPROFILE /DVERBOSE_GC


Remember :
A conditional break "newObj == 0x7eeff200" on the last line of RexxMemory::newObject (RexxMemory.cpp)
lets stop the execution when the object is created. If too long, then modify the source :
    if (newObj == (RexxObject*)0x7eeff200)
    {
        int dummy=0;    //  <-- put breakpoint here
    }
    return newObj;
Then put a data breakpoint to detect when the attribute 'behavior' is overwritten.


===============================================================================
2012 feb 18

Implementation of this Coactivity todo :
<<
The arguments passed to the coactivity with resume should be available like traditional
arguments (use arg...). Currently they are returned by yield as an array.
>>
Implemented by adding support for :
    context = .context~parentContext : let retrieve the context of the yield's caller.
    .context~args=<an array of arguments> : let store the arguments passed to resume.
Now, the method ~yield no longer return a value.


A routine-version of yield is available : "call yield value" where value is optional.


Changed the search order in RexxDotVariable::evaluate :
Try first context->rexxVariable : .methods, .routines, .rs, .line, .context
then try context->resolveDotVariable :  getSourceObject()->findClass(name)
    findInstalledClass(internalName)
    findPublicClass(internalName)
    ActivityManager::getLocalEnvironment(internalName) controlled by security manager
    TheEnvironment->at(internalName)                   controlled by security manager
The use of .context becomes prominent with coactivities, the goal of this change is
to find the value of .context as fast as possible.
Tested from ooRexxShell where more than 700 classes are loaded :
do i=1 to 100000; v=.context ; end
    5 runs : 0.032 0.047 0.078 0.063 0.078
.environment~my.var=1
do i=1 to 100000; v=.my.var ; end
    5 runs : 0.703 0.625 0.593 0.594 0.672


Implemented RFE 2868655.
Done by adding support for variable ".threadLocal" in RexxActivation::rexxVariable.
This implementation is faster than the previous implementation with .activity.
Note 1 :
I did not modify RexxDotVariable to search in .threadLocal. Maybe should be done,
but I find that the search made by RexxDotVariable is already slow enough.
Note 2 :
Seems faster to do that :
do i=1 to 100000; v=.threadlocal["MY.VAR"] ; end
    5 runs : 0.078 0.109 0.109 0.046 0.046
rather than that :
do i=1 to 100000; v=.threadlocal~my.var ; end
    5 runs : 0.140 0.141 0.156 0.140 0.141


coactivity.cls is no longer compatible with standard ooRexx, because depends on :
.context~args = <array>
.threadLocal


interpreter\platform\windows\SysActivity.hpp
interpreter\platform\unix\SysActivity.hpp
Moved SysActivity::yield to the .cpp file to reduce the amount of recompilation when
experimenting various settings. For the moment, sleep(0) under Windows works fine for me,
and is quit faster than sleep(1) used in standard ooRexx.
sleep(0) : rexx coactivity-stress.rex 100 --> global duration=1.671, duration per consumer=0.01671
sleep(1) : rexx coactivity-stress.rex 100 --> global duration=24.625, duration per consumer=0.24625

JLF 10/09/2016
https://www.quora.com/What-is-the-difference-between-sleep-0-and-sched_yield
sched_yield()
    The sched_yield() function shall force the running thread to relinquish the
    processor until it again becomes the head of its thread list.
    This function has a standard C++ analog, std::this_thread::yield()
sleep()
    The sleep() function shall cause the calling thread to be suspended from
    execution until either the number of realtime seconds specified by the
    argument seconds has elapsed or a signal is delivered to the calling thread.
sleep(0)
    If you call sleep(0), the implementation is allowed to do exactly nothing
    and return immediately.
    The idea of sleeping for zero seconds probably comes from Windows API, where
    Sleep(0) is specified to "cause the thread to relinquish the remainder of
    its time slice to any other thread of equal priority that is ready to run.".
    Until Windows XP introduced SwitchToThread, this was the only way to yield in WinAPI.


Added counters for monitoring interpreter activities :
.yieldCounter :              how many times SysActivity::yield has been called since the begining
.addWaitingActivityCounter : how many times ActivityManager::addWaitingActivity has been called since the begining
.relinquishCounter :         how many times ActivityManager::relinquish has been called since the begining
.requestAccessCounter :      how many times RexxActivity::requestAccess has been called since the begining
.getAPIManagerCounter :      how many times LocalAPIContext::getAPIManager has been called since the begining
See samples/concurrency/coactivity-stress.rex
See samples/concurrency/factorials_generators.rex


===============================================================================
2012 feb 16

[parser]
Fixed a bug in .Clauser.
When parsing a source literal embedded into another source literal, the ';' were removed.
Ex :
    block = {return {::closure.coactive expose item ; do forever ; .yield[item] ; item += 1 ; end}}
    block~source~each{say item}
Output before fix:
    return {::closure.coactive expose item  do forever  .yield[item]  item += 1  end}
Output after fix :
    return {::closure.coactive expose item ; do forever ; .yield[item] ; item += 1 ; end}


[pipes]

The implicit argument 'value' has been renamed 'item'.

New convenience method ~pipe.generate to let yield the values produced by the pipe, one by one :
    .object~pipe.generate(.subClasses recursive once | .do {.yield[item]})
is equivalent to
    {::coactivity .object~pipe(.subClasses recursive once | .do {.yield[item]})}

New pipeStage :
.importedPackages : equivalent to .inject {item~importedPackages} iterateAfter

.console pipeStage :
The option "showTags" has been removed : the tags are now always included in the string representation.

.inject pipeStage :
The option "unique" has been renamed "once", to follow the same naming convention as coactivities.
New options "iterateBefore", "iterateAfter" : no longer need the helpers index_item and index_item (removed).

Gradually, the pipeIndex class evolved from a simple index to a whole data flow.
So renamed pipeIndex : now dataflow.
The index parameter is now only the index generated by the previous pipeStage.
A third parameter "dataflow" is passed to the process methods.
The option "memorizeIndex" has been renamed "memorize". It's used to indicate which stages
to memorize in the dataflow.

As written in the 2011 nov 16 entry, I find more natural to retrieve the produced item from
the producing stage, rather than from the next stage.
A stage's dataflow contains the produced item and index.
New methods :
    ~index
    ~item

Ex : "hello"~pipe(.console dataflow)
source:1,'hello'
       |    |
       |    +-> this is the produced item.
       |
       +-> this is the index of the produced item.
           Here, only one value is produced.


Ex : .array~of(10,20,30)~pipe(.console dataflow)
source:1,10
source:2,20
source:3,30
       |  |
       |  +-> produced item
       |
       +-> this item is the 3rd produced from the source.


Ex : List of visible packages with their public classes.
Compare with entry 2011 nov 16, the option "mem.package" has been moved to the producing stage).
Other difference : must specify explicitely "iterateAfter".
    packageName = {.file~new(dataflow["package"]~item~name)~name}
    .context~package~pipe(.inject once after {item~importedPackages} iterateAfter recursive mem.package |,
                          .inject {item~publicClasses} iterateAfter |,
                          .sort {item~id} packageName |,
                          .console packageName ":" item,
                         )


[array]
New extension ArrayPrettyPrinter which defines the method ~ppRepresentation.
This method is used by ooRexxShell to display arrays in condensed form.


[file]
Added extension method listFilesIfNotSymbolicLink, which is a convenience method to support the generation of files, even in case of recursive paths :
    g=.file~new("C:\Program Files\ooRexx")~generate("listFilesIfNotSymbolicLink")~iterateAfter~recursive
Reminder :
    - SysFileTree for Unix does not dereference symbolic links, which is good because it's possible to create recursive paths.
    - SysFileTree for Windows dereferences the symbolic links (tested with a junction), but does not crash with recursive paths.
      The recursion is stopped when the path becomes too long.
    - File~listFiles dereferences the symbolic links : if File is a symbolic link to a directory, then ~listFiles returns the list of files of the target directory.
      MUST test SysIsFileLink when recursively walking through the directories, otherwise internal buffer overflow.


===============================================================================
2012 jan 31

[parser]

Parsing problem with
    .environment~select{index~left(1) == "S"}
because == not recognized as equality operator.
Modified SourceFile.cpp, RexxSource::instruction
Now, this example is ok :
    xrange("A", "Z")~eachC{use arg letter ; .environment~select{::closure expose letter ; left(index, 1) == letter}~dump2}


[functional]

The implicit argument 'value' has been renamed 'item'.

Modified the result returned by the methods xxxI (eachI, eachCI, eachWI, etc...)
Was an array of two arrays (array of items and array of indexes).
Now it's an array of pairs (item, index), which is more appropriate for yielding.

New methods available on .String and .MutableBuffer :
Characters :
    ~dropC(count=1)
    ~dropCI(count=1)
    ~dropLastC(count=1)
    ~dropLastCI(count=1)
    ~dropUntilC(predicate)
    ~dropUntilCI(predicate)
    ~dropWhileC(predicate)
    ~dropWhileCI(predicate)
    ~rejectC(predicate)
    ~rejectCI(predicate)
    ~selectC(predicate)
    ~selectCI(predicate)
    ~takeC(count=1)
    ~takeCI(count=1)
    ~takeLastC(count=1)
    ~takeLastCI(count=1)
    ~untilC(predicate)
    ~untilCI(predicate)
    ~whileC(predicate)
    ~whileCI(predicate)
Words :
    ~dropW(count=1)
    ~dropWI(count=1)
    ~dropLastW(count=1)
    ~dropLastWI(count=1)
    ~dropUntilW(predicate)
    ~dropUntilWI(predicate)
    ~dropWhileW(predicate)
    ~dropWhileWI(predicate)
    ~rejectW(predicate)
    ~rejectWI(predicate)
    ~selectW(predicate)
    ~selectWI(predicate)
    ~takeW(count=1)
    ~takeWI(count=1)
    ~takeLastW(count=1)
    ~takeLastWI(count=1)
    ~untilW(predicate)
    ~untilWI(predicate)
    ~whileW(predicate)
    ~whileWI(predicate)

New methods available on .Collection :
    ~reject(predicate)
    ~rejectI(predicate)
    ~select(predicate)
    ~selectI(predicate)

New methods available on .OrderedCollection :
    ~drop(count=1)
    ~dropI(count=1)
    ~dropLast(count=1)
    ~dropLastI(count=1)
    ~dropUntil(predicate)
    ~dropUntilI(predicate)
    ~dropWhile(predicate)
    ~dropWhileI(predicate)
    ~take(count=1)
    ~takeI(count=1)
    ~takeLast(count=1)
    ~takeLastI(count=1)
    ~until(predicate)
    ~untilI(predicate)
    ~while(predicate)
    ~whileI(predicate)

New methods available on .Supplier :
    ~drop(count=1)
    ~dropI(count=1)
    ~dropLast(count=1)
    ~dropLastI(count=1)
    ~dropUntil(predicate)
    ~dropUntilI(predicate)
    ~dropWhile(predicate)
    ~dropWhileI(predicate)
    ~reject(predicate)
    ~rejectI(predicate)
    ~select(predicate)
    ~selectI(predicate)
    ~take(count=1)
    ~takeI(count=1)
    ~takeLast(count=1)
    ~takeLastI(count=1)
    ~until(predicate)
    ~untilI(predicate)
    ~while(predicate)
    ~whileI(predicate)

[coactivity]

~resume must be guarded otherwise the same value can be returned to different consumers
running concurrently (detected when running coactivity-stress.rex).
So, the fix for deadlock4 was not good... It's not ~resume that must be unguarded, it's ~yield.

"LazyCoactivitySupplier" renamed "CoactivitySupplier".

The class CoactivitySupplier was not lazy enough : the first item was calculated
by the ~init method, to know if an item would be available or not. Now, the first item
is calculated when really needed by the following methods : ~available, ~index, ~item.

The behaviour of CoactivitySupplier has been changed :
No longer ends when no result returned. Instead, returns item=.nil and index=.nil

Two subclasses have been added to CoactivitySupplier :
- CoactivitySupplierForGeneration : the services are specialized for generation, where items
  are yielded one by one. This kind of supplier is returned by default for coactivities.
- CoactivitySupplierForIteration : the services are specialized for iteration, where all items
  are consumed in one loop. This kind of supplier is returned by the method ~iterator.
Example :
    {::coactivity do i=1 to 10; .yield[i]; end}~each{say item}= -- return a Coactivity, nothing displayed
    {::coactivity do i=1 to 10; .yield[i]; end}~iterator~each{say item}= -- display 1 2 3 4 5 6 7 8 9 10 and return an empty array

New methods available on .Coactivity and .CoactivitySupplier :
    ~drop(count=1) : drop the 'count' first items
    ~dropI(count=1) : like drop, but yield pairs (item, index)
    ~dropLast(count=1) : drop the 'count' last items
    ~dropLastI(count=1) : like dropLast, but yield pairs (item, index)
    ~dropUntil(predicate) : drop the first items, until the predicate is true
    ~dropUntilI(predicate) : like until, but yield pairs (item, index)
    ~dropWhile(predicate) : drop the first items, while the predicate is true
    ~dropWhileI(predicate) : like while, but yield pairs (item, index)
    ~reject(predicate) : yield all the items but those for which the predicate is true
    ~rejectI(predicate) : like reject, but yield pairs (item, index)
    ~select(predicate) : yield all the items for which the predicate is true
    ~selectI(predicate) : like select, but yield pairs (item, index)
    ~take(count=1) : yield the 'count' first items
    ~takeI(count=1) : like take, but yield pairs (item, index)
    ~takeLast(count=1) : yield the 'count' last items
    ~takeLastI(count=1) : like takeLast, but yield pairs (item, index)
    ~until(predicate) : yield the first items, until the predicate is true
    ~untilI(predicate) : like until, but yield pairs (item, index)
    ~while(predicate) : yield the first items, while the predicate is true
    ~whileI(predicate) : like while, but yield pairs (item, index)

New class .Generator which is somewhat equivalent to the pipeStage .inject.
The .Generator class supports a doer of type message (.inject does not support messages because a string
is always interpreted as an option, not as a doer).
The options are passed by calling methods :
~action(action) :
    The action to execute on each item. The default action is {use arg item ; return item}.
    An action of type message (string) is supported. For convenience, the message is sent only
    if the receiver understands it (i.e. ~hasMethod returns .true). In case of recursive execution,
    the recursion is automatically stopped if the current item does not understand the message.
    Ex : the method .File~listFiles returns .nil if the item is not a directory. Since .nil does
    not understand ~listFiles, the recursion is stopped.
    This method returns the generator (self), to let chaining other methods.
~allowCommands :
    To allow execution of system commands from a RexxBlock.
    By default, the message ~functionDoer is sent to the RexxBlock. The source is transformed to
    support implicit return, which implies the NOCOMMANDS option.
    When this option is specified, the message ~actionDoer is sent to the RexxBlock. There is no
    implicit return, and the NOCOMMANDS option is not injected in the source.
    This method returns the generator (self), to let chaining other methods.
~iterateBefore :
    If the current item has the method "supplier", then apply the doer on each item returned by the supplier.
    This method returns the generator (self), to let chaining other methods.
~iterateAfter :
    If the current result has the method "supplier", then yield each item returned by the supplier.
    In case of recursive execution, each item is used as input value for the next recursive call.
    This method returns the generator (self), to let chaining other methods.
~once :
    To remember all the processed items from the start, and process an item only once.
    This option encompasses the option ~recursive("cycles") which is limited to the call stack.
    This method returns the generator (self), to let chaining other methods.
~recursive(options="") :
    To execute the action recursively on the returned values.
    The default algorithm is depthFirst.
    Options can be ([limit|depthFirst|breadthFirst|cycles][.])*
    Ex :
    ~recursive(0) : limit=0, execute the action on each item, no recursive call
    ~recursive(1) : limit=1, execute the action on each item and reexecute the action on each resulting item (1 level of recursion)
    ~recursive("depthFirst") : http://en.wikipedia.org/wiki/Depth-first_search
    ~recursive("breadthFirst") : http://en.wikipedia.org/wiki/Breadth-first_search
    ~recursive("cycles") : detect cycles, to not reprocess an item already processed in the call stack.
    ~recursive("10.breadthFirst.cycles") : combination of several options.
    This method returns the generator (self), to let chaining other methods.
~returnIndex :
    To yield .array~of(item, index).
    If the generation is recursive then yield .array~of(item, index, depth) where depth is the number of nested calls.
    This method returns the generator (self), to let chaining other methods.
~trace :
    To activate internal trace.
    This method returns the generator (self), to let chaining other methods.

New methods :
    .Object~generate(action) : returns .Generator~new(self)~action(action)
    .Object~generateI(action) : returns .Generator~new(self)~action(action)~returnIndex
    .String~generateC(action) : returns .Generator~new(self~makeArray(""))~action(action)
    .String~generateCI(action) : returns .Generator~new(self~makeArray(""))~action(action)~returnIndex
    .String~generateW(action) : returns .Generator~new(self~subwords)~action(action)
    .String~generateWI(action) : returns .Generator~new(self~subwords)~action(action)~returnIndex
    .MutableBuffer~generateC(action) : returns .Generator~new(self~makeArray(""))~action(action)
    .MutableBuffer~generateCI(action) : returns .Generator~new(self~makeArray(""))~action(action)~returnIndex
    .MutableBuffer~generateW(action) : returns .Generator~new(self~subwords)~action(action)
    .MutableBuffer~generateWI(action) : returns .Generator~new(self~subwords)~action(action)~returnIndex
    .Collection~generate(action) : returns .Generator~new(self)~iterateBefore~action(action)
    .Collection~generateI(action) : returns .Generator~new(self)~iterateBefore~action(action)~returnIndex
    .Supplier~generate(action) : returns .Generator~new(self)~iterateBefore~action(action)
    .Supplier~generateI(action) : returns .Generator~new(self)~iterateBefore~action(action)~returnIndex
    .Coactivity~generate(action) : returns .Generator~new(self)~iterateBefore~action(action)
    .Coactivity~generateI(action) : returns .Generator~new(self)~iterateBefore~action(action)~returnIndex

~times.yield renamed ~times.generate
~yield~upto renamed ~generate~upto
~yield~downto renamed ~generate~downto
Careful :
100000~times~generate{2*item} -- Collect all items in an array and then generate each array's item one by one (you don't get the first item immediatly)
100000~times.generate{2*item} -- Generate directly each item one by one (you get the first item immediatly)
The duration is roughly the same for the two lines.

Examples :
-- All items in .environment
    g=.environment~generate
    g~do= -- [The OLEObject class id#_268012703]
    g~do= -- [The InvertingComparator class id#_268059180]
    ...

-- All pairs of index,item in .environment
    g=.environment~generateI
    g~do= -- [(The OLEObject class),'OLEOBJECT']
    g~do= -- [(The InvertingComparator class),'INVERTINGCOMPARATOR']
    ...

-- Illustration of depthFirst (default) vs breadthFirst
   "one two three"~generateW{if depth == 0 then item; else if item <> "" then item~substr(2)}~recursive~makeArray=
        ['one','ne','e','','two','wo','o','','three','hree','ree','ee','e','']
   "one two three"~generateW{if depth == 0 then item; else if item <> "" then item~substr(2)}~recursive("breadthFirst")~makeArray=
        ['one','two','three','ne','wo','hree','e','o','ree','','','ee','e','']

-- All the files and directories in the ooRexx directory
    g=.file~new("C:\Program Files\ooRexx")~generate("listFiles")~iterateAfter~recursive
    t=g~take(4) -- The 4 first results returned by ~listFiles, one by one
    t~do= -- C:\Program Files\ooRexx\api
    t~do= -- C:\Program Files\ooRexx\api\oorexxapi.h
    t~do= -- The NIL object -- ~listFiles returns .nil when the target is not a directory
    t~do= -- C:\Program Files\ooRexx\api\oorexxerrors.h
    t~do= -- no result -- The take coactivity is ended, but not the listFiles coactivity...
    g~makeArray(4)~dump2 -- The next 4 results returned by ~listFiles, as an array.
        # 1: index=[1] -> item=[The NIL object id#_268001399]
        # 2: index=[2] -> item=[C:\Program Files\ooRexx\api\rexx.h id#_263525300]
        # 3: index=[3] -> item=[The NIL object id#_268001399]
        # 4: index=[4] -> item=[C:\Program Files\ooRexx\api\rexx.lib id#_263525874]
    t=g~reject{item == .nil}~take(5) -- Add a constraint to no longer get the .nil results and take only 5 results.
    t~do= -- C:\Program Files\ooRexx\api\rexxapi.lib
    t~do= -- C:\Program Files\ooRexx\api\rexxapidefs.h
    t~do= -- C:\Program Files\ooRexx\api\rexxapitypes.h
    t~do= -- C:\Program Files\ooRexx\api\rexxplatformapis.h
    t~do= -- C:\Program Files\ooRexx\api\rexxplatformdefs.h
    t~do= -- no result

-- All the imported packages, with an indented view of the dependencies
    g = .context~package~generateI("importedPackages")~iterateAfter~recursive("cycles")
    -- Next line :
    -- item[1] is the package
    -- item[3] is the depth of recursivity, can be used to indent.
    g~iterator~each{say "   "~copies(item[3]) || item[1]~name}
    Output :
        ...
        C:\Program Files\BSF4ooRexx\BSF.CLS
        C:\Program Files\BSF4ooRexx\UNO.CLS
           C:\Program Files\BSF4ooRexx\BSF.CLS
           C:\Program Files\BSF4ooRexx\UNO_XINTERFACES.RXO
           C:\Program Files\BSF4ooRexx\rgf_util2.rex
        d:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\extension\extensions.cls
           d:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\extension\doers.cls
              d:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\concurrency\coactivity.cls
                 d:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\concurrency\activity.cls
        ...

-- Generation of all natural numbers : 1 2 3 ...
    g=0~generate{item+1}~recursive

-- Factorial
    1~times.generate~reduce("*")= -- 1
    2~times.generate~reduce("*")= -- 2
    3~times.generate~reduce("*")= -- 6
    ...
    100~times.generate~reduce("*")= -- 9.33262137E+157
    ...
    1000000~times.generate~reduce("*")= -- 8.26394715E+5565708

-- *NAIVE* generation of factorials from 0! :
    g=(-1)~generate{item+1}~recursive~each{.array~of(item~times.generate~reduce(1, "*"), item)}
    g~take(10)~iterator~each{say item[2]"! =" item[1]}
        0! = 1
        1! = 1
        2! = 2
        3! = 6
        4! = 24
        5! = 120
        6! = 720
        7! = 5040
        8! = 40320
        9! = 362880

-- Less naive generation of factorials from 0! :
    g=0~generateI{if item == 0 then 1; else stack[1] * depth}~recursive
    g~take(10)~iterator~each{say item[3]"! =" item[1]}
        0! = 1
        1! = 1
        2! = 2
        3! = 6
        4! = 24
        5! = 120
        6! = 720
        7! = 5040
        8! = 40320
        9! = 362880

[doers]

Added the method ~arity to Doers, which lets higher-order functions to decide which arguments to pass.
Usage :
myDoer~arity -- returns the arity of myDoer (number of supported arguments). -1 if unknown (default).
myDoer~arity(3) -- set the arity to 3, return myDoer.

Fixed a problem of variable name collision in .Closure~initVariables :
If there was a variable 'supplier' in the outer environment, then when doing
'call value "supplier", supplierValue', the iteration over the variables was impacted,
because the variable 'supplier' was used in ~initVariables.

Added the method ~unknown to RexxBlock : any unknown message is forwarded to the implicit doer.
Ex :
The methods ~take and ~select are not defined on .RexxBlock, but they are defined on .Coactivity.
{::coactivity i=1 ; do forever; .yield[i]; i += 1 ; end}~take(5)~iterator~each{say item}
{::coactivity i=1 ; do forever; .yield[i]; i += 1 ; end}~select{item//2 == 0}~take(5)~iterator~each{say item}


[Summary of extension methods]

                                 -----------------------------------------------------------------------------
                                  |        |           |        generateC    generateW   |       |    generate
                                 -|--------|-----------|-----------|------------|--------|-------|--------|---
                                  |     reduce         |        reduceC      reduceW     |       |        |
                                 -|--------|-----------|-----------|------------|--------|-------|--------|---
                                 map       |           |        mapC         mapW        |       |        |
                                 mapR      |           |           |            |      mapCR   mapWR      |
                                 -|--------|-----------|-----------|------------|--------|-------|--------|---
                                  |     each           |        eachC        eachW       |       |        |
                                  |     eachI          |        eachCI       eachWI      |       |        |
                                 -|--------|-----------|-----------|------------|--------|-------|--------|---
                                  |        |        drop        dropC        dropW       |       |        |
                                  |        |        dropI       dropCI       dropWI      |       |        |
                                  |        |        dropLast    dropLastC    dropLastW   |       |        |
                                  |        |        dropLastI   dropLastCI   dropLastWI  |       |        |
                                  |        |        dropUntil   dropUntilC   dropUntilW  |       |        |
                                  |        |        dropUntilI  dropUntilCI  dropUntilWI |       |        |
                                  |        |        dropWhile   dropWhileC   dropWhileW  |       |        |
                                  |        |        dropWhileI  dropWhileCI  dropWhileWI |       |        |
                                  |     reject         |        rejectC      rejectW     |       |        |
                                  |     rejectI        |        rejectCI     rejectWI    |       |        |
                                  |     select         |        selectC      selectW     |       |        |
                                  |     selectI        |        selectCI     selectWI    |       |        |
                                  |        |        take        takeC        takeW       |       |        |
                                  |        |        takeI       takeCI       takeWI      |       |        |
                                  |        |        takeLast    takeLastC    takeLastW   |       |        |
                                  |        |        takeLastI   takeLastCI   takeLastWI  |       |        |
                                  |        |        until       untilC       untilW      |       |        |
                                  |        |        untilI      untilCI      untilWI     |       |        |
                                  |        |        while       whileC       whileW      |       |        |
                                  |        |        whileI      whileCI      whileWI     |       |        |
--------------------------------------------------------------------------------------------------------------
.Object ..................................................................................................X...
.String ...........................................................X............X.........................X...
.MutableBuffer ....................................................X............X........X.......X........X...
.Collection.......................X........X..............................................................X...
.OrderedCollection................X........X...........X..................................................X...
.Supplier .................................X...........X..................................................X...
.Coactivity ...............................X...........X..................................................X...
.CoactivitySupplierForGeneration ..........X...........X..................................................X...
.CoactivitySupplierForIteration ...........X...........X..................................................X...


===============================================================================
2011 dec 23

Renamed RexxContextualSource to RexxBlock, because it's now more than a simple
source. Since it's close to Smalltack blocks or Ruby blocks, the name RexxBlock
seems more appropriate.


===============================================================================
2011 dec 19

Moved wide-char oodialog (now outdated) to oodialog.wchar and adapted the makefiles
to build both standard oodialog and oodialog.wchar. The wide-char version can be
still useful to test unicode support by the interpreter.

Next step : merge from trunk.
Done.


===============================================================================
2011 dec 18

[parser]

Fixed a bug that I introduced in RexxSource::argList when adding support for the
shortcut syntax f(a1,a2,...){...}.
The end-of-clause was not tested and a token was read beyond the EOC.
Symptom : the following piece of code displayed 1 because an argument was
associated to the CallInstruction. That argument was the token {dummy2} from
the previous clause...
    {}~instancemethods({}~class) ; call dumpresult
    return
    dumpResult: procedure
        say arg()


[doers]

Simplification : Only a RexxContextualSource supports the method ~sourceDoer.
Previously, any doer supported this method, because any doer has potentially an
associated source from which a doer can be created. But to support this feature,
I should add the methods ~package, ~kind and ~rawExecutable to all the doers.
That would add complexity for something not really needed.

Added the method ~trampoline to Doer.
http://en.wikipedia.org/wiki/Tail_call#Through_trampolining
A trampoline is a technique to transform recursive calls into a sequence of calls
to doers. Instead of returning the result, the doer returns a doer which returns
the result. While the result returned by the doer is a doer, the result is called.
The loop is ended when the result is not a doer.
Ex :
    say {say "one" ; return {say "two" ; return "three"}}~trampoline -- one two three
Ex :
    factorial = {
        use strict arg n, accu=1
        if n <= 1 then return accu
        executable = .context~executable
        return {::cl
            expose n accu executable
            return executable~(n-1, n*accu)
        }
    }
    say factorial~trampoline(1000000) -- 8.26394406E+5565708

Added the method ~partial to Doer
http://en.wikipedia.org/wiki/Partial_application
Returns a closure which remembers the arguments passed to ~partial.
When this closure is called with the remaining arguments, a whole argument array is
built from both argument lists (partial and remaining) and passed to the target of
~partial.
Ex :
    add10 = "+"~partial(10)
    say add10~(1) -- 11
Ex :
    sub10 = "-"~partial(, 10)
    say sub10~(1) -- -9
Ex :
    myArguments = .context~package~findRoutine("myArguments")
    p1 = myArguments~partial(1,,3,,5)
    p1~()                               1:1 3:3 5:5
    p1~(2,,6)                           1:1 2:2 3:3 5:5 6:6
    p1~(2,4,6,,8)                       1:1 2:2 3:3 4:4 5:5 6:6 8:8
    p2 = myArguments~partial(,,3,4)
    p2~()                               3:3 4:4
    p2~(2,,6)                           1:2 3:3 4:4 5:6
    p2~(2,4,6,,8)                       1:2 2:4 3:3 4:4 5:6 7:8
    ::routine myArguments
        arg(1, "a")~each{call charout, index":"value" "}
        say
    ::requires "extension/extensions.cls"


===============================================================================
2011 dec 13

[source literal]
No more deferred parsing, the parser delegates the parsing of the source literals
to .SourceLiteralParser~rawExecutable, which creates routines or methods.
Easy because the parser supports reentrancy (or I did not yet detect problems in
relation with reentrancy...).
This class SourceLiteralParser must be preloaded (part of rexx.img).
Consequence :
- all the source literals are parsed at load-time, syntax errors are detected immediately.
- performances are good, even if the source literal is inside a loop.
  see benchmark/doers-benchmark.output.txt


[doers]

Simplification of ~sourceDoer : no longer need to create a pure expression, so
parameter expression and related code removed.
That was done in the early days to bypass a parse error when using arg() as
first expression. But since then, the parser has been modified to no longer raise
an error when arg() appears as first expression.


===============================================================================
2011 dec 10

[source literal]

RexxContextualSource : added the native method "executable=" to let the ooRexx code
in doers.cls store the executable on the instance of RexxContextualSource.
That will be used both for convenience (no longer needed for the user to call ~doer)
and performance (reuse cached executable).
JLF 2012 dec 09 : native implementation of "executable=" not needed.
Better to expose an internal variable "executable".


[doers]

(Updated 2011 dec 13)
At the first call of ~RexxContextualSource~doer, if an executable is not already stored
on the RexxContextualSource, then an executable is created and cached on the RexxContextualSource.
The next calls of ~doer return directly the cached executable.
Unlike ~doer, the methods ~functionDoer and ~actionDoer will create and cache a new
executable at each call (replacing the previous cached executable). This is because these
methods let transform the source before creating the executable.

RexxContextualSourceDoer : implemented the 3 abstract methods declared by .doer :
    ~needsObject
    ~do
    ~doWith
An implicit call to ~doer is done when calling these methods.
Ex :
    range = { use arg min, max ; return { ::closure expose min max ; use arg num ; return min <= num & num <= max }}
    from5to8 = range~do(5, 8) --     each execution of range returns a different RexxContextualSource.
    from20to30 = range~do(20, 30) -- since the RexxContextualSource is a closure's source, it holds a snapshot of the context's variables.
    say from5to8~do(6) -- 1          first execution : the RexxContextualSource is parsed, the closure executable is created and cached.
    say from5to8~do(9) -- 0          reuse the RexxContextualSource's cached closure executable.
    say from20to30~do(6) -- 0        from20to30 contains a RexxContextualSource different from from5to8. first execution : the closure is parsed.
    say from20to30~do(25) -- 1       reuse the cached executable.

Big picture (updated 2011 dec 13) :
    a RexxSourceLiteral is an internal rexx object, created by the parser, not accessible from ooRexx scripts.
    a RexxSourceLiteral holds these properties, shared among all the RexxContextualSource instances created from it.
      |  source : the text between the curly brackets {...} as an array of lines, including the tag :xxx if any.
      |  package : the package which contain the source literal.
      |  kind : kind of source, derived from the source's tag.
      |  rawExecutable : routine or method created at load-time (immediate parsing).
      |
      +--> a RexxContextualSource is created each time the RexxSourceLiteral is evaluated, and is accessible from ooRexx scripts.
      |    Why not return directly the RexxSourceLiteral ? (after all, this is what is done for other literals :
      |    A RexxInteger, a RexxNumberString, a RexxString  evaluate to itself)...
      |    Because, as indicated by its name, a RexxContextualSource contains informations that depends on the evaluation context.
      |    In particular, when a RexxContextualSource is a closure's source, it will hold a snapshot of the context's variables.
      |        ~source : source of the RexxSourceLiteral, never changed even if ~functionDoer or ~actionDoer called.
      |        ~variables : snapshot of the context's variables (a directory), created only if the source starts with "::cl".
      |        ~rawExecutable : the raw executable of the RexxSourceLiteral, created at load-time (routine or method).
      |        ~executable : cached executable, managed by doers.cls.
      |                      routine or method or coactivity or closure. ~executable~source can be different from ~source.
      |
      +--> a RexxContextualSource
      |
      +--> etc... (a new instance is created at each evaluation of the RexxSourceLiteral)

Example, from ooRexxShell (the final '=' is used to display the result) :

    cs = {"hello"} -- immediate parsing (if syntax error, will be raised when the package is loaded)
    cs~source= -- the RexxSourceLiteral's source
        # 1: index=[1] -> item=["hello"]
    cs~rawExecutable= -- [a Routine id#_264298413]
    cs~rawExecutable~source=
        # 1: index=[1] -> item=["hello"]
    cs~executable= -- [The NIL object id#_268001399]
    cs~do -- execute the system command "hello" --> display "Bonjour, le monde!"
    cs~executable= -- cached executable [a Routine id#_264001464]

    cs~functionDoer= -- [a Routine id#_267150234] created from a transformed source derived from cs~source
    cs~executable= -- [a Routine id#_267150234] this new routine has been memorized
    cs~executable~source= -- transformed source
        # 1: index=[1] -> item=[options "NOCOMMANDS" ; "hello"]
        # 2: index=[2] -> item=[ ; if var("result") then return result]
    cs~source= -- the original source is unchanged and still available
        # 1: index=[1] -> item=["hello"]
    cs~do= -- [hello]

    cs~actionDoer= -- [a Routine id#_266463660] created from a source derived from cs~source (no transformation)
    cs~executable= -- [a Routine id#_266463660] memorized
    cs~executable~source=
        # 1: index=[1] -> item=["hello"]
    cs~do -- execute the system command "hello" --> display  "Bonjour, le monde!"

    cs~executable = .nil -- reset the cache
    cs~executable= -- [The NIL object id#_268001399]


[parser]

Added support for tilde-call message "~()".
The message name can be omitted, but the list of parameters is mandatory (can be empty).
    target~()
    target~(arg1, arg2, ...)
    target~~()
    target~~(arg1, arg2, ...)
When the expression is evaluated, the target receives the message "~()".
Why not just "()" ? because I keep the possibility to have a distinct message in case of
pure function-call (not activated, but the code is implemented and it works.
See functionCallMessage in SourceFile.cpp).
So now, an additional form of message term is supported :
>>-receiver-+- ~ --+----+---------+----(--+----------------+--)--><
            +- ~~ -+    +-:symbol-+       | +-,----------+ |
                                          | V            | |
                                          +---expression-+-+
Implementation in doers.cls :
    ::class "Doer" mixinclass Object public inherit DoerFactory
    -- Tilde call
    ::method "~()" unguarded
        forward message "do" to (self~doer)
So any doer which receives the message "~()" will execute its ~do method.
Ex :
    {say hello}~() -- HELLO
    run={arg(1)~()} ; run~{say hello} -- HELLO
    {say arg(1)}~~("hello")~~("bye") -- hello bye
    say 1 + {return 2 * arg(1)}~(2) + 3 -- 1 + 2*2 + 3 = 8
Ex :
    myFunc = {return 2 * arg(1)}
    do i=1 to 10 ; say 1 + myFunc~(i) ; end
Ex : (already seen above, but here only tilde-calls are used, no more ~do)
    range = { use arg min, max ; return { ::closure expose min max ; use arg num ; return min <= num & num <= max }}
    from5to8 = range~(5, 8)
    from20to30 = range~(20, 30)
    say from5to8~(6) -- 1       first execution : the closure is parsed
    say from5to8~(9) -- 0
    say from20to30~(6) -- 0     first execution : the closure is parsed
    say from20to30~(25) -- 1


[functional]

Modified the following methods to always return an array, even if no result collected
(in this case, the returned array is empty) :
    ~times
    ~upto
    ~downto
This is more consistent for the caller, no need to test if a result was returned or not.


===============================================================================
2011 nov 16


[pipes]

The option 'memorizeIndex' lets specify an optional tag : memorizeIndex[.tag]
By default, the tag is the pipeStage class id.
Still thinking to improve this memorization, because when needing the produced value,
the tag must be specified on the next pipeStage (which consumes the value).
In the example below, the tag "package" is associated to the 2nd inject, whereas
I find it would be more natural to associate it to the 1st inject.
todo : add ~valueIn, ~valueOut.
Ex : List of visible packages with their public classes
.context~package~pipe(.inject {value~importedPackages} recursive unique after |,
                      .inject {value~publicClasses} mem.package |,
                      .sort {value~id} {index["package"]~value~name} |,
                      .console {.file~new(index["package"]~value~name)~name} ":" value,
                     )
activity.cls : The Activity class
coactivity.cls : The Coactivity class
coactivity.cls : The WeakProxy class
coactivity.cls : The yield class
array.cls : The ArrayInitializer class
doers.cls : The Clauser class
doers.cls : The CoactivityDoer class
...


[source literal]

Removed RexxContextualSource::getContext (~context)
Added RexxContextualSource::getVariables (~variables)
The method ~variables returns a snapshot of .context~variables at the time of creation
of the RexxContextualSource.


[doers]

Added support for closures by value.
When a RexxSourceLiteral is evaluated, a RexxContexualSource is created, which holds
a snapshot of the current context (directory of variables).
The RexxContexualSource can be passed back to the caller, the directory of variables
will remain accessible (unlike a RexxContext instance which becomes invalid once the
RexxActivation has been popped).

Closure by value means : Updating a variable from the closure will have no impact on the
original context.
Note : If the variable contains a mutable value then updating the mutable value from the
closure will have an impact on the original context (if still active).

A closure is an object whose exposed variables are created from a directory of variables.
This directory of variables can be passed explicitely, or taken from a RexxContextualSource.
The behavior of the closure is a user-defined method which expose the needed variables.
This method is added to the closure, with the name "do". Ex :
    v = 1 ; closure = .Closure~new(.context~variables){::m expose v ; say v} ; closure~do -- display 1

New tags :
    ::cl[osure]
    ::cl[osure].c[oactive]

The example above can be rewritten :
    v = 1 ; {::closure expose v ; say v}~doer~do -- display 1
The ~doer method returns a closure, because the tag indicates it's a closure.

Can be also a coactive closure :
    v = 1
    w = 2
    closure = {::cl.c expose v w ; .yield[v] ; .yield[w]}~doer
    say closure~do -- 1
    say closure~do -- 2

The context of a closure can be a method :
    myInstance = .myClass~new("myAttributeValue")
    myContextualSource = myInstance~myMethod
    say myContextualSource~class
    say myContextualSource~source~toString
    do v over myContextualSource~variables
        say v
    end
    doer = myContextualSource~doer
    say doer~class
    doer~do
    ::class myClass
    ::method init
        expose a1
        use strict arg a1
    ::method myMethod
        expose a1
        local = "myLocal"
        return {::cl expose self a1 local ; say self~class ; say a1 ; say local}
    ::requires "extension/extensions.cls"
Output :
    The RexxContextualSource class
    ::cl expose self a1 local ; say self~class ; say a1 ; say local
    SELF
    LOCAL
    A1
    SUPER
    The Closure class
    The MYCLASS class
    myAttributeValue
    myLocal


===============================================================================
2011 nov 14

[extensions]

Added a ~help method on the class .Object.
When working from ooRexxShell, I often need to get a quick reminder of some
functionalities, especially for pipeStages. The ~help method searches for the
self~_description_ method. If found, the help text is extracted from the source,
as an array of strings. The first 2 lines and last 2 lines are removed, according
the convention described below. The array is displayed with : say array~toString
and returned as result.
Must follow this convention :
    ::method _description_
    nop
    /*
    <text here>
    */
    nop
I use nop before and after because otherwise the comment is not stored in the method's
source (any instruction would do the trick). Don't know if it's a bug or a feature...
Usage :
    .pipeStage~help
    .pipeIndex~help
    .fanin~help
    .merge~help
    ...


[pipes]

Implemented some ~help methods.

Refactoring of .secondaryConnector : did not connect the wrapped pipeStage
to its follower. Now, .secondaryConnector is a normal pipeStage, the method
~secondaryConnector is no longer needed.
Ex :
    fanin = .fanin mem | .console showTags
    fanout1 = .left[3]  mem | .lower mem | fanin  -- not bufferized
    fanout2 = .right[3] mem | .upper mem | .inject {"my_"value} after | .secondaryConnector | fanin -- bufferized until fanout1 is eof
    .array~of("aaaBBB", "CCCddd", "eEeFfF")~pipe(.fanout mem >> fanout2 > fanout1)
source[Array#1(an Array),1]|fanout[i1='aaaBBB']|left[i1]|lower[i2='aaa']|fanin[i2] : aaa
source[Array#1(an Array),2]|fanout[i1='CCCddd']|left[i1]|lower['CCC']|fanin['ccc'] : ccc
source[Array#1(an Array),3]|fanout[i1='eEeFfF']|left[i1]|lower['eEe']|fanin['eee'] : eee
source[Array#1(an Array),1]|fanout[i1='aaaBBB']|right[i1]|upper[i2='BBB']|fanin[i2] : BBB
source[Array#1(an Array),1]|fanout[i1='aaaBBB']|right[i1]|upper['BBB']|fanin['my_BBB'] : my_BBB
source[Array#1(an Array),2]|fanout[i1='CCCddd']|right[i1]|upper['ddd']|fanin['DDD'] : DDD
source[Array#1(an Array),2]|fanout[i1='CCCddd']|right[i1]|upper['ddd']|fanin['my_DDD'] : my_DDD
source[Array#1(an Array),3]|fanout[i1='eEeFfF']|right[i1]|upper['FfF']|fanin['FFF'] : FFF
source[Array#1(an Array),3]|fanout[i1='eEeFfF']|right[i1]|upper['FfF']|fanin['my_FFF'] : my_FFF


===============================================================================
2011 nov 12

[coactivity]

No longer use the directive ::OPTIONS NOMACROSPACE in coactivity.cls and activity.cls.
That breaks oorexxShell when run with standard ooRexx.
For me, ::OPTIONS should not raise an error in case of unknown option.
This is the case for the instruction options : Unrecognized words in the result are
ignored, since they are assumed to be instructions for a different language processor.

Fixed a deadlock which is due to the split of .Coactivty in two distinct classes.
The following methods must be declared unguarded because they can start the wrapped .CoactivityObj :
.Coactivity~start
.Coactivity~resume
See samples/concurrency/deadlock4.rex for the details


===============================================================================
2011 nov 07

[coactivity]
The LazyCoactivitySupplier no longer needs an uninit method.


[GC]
Added testcase2.rex for uninit which covers both cases :
step 1 : call only predefined functions/methods --> no uninit called during the loop
step 2 : call only user-defined procedures/routines/methods --> uninit called during the loop


===============================================================================
2011 nov 06

[coactivity]

By default, a coactivity is no longer started when created.
Now automatically started by the first resume, if not yet started.

Spent several hours for nothing, trying to use WeakReferences for the global cache
of coactivities. I was hopping to get an automatic end of coactivity when this
coactivity is no longer referenced by a client. But the tests demonstrated that a
started coactivity can't be GC'ed, even if no longer referenced by a client. I suppose
it's because of the method ~start which is running on its own thread, and the self
variable references the coactivity, thus keeping it alive...

There is a way to auto-end a coactivity : just use a wrapper object whose sole
responsibility is to end the coactivity when itself is GC'ed. This is what is already
doing LazyCoactivitySupplier, and that works as expected.
Now using two distinct classes :
- .Coactivity for the wrapper instance.
- .CoactivityObj for the wrapped instance.
Maybe I could use only one class (.Coactivity) to create both the wrapper and the
wrapped instances. Will see, but for the moment, I think the code is more clear
with two classes (despite the forwarding methods on .Coactivity).
Examples of auto-ending coactivies (to test from ooRexxShell) :
    .coactivity~new{i=0; do forever; i+=1; .yield[i]; end}~makeArray(5)=
        # 1: index=[1] -> item=[1]
        # 2: index=[2] -> item=[2]
        # 3: index=[3] -> item=[3]
        # 4: index=[4] -> item=[4]
        # 5: index=[5] -> item=[5]
    #Coactivities: 1                -- still active but no longer reachable, not yet GC'ed
    .coactivity~new{i=0; do forever; i+=1; .yield[i]; end}~pipe(.take 5 | .console)
        (a Coactivity),1 : 1
        (a Coactivity),2 : 2
        (a Coactivity),3 : 3
        (a Coactivity),4 : 4
        (a Coactivity),5 : 5
    #Coactivities: 2                -- still active but no longer reachable, not yet GC'ed
    do 10000 ; .object~new ; end    -- force a GC
    #Coactivities: 0                -- both coactivities have been ended by uninit


[GC]
The work on WeakReferences showed that the calls to uninit methods are impacted by
the use of a security manager (was detected from ooRexxShell which has a security
manager) : more "reactive", i.e. the uninit methods are called during the execution
and not just when the interpreter is halting.
Added samples/gc/testcase1 and several outputs.
Added internals/notes/uninit.txt (code review and various notes)
Added some verbose messages in the interpreter to trace the calls to uninit.
(remember : in trunk/lib/orxwin32.mak, add /DVERBOSE_GC at the end of cflags_common)


[functional]
Modified the ~each methods to always return an array, even if no result collected
(in this case, the returned array is empty). This is more consistent for the caller,
no need to test if a result was returned or not.


===============================================================================
2011 nov 04

[coactivity]

Fixed a deadlock.
(see concurrency/deadlock3.rex for the description of the test case)
The minimal fix was to declare .RoutineDoer~do and ~doWith unguarded.
But I declared unguarded all the methods in doers.cls and functional.cls that don't
modify the state of the self object. I hope this is the right strategy to follow...

According to my tests, a predefined method which is declared guarded is never locked.
But a user-defined method which is declared guarded is locked, as expected.
See :
concurrency/guarded_predefined_method_are_not_locked.rex
concurrency/guarded_user-defined_method_are_locked.rex


Changed the behaviour of ~makeArray, now working like the pipestage .take :
c = 1000~times.yield
c~makeArray(5)
    # 1: index=[1] -> item=[1]
    # 2: index=[2] -> item=[2]
    # 3: index=[3] -> item=[3]
    # 4: index=[4] -> item=[4]
    # 5: index=[5] -> item=[5]
c~makeArray(5)
    # 1: index=[1] -> item=[6]
    # 2: index=[2] -> item=[7]
    # 3: index=[3] -> item=[8]
    # 4: index=[4] -> item=[9]
    # 5: index=[5] -> item=[10]
etc...


[pipes]
I see a loss of performance (twice longer) in the profiled pipeline at the end of
pipe_extension_test.output.txt, and I can't find why...
    7048    20.485   dbg (ok, dbg config is slower due to semaphores tracing)
    7078     8.281   rel
    7086     8.781   rel
    7112     8.531   rel
    7139     8.265   rel
    7154     8.828   rel
    7172     8.953   rel
    7246     8.953   rel
    current 17.936   rel
Made a rebuild of the binaries at revision 7123 : same loss of performance.
Made a test with samples at revision 7048 : no longer adapted to current binaries
(RexxContextualSource source is no longer a string, but an array).
Made a test with samples at revision 7080 : same loss of performance (using current
binaries or rev 7123).
Added a non-profiled version of the same pipeline, with duration, to detect if a similar
loss of performance happens in the future with non-profiled code.


===============================================================================
2011 oct 30

Each call to an external function (like SysXxx functions) triggers a communication
with the rxapi server through a socket (QUERY_MACRO, to test is the function is
defined in the macrospace).
This has a major impact on performance !
Example with .yield[] which calls SysGetTid() or SysQueryProcess("TID") at each call :
    10000 calls to .yield[] with macrospace enabled  : 2.1312
    10000 calls to .yield[] with macrospace disabled : 0.4531
(samples/benchmark/doers-benchmark-output.txt)
So I decided to add an option to control the use of macrospace :
    ::options MACROSPACE
    ::options NOMACROSPACE
    options "MACROSPACE"
    options "NOMACROSPACE"
By default, the macrospace is queried, according to the rules described in rexxref
section "7.2.1 Search order".
When using the option NOMACROSPACE, the macrospace is not queried.


Yet something to investigate (no relation with rxapi) : Under WinXP, a call to a routine
is much slower than a run of a method (sandbox or main - same results) :
    10000 calls of an empty routine by name : 0.2422
    10000 calls of an empty routine object  : 0.2437
    10000 runs of an empty method           : 0.0141
Under MacOsX, no such difference :
    10000 calls of an empty routine by name : 0.0103
    10000 calls of an empty routine object  : 0.0104
    10000 runs of an empty method           : 0.0087
(samples/benchmark/call-benchmark.rexx)


===============================================================================
2011 oct 26

Fixed a crash in relation with RexxContextualSource and GC :
Must mark objectVariables.

Fixed a crash in hostemu for Windows platform :
Must add RexxEntry in the declaration of GrxHost.


===============================================================================
2011 oct 23

[doers]

Currently {::coactivity ...} always create a routine from the source literal.
But a method can be also a coactivty.
Assuming 'coactive' is like an option for the directives ::method and ::routine,
I added the following tags :
::routine myRoutine coactive  --> tag = ::r[outine][.c[oactive]]
::method myMethod coactive    --> tag = ::m[ethod][.c[oactive]]

The following declarations are equivalent :
{::c[oactivity] ...}
{::r[outine].c[oactive] ...}

Example of coactive method :
c={::m.c self~each{.yield[arg(1)]}}~doer(.array~of(1,2,3))
c~do -- returns 1
c~do -- returns 2
c~do -- returns 3
The object is the array.
The method is {::m self~each{.yield[arg(1)]}} where self is the array.

Something to think about :
When the doer is a method, the object on which the method is applied is passed as
first argument of ~do. And the rest of the arguments are passed to the method in
arg(1), arg(2), ...
    {::m say self~class ":" arg(1)}~doer~do(.array~new, "2nd arg") -- The Array class : 2nd arg
is implemented by
    .array~new~run(doer, "i", "2nd arg")
When the doer is a coactive method, the object on which the method is applied is
passed using ~doer and memorized by the coactivity. That makes sense since the method
can yield several result, and it's the same object which is used at each resume.
But then, the ~do method has less arguments.
    {::m.c say self~class ":" arg(1)}~doer(.array~new)~do("1st arg") -- The Array class : 1st arg
Internally, the call to the method is the same as a normal method, but with this test that I have
only in coactivity (for the moment) :
    if doer~needsObject then doer~doWith(object, arguments) -- object needed (message, method)
    else doer~doWith(arguments) -- no object needed (routine)
I could modify .MethodDoer~doer to pass the object with ~doer. But that breaks a lot of code.
And I would need to do the same for StringDoer~doer (a .Message is sent to an object,
the object is passed as first argument of ~do).
    say "+"~doer~do(1,2) -- here, 1 is the object : 1~send("+", 2)
Will see on usage if this difference of parameters between a method and a coactive method
is effectively a problem or not...


[functional]

Simplification :
I follow the same approach than for pipes, by transforming the source literals
to add the parameters value and index.
For reduce, three parameters are passed : accu, value, index.
A difference with pipes, when calling the doer~do method, I pass the index only if
~functionDoer exists on the doer. That lets use messages like "+" with reduce.
The current pipe implementation does not support doers of type message (and will
never do), because strings are recognized as options, not as doers.

Consequence :
reduceI, reduceCI, reduceWI, mapI, mapCI, mapWI, mapRI, mapCRI, mapWRI, eachI, eachCI, eachWI : removed
eachII, eachCII, eachWII : renamed respectively eachI, eachCI, eachWI


===============================================================================
2011 oct 18

I just discovered that I have a conflict on the ~doer method for .Coactivity :
In coactivity.cls, "doer" is a private attribute
In doers.cls, "doer" is a public method on CoactivityDoer.

After thoughts, I find that using ::attribute for a private object variable is probably
a wrong decision. With expose, no risk of such conflict.
-->
Now using expose.


Added the method 'executable' to give access to the routine or method controlled by the
coactivity.


===============================================================================
2011 oct 16


[functional]

Refactoring of ~reduce, ~map and ~each :
- Since a parameter "options" is supported by ~reduce and ~map, I could remove
  ~reduceChar ~reduceWord ~mapChar ~mapWord, and pass an option "char" or "word"
  to the methods ~reduce and ~map.
  After experimentation, I think it's not a good idea. More verbose to write, and
  sometimes must omit parameters.
  The reading of http://en.wikipedia.org/wiki/Fold_(higher-order_function) convinced
  me to have different methods names, using one letter for each option, including the
  "indexed" and "inplace" options, "inplace" being renamed "replace".
  Consequence : the parameter "options" is removed.
- ~map allowed to update in-place, but the design decisions were not good... I limited
  this option to collections which understand ~append, because I wanted to support
  deletion (filtering) of items. But that's a bad idea, better to not allow deletion
  and use []= for assignment. That will work with any collection, including multi-
  dimensional arrays.
- String and MutableBuffer are a special case, where ~append is more appropriate for
  implementing ~map. Filtering is supported.
- ~map and ~each had overlapping features. Now, these methods have distinct usage :
  The result returned by ~map has the same type as the self object.
  The result returned by ~each is either an array or no result (if procedural action).
  ~map can be in-place, ~each is never in-place.
  ~map can't filter collections, ~each can filter collections.
- ~each must be available on String and MutableBuffer. The result is an array or no result.

In summary :
(update JLF 23 oct 2011 : the xxxI methods have been removed, the xxxII methods have been renamed xxxI)
                reduce   reduceC   reduceW   map   mapC   mapW   mapR   mapCR   mapWR   each    eachC    eachW
                reduceI  reduceCI  reduceWI  mapI  mapCI  mapWI  mapRI  mapCRI  mapWRI  eachI   eachCI   eachWI
                                                                                        eachII  eachCII  eachWII
.String         ............X.........X..............X......X......................................X........X...
.MutableBuffer  ............X.........X..............X......X.............X.......X................X........X...
.Array          ...X..........................X....................X......................X.....................
.Bag            ...X..........................X....................X......................X.....................
.CircularQueue  ...X..........................X....................X......................X.....................
.Directory      ...X..........................X....................X......................X.....................
.List           ...X..........................X....................X......................X.....................
.Properties     ...X..........................X....................X......................X.....................
.Queue          ...X..........................X....................X......................X.....................
.Relation       ...X..........................X....................X......................X.....................
.Set            ...X..........................X....................X......................X.....................
.Stem           ...X..........................X....................X......................X.....................
.Table          ...X..........................X....................X......................X.....................
.IdentityTable  ...X..........................X....................X......................X.....................
.Supplier       ...X......................................................................X.....................
.Coactivity     ...X......................................................................X.....................

Reduce on non-ordered collections will give good results only with commutative operations.
Ex : any collection can be reduced with "+", but only ordered collections should be reduced with "-".

Experimental : I search my way to implement lazy iterators using coactivities.
I created additional methods like
    ~times.yield
    ~yield.upto
    ~yield.downto
They work as expected, but having to create a new method to manage the coactivity sounds not good.
Especially if I want to do the same for the ~each methods (21 methods to add...).
So far, I see these possibilities :
    1~yield.upto(10){arg(1)}   -- Current implementation, with a distinct method which creates the coactivity and delegates to ~upto which yields each value.
    1~upto(10, .true){arg(1)}  -- Pass a boolean to ask for a coactivity. The coactivity and the yield are managed by ~upto.
    1~upto(10){.yield[arg(1)]} -- The yield is done by the doer. Problem : ~upto has no way to know that a coactivity must be created...
                               -- ...unless the doer "knows" it contains a yield, and ~upto can test that...
According to what I see in Python, the interpreter automatically creates a generator when a yield is in the code of a function.
At the first call of the function, the generator object is returned.
    def countdown(n):
        print "Counting down from", n
        while n > 0:
            yield n
            n -= 1
    >>> x = countdown(10)
    >>> x
    <generator object at 0x58490>
    >>>
So it looks similar to the third solution. Except that in the Python example, the loop and the yield are in the same function.
In the case of ~upto, the loop and the yield are not in the same routine.


===============================================================================
2011 oct 02

[parser]

For good or bad reason, arg(1) at the begining of a clause is recognized as an
instruction, because arg is a keyword instruction.
I often use source literals like {arg(1)...} where I want arg(1) to be interpreted
as a function call. So I decided to change the behavior of the parser to interpret
as a function call any symbol followed immediatly by a left paren, even if the
symbol is a keyword instruction.

With implicit return, such an expression is quite common when filtering : value==1
    .array~of(1,2,1)~pipe(.select {value==1} | .console)
but the parser raises an error to protect the user against a potential typo error,
assuming the user wanted to enter : value=1.
I deactivated this control, now the expression above is ok.
Yes, it remains a problem (no syntax error, but it's an assignment, not a test) :
    .array~of(1,2,1)~pipe(.select {value=1} | .console)
good point, the lack of returned value is detected, must surround by parentheses
to make it a real expression.
    .array~of(1,2,1)~pipe(.select {(value=1)} | .console)
(an Array),1 : 1
(an Array),3 : 1


[functional]

reduce : added optional initial value
123~reduceChar("+")                    -- initial value is the first char (default), returns 6
123~reduceChar(100, "+")               -- initial value is 100, returns 106
"10 20 30"~reduceWord("+")             -- initial value is the first word (default), returns 60
"10 20 30"~reduceWord(100, "+")        -- initial value is 100, returns 160
.array~of(10, 20, 30)~reduce("+")      -- initial value is the first item (default), returns 60
.array~of(10, 20, 30)~reduce(100, "+") -- initial value is 100, returns 160

(update JLF 16 oct 2011 : 'option' parameter removed)
reduce : added option "ind[exed]"
    arg(1) : accumulated result
    arg(2) : current item of collection
    arg(3) : current index of collection, passed only if option "ind[exed]" is specified
"10 20 30"~reduceWord(, "ind"){arg(1) + arg(2) + arg(3)}         -- initial value is the first word (default), index passed as 3rd argument, returns 10 + 20+2 + 30+3 = 65
"10 20 30"~reduceWord(0, "ind"){arg(1) + arg(2) + arg(3)}        -- initial value is 0, index passed as 3rd argument, returns 0 + 10+1 + 20+2 + 30+3 = 66
.array~of(10, 20, 30)~reduce(, "ind"){arg(1) + arg(2) + arg(3)}  -- initial value is the first item (default), index passed as 3rd argument, returns 10 + 20+2 + 30+3 = 65
.array~of(10, 20, 30)~reduce(0, "ind"){arg(1) + arg(2) + arg(3)} -- initial value is 0, index passed as 3rd argument, returns 0 + 10+1 + 20+2 + 30+3 = 66

map : can act as a filter.
"one two three"~mapWord{if arg(1)~length == 3 then arg(1)} -- returns "one two"

(update JLF 16 oct 2011 : 'option' parameter removed)
map : added option "ind[exed]".
    arg(1) : current item of collection
    arg(2) : current index of collection, passed only if option "ind[exed]" is specified
"one two three"~mapWord("ind"){arg(2)":"arg(1)} -- returns "1:one 2:two 3:three"

(update JLF 16 oct 2011 : no result instead of .nil when nothing returned)
(update JLF 16 oct 2011 : no longer raise an error if no action : default is {arg(1)})
times : now can act as an array generator.
3~times{0}          -- returns .array~of(0,0,0)
3~times{arg(1)}     -- returns .array~of(1,2,3)
3~times{say arg(1)} -- returns .nil : no resulting array because no result returned during the iteration
3~times             -- raise an error because the parameter action is mandatory

(update JLF 16 oct 2011 : no result instead of .nil when nothing returned)
upto and downto : now can act as an array generator.
11~upto(13)             -- returns .array~of(11,12,13) because the default action is {arg(1)}
(-1)~upto(3)            -- returns .array~of(-1,0,1,2,3) -- Note that -1 MUST be surrounded by paren or quotes
11~upto(13){2*arg(1)}   -- returns .array~of(22,24,26)
11~upto(13){say arg(1)} -- returns .nil : no resulting array because no result returned during the iteration

(update JLF 16 oct 2011 : now, ~each always return an array)
each : can act as a collection generator and a filter.
The type of generated collection depends on the type of itererated source :
    collection --> same type of collection
    supplier --> array
    coactivity --> array
.array~of(1,2,3)~each{2*arg(1)}                       -- returns .array~of(2,4,6)
.set~of(1,2,3)~each{2*arg(1)}                         -- returns .set~of(2,4,6)
.set~of(1,2,3)~supplier~each{2*arg(1)}                -- returns .array~of(2,4,6)
{::c do i=1 to 3; .yield[i]; end}~doer~each{2*arg(1)} -- returns .array~of(2,4,6)
1~upto(20){if arg(1) // 3 == 0 then arg(1)}           -- returns .array~of(3,6,9,12,15,18) -- filter

[pipes]

pipeIndex representation : When using the option 'showTags', a tag class#id is
inserted before the representation of objects. The id is a short id (starts from 1,
incremented for each new instance of the same class in the index).
before : tag1['a',1,2,3,4]|tag2['a',1,2]|tag3[(22222),(my file)]
now    : tag1['a',1,2,3,4]|tag2['a',1,2]|tag3[MutableBuffer#1(22222),File#1(my file)]

pipeIndex representation : ~makeString takes two additional parameters :
localMask : which local indexes to include ("" means all). Ex : "2 3".
showNested : if .false then the nested index is not included.

Added two scripts to illustrate how a pipeline can be used for real scripts :
grep_sources.rex
trailing_whitespaces.rex


[profiling]

Added support for class methods.
But that won't work with standard ooRexx, because depends on ~setMethod which is private.


[array programming]

Currently investigating this area from several languages : APL, J, F-Script.
A first consequence was the modification of ~times ~upto ~downto and ~each to make them
generators of array.

Work in progress in extension/array.cls


===============================================================================
2011 sep 18

[pipes]

.startsWith now accepts a variable number of arguments (like .all and .notAll).
The value is selected if it starts with one of the strings passed as argument.

New pipeStage .endsWith, useful to test the suffix of files.
"c:\"~pipe(.fileTree | .endsWith["sys", "bat"] caseless | .console)

Added partition support to pipeStages that delay their output :
.drop, .take, .buffer, .lineCount, .charCount, .wordCount
(.take had already partition support for 'first' but not for 'last').

New management of indexes.
A pipeIndex is an array of variable length :
array[1] : tag (generally the id of the pipeStage class, or "source" for the initial index)
array[2] : nested pipeIndex (received from previous pipeStage)
array[3] : optional local index1
array[4] : optional local index2
etc...
When a pipeStage receives an index and a value, it applies transformations or
filters on the value. When a value is forwarded to a following pipeStage, it can
be accompanied by a new index that encapsulates the received index and add a tag
and local indexes. See option 'memorizeIndex' below.
Conventions followed in this pipeline implementation :
- The received value becomes the first local index (you have a call stack with arguments).
- If the pipeStage generates several values from the received value, then a second
  local index is added, which gives the position of the current generated value.
- If the pipeStage lets create a user-defined index (ex : .inject), then this index
  becomes the third (and following) local index.

The creation of the pipe indexes is controlled by the option 'memorizeIndex' (abbrev 'mem').
This option is available from any pipeStage.
By default, the pipe indexes are not created, except for the source of the pipeline.

.inject : adaptation of the behaviour to the new management of indexes.
Two options are available : 'memorizeIndex' and 'recursive.memorizeIndex'.
By default, no index is memorized by .inject.
In the example below, the first column is the source index (always memorized)
1~pipe(.inject {value+1} recursive.2 | .console)
1,1 : 2
1,1 : 3
1,1 : 4
Here, the last index calculated by .inject during recursive calls is memorized.
1~pipe(.inject {value+1} recursive.2 mem | .console)
1,1|1,1 : 2
1,1|2,1 : 3
1,1|3,1 : 4
Here, the intermediate indexes calculated by .inject during recursive calls are memorized.
No need to specify the stand-alone 'memorizeIndex' option, because 'recursive.memorizeIndex'
includes its functionality (but you can if you wish, it's just redundant).
1~pipe(.inject {value+1} recursive.2.mem | .console)
1,1|1,1 : 2
1,1|1,1|2,1 : 3
1,1|1,1|2,1|3,1 : 4

A memorized index can be retrieved by tag.
Example :
This pipeline iterates over all the files in the ooRexx install directory.
For each file, iterates over its contents, line by line.
Selects the lines which contain '::class'.
The .take pipeStage takes only one line per file.
'C:\Program Files\ooRexx\'~pipe(.fileTree recursive | .getFiles memorize | .all['::class'] | .take 1 {index~get('getFiles')~value} | .console)
Example of output :
'C:\Program Files\ooRexx\',1|(C:\Program Files\ooRexx\csvStream.cls),55 : ::class CsvStream subclass Stream Public
'C:\Program Files\ooRexx\',1|(C:\Program Files\ooRexx\mime.cls),49 : ::class mimepart public
'C:\Program Files\ooRexx\',1|(C:\Program Files\ooRexx\OODIALOG.CLS),54 : ::class 'DialogExtensions' public MIXINCLASS object
...

The class pipeIndex has a specific 'makeString' method which accepts two arguments :
- showTags (default .false) : when .true, the tags are inserted in the representation string.
- showPool (default .false) : when .true, a value which appears several times is replaced by
  a reference to the first occurence of the value.
Strings are surrounded by quotes, except string numbers.
To make a distinction between a real string and other objects, the representation
of instances of objects other than strings are surrounded by round brackets.
Example :
i1 = .pipeIndex~create("tag1", .nil, 1)                   -- 1
i2 = .pipeIndex~create("tag2", i1, "a")                   -- 1|'a'
i3 = .pipeIndex~create("tag3", i2, .mutableBuffer~new(2)) -- 1|'a'|(2)
i4 = .pipeIndex~create("tag4", i3, .file~new("c:\"))      -- 1|'a'|(2)|(c:)
i5 = .pipeIndex~create("tag5", i4, .file~new("c:\"))      -- 1|'a'|(2)|(c:)|(c:)
say i5~makeString(.true)                                  -- tag1[1]|tag2['a']|tag3[(2)]|tag4[(c:)]|tag5[(c:)]
say i5~makeString(.false, .true)                          -- 1|'a'|(2)|i1=(c:)|i1

.console :
- By default, the tags of the pipe indexes are not displayed by .console.
  Use the option 'showTags' to see them.
- .console always use showPool=.true.
- By default, .console writes a newline at the end of the text.
  If the last expression is an empty string "" then no newline is written.


===============================================================================
2011 sep 04

[pipes]

Standardization of doers usage :
    try first ~functionDoer,
    then ~actionDoer (if candidate),
    then ~doer.
The goal is to accept traditional routines or methods everywhere a functionDoer is
accepted. Currently, only RexxContextualSourceDoer has the methods ~functionDoer
and ~actionDoer.
Ex :
.sort myRoutine
where myRoutine is a routine which returns a result that is used as key for sorting.
Before, only .sort {my source literal} was accepted.

The .system pipeStage now manages a private queue for each execution of command.

The .inject pipeStage now accepts the options 'before' and 'after'.
When using 'before', the new values generated from the current value by .inject
are written to the pipe before writing the current value :
    new_values value.
When using 'after', the new values generated from the current value by .inject
are written to the pipe after writing the current value :
    value new_values.
You can specify both 'before' and 'after'. In this case, you will have the sequence
    value new_values value
The option 'append' has been removed, since equivalent to 'after'.
The option 'replace' has been removed, because useless (just don't use 'before'
and 'after' to get the same effect).


[source literal]
Fixed a crash in relation with line adjustment.


===============================================================================
2011 aug 21

Refinement of tokens 'subclass' attribute (for analysis) :
The scanner splits a source file in clauses, and decompose each clause in tokens.
Then the parser creates an AST from the tokens.
The tokens were not annotated by the parser to attach semantic information found
during parsing. After a discussion with Rony about syntax coloring, I decided to
see which informations could be added to the tokens. I found that the attribute
'subclass' of the tokens could hold informations like that :
IS_KEYWORD
IS_SUBKEY
IS_DIRECTIVE
IS_SUBDIRECTIVE
IS_CONDITION
IS_BUILTIN
There is no impact on the interpreter, as far as I can tell... Except maybe the
tokenized files ? did not check.

For the moment, there is no access to the clauses/tokens from an ooRexx script.
If the environment variable RXTRACE_PARSING=ON then the clauses and tokens are
dumped to the debug output (Windows) or the log (Unix) using dbgprintf.
See samples/parsing for an example of dump.

Interesting to watch :
http://ibm-netrexx.215625.n3.nabble.com/NetRexx-Eclipse-status-video-td3271843.html


===============================================================================
2011 aug 16

Fixed a crash in relation with source literals and GC.
Two problems :
1) Forgot to replace RexxDirectory by RexxList when disabling the optimization
for source literals (was a copy-paste of optimization done for string literals).
2) The constructor RexxSourceLiteral::RexxSourceLiteral can trigger a GC. Must protect
'this'.


Remember1:
----------
When the crash occurs during GC (ex : in ObjectHeader::isObjectMarked), it's possible
to see which ooRexx object is corrupted. Here the object is 0x7eeff200
 	rexx.dll!ObjectHeader::isObjectMarked(unsigned int mark)  Line 106 + 0xa bytes	C++
 	rexx.dll!RexxInternalObject::isObjectMarked(unsigned int markword)  Line 247 + 0x16 bytes	C++
 	rexx.dll!RexxListTable::live(unsigned int liveMark)  Line 55 + 0x26 bytes	C++
>	rexx.dll!RexxMemory::markObjectsMain(RexxObject * rootObject)  Line 374	C++                 <-- markObject = 0x7eeff200 {size=2129676696 elements=0x7eeff214 }  RexxListTable with OVERWRITTEN size !!!
 	rexx.dll!RexxMemory::markObjects()  Line 645	C++
 	rexx.dll!RexxMemory::collect()  Line 1022	C++

A conditional break "newObj == 0x7eeff200" on the last line of RexxMemory::newObject (RexxMemory.cpp)
lets stop the execution when the object is created. If too long, then modify the source :
    if (newObj == (RexxObject*)0x7eeff200)
    {
        int dummy=0;    //  <-- put breakpoint here
    }
    return newObj;
Once the interpreter is stopped here, it's relatively easy to do a code review of the methods
in the call stack, to check if an intermediate object must be protected.

If needed, a data breakpoint can be set on the part of memory which is overwritten
(here the 'size' attribute). In my case, was triggered when the object was inserted
in the list of dead objects.


Remember2:
----------
Occurences of new_directory, not protected (no crash so far, except for createConditionObject) :
DirectoryClass.cpp, RexxDirectory::newRexx (05/03/2012 : done when fixing OREF_INIT)
ExceptionClass.cpp, ExceptionClass::getCondition (05/03/2012 : done)
RexxActivation.cpp, RexxActivation::raise  : here, the conditionObj is passed by argument.
                                             BUT there is one case where conditionObj is created. To protect !
    called by RexxActivation::raiseExit --> the directory conditionobj is passed by argument, no need of protect here.
        called by RexxInstructionRaise::execute --> the directory conditionobj is created here, seems ok because comes from context->getConditionObj()
                                                    [06/03/2012] Got a GC crash where RexxInstructionRaise::execute is in the call stack...
                                                                 After a new review, I think that following variables must be protected : _result, _additional
    called by RexxInstructionRaise::execute --> the directory is created here, seems ok because comes from context->getConditionObj().
RexxActivity.cpp, RexxActivity::createConditionObject (fixed in sandbox)

Other potential problems. A fresh created object is not protected, and some calls are made that could trigger GC.
RexxBehaviour.cpp, RexxBehaviour::copy : newBehaviour is not protected. (05/03/2012 : done)
RexxBehaviour.cpp, RexxBehaviour::addScope : this->scopes->allAt(TheNilObject) creates an object which is not protected. (05/03/2012 : added to this->scopes, so seems protected)
RexxCollection.cpp, RexxHashTableCollection::copy : newObj is not protected.
    Should be protected only if ActivityManager::currentActivity != NULL, otherwise crash in implementation of ProtectedObject's methods
    (RexxHashTableCollection::copy is called during interpreter initialization, and at this time, ActivityManager::currentActivity == NULL).
ArrayClass.cpp, RexxArray::copy : newArray is not protected.
ClassClass.cpp, RexxClass::defineMethod : method_name and method_object are not protected.
ClassClass.cpp, RexxClass::methodDictionaryCreate : method_name is not protected.
DirectoryClass.cpp, RexxDirectory::copy : newObj is not protected.
ListClass.cpp, RexxList::copy : newList is not protected.
ObjectClass.cpp, RexxObject::copy : newObj is not protected.
ObjectClass.cpp, RexxObject::defMethod : msgname and methcopy are not protected.
InstructionParser.cpp, RexxSource::signalNew : newObject is not protected.
SourceFile.cpp, RexxSource::translateBlock : _instruction is not protected.


===============================================================================
2011 aug 14

[doers]

Modified functionDoer : Try first the source as-is, and in case of error try
the 'clause transformed to expression'.
Before this change :
    say {if .true then 2}~functionDoer~do
    -- display : "IF 1 THEN 2"
    -- because the clause has been transformed to an expression.
    say {if .true then 2}~functionDoer~source~tostring
    -- display :
    -- options "NOCOMMANDS" ; ( if .true then 2 )
    --  ; if var("result") then return result
Now :
    say {if .true then 2}~functionDoer~do
    -- display : "2"
    -- because the clause remains as-is :
    -- options "NOCOMMANDS" ; if .true then 2
    --  ; if var("result") then return result


[pipes]

New pipeStages :
.superClasses    : equivalent to .inject {value~superClasses}
.subClasses      : equivalent to .inject {value~subClasses}
.methods         : equivalent to .inject {value~methods}
.instanceMethods : equivalent to .inject {value~instanceMethods}
.system          : to execute a system command and get the contents of its stdout line by line

The index created by .inject is now a pair (value, resultIndex) where
- value is the processed value.
- resultIndex is the index of the current result calculated with value.
When doing recursive calculations and using the pushIndex option, the index
is like a call stack with intermediate results : you get one pair
(value, resultIndex) for each level of recursion.
Ex :
.stream~pipe(.superclasses recursive pushIndex | .console)
1|The Stream class|1 : The InputOutputStream class
1|The Stream class|1|The InputOutputStream class|1 : The Object class
1|The Stream class|1|The InputOutputStream class|2 : The InputStream class
1|The Stream class|1|The InputOutputStream class|2|The InputStream class|1 : The Object class
1|The Stream class|1|The InputOutputStream class|3 : The OutputStream class
1|The Stream class|1|The InputOutputStream class|3|The OutputStream class|1 : The Object class

New option 'unique' added to .inject.
When used, a value that has been already processed will not be processed again.
No need of having sorted values, a list of all previously processed values is kept.
This option is different from 'cycles' which lets stop infinite recursion (use
also a list, but the list is limited to the call stack).
Ex :
.stream~pipe(.superclasses recursive pushIndex unique | .console)
1|The Stream class|1 : The InputOutputStream class
1|The Stream class|1|The InputOutputStream class|1 : The Object class
1|The Stream class|1|The InputOutputStream class|2 : The InputStream class
1|The Stream class|1|The InputOutputStream class|3 : The OutputStream class


===============================================================================
2011 aug 14

Fixed a crash that occured after GC : in RexxActivity::createConditionObject),
the value returned by new_directory() must be protected.


[source literal]

Fixed a crash which occurred when running
    interpret "{"
where interpret is on line 2 or above.

I need a line adjustment (similar to what's done for interpret) for error reporting.
- The line adjustment is made only in case of immediate parsing.
- The current name 'interpret_adjust' is not adapted to source literals...
  Renamed 'line_adjust'.
- Same remark for RexxSource::interpretLine, renamed RexxSource::adjustLine.
- To support this line adjustment for source literals, I had to deactivate this
  optimization :
      case TOKEN_SOURCE_LITERAL:
          retriever = this->sourceLiterals->fastAt(name);
  Was a copy-paste of the optimization done for the string literals.
  Using this optimization, when the same source literal was used at different places
  in the package's source, only one instance of RexxSourceLiteral was created, and so
  only one routine object was created.
  Not sure it was a useful optimization for source literals.


===============================================================================
2011 july 31

[doers]

ClauseSupplier renamed Clauser because it does not follow the semantics of a supplier.
New implementation which is derived from the ooRexx scanner : the comments and
continuations are correctly supported.
The multiline clauses are flattened to get only monoline clauses (more easy to transform).

New kind of doers : coactivity

The tag can be abbreviated like that :
    ::m[ethod]
    ::c[oactivity]
    :[:routine]
    : (defaults to routine)

Exemple :
    doer = {::coactivity
            say "hello" arg(1)
            arg = .yield[]
            say "good bye" arg[1]
           }~doer
    say doer~class -- The Coactivity class
    doer~do("John") -- hello John
    doer~do("Kathie") -- good bye Kathie
    doer~do("Keith") -- <nothing done, the coactivity is ended>

    doer = {::c
            do i=1 to 10000000
                call charout ,"yield["i"] "
                .yield[i]
            end}~doer
    doer~pipe(.take 3 | .console)
    doer~pipe(.take 4 | .console)
    .coactivity~endAll
    ----------
    Output :
    yield[1] 1 : 1
    yield[2] 2 : 2
    yield[3] 3 : 3
    yield[4] 1 : 4
    yield[5] 2 : 5
    yield[6] 3 : 6
    yield[7] 4 : 7


[functional]

Make use of functionDoer to emulate pure expressions, but the current emulation shows its limits.
    arg(1) * 2 --> Incorrect PARSE template detected at "*"
If I change the expression to :
    2 * arg(1)
then it's ok.
That gave me the idea to modify functionDoer to surround the first clause other than "expose" and
"use [strict] arg" by round brackets. An error is raised if a clause other than "return" is found
after the surrounded clause. So the pattern is :
    [expose some variables]
    * point of insertion of clauseBefore
    [use [strict] arg some arguments]
    [a clause candidate to expression] --> if present then will be surrounded by round brackets
    [return something]
    * point of insertion of clauseAfter
In case of syntax error, the so-called 'clause candidate to expression' is used as-is.
Will see on usage if that works effectively...


===============================================================================
2011 july 31

The parsing of a source literal is now immediate when the first character is not ':'.
A routine is created and attached to the source literal.
This routine is accessible using the method RexxContextualSource~executable.
    routine = {say arg(1)+1}~executable
    routine~call(99) -- 100
[Updated 2011 dec 08] Next method has been removed, because now it's possible to
use directly ~do.
For convenience, this routine is callable using the method RexxContextualSource~call.
    {say arg(1)+1}~call(99) -- 100
    say {return arg(1)+1}~call(99) -- 100

A source literal starting with ':' is not parsed immediately (deferred parsing).
In this case, no routine is attached to the source literal.
    {:say arg(1)+1}~executable -- .nil
    [Updated 2011 dec 08] ~call has been removed
    {:say arg(1)+1}~call(99) -- Error : Incorrect call to routine
Such a source literal can be handled by the package extensions.cls :
    {:say arg(1)+1}~doer~do(99) -- 100
    [Updated 2011 dec 08] it's possible to use directly ~do
    {:say arg(1)+1}~do(99) -- 100
    ::requires "extension/extensions.cls"


===============================================================================
2011 july 25

[pipe]
.displayer renamed .console, to be closer to CMS pipeline.


[pipe extensions]
Refactoring of makeFunctionDoer and makeActionDoer : now implemented in doers.cls
as methods functionDoer and actionDoer on RexxContextualSource.


[doers]
New class ClauseSupplier which lets iterate over the clauses of a source and replace
a clause by a new clause.

New method sourceDoer which lets transform the source before creating a doer from it.
This method is used by functionDoer and actionDoer .
Ex :
    {if value==0 then "infinity" ; else 1/value}~functionDoer("use arg value")
returns a routine built using this transformed source
    {use arg value                            -- optional source fragment passed as parameter to functionDoer
     option "NOCOMMANDS"                      -- added by functionDoer : expressions are not commands in functions
     if value==0 then "infinity" else 1/value -- original source literal, unchanged
     if var("result") then return result}     -- added by functionDoer : returns the result of the last evaluated expression


===============================================================================
2011 july 21

[expression evaluation]
Added an option to control execution of commands :
    ::options COMMANDS
    ::options NOCOMMANDS
    options "COMMANDS"
    options "NOCOMMANDS"
By default, a clause consisting of an expression only is interpreted as a command string.
When using the option NOCOMMANDS, the value of the expression is stored in the
variable RESULT, and not interpreted as a command string.


[source literal]
Removed method RexxSourceLiteral::setSource
Removed method RexxContextualSource::setSource
Removed method RexxContextualSource~"source="
This assignment of source is not needed, and moreover was buggy (overwriting directly
the literal source in the directory of literals).


[source literal]
Now RexxSourceLiteral::getSource returns an array of strings, no longer a monoline string.
The monoline string was buggy, because continuation characters were not supported correctly.
And that's how the sources are managed everywhere else.


[source literal]
To investigate...
When a routine or method is created, a new RexxSource is created. So all the settings
defined on the package level (i.e. RexxSource) have the default values.
It's possible to pass a context from which a RexxSource is taken (called parentSource)
which allows the created routine/method to inherit class and routine lookup scope from
another source. Nothing else is inherited.
    [inherited from context]
        routines
        merged_public_routines
        installed_classes
        merged_public_classes
    [currently never inherited from context]
        digits
        fuzz
        form
        trace
        enableCommands
See RoutineClass::newRoutineObject and RexxMethod::newMethodObject, there is a call to
getSourceObject()->inheritSourceContext(parentSource).
This chained context is managed in the following methods :
    RexxSource::findLocalRoutine   (search in routines)
    RexxSource::findPublicRoutine  (search in merged_public_routines)
    RexxSource::findInstalledClass (search in installed_classes)
    RexxSource::findPublicClass    (search in merged_public_classes)
A source literal is somewhat special, because it's supposed to have all the settings of
the package in which it's defined (well, I suppose...). So, should find a way to
initialize the RexxSource of the source literal with the settings of the package.
Then, I have the same need for the settings of the RexxActivation in which the executable
created from the RexxContextualSource will run. I think that the closure will be the right
place to manage that, since the closure is a snapshot of the RexxActivation in which the
RexxContextualSource is created.


===============================================================================
2011 july 11

More work on pipe.

.inject : the detection of cycles has a runtime cost. This detection is no longer
active by default, must pass the option "cycles" to activate it.


.inject : it's now possible to replace completely the current index by a new index,
using .index_value or .value_index.
.array~of(10,20,30)~pipe(.displayer)
1 : 10
2 : 20
3 : 30
.array~of(10,20,30)~pipe(.inject {.index_value[value, 2*value]} | .displayer)
10 : 20
20 : 40
30 : 60


.inject : with option 'pushIndex', it's now possible to pass an array of indexes.
.array~of(10,20,30)~pipe(.inject {
    .index_value[ .array~of(value-1, value+1), 2*value ]
    } push | .displayer)
1|9|11 : 20
2|19|21 : 40
3|29|31 : 60


Made .do a subclass of .inject, because I realized that .do is really like .inject,
except for the execution of commands : with .do, you can execute address commands,
with .inject, it's not allowed.


.take : added support for partition expression, to take the specified number of
elements in the partition. When the partition key changes, the counter is reset.
.array~of(1,1,1,2,2,2,2,3,3,3,3,3,1,1,1)~pipe(.take 2 {value} | .displayer)
1 : 1
2 : 1
4 : 2
5 : 2
8 : 3
9 : 3
13 : 1
14 : 1


Added profiling of pipeline :
.array~of(b, a, c)~pipeProfile(.sort byValue | .displayer)
2 : A
1 : B
3 : C
----------------------------------------
.SORT~go
  .SORT~EOF count=1 duration=0
    .DISPLAYER~EOF count=1 duration=0
    .DISPLAYER~ISEOP count=6 duration=0
    .DISPLAYER~PROCESS count=3 duration=0
  .SORT~ISEOP count=3 duration=0
  .SORT~PROCESS count=3 duration=0
  .SORT~START count=1 duration=0
    .DISPLAYER~START count=1 duration=0
duration=0
----------------------------------------
The pipeline's methods to profile must be instrumented.
    ::method myMethod
    my code here...

    is instrumented to become :

    ::method myMethod protected        <-- will be intercepted
    forward message("myMethod_unprotected")

    ::method myMethod_unprotected      <-- the security manager will forward this message
    my code here...
The profiling has an impact on the performances, but the durations should keep their
proportions.


===============================================================================
2011 july 06

Adapted the package doers.cls to source literals.
The class String is no longer used to hold routine's source or method's source.
Now RexxContextualSource is used for that.
    doer = {use arg name; say "hello" name}~doer
    say doer~class -- The Routine class
    doer~do("John") -- hello John

    doer = {::method say "hello" self}~doer
    say doer~class -- The Method class
    doer~do("John") -- hello John
Strings are still used for doers of type Message.
    doer = "length"~doer
    say doer~class -- The String class
    say doer~do("John") -- 4


Adapted the samples in extension, concurrency, pipeline :
- No longer need to call Doers.AddVisibilityFrom(.context).
- Source fragments are no longer strings, but source literals.
- Use abbreviated syntax when passing source literals


===============================================================================
2011 july 06

When a source literal was evaluated by an interpret instruction, the package associated
to the RexxContextualSource (at parse time) was not holding the right informations
for class & routine lookup scope.
Symptom (assuming .myclass is visible from the current package, thanks to a ::requires) :
    {say .myclass}~doer~do             --> display The MYCLASS class (good)
    interpret "{say .myclass}~doer~do" --> display .MYCLASS          (not good)
Fixed by using the package associated to the RexxActivation in which the interpret is parsed.


I get "Error 49:  Interpretation error" when running
    rexx -e "v={}"
This is because SourceLiteral is currently a transient class, and I reach this code
in RexxEnvelope.cpp :
        // transient classes should never be flattened.  This is a problem if we encounter one
        if (newObj->behaviour->isTransientClass())
        {
            reportException(Error_Interpretation);
        }
Fixed by making the class SourceLiteral an internal class.


Added support for abbreviated syntax of arguments list (similar to Groovy syntax for closures) :
    f{...} is equivalent to f({...})
    f(a1,a2,...){...} is equivalent to f(a1,a2,...,{...})
Example :
    10~times{call charout , arg(1)}  -- 12345678910
    4~upto(7){call charout , arg(1)} -- 4567

New method on class RexxContextualSource :
::method "source=" -- lets assign an updated source, while keeping all the contextual infos.
I need that for the pipe stages which accept source literals used as expression.
.select {value~isPrivate} --> the source of the RexxContextualSource is transformed to :
"use arg value, index; return value~isPrivate"
See makeFunctionDoer in pipeline/pipe_extension.cls.


===============================================================================
2011 june 27

Added support for source literals.
Currently, a source literal is surrounded by curly braces, which is probably heretical,
but my main focus is not on the syntax.
My needs :
- I need to make a distinction between a "real" string and a source literal.
  (will be useful for the pipeStage .Displayer)
- I need the context of the source literal's definer. Thay way, I no longer need to call
  Doers.AddVisibilityFrom.
- I need sometimes to transform the source (see pipelines : add arguments, add return),
  so must not be parsed too early because the initial source is not always valid ooRexx.
  I prefer to have the source as a single string, instead of an array of lines.
  (this transformation of source must be reworked, because current implementation is not
  very robust, especially for the insertion of return).
- I want to keep the current functionalities of doers. The source literal is passed
  as argument to .Method~new or .Routine~new, or used as a message when containing
  only one word.
In the current implementation, a source literal is a multiline string whose scanning is
aware of the ooRexx tokens. Curly braces in comments or in string are properly supported.
For the parser, a source literal is a token, which is translated to a RexxSourceLiteral
(transient class). When evaluated, a RexxSourceLiteral returns a RexxContextualSource
(exported class).

New class available from an ooRexx script :
::class RexxContextualSource
::method package -- the package where the source literal is defined.
::method context -- the context of the execution environment from which the source literal was evaluated.
::method source -- the text inside the curly braces, where '\n' has been replaced by ';'

Example of use :
The source literal can be assigned to a variable and passed as argument to a routine.

-- package1.rex
function = {use arg n
            return doubler(n)}
do v over map(.array~of(1,2,3,4), function)
    say v
end
::routine doubler
return 2*arg(1)
::requires package2.rex

-- package2.rex
::routine map public
use strict arg array, contextualSource
say contextualSource~source
-- parse only once, before iteration
routine = .routine~new("", contextualSource~source, contextualSource~package)
value = .array~new(array~items)
do v over array
    value~append(routine~call(v)) -- 'doubler', which is defined in package1, is visible
end
return value

Output :
use arg n;            return doubler(n)
2
4
6
8


===============================================================================
2011 june 25

More work on pipe.

.inject : added options 'append', 'pushIndex'.
The option 'recursive' has two new sub-options : 'depthFirst', 'breadthFirst'.

.fileTree : new pipeStage
Get the childrens (files or directories) of a file instance.

.fileText : new pipeStage
Get the contents of a text file line by line.

.words : new pipeStage
Get the words of the current value.

.characters : new pipeStage
Get the characters of the current value.


===============================================================================
2011 june 20

More work on pipe.

.sort : the doers are parsed as soon as possible (during initOptions)

.all, .startsWith, .notall, .between, .after, .before : added option 'caseLess'

.displayer : added options 'index', 'value', 'space', newline', expression

Added support for end of process (EOP). The idea comes from
CMS Pipeline Telecourse (http://www.vm.ibm.com/download/packages/descript.cgi?TCVM2)
<<
pipe < big file a | take 5 | console
The TAKE stage take the first 5 records passing through the pipe (in this case
coming from the disk-read stage). After having seen 5 records go by, the TAKE stage
tells the PIPE dispatcher "I've done my job, I don't need anything more...", and the
dispatcher in turn informs the previous stage that there isn't anybody listening
anymore to its output, so it can stop also.
So, a pipeline can suddenly collapse when one stage decides to stop
>>
There is no dispatcher in current implementation, but the idea of end of process is
very interesting. In particular with infinite coactivities :
.coactivity~new("i=0; do forever; i+=1; .yield[i]; end")~pipe(.take 5 | .displayer)
Also interesting with big files, when only the n first lines must be processed...

.drop : replace both .dropFirst and .dropLast

.take : replace both .takeFirst and .takeLast

.append : new pipeStage
Copy items from its primary input to its primary output, and then invoke the supplier
passed as argument and write the items produced by that supplier to its primary output.


===============================================================================
2011 june 13

More work on pipe.

.sort : refactoring of the internal helpers.
Now a single indexedValueComparator handles all the kinds of comparisons
(by value, by index, by expression).

.sort : added option 'strict'

.sort : can sort on several criteria.
The order in which the options are passed is the order in which they are executed.
A 'value' or 'index' or expression option is impacted only by the preceding options.

.inject : a limit can be specified with option recursive : recursive.10


===============================================================================
2011 june 09

More work on pipe.rex.

Added support to pass options to a pipeStage (use the blank operator) :
    .myStage[arg1, arg2, ...] option1 option2 ...

.sort : added options byValue, byIndex, ascending, descending, caseless, quickSort.

.sortWith : added option quickSort.

.inject : added option recursive.
In case of infinite recursion, the recursion is stopped. This is detected
by keeping a stack of items already processed.


===============================================================================
2011 june 09

The alternate syntax [] for pipeStage gave me the idea to do the same for the yield
method of the coactivity class.
    .yield[value]
    is equivalent to (and more compact than)
    .Coactivity~yield(value)
Remember : the blank operator would be still more compact,
    .yield value
but unfortunately a result is mandatory (an operator is not a message instruction),
and that triggers a command if the result is not used... So forget this syntax.


Side note : I start to find this triggering of commands seriously annoying !
Too easy to trigger a command accidentaly. Yes, I could use a security manager, but
would be tedious to put it *everywhere*.
To investigate : a message instruction can trigger a command only if surrounded by ().
Not possible to apply this rule all the time, including expressions ?
rm "*".lst --> the string "rm *.lst" would be assigned to the variable RESULT.
(rm "*".lst) --> the string "rm *.lst" would be submitted as a command to the external environment.
That way, the programmer controls explicitely where a command can be triggered.
Code review :
    SourceFile.cpp
        RexxSource::instruction
            this->messageNew
                RexxSource::messageNew
                    new RexxInstructionMessage
            this->commandNew
                RexxSource::commandNew
                    _expression = this->expression(TERM_EOC)
                        RexxSource::expression
                            this->subExpression(terminators)
                    new RexxInstructionCommand
    InstructionParser.cpp
        RexxInstructionCommand
        RexxSource::commandNew
            expression = this->expression(TERM_EOC)
    MessageInstruction.cpp
        RexxInstructionMessage::execute (assign the RESULT variable)
    CommandInstruction.cpp
        RexxInstructionCommand::execute
            RexxObject *result = this->expression->evaluate(context, stack);
                ***HERE*** could decide to assign result to RESULT instead of triggering command
            RexxString *command = REQUEST_STRING(result);    /* force to string form              */
            context->command(context->getAddress(), command);


Side note :
A message term can have one of the following forms :
    receiver~messagename:symbol(expression, ...)
    receiver~~messagename:symbol(expression, ...)
    receiver[expression, ...]
The receiver is a term.
Would it make sense to add that ?
    receiver(expression, ...)
Probably not, according to my tests :
    .c~"()"    -- the method "()" is called
    .c()       -- could not find routine ".C"
    ::class c
    ::method "()" class
A function call is a term in an expression calling a routine.
    function_name(expression, ...)
The function_name is a literal string or a single symbol, which is taken to be a constant.
So no way to have something similar to the C++ operator().


===============================================================================
2011 may 29

Modified pipe.rex to keep the index information of the collection passed as argument to ~go.
Useful when working with a collection of methods, where the name of the methods is available
only through the indexes.

Added the extension ~pipe to all objects.
myObject~pipe(myPipeline)

Added extensions to pipe.rex, to benefit from doers :
inject
do
select

Added the extension ~each to all the collections.

Added the extensions ~each and ~reduce to the suppliers.

Fixed a bug in rgf_util2 :
dump2 was not working with suppliers, because ~items was called.

Concurrency trace : report information about ovd, even if not yet assigned to the RexxActivation.
See getReserveCount and getVariableDictionary in RexxActivation.hpp.

Debug of semaphores : the variable name was overwritten, fixed.


===============================================================================
2011 may 29

Adaptation of concurrency trace to support 64 bits pointers.

Now, concurrency trace is displayed only when env variable RXTRACE_CONCURRENCY=ON

The debug messages for semaphores and mutexes are very costly : about 400 times
slower than main/trunk... Now, those messages are controlled by conditional
compilation, and activated only in debug configuration.

Slow learning curve of xcode4 under MacOsX, experimentation of several configurations :
gcc/debug
    $oorexx_src_dir/configure --prefix=$oorexx_delivery CFLAGS="-g -O0 -D_DEBUG" CXXFLAGS="-g -O0 -D_DEBUG"
gcc/default :
    $oorexx_src_dir/configure --prefix=$oorexx_delivery
gcc/release
    $oorexx_src_dir/configure --prefix=$oorexx_delivery CFLAGS="-g -O3" CXXFLAGS="-g -O3"
Currently using gcc only, but plan to test llvmgcc.
Each configuration is initialized by running a shell script located in the appropriate delivery folder.
If debug from xcode4 is needed, then must launch xcode4 from the config's shell : open -a xcode4
The directory layout is like that :
oorexx
    build
        main
            releases
                4.1.0
                    trunk
                        gcc
                            default : run configure here
            trunk
                gcc
                    default : run configure here
        sandbox
            jlf
                trunk
                    gcc
                        debug : run configure here
                        default : run configure here
                        release : run configure here
    delivery
        main
            releases
                4.1.0
                    trunk
                        gcc
                            default : setenv.sh to declare config variables
            trunk
                gcc
                    default : setenv.sh to declare config variables
        sandbox
            jlf
                trunk
                    gcc
                        debug : setenv.sh to declare config variables
                        default : setenv.sh to declare config variables
                        release : setenv.sh to declare config variables
    svn
        main
            trunk
        sandbox
            jlf
                trunk

===============================================================================
2011 mar 18

Added an early traceEntry for proper diagnostic in case of deadlock of guarded method.
See test cases in samples/concurrency :
deadlock1.rex
deadlock2.rex

Fixed in RexxActivation::run


===============================================================================
2011 mar 17

I have a small problem with doers :
Any routine/method created by StringDoer will have a lookup scope limited to the
doers package, because the routines/methods are created from the doers package,
not from the caller's package.
StringDoer~doer accepts a context parameter to let the caller pass its own lookup scope,
but this is tedious to pass it explicitely at each call.
Example from oorexxshell :
say .color                     -- The COLOR class
"say .color"~doer~do           -- .COLOR because the COLOR class is not visible from doers
"say .color"~doer(.context)~do -- The COLOR class

I provide the convenience routine "Doers.AddVisibilityFrom" which lets see from doers
the same packages/methods/routines as the caller.
Usage from caller's package :
call Doers.AddVisibilityFrom(.context)
::requires "extension/doers.cls"
With this sequence, no need to pass explicitely the .Context when creating a doer :
"say .color"~doer~do           -- The COLOR class

This problem would not exist if we had support for first-class expressions/instructions
that are parsed in place, instead of being parsed by StringDoer.
https://sourceforge.net/mailarchive/message.php?msg_id=19911593
https://sourceforge.net/mailarchive/message.php?msg_id=19912031
The proposed syntax [expr] lets defer the evaluation of expr, but is not supposed to
support instructions (why not ?).
Maybe
    c = .Coactivity~new("do i = 1 to 10 ; .Coactivity~yield(i) ; end")
could become
    c = .Coactivity~new([do i = 1 to 10 ; .Coactivity~yield(i) ; end])
In this case, the context is the "good" context, i.e. the context of the place from where
the block is parsed. The distinction expression/instructions is similar to the distinction
eval/apply in Lisp : You evaluate an expression, you apply a method/routine to a list of
arguments.


===============================================================================
2011 mar 17

m17n :
Don't use strong types by default, because gcc can't compile as-is.
Fixed compilation errors under Linux.


===============================================================================
2011 mar 16

I learned recently that ooRexx manages nested guard conditions...
So, I added new informations in the trace output :
- variable dictionary id (3rd column)
- nesting counter (4th column)

Raw trace, generated by rexx :
00004fec 7efc0fb0 7efc10f0 00001*     79 *-* if start
00004fec 7efc0fb0 7efc10f0 00001*        >V>   START => "1"
00004fec 7efc0fb0 7efc10f0 00001*        >>>   "1"
00004fec 7efc0fb0 7efc10f0 00001*     79 *-*   then
00004fec 7efc0fb0 7efc10f0 00001*     79 *-*     self~start
00004fec 7efc0fb0 7efc10f0 00001*        >V>       SELF => "a Coactivity"
00004fec 7efc9918 7efc10f0 00002*        >I> Method START with scope "The Coactivity class" in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\concurrency\coactivity.cls
...
00004fec 7efc9918 7efc10f0 00002*     93 *-* reply self
00004fec 7efc9918 7efc10f0 00002*        >V>   SELF => "a Coactivity"
00004fec 7efc9918 7efc10f0 00002*        >>>   "a Coactivity"
00004fec 7efc0fb0 7efc10f0 00001*        >>>       "a Coactivity"
00004fec 7eee9be8 00000000 00000         >M>   "NEW" => "a Coactivity"
0000478c 7efc9918 7efc10f0 00001*        >I> Method START with scope "The Coactivity class" in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\concurrency\coactivity.cls
00004fec 7eee9be8 00000000 00000         >>>   "a Coactivity"
0000478c 7efc9918 7efc10f0 00001*     94 *-* .Activity~local~empty


Human readable trace, generated by rexx trace/tracer using raw trace as input :
T1   A4     V2      1*     79 *-* if start
T1   A4     V2      1*        >V>   START => "1"
T1   A4     V2      1*        >>>   "1"
T1   A4     V2      1*     79 *-*   then
T1   A4     V2      1*     79 *-*     self~start
T1   A4     V2      1*        >V>       SELF => "a Coactivity"
T1   A5     V2      2*        >I> Method START with scope "The Coactivity class" in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\concurrency\coactivity.cls
...
T1   A5     V2      2*     93 *-* reply self
T1   A5     V2      2*        >V>   SELF => "a Coactivity"
T1   A5     V2      2*        >>>   "a Coactivity"
T1   A4     V2      1*        >>>       "a Coactivity"
T1   A3                       >M>   "NEW" => "a Coactivity"
T2   A5     V2      1*        >I> Method START with scope "The Coactivity class" in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\concurrency\coactivity.cls
T1   A3                       >>>   "a Coactivity"
T2   A5     V2      1*     94 *-* .Activity~local~empty


===============================================================================
2011 mar 10

Implemented an emulation of coroutine, named "coactivity" to follow the ooRexx
vocabulary. This is not a "real" coroutine implementation, because it's based on
ooRexx threads and synchronization. But at least you have all the functionalities
of a stackful asymmetric coroutine (resume + yield). All is in place to support
symmetric coroutines (yield only), but the scheduler remains to implement.

For a better support of coactivity, I'm thinking to modify the interpreter :
Arguments can be passed by the consumer when he resumes a coactivity.
For the first resume, the traditional arguments declaration can be used on the producer side.
But for the following resumes, it's less declarative : you get only an array returned by yield.
I'd like to use the traditional arguments declaration everywhere...
    consumer : res = coactivity~resume(arg1, arg2)
               res = coactivity~resume(arg1, arg2)
               ...
    producer : use strict arg arg1, arg2
               res = f(arg1, arg2)...
               args = coactivity~yield(res) --> returns an array of arguments
               use strict arg arg1, arg2   --> but this array of arguments can't be read that way
               ...

For an example of coroutine implementation for the HotSpot JVM, see :
http://ssw.jku.at/Research/Papers/Stadler11Master
I found the reading interesting because :
- Java, like ooRexx, has synchronized threads.
- Java, like ooRexx, doesn't support real coroutines.
- With the proposed implementation for JVM, operations on coroutines implicitly always
  operate on the current thread. This allows the system to assume that only a minimal amount
  of synchronization is necessary.


===============================================================================
2011 mar 10

For all scripts under jlf/sandbox/samples, use path relative to samples in requires,
assuming the path to samples will be in the PATH.


Refactoring of extension :
- Separation between code for standard ooRexx (in subdirectory std), and sandbox.
- Removed factory.rex : can be replaced by ~enhanced
- When ~enhanced can't be used then use delegation

Current pattern for standard ooRexx, to extend a predefined class, assuming that
the name of the predefined class is "ClassName", and the name of the extension
is "Extension" (no need of that with ::extension) :

::class ClassNameExtension mixinclass Object public

::method init
    expose className -- optional : an encapsulated instance of the predefined class
    use arg className=.nil

::method myMethod
    expose className
    if var("className"), className <> .nil then self = className -- delegates to the encapsulated instance
    -- here your extension code which depends on self

::class ExtendedClassName subclass ClassName public inherit ClassNameExtension1 ClassNameExtension2 ...

The level of integration brougth by extension/std is poor compared to the integration with ::extension !
Most of the time, you will create instances of your extended class.
Ex : .ExtendedString~new("say 2*arg(1)")~doer~do(10) -- display 20
But sometimes, you must work with instances returned by the interpreter, and you can't create an instance
of your extended class. In this case, you create an instance of your extension mixin which encapsulates the
instance returned by the interpreter.
Ex : routine = .context~package~findRoutine("multiply_by_2")
     doer = .RoutineDoer~new(routine)
     doer~do(10) -- display 20

     ::routine multiply_by_2
     say 2*arg(1)


===============================================================================
2011 mar 09

Send the trace output to the debug output.
Made the debug output of SysSemaphore and SysMutex compatible with trace output.
Now I get the trace lines and the interpreter locks in the same stream, and I can
parse them with tracer.rex (could be faster, but...).

0001eab4 7eff0af8 *     89 *-* reply self
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.release : before ReleaseMutex(0x1fb4) from ActivityManager::unlockKernel (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.release : after ReleaseMutex(0x1fb4) from ActivityManager::unlockKernel (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.requestImmediate : before WaitForSingleObject(0x1fb4) from ActivityManager::lockKernelImmediate (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.requestImmediate : after WaitForSingleObject(0x1fb4) from ActivityManager::lockKernelImmediate (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.release : before ReleaseMutex(0x1fb4) from ActivityManager::unlockKernel (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.release : after ReleaseMutex(0x1fb4) from ActivityManager::unlockKernel (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.requestImmediate : before WaitForSingleObject(0x1fb4) from ActivityManager::lockKernelImmediate (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.requestImmediate : after WaitForSingleObject(0x1fb4) from ActivityManager::lockKernelImmediate (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.release : before ReleaseMutex(0x1fb4) from ActivityManager::unlockKernel (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.release : after ReleaseMutex(0x1fb4) from ActivityManager::unlockKernel (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.requestImmediate : before WaitForSingleObject(0x1fb4) from ActivityManager::lockKernelImmediate (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.requestImmediate : after WaitForSingleObject(0x1fb4) from ActivityManager::lockKernelImmediate (0x55dec0)
0001eab4 7eff0af8 *        >V>   SELF => "a COACTIVITY"


===============================================================================
2011 feb 27

Implemented the script samples\trace\tracer.rex.
This script lets :
- replace hexadecimal values by more human-readable values like T1, A1.
- generate a CSV file, for further analysis with your favorite tool.

Can be used as a pipe filter (reads from stdin) :
rexx my_traced_script.rex 2>&1 | rexx tracer

or can read from a file :
rexx tracer -csv my_trace_file.txt


===============================================================================
2011 feb 24

Added thread id, activation id and lock flag in the lines printed by trace.
Should help to analyze the traces of a multithreaded script.

Not sure yet to have covered all the cases, since I modified only this method :
RexxActivity::traceOutput
But looks good on my first tests.

The extract below illustrates quite well the problem of interleaved traces.
See after the reply, two threads are running concurrently.

coroutine~start -- guarded
coroutine~resume -- unguarded

0000ccac 7efcae78 *        >I> Method START with scope "The COROUTINE class" in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\generator\coroutine.cls
...<snip>...
0000ccac 7efcae78 *     92 *-* status = .Coroutine~suspended
0000ccac 7efcae78 *        >E>   .COROUTINE => "The COROUTINE class"
0000ccac 7efcae78 *        >M>   "SUSPENDED" => "1"
0000ccac 7efcae78 *        >>>   "1"
0000ccac 7efcae78 *        >=>   STATUS <= "1"
0000ccac 7efcae78 *     93 *-* guard off
0000ccac 7efcae78       94 *-* reply self
0000ccac 7efcae78          >V>   SELF => "a COROUTINE"
0000ccac 7efcae78          >>>   "a COROUTINE"
0000c8dc 7efcae78          >I> Method START with scope "The COROUTINE class" in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\generator\coroutine.cls
0000ccac 7efd0968          >I> Method RESUME with scope "The COROUTINE class" in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\generator\coroutine.cls
0000c8dc 7efcae78       95 *-* signal on any
0000ccac 7efd0968      162 *-* expose status yieldValue
0000c8dc 7efcae78       96 *-* guard on when status <> .Coroutine~suspended
0000ccac 7efd0968      163 *-* if status == .Coroutine~notStarted
0000c8dc 7efcae78 *        >V>   STATUS => "1"
0000ccac 7efd0968          >V>   STATUS => "1"

If you redirect the stderr to a file, and open it with Excel, then you can filter by thread and/or by activation.


===============================================================================
2010 nov 14

I have reached a state where the interpreter is no longer broken by m17n.
The most difficult bugs were because of the default constructor of rxStringSize.
By assigning 0 (a good practice for me), I had nasty bugs in the parser.
Solved by leaving the attribute uninitialized...
Remember :

RexxSource::sayNew
    RexxObject *_expression = this->expression(TERM_EOC);
    RexxInstruction *newObject = new_instruction(SAY, Say);     <-- location is copied from this->clause by RexxSource::sourceNewObject
    new ((void *)newObject) RexxInstructionSay(_expression);    <-- boom ! location is overwritten by default constructor of rxStringSize

inline RexxBuffer *new_buffer(sizeB_t s) { return new (size_v(s)) RexxBuffer; }     <-- bufferSize and dataLength were always 0 !
void *RexxBuffer::operator new(size_t size, size_t _length)
    newBuffer->bufferSize = _length;    <-- initialized here, *before* the execution of default constructor
    newBuffer->dataLength = _length;    <-- same problem


Now, the next step is probably to change the signature of the methods in StringUtil,
to pass a IRexxString parameter, instead of a couple (char*, size_t) which are the
internal attributes stringData and length.


===============================================================================
2010 oct 10

rexx.h
Defined strong types to detect misuse between 'size in bytes' and 'size in chars'.
When changing the sources for m17n, I activate the strong types.
Otherwise I use the weak types.
See rxStringSize.


===============================================================================
2010 sept 24

Started a review of the NetRexx specification, in unicode/_readme.odt.
The goal is to see how the issues reported by Rick are covered by NetRexx.


===============================================================================
2010 sept 20

Fixed the build of m17n under Linux.
Had to rename all the *.c files to *.cpp, because .c source files are not correctly
built by Makefile.am.


Note about Parrot :
The charset/encoding merge has been moved in Parrot's trunk.
I will probably apply this merge.


===============================================================================
2010 sep 05

Found a bug, fixed in sandbox, to fix in trunk.
.mutablebuffer~new('abcdef')~replaceat('XXX', 1, 16)
makes the interpreter crash.


Parrot charset/encoding merge :
http://lists.parrot.org/pipermail/parrot-dev/2010-September/004678.html
I will wait for the move in Parrot's trunk before analysing that.


===============================================================================
2010 aug 28

Added encoding to RexxString (m17n) : I borrowed the Parrot's implementation
(the overall design is kept, but a lot of things has been adapted to ooRexx).

For the moment, I have three sources of inspiration : Parrot, Ruby, Falcon
I choosed Parrot to start, because it uses ICU if available at compile-time.
It's a minimal use, but at least I can put my hands on ICU through a concrete work.
One pointer for charset and one pointer for encoding is probably too much, but this is
how Parrot is implemented... And a third pointer is coming, for NFG.
[2010 aug 25] New, there is an RFC to merge charsets and encodings :
http://lists.parrot.org/pipermail/parrot-dev/2010-August/004633.html

Ruby's m17n is more complete than Parrot's, but seems more difficult to apprehend.
The encoding is stored as a 16 bits index.

Falcon is not like Parrot or Ruby, its internal charset is Unicode only.
I'm interested by its "string polymorphism".
The string manager (ako encoding) is stored as a pointer.

See unicode/_readme.odt for more details.


To build with ICU under Windows :
    set HAVE_ICU=1      <-- assign 0 or put this line in comment if you don't want to build with ICU
    set icu_dir=D:\local\Unicode\ICU\icu4c-4_4_1-Win32-msvc9
    set PATH=%icu_dir%\bin;%PATH%
    set INCLUDE=%icu_dir%\include;%INCLUDE%
    set LIB=%icu_dir%\lib;%LIB%

The environment variable HAVE_ICU is tested in buildorx.bat :
    set ICU_OPTION=
    if defined HAVE_ICU set ICU_OPTION="HAVE_ICU=%HAVE_ICU%"
    NMAKE /F INTERPRETER.MAK %ICU_OPTION%

interpreter.mak :
    !IFNDEF HAVE_ICU
    HAVE_ICU=0
    !ENDIF

    !IF "$(HAVE_ICU)" == "0"
    ICU_OPTIONS=
    !ELSE
    ICU_OPTIONS=/DHAVE_ICU
    !ENDIF


Careful if building from Visual Studio (no problem when building from Cmd shell) :
The INCLUDE environment variable is redefined by Visual Studio, and because of that,
the ICU headers are not found. You must launch Visual Studio like that :
    vcexpress /useenv
See makeorx_verbose.bat for more details to build from Visual Studio.


===============================================================================
2010 july 3

Continue Unicode review : added notes about Falcon.

Adapted ooRexxTry to use utf8 encoding and Arial Unicode MS.
Preloads all the main components (math, ftp, socket, bsf, hostemu, ...).


===============================================================================
2010 july 3

Debug crash in gc
RexxMemory::markObjectsMain
    markObject->live(liveMark);

0x003d2b8c                                          --> this is 0x7eee1ac0->behaviour
Access violation reading location 0x44414550        --> this is the vfptr of the behaviour of a string

((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*markObject))))).__vfptr


RexxMemory::mark(RexxObject *markObject)
    pushLiveStack((RexxObject *)markObject->behaviour);
markObject = 0x7eee1ac0                             --> see below, this is the 30th element of string array
    [RexxString]
               if tmp<2 then         -- start at first char

called by RexxArray::live(size_t liveMark)      ArrayClass.cpp
where this = 0x7f30ed70
this->objects = 7f30ed98
arrayPtr=7f30ee0c
0x7f30ee0c - 0x7f30ed98 = 116 = 29 * 4 --> this is the 30th element

element 1 to 13 : not a string... but doesn't be a problem
+		(*(RexxString*)this->get(14)).stringData	0x7eee36a4 "  len1=length(arg1string)        -- get length of string"	char [4]
+		(*(RexxString*)this->get(15)).stringData	0x7eee3704 "  newArr=.array~new        -- create new array for the arguments"	char [4]
+		(*(RexxString*)this->get(16)).stringData	0x7eee376c "  newArr[1]=new1string     -- "new"-string"	char [4]
+		(*(RexxString*)this->get(18)).stringData	0x7eee37e4 "  prepend=""               -- optional prepend string (if positioning before start!)"	char [4]
+		(*(RexxString*)this->get(20)).stringData	0x7eee388c "  arg2startori=arg2start         -- save passed-in value, if any"	char [4]
+		(*(RexxString*)this->get(21)).stringData	0x7eee38f4 "  if arg4pad=="" then arg4pad=" "-- define blank as the default pad char"	char [4]
+		(*(RexxString*)this->get(23)).stringData	0x7eee398c "  if arg(3,"Exists") then  -- start in "target"-string"	char [4]
+		(*(RexxString*)this->get(24)).stringData	0x7eee2dfc "  do"	char [4]
+		(*(RexxString*)this->get(25)).stringData	0x7eee2e2c "     if datatype(arg2start,"W") then"	char [4]
+		(*(RexxString*)this->get(26)).stringData	0x7eee2e7c "     do"	char [4]
+		(*(RexxString*)this->get(27)).stringData	0x7eee2eac "        if arg2start<0 then      -- negative, start from right"	char [4]
+		(*(RexxString*)this->get(28)).stringData	0x7eee2f14 "        do"	char [4]
+		(*(RexxString*)this->get(29)).stringData	0x7eee2f44 "           tmp=len1+arg2start+1  -- get starting position"	char [4]
+		(*(RexxString*)this->get(30)).stringData	0x7eee1ae4 "           if tmp<2 then         -- start at first char"	char [4]
+		(*(RexxString*)this->get(31)).stringData	0x7eee1b44 "           do"	char [4]
+		(*(RexxString*)this->get(32)).stringData	0x7eee1b7c "              if tmp<0 then"	char [4]

The behaviour of the 30th element is broken :
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(28))))).behaviour)))))).__vfptr	0x003aa62c const RexxBehaviour::`vftable'	*
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(29))))).behaviour)))))).__vfptr	0x003aa62c const RexxBehaviour::`vftable'	*
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(30))))).behaviour)))))).__vfptr	0x44414548	*
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(31))))).behaviour)))))).__vfptr	0x003aa62c const RexxBehaviour::`vftable'	*
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(32))))).behaviour)))))).__vfptr	0x003aa62c const RexxBehaviour::`vftable'	*

the behaviour of 30th element is stored at 0x7eee1acc


called by RexxMemory::markObjectsMain(RexxObject *rootObject)
where rootObject =
+		rootObject	0x003d2a90 class RexxMemory memoryObject {markWord=1 markReason=1 variableCache=0x7f5b55a8 ...}	RexxObject *

called by RexxMemory::markObjects()

called by RexxMemory::collect()

objectclass.hpp
inline void   setBehaviour(RexxBehaviour *b) { behaviour = b; }         <-- this method is called to assign the behavior of type 22 (T_String)
>	rexx.dll!RexxInternalObject::setBehaviour(RexxBehaviour * b)  Line 265 + 0x10 bytes	C++
 	rexx.dll!RexxObject::initializeNewObject(unsigned int mark, void * vft, RexxBehaviour * b)  Line 362	C++
 	rexx.dll!RexxMemory::newObject(unsigned int requestLength, unsigned int type)  Line 1134	C++
 	rexx.dll!new_object(unsigned int s, unsigned int t)  Line 422 + 0x1e bytes	C++
 	rexx.dll!RexxString::newString(const char * string, unsigned int length)  Line 1894 + 0xd bytes	C++
 	rexx.dll!new_string(const char * s, unsigned int l)  Line 521	C++
 	rexx.dll!RexxSource::get(unsigned int _position)  Line 838 + 0x1d bytes	C++
 	rexx.dll!RexxSource::extractSource(SourceLocation & location)  Line 1119 + 0x10 bytes	C++                 <-- counter = 735
 	rexx.dll!RexxCode::getSource()  Line 199	C++
 	rexx.dll!BaseExecutable::source()  Line 149	C++
 	rexx.dll!CPPCode::run(RexxActivity * activity, RexxMethod * method, RexxObject * receiver, RexxString * messageName, RexxObject * * argPtr, unsigned int count, ProtectedObject & result)  Line 144 + 0x6 bytes	C++
 	rexx.dll!RexxMethod::run(RexxActivity * activity, RexxObject * receiver, RexxString * msgname, RexxObject * * argPtr, unsigned int count, ProtectedObject & result)  Line 325	C++
 	rexx.dll!RexxObject::messageSend(RexxString * msgname, RexxObject * * arguments, unsigned int count, ProtectedObject & result)  Line 793	C++
 	rexx.dll!RexxExpressionStack::send(RexxString * message, unsigned int count, ProtectedObject & result)  Line 74 + 0x33 bytes	C++
 	rexx.dll!RexxExpressionMessage::evaluate(RexxActivation * context, RexxExpressionStack * stack)  Line 139	C++
 	rexx.dll!RexxExpressionMessage::evaluate(RexxActivation * context, RexxExpressionStack * stack)  Line 123 + 0x23 bytes	C++
 	rexx.dll!RexxInstructionAssignment::execute(RexxActivation * context, RexxExpressionStack * stack)  Line 122 + 0x1d bytes	C++
 	rexx.dll!RexxActivation::run(RexxObject * _receiver, RexxString * msgname, RexxObject * * _arglist, unsigned int _argcount, RexxInstruction * start, ProtectedObject & resultObj)  Line 522	C++
 	rexx.dll!RexxCode::call(RexxActivity * activity, RoutineClass * routine, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, RexxString * calltype, RexxString * environment, int context, ProtectedObject & result)  Line 116	C++
 	rexx.dll!RexxCode::call(RexxActivity * activity, RoutineClass * routine, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, ProtectedObject & result)  Line 92	C++
 	rexx.dll!RoutineClass::call(RexxActivity * activity, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, ProtectedObject & result)  Line 234	C++
 	rexx.dll!InterpreterInstance::runRequires(RexxActivity * activity, RexxString * name, RoutineClass * code)  Line 877	C++
 	rexx.dll!InterpreterInstance::loadRequires(RexxActivity * activity, RexxString * shortName, RexxString * fullName)  Line 932	C++
 	rexx.dll!RexxSource::loadRequires(RexxActivity * activity, RexxString * target)  Line 6082 + 0x14 bytes	C++
 	rexx.dll!PackageClass::loadPackage(RexxString * name, RexxArray * s)  Line 366 + 0x16 bytes	C++             <-- rgf_util2.rex


The previous behaviour is overwritten by
inline void insertAfter(DeadObject *newDead)            DeadObject.hpp
where newDead = 7eee1ac0
 	rexx.dll!DeadObject::insertAfter(DeadObject * newDead)  Line 89	C++
 	rexx.dll!DeadObjectPool::add(DeadObject * obj)  Line 165	C++
>	rexx.dll!NormalSegmentSet::addDeadObject(char * object, unsigned int length)  Line 461	C++
 	rexx.dll!MemorySegmentSet::sweep()  Line 1170	C++
 	rexx.dll!RexxMemory::collect()  Line 1038	C++
 	rexx.dll!NormalSegmentSet::handleAllocationFailure(unsigned int allocationLength)  Line 1272	C++
 	rexx.dll!RexxMemory::newObject(unsigned int requestLength, unsigned int type)  Line 1117 + 0x12 bytes	C++ <-- length = 48, we are in "small object" part (lesser than LargeBlockThreshold 4096)
 	rexx.dll!new_object(unsigned int s, unsigned int t)  Line 422 + 0x1e bytes	C++
 	rexx.dll!RexxString::newString(const char * string, unsigned int length)  Line 1894 + 0xd bytes	C++
 	rexx.dll!new_string(const char * s, unsigned int l)  Line 521	C++
 	rexx.dll!new_string(const char * s, unsigned int l)  Line 521	C++
 	rexx.dll!RexxSource::get(unsigned int _position)  Line 838 + 0x1d bytes	C++
 	rexx.dll!RexxSource::extractSource(SourceLocation & location)  Line 1119 + 0x10 bytes	C++                 <-- counter = 754
 	rexx.dll!RexxCode::getSource()  Line 199	C++
 	rexx.dll!BaseExecutable::source()  Line 149	C++
 	rexx.dll!CPPCode::run(RexxActivity * activity, RexxMethod * method, RexxObject * receiver, RexxString * messageName, RexxObject * * argPtr, unsigned int count, ProtectedObject & result)  Line 144 + 0x6 bytes	C++
 	rexx.dll!RexxMethod::run(RexxActivity * activity, RexxObject * receiver, RexxString * msgname, RexxObject * * argPtr, unsigned int count, ProtectedObject & result)  Line 325	C++
 	rexx.dll!RexxObject::messageSend(RexxString * msgname, RexxObject * * arguments, unsigned int count, ProtectedObject & result)  Line 793	C++
 	rexx.dll!RexxExpressionStack::send(RexxString * message, unsigned int count, ProtectedObject & result)  Line 74 + 0x33 bytes	C++
 	rexx.dll!RexxExpressionMessage::evaluate(RexxActivation * context, RexxExpressionStack * stack)  Line 139	C++
 	rexx.dll!RexxExpressionMessage::evaluate(RexxActivation * context, RexxExpressionStack * stack)  Line 123 + 0x23 bytes	C++
 	rexx.dll!RexxInstructionAssignment::execute(RexxActivation * context, RexxExpressionStack * stack)  Line 122 + 0x1d bytes	C++
 	rexx.dll!RexxActivation::run(RexxObject * _receiver, RexxString * msgname, RexxObject * * _arglist, unsigned int _argcount, RexxInstruction * start, ProtectedObject & resultObj)  Line 522	C++
 	rexx.dll!RexxCode::call(RexxActivity * activity, RoutineClass * routine, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, RexxString * calltype, RexxString * environment, int context, ProtectedObject & result)  Line 116	C++
 	rexx.dll!RexxCode::call(RexxActivity * activity, RoutineClass * routine, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, ProtectedObject & result)  Line 92	C++
 	rexx.dll!RoutineClass::call(RexxActivity * activity, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, ProtectedObject & result)  Line 234	C++
 	rexx.dll!InterpreterInstance::runRequires(RexxActivity * activity, RexxString * name, RoutineClass * code)  Line 877	C++
 	rexx.dll!InterpreterInstance::loadRequires(RexxActivity * activity, RexxString * shortName, RexxString * fullName)  Line 932	C++
 	rexx.dll!RexxSource::loadRequires(RexxActivity * activity, RexxString * target)  Line 6082 + 0x14 bytes	C++
 	rexx.dll!PackageClass::loadPackage(RexxString * name, RexxArray * s)  Line 366 + 0x16 bytes	C++             <-- rgf_util2.rex
    while loading rgf_util2.rex

Why is 0x7eee1ac0 a dead object ?
In RexxSource::extractSource, the array "source" is created, but is not a ProtectedObject.


===============================================================================
2010 may 15

Fix build under Windows for dbgprintf (link error).

Changed the build for "oodialog" target :
Builds both oodialogA and oodialogW (and not just oodialogA as before)
Ex :
makeorx BOTH oodialog clean --> cleans the debug & release files of oodialogA and oodialogW
makeorx BOTH oodialog       --> builds the debug & release files of oodialogA and oodialogW

Made a review of the conversions and removed those unneeded.
opts can remain byte-char.
strdupupr and strdupupr_nospace can remain byte-char.
setControlData can remain byte-char. The conversion is done internally.
putUnicodeText converts to wide-char, so no need to convert byte-char to wide-char before calling it (but keep the wide-char signature)


===============================================================================
2010 may 15

Added the function dbgprintf to write debug strings.
Under Windows, it calls OutputDebugString.
Under Linux, it calls syslog.

Remember, typical debug session under PuppyLinux (with busybox) :
Open a console :
    syslogd -S -C   # -S Smaller loggin output. -C Log to share mem buffer (read it using logred).
    logread -f
    The output of syslog is displayed by logread in this console (lock management, on client and server side).
Open a console, launch rxapi.
    Has been compiled to stay as a foreground process.
    It sends debug strings to stderr, more easy to follow in this console (messages between client and server).
Open a console, run the rexx command. The two other consoles are updated with debug infos.


[2011 apr 25 update]
Under MacOsX, I see this message in console : process exceeded 500 log messages per second limit.
To bypass this limit :
Edit /System/Library/LaunchDaemons/com.apple.syslogd.plist with xcode (binary format)
Search for : <string>/usr/sbin/syslogd</string>
Add these lines to the program arguments section :
<string>-mps_limit</string>
<string>0</string>
A value of 0 disables the limit. The default is 500 messages per second.
Restart the syslog daemon with:
sudo launchctl unload /System/Library/LaunchDaemons/com.apple.syslogd.plist
sudo launchctl load /System/Library/LaunchDaemons/com.apple.syslogd.plist
-----
LOG_DEBUG messages still not visible in console...
Probably because of /etc/asl.conf :
    # save everything from emergency to notice
    ? [<= Level notice] store
Remember :
    Emergency     (level 0)
    Alert         (level 1)
    Critical      (level 2)
    Error         (level 3)
    Warning       (level 4)
    Notice        (level 5)
    Info          (level 6)
    Debug         (level 7)
-----
Create the file /var/log/debug.log :
sudo touch /var/log/debug.log
Add this line to /etc/syslog.conf to get the debug messages in /var/log/debug.log :
*.debug   /var/log/debug.log
then restart the syslogd daemon as explained above.


===============================================================================
2010 may 14

More work on wide-chars in oodialog.

Fixed a crash in the conversion A2W and W2A : The length must be asked to the Windows service,
and not calculated with bad assumptions as I did.


Something not clear to me :
In oodMessaging.cpp, there is a message queue implemented as a string.
Each element is separated by a special character 0xFF.
This message queue is declared rxcharT, so it's a wide-char string when building the wide-char configuration.
Several methods have a rexxMethod parameter, and I declared it rxcharT.
But normally, a method name is always a byte-char string, there is no need to convert it to wide-char...
Problem : if I declare it as rxcharA, then what should I do with the pMessageQueue ?
Can I declare it rxcharA ? in this case, I must encode wide-char to byte-char each time a message is added
Or is it better to keep it rxcharW ? Currently addDialogMessage takes two wide-char arguments...
It's a matter of conversion boundary...


The japanese characters are not properly displayed by MessageBox (i.e. InfoDialog).
It seems that under XP, one must install files for complex scripts.
Not needed under Vista.
--> go to the "Regional and Language Options" control panel, go to the "Languages" tab,
and select "Install filesfor complex script...".
You need to reboot :-(
--> good, after reboot it works...


===============================================================================
2010 may 13

More work on wide-chars in oodialog.

New configuration names : oodialogA and oodialogW.
No longer needed to pass "WCHAR=1" to build the wide-char configuration.
makeorx DEBUG                   builds both configurations
makeorx DEBUG oodialogA         builds the byte-char configuration
makeorx DEBUG oodialogA clean   cleans the byte-char configuration
makeorx DEBUG oodialogW         builds the wide-char configuration
makeorx DEBUG oodialogW clean   cleans the wide-char configuration
makeorx DEBUG oodialog          like oodialogA

byte-char and wide-char configurations of oodialog are working, tested with oodialog examples.
There are some problems, but I have the same problems in trunk, so I assume there are some work in progress there...

Test of wide-char configuration :
It's not enough to put win32dbg/wchar in fromt of %PATH%, you must also rename
or remove win32dbg/oodialog.dll because it's this DLL which is loaded by default.
See unicode/ooRexx/oodtree.png for a screenshot with french, german, hebrew, russian, greek, etc...

Summary of the changes made to the oodtree example :
oodtree.rex, added : call setCodePage 65001 -- UTF-8
oodtree.rc, changed : FONT 8, "Arial Unicode MS"
oodtree.inp, added UTF-8 strings for demo


===============================================================================
2010 may 9

Added support for wide-chars in oodialog.
Currently, the "A" Windows API is called, and the conversion occurs there, inside Windows, based on the current locale.
When compiling ooDialog with wide chars UTF-16, the "W" API is called directly, making the dialogs Unicode-enabled.
GTK+ uses UTF-8 internally. Most of  the Unix-style operating systems use UTF-8 internally.
So it's natural to use multi-byte chars in ooRexx instead of wide chars, and to provide string services which supports UTF-8.
But the case of ooDialog is different :
This is a Windows-only sub-system, and for better integration with Windows, it must use UTF-16 chars internally.
The conversion to UTF-16 is under the responsability of ooDialog, which lets support code pages that are different
from the system's default code page. Typically, we can pass UTF-8 string to ooDialog which convert them to UTF-16 strings
before calling the Windows "W" API.

By default, the byte-char configuration is built when buildling the whole interpreter :
makeorx DEBUG

To build the byte-char configuration only, enter :
makeorx DEBUG oodialog
or
makeorx DEBUG oodialog "WCHAR=0"


To clean the byte-char configuration, enter :
makeorx DEBUG oodialog clean
or
makeorx DEBUG oodialog clean "WCHAR=0"

To build the wide-char configuration, enter :
makeorx DEBUG oodialog "WCHAR=1"
The output files are generated in the subdirectory win32dbg\wchar

To clean the wide-char configuration, enter :
makeorx DEBUG oodialog clean "WCHAR=1"


===============================================================================
2010 april 28

rgf_util2 wrappers to make the services of Rony available as methods on predefined classes.
For proof of concept... For a real library of methods, rgf_util2 should be rewritten to use
the variable "self" where appropriate, instead of passing the object as first parameter.



===============================================================================
2010 april 25

Add ::extension directive
todo : Limit the extension to new methods, raise an error if redefining a predefined method
(but keep ~define unlocked for investigation).

todo : I don't manage dependencies on ExtensionDirective
See RexxSource::resolveDependencies, there is maybe something to do there.
Currently, if the same method is extended several times, then it's the "last" extension who wins...
The definition of "last" depends on the order of resolution of ::requires
See samples\extension\test_extension_order.rex

Remember :
Unlike ::class, you can have several ::extension in the same source for the same class.
So the current check for duplicate method in an ExtensionDirective is not very useful.
The interpreter will complain for that :
::extension object
::method m
::method m
but not for that :
::extension object
::method m
::extension object
::method m


===============================================================================
2010 april 24

Unlock ~define


Creation of sandbox :
cd D:\local\Rexx\ooRexx\svn\sandbox
mkdir jlf
svn add jlf
svn commit jlf
svn copy https://oorexx.svn.sourceforge.net/svnroot/oorexx/main/trunk https://oorexx.svn.sourceforge.net/svnroot/oorexx/sandbox/jlf
svn update jlf

rev 5812
merge 5812-5835 from main/trunk
merge 5835-5957 from main/trunk
merge 5957-5988 from main/trunk
merge 5988-6048 from main/trunk
merge 6048-6142 from main/trunk
merge 6142-6189 from main/trunk
merge 6189-6500 from main/trunk

merge 6500-6784 from
    main/trunk/api
    main/trunk/extension/hostemu
    main/trunk/interpreter
    main/trunk/platform
    main/trunk/rexxapi

merge 6784-6976 from
    main/trunk/configure.ac (except oodialog)
    main/trunk/Makefile.am
    main/trunk/makeorx.bat
    main/trunk/extensions/platform/unix
    main/trunk/extensions/rexxutil
    main/trunk/extensions/rxsock
    main/trunk/interpreter
    main/trunk/platform/unix
    main/trunk/rexxapi

move oodialog to oodialog.wchar
commit
copy oodialog from trunk
commit
merge 6500-7390 from main/trunk/samples
merge 6784-7390 from main/trunk/platform/windows
merge 6976-7390 from main/trunk
revert oodialog (to stay with the last copied version)
revert oodialog.wchar (to not take into account the new oodialog)
resolve remaining conflicts
commit

merge 7390-7647 from main/trunk
revert oodialog.wchar (to not take into account the new oodialog)
Strange, when comparing after merge oodialog in my sandbox with trunk, I get a lot of differences
after the merge, whereas I should have zero difference. Not sure it's a good decision, but to fix that,
I made a copy-paste of the whole oodialog from trunk to my sandbox...
Same problem with samples/windows/oodialog (first level) : fixed by copy
Same problem with samples/windows/oodialog/examples (first level) : fixed by copy
Same problem with samples/windows/oodialog/examples/resources (first level) : fixed by copy

merge 7647-7688 from main/trunk

merge 7688-7691 from main/trunk

merge 7691-7736 from main/trunk

merge 7736-7771 from main/trunk

merge 7771-8678 from main/trunk

merge 8678-9423 from main/trunk

merge 9423-9515 from main/trunk

merge 9515-9978 from main/trunk
remove oodialog :
main/trunk/extensions/platform/windows/oodialog
main/trunk/samples/windows/oodialog


Remember Cornerstone :
Merge by cherry-pick, option ignore line endings
To solve conflict, select file, then Working Copy/Resolve conflict using File Merge
In FileMerge, if you don't see the merged file, then drag the splitter bar at the bottom of the window
In FileMerge, there is a default merge applied, even on conflicted area.
If the default merge is ok, then just File/Save merge.
Back in Cornerstone, click the button Resolve.
