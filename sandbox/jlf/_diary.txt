Sandbox for experimental work, what's done so far.
See tests/encoding/diary_examples.rex for [non-]regression tests.


===============================================================================
2025 Dec 19

Rework the md2md script.
(in incubator/scripts)
Description:
    Transform a Markdown file to another Mardown file.
    The titles are numbered, except the first level.
Usage:
    md2md [-h | --help] [-fo | --force-overwrite] [-fu | --force-update] [-v | --verbose] [--] [inputname [outputname]]
    where
        -fo --force-overwrite  forces overwriting if the output name already exists
        -fu --force-update     forces the update in case of reported errors
        -v  --verbose          activates the verbose mode
        -h  --help             show help
        --                     indicates the end of the options
        The default value for inputname is stdin.
        The default value for outputname is stdout.

Non regression tests
in incubator/scripts/md2md-tests


===============================================================================
2025 Dec 18

[Compatibility with ooRexx5]

Align StreamClasses.orx with ooRexx 5.
New methods on File:
    extension
    makeString

This query counts the number of files and directories per extension:
s. = 0; "."~pipe(.filetree "recursive" | .inject {item~extension} | .do {expose s.; s.item += 1}); s.=
Output when run from the net-oo-rexx root directory:
    a Stem (132 items)
    ''             :  549
    ...
    'rex'          :  281
    'rexx'         :  7
    'runTests'     :  2
    'rxj'          :  234
    'RXO'          :  2
    'rxo'          :  78
    'rxu'          :  28
    ...

This query displays the files and directories having no extension.
"."~pipe(.filetree "recursive" mem.file | .inject {if item~extension == "" then item} | .console {item~path})
Output when run from net-oo-rexx root directory:
    ...
    netrexx/examples/ant-task/debian-android-tools/src/org
    netrexx/examples/ant-task/debian-android-tools/src/org/rexxla
    netrexx/examples/ant-task/debian-android-tools/src/org/rexxla/compostimate
    netrexx/lib
    netrexx/runlib
    netrexx/documents
    packages
    packages/rexxdebugger
    packages/rexxdebugger/LICENSE
    ...


Still to be done:
    ::CLASS "File" ...
    ::method file_temporary_path class private external "library REXX"
    ::method temporaryPath class

    ::METHOD searchPathImpl CLASS PRIVATE EXTERNAL 'LIBRARY REXX file_search_path_impl'
    ::method searchPath CLASS

    ::METHOD setWritableImpl PRIVATE EXTERNAL 'LIBRARY REXX file_set_writable'
    ::METHOD setWritable

    ::METHOD isCaseSensitiveImpl PRIVATE EXTERNAL 'LIBRARY REXX this_file_case_sensitive'
    ::METHOD isCaseSensitive

    ::METHOD getLastAccessedImpl PRIVATE EXTERNAL 'LIBRARY REXX file_get_last_accessed'
    ::ATTRIBUTE lastAccessed GET

    ::METHOD setLastAccessedImpl PRIVATE EXTERNAL 'LIBRARY REXX file_set_last_accessed'
    ::ATTRIBUTE lastAccessed SET


===============================================================================
2025 Dec 18

New extension method on File:
    listIfNotSymbolicLink
Returns .nil if self is a symbolic link,
otherwise returns self~list.


The .FileTree pipe stage now returns files having a path relative to the item's path.
Output when run from the net-oo-rexx root directory:
"."~pipe(.fileTree | .console)
    1 : (./setup.sh)
    2 : (./.config)
    3 : (./.DS_Store)
    4 : (./setenv)
    5 : (./readme_net-oo-rexx.txt)
    6 : (./setup.rex)
    ...


===============================================================================
2025 Dec 18

[Compatibility with ooRexx5]

Moved the following methods from string.cls to CoreClasses.orx, to have them in rexx.img.
String and MutableBuffer
    contains
    caselessContains
    startsWith
    caselessStartsWith
    endsWith
    caselessEndsWith
    []


===============================================================================
2025 Dec 18

[Compatibility with ooRexx5]

Retrofit ooRexx5 [feature-requests:#650] Remove position restriction on match() and matchChar()
RexxString::match
RexxString::caselessMatch
MutableBuffer::match
MutableBuffer::caselessMatch

Retrofit ooRexx5 [feature-requests:#650] Remove position restriction on match() and matchChar()
RexxString::matchChar
RexxString::caselessMatchChar
MutableBuffer::matchChar
MutableBuffer::caselessMatchChar

Retrofit ooRexx5 [feature-requests:674] (caseless)changeStr should allow 0 as 'count' argument
RexxString::changeStr
RexxString::caselessChangeStr
MutableBuffer::changeStr
MutableBuffer::caselessChangeStr

"a"~match(1, "a")=                  -- 1
"a"~match(2, "a")=                  -- 0 instead of Invalid position argument specified; found "2"
"a"~match(1, "aa", 2)=              -- 1
"a"~match(1, "aa", 3)=              -- 0 instead of Invalid position argument specified; found "3"
"a"~caselessMatch(1, "a")=          -- 1
"a"~caselessMatch(2, "a")=          -- 0 instead of Invalid position argument specified; found "2"
"a"~caselessMatch(1, "aa", 2)=      -- 1
"a"~caselessMatch(1, "aa", 3)=      -- 0 instead of Invalid position argument specified; found "3"

"a"~matchChar(1, "a")=              -- 1
"a"~matchChar(2, "a")=              -- 0 instead of Invalid position argument specified; found "2"
"a"~caselessMatchChar(1, "a")=      -- 1
"a"~caselessMatchChar(2, "a")=      -- 0 instead of Invalid position argument specified; found "2"

"aa"~changeStr("a", "b", 1)=            -- 'ba'
"aa"~changeStr("a", "b", 0)=            -- 'aa' instead of Method positional argument 3 must be a positive whole number; found "0"
"aa"~caselessChangeStr("A", "B", 1)=    -- 'Ba'
"aa"~caselessChangeStr("A", "B", 0)=    -- 'aa' instead of Method positional argument 3 must be a positive whole number; found "0"

.mutableBuffer~new("a")~match(1, "a")=                  -- 1
.mutableBuffer~new("a")~match(2, "a")=                  -- 0 instead of Invalid position argument specified; found "2"
.mutableBuffer~new("a")~match(1, "aa", 2)=              -- 1
.mutableBuffer~new("a")~match(1, "aa", 3)=              -- 0 instead of Invalid position argument specified; found "3"
.mutableBuffer~new("a")~caselessMatch(1, "a")=          -- 1
.mutableBuffer~new("a")~caselessMatch(2, "a")=          -- 0 instead of Invalid position argument specified; found "2"
.mutableBuffer~new("a")~caselessMatch(1, "aa", 2)=      -- 1
.mutableBuffer~new("a")~caselessMatch(1, "aa", 3)=      -- 0 instead of Invalid position argument specified; found "3"

.mutableBuffer~new("a")~matchChar(1, "a")=              -- 1
.mutableBuffer~new("a")~matchChar(2, "a")=              -- 0 instead of Invalid position argument specified; found "2"
.mutableBuffer~new("a")~caselessMatchChar(1, "a")=      -- 1
.mutableBuffer~new("a")~caselessMatchChar(2, "a")=      -- 0 instead of Invalid position argument specified; found "2"

.mutableBuffer~new("aa")~changeStr("a", "b", 1)=            -- M'ba'
.mutableBuffer~new("aa")~changeStr("a", "b", 0)=            -- M'aa' instead of Method positional argument 3 must be a positive whole number; found "0"
.mutableBuffer~new("aa")~caselessChangeStr("A", "B", 1)=    -- M'Ba'
.mutableBuffer~new("aa")~caselessChangeStr("A", "B", 0)=    -- M'aa' instead of Method positional argument 3 must be a positive whole number; found "0"


===============================================================================
2025 Nov 7

Reactivate the declaration of the Buffer class.
The Buffer class is used by ooDialog.
I had the error "postionnal argument 1 must be an instance of the Buffer class"
when running oodtree.rex. It's because the Buffer class was not found.
oodResources.cpp
RexxMethod1(RexxObjectPtr, image_init, RexxObjectPtr, cselfObj)
{
    if ( requiredClass(context->threadContext, cselfObj, "Buffer", 1) )     -- false because Buffer class not found
    ...


===============================================================================
2025 Oct 20

[Compatibility with ooRexx5]

Add support for .Package~local

p1 = .Package~new("P1", "say 'Package P1'")
p1~local~var1 = "p1 var1"
p1~local~var2 = "p1 var2"
p1~local=

output
    Package P1
    a Directory (2 items)
    'VAR1' : 'p1 var1'
    'VAR2' : 'p1 var2'


===============================================================================
2024 Jul 02

Align the result of the C2X BIF with the result of the C2X BIM
c2x("NoÃ«l")=    -- '4E 6F C3AB 6C' (was '4E6FC3AB6C')
"NoÃ«l"~c2x=     -- '4E 6F C3AB 6C'
c2x("Noel")=    -- '4E6F656C' (unchanged)
"Noel"~c2x=     -- '4E6F656C' (unchanged)


===============================================================================
2024 June 22

[Encoded strings]

Only ASCII compatible encodings can be used as the default encoding.
.stringIndexer~pipe(.subclasses "recursive" | .select {item~canBeDefaultEncoding} | .console)
    1 : (The Byte_Encoding class)
    1 : (The ISO88591_Encoding class)
    2 : (The IBM1252_Encoding class)
    3 : (The WINDOWS1252_Encoding class)
    4 : (The IBM437_Encoding class)
    4 : (The WTF8_Encoding class)
    9 : (The UTF8_Encoding class)
    12 : (The Unicode8_Encoding class)
Reason:
The interpreter can return ASCII strings with no stored encoding (per design).
In this case their encoding is the default encoding.
This encoding must be compatible with ASCII.
Examples:
    oldEncoding = .encoding~setDefaultEncoding("byte")          -- ok
    .encoding~defaultEncoding = "cp1252"                        -- ok
    .encoding~defaultEncoding = "utf8"                          -- ok
    .encoding~defaultEncoding = "wtf8"                          -- ok
    .encoding~defaultEncoding = "unicode8"                      -- ok
    .encoding~defaultEncoding = "utf16"                         -- Encoding: 'utf16' is not supported as default encoding. Must be compatible with ASCII
    .encoding~defaultEncoding = "utf32"                         -- Encoding: 'utf32' is not supported as default encoding. Must be compatible with ASCII
    .encoding~setDefaultEncoding(oldEncoding)=                  -- (The Unicode8_Encoding class)    last default encoding successfully assigned

    executor --encoding byte -e "say .encoding~defaultEncoding"     -- The Byte_Encoding class
    executor --encoding utf-8 -e "say .encoding~defaultEncoding"    -- The The UTF8_Encoding class
    executor --encoding utf-16 -e "say .encoding~defaultEncoding"   -- "utf-16" is an invalid default encoding


The method setEncoding has now a default value for its 'encoding' argument, which
is the current self encoding. This is useful when the encoding is not stored, and
we want to make it stored. The "setEncoding" message without arguments will be sent
from native methods, without having to send the "encoding" message before.
Examples:
    s = "a" "string"
    s~hasEncoding=          -- 0
    s~encoding=             -- (The UTF8_Encoding class)
    s~setEncoding           -- make the current encoding persistent if not already stored
    s~hasEncoding=          -- 1
    s~encoding=             -- (The UTF8_Encoding class)

    t = "PÃ¨re" "NoÃ«l"
    t~hasEncoding=          -- 1    true because a RexxText has always an encoding
    t~string~hasEncoding=   -- 1    true because linked to a RexxText


New native methods:
    .Package~!setEncoding
    .MutableBuffer~!setEncoding
to store directly the encoding on PackageClass and RexxMutableBuffer instances.
Currently I have a dual storage (managed by extension, and managed by these methods).
In the end, only the native storage will remain.


===============================================================================
2024 June 22

No longer deliver ICU4X.
I have an error when cloning the Github repository.
    ~/rexx/oorexx$ git clone https://github.com/jlfaucher/executor.git
    Cloning into 'executor'...
    remote: Enumerating objects: 20591, done.
    remote: Counting objects: 100% (7721/7721), done.
    remote: Compressing objects: 100% (2380/2380), done.
    error: 9080 bytes of body are still expected MiB | 248.00 KiB/s
    fetch-pack: unexpected disconnect while reading sideband packet
    fatal: early EOF
    fatal: fetch-pack: invalid index-pack output

I suspect it's because of the ICU4X libraries that I put in the source directory.
Since I dont't use yet ICU4X, I decide to remove it from the Github repository.

After push:
The error is still there.
No error when using ssh, but this is not a solution because works only for me (password)

Workaround:
use --depth 1
git clone --depth 1 https://github.com/jlfaucher/executor.git

Strange... after the git clone, I have changes reported by git status.
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   sandbox/jlf/demos/executor-demo-extensions-output.html
        modified:   sandbox/jlf/demos/executor-demo-extensions-output.txt
        modified:   sandbox/jlf/demos/ooRexxShell-demo-queries-output.html
        modified:   sandbox/jlf/demos/ooRexxShell-demo-queries-output.txt
        modified:   sandbox/jlf/tests/encoding/diary_examples.output.html
git restore does not make them disapear.
I's maybe related to EOL, I have that under macOS, under WSL.
But not under Windows.


===============================================================================
2024 May 12

[Compatibility with ooRexx5]

Retrofit
    .Class~isAbstract
    .Class~isMetaclass
    .Class~package

    .Object~isNil       native

    .Method~isPackage
    .Method~isAbstract
    .Method~isConstant
    .Method~isAttribute
    .Method~scope

    ::CLASS option ABSTRACT
    ::ATTRIBUTE option PACKAGE
    ::METHOD option PACKAGE

    .Context~package    extension

Was not so easy for the management of packages...
It's still a mix of RexxSource and PackageClass.
ooRexx5 assigns TheRexxPackage during the "PREPARINGIMAGE" phase of rexx.img.
ooRexx4 doesn't support this phase.
As a workaround, I added a mark 'isInRexxPackage' which is set during the
"SAVINGIMAGE" phase on ALL the objects which are alive. Some native classes are
marked by their liveGeneral, like with ooRexx5:
    RexxClass, CPPCode, RexxCode, RexxNativeCode.
Currently, the mark 'isInRexxPackage' is tested for classes and methods (all
kinds of methods):
    RexxClass::getPackage()
    if (this->isInRexxPackage()) return TheRexxPackage;

    BaseExecutable::getPackage()
    if (code->isInRexxPackage()) return TheRexxPackage;


Still not working:
The REXX Package has no class after RESTORINGIMAGE.
Before SAVINGIMAGE, it has 59 classes.


===============================================================================
2024 May 04

[Procedural extensions]

I finalized the implementation of pretty print for ooRexx 5.
That was an interesting project, with several design iterations.

Iteration 1
I started with routines in ppstring.cls, but quickly discovered that rgf_util2
would need to require ppstring.cls to see the routines.

Iteration 2
I replaced the routines by class methods on a .PrettyPrinter class.
All went good and eventually got something working.
But I noticed a design glitch:
I had the .PrettyPrinter~v method used to return an empty vector.
This method has nothing to do with the pretty printâ€¦ Itâ€™s an array functionality.

Iteration 3
Worked on a general â€œproceduralâ€ solution, not limited to pretty print.
The design is described in procedural/dispatcher.cls.
Itâ€™s similar to the C# static extension methods.
But, unlike C#, it's not possible to use myObject~myMethod.
Must use .ExtensionDispatcher~myMethod(myObject).

Tested with ooRexx 4.2 and ooRexx 5.


===============================================================================
2024 Apr 24

[Encoded strings]

To check:
    CHAROUT, LINEOUT, STREAM

    ADDRESS, ARG, BEEP, CONDITION, DATE, DIGITS, DIRECTORY, ENDLOCAL, ERRORTEXT,
    FILESPEC, FORM, FUZZ, QUALIFY, QUEUED, RANDOM, RXFUNCADD, RXFUNCDROP,
    RXFUNCQUERY, RXQUEUE, SETLOCAL, SOURCELINE, SYMBOL, TIME, TRACE, USERID,
    VALUE, VAR


TODO
Don't lose the encoding at String level when creating new strings.
Literals
    (package encoding)  string literal, hexadecimal string literal, binary string literal
Class methods
    (default) BIM returning an ASCII constant string: alnum, alpha, blank, cntrl, cr, digit, graph, lower, nl, null, print, punct, space, tab, upper, xdigit
    (same)    BIM returning a string, not needing the concatenation rules: new
Instance methods
    (Default) BIM returning an ASCII constant string: dataType
    (Default) BIF returning an ASCII constant string: DATATYPE
    (Default) BIM returning a boolean: abbrev, contains, containsWord, endsWith, equals, match, matchChar, startsWith
    (Default) BIF returning a boolean: ABBREV
    (Default) OPE returning a boolean: = \= >< <> > < >= \< <= \> & | && prefix\
    (Default) BIM returning a decimal number: abs, c2d, ceiling, compare, compareTo, countStr, floor, format, lastPos, length, max, min, modulo, pos, round, sign, trunc, verify, wordIndex, wordLength, wordPos, words, x2d
    (Default) BIF returning a decimal number: ABS, C2D,          COMPARE,            COUNTSTR,        FORMAT, LASTPOS, LENGTH, MAX, MIN,         POS,        SIGN, TRUNC, VERIFY, WORDINDEX, WORDLENGTH, WORDPOS, WORDS, X2D
    (Default) OPE returning a decimal number: + - * / % // ** prefix- prefix+
    (Default) BIM returning an hexadecimal number: b2x, c2x, d2x
    (Default) BIF returning an hexadecimal number: B2X, C2X, D2X
    (Default) BIM returning a binary number: x2b
    (Default) BIF returning a binary number: X2B
    (Byte)    BIM returning a byte string: bitAnd, bitOr, bitXor, decodeBase64, encodeBase64, hashCode
    (Byte)    BIF returning a byte string: BITAND, BITOR, BITXOR
    (?)       BIM creating a string maybe not ASCII: d2c, x2c
    (?)       BIF creating a string maybe not ASCII: D2C, X2C, XRANGE
    (same)    BIM returning a string, not needing the concatenation rules: [], copies, delStr, delWord, lower, makeString, reverse, strip, subChar, subWord, upper, word
    (same)    BIF returning a string, not needing the concatenation rules:     COPIES, DELSTR, DELWORD, LOWER,             REVERSE, STRIP,          SUBWORD, UPPER, WORD
    (same)    BIM returning an array of strings, not needing the concatenation rules: makeArray, subWords
    (concat)  BIM returning a string, needing the concatenation rules: append, center, centre, changeStr, insert, left, overlay, replaceAt, right, space, substr, translate
    (concat)  BIF returning a string, needing the concatenation rules:         CENTER, CENTRE, CHANGESTR, INSERT, LEFT, OVERLAY,            RIGHT, SPACE, SUBSTR, TRANSLATE
    (concat)  OPE returning a string, needing the concatenation rules: "" || " "
    (N/A)     BIM not impacted: "?"
Stream
    (stream encoding)   BIM returning a string: charIn, lineIn
    (stream encoding)   BIF returning a string: CHARIN, LINEIN
    (stream encoding)   BIM returning an array of strings: arrayIn
    (Default)           BIM returning a decimal number: chars, lines
    (Default)           BIF returning a decimal number: CHARS, LINES
    (Default)           BIM returning an ASCII constant string:
    (Default)           BIF returning an ASCII constant string: DATATYPE


TODO
Don't lose the encoding when using a MutableBuffer.
I don't repeat the BIM already covered for String.
Instance methods
    (concat)  BIM needing the concatenation rules: []=


Rework the support of encoding for RexxBlock.
The definition doesn't change:
A RexxBlock has the same encoding as its definition package.
New methods:
    encoding
    encoding=
    hasEncoding
    setEncoding
Examples:
    block = {say .context~package~encoding; s1 = "PÃ¨re NoÃ«l"; say s1~class s1~encoding; s2 = "PÃ¨re" "NoÃ«l"; say s~class s~encoding}
    block~hasEncoding=                                  -- 1
    block~encoding=                                     -- (The UTF8_Encoding class)
    block~()
        The UTF8_Encoding class                         -- encoding of the definition package
        The RexxText class The UTF8_Encoding class      -- encoding of the definition package (string literal)
        The String class The UTF8_Encoding class        -- encoding of the calculated string

    -- Changing the block encoding
    block = {say .context~package~encoding; s1 = "PÃ¨re NoÃ«l"; say s1~class s1~encoding; s2 = "PÃ¨re" "NoÃ«l"; say s~class s~encoding}
    oldEncoding = block~setEncoding("byte")
    oldEncoding=                                        -- (The UTF8_Encoding class)
    block~hasEncoding=                                  -- 1
    block~encoding=                                     -- (The Byte_Encoding class)
    block~()
        The Byte_Encoding class                         -- encoding of the definition package
        The String class The Byte_Encoding class        -- encoding of the definition package (string literal)
        The String class The UTF8_Encoding class        -- Calculated string. TODO should be The Byte_Encoding
    block~setEncoding(oldEncoding)
    block~hasEncoding=                                  -- 1
    block~encoding=                                     -- (The UTF8_Encoding class)
    block~()
        The UTF8_Encoding class
        The String class The Byte_Encoding class        -- Once a string literal has a stored encoding, it doesn't change
        The String class The UTF8_Encoding class


===============================================================================
2024 Apr 22

[Vocabulary]

string literal? or literal string?
"string literal"    around 741â€¯000 results
"literal string"    around 482â€¯000 results
Wikipedia uses "string literal" (https://en.wikipedia.org/wiki/String_literal)
RexxRef uses "literal string"
I decide to use "string literal", because I use also "source literal" which
sounds better than "literal source".


[Code review]

globalStrings
    initialized by RexxMemory::createStrings: globalStrings = new_directory();
    updated by RexxMemory::getGlobalName
    used by RexxSource::globalSetup if not null
        when building an image, all the strings from all the packages are stored in this directory.
        when not building an image, each source (package) has its own directory: this is what I need to assign the package encoding to the string literals.

getGlobalName(const char *value)
    There is always a RexxString created with new_string(value)
    if globalStrings is NULL then return this new string, unprotected (globalStrings is not NULL when building an image)
    if this new string is found in globalStrings then return the found string.
    otherwise add this new string in globalStrings
called by
    RexxMemory::createStrings
    RexxBehaviour::define
    RexxMemory::saveImage for CHAR_MEMORY and CHAR_KERNEL
    Setup.cpp for several strings

RexxMemory::createStrings in GlobalNames.cpp,
which initialize the global variables OREF_XXX
        #define GLOBAL_NAME(name, value) OREF_##name = getGlobalName(value);
    called by RexxMemory::createImage


OrefSet
ooRexx5 uses sometimes
    #define setField(r, v)  OrefSet(this, this->r, v)
    #define clearField(r) setField(r, OREF_NULL)
    #define setOtherField(o, r, v) OrefSet(o, o->r, v)


[Debug]

TWO weeks of debug to understand why the attributes text and encoding that I
added to the class String are sometimes corrupted.
It's because the string instances are flagged setHasNoReferences by default,
and I was not calling setHasReferences when assigning a value to text or encoding.
Consequence: liveGeneral was not visiting these 2 fields when building an image,
and bad things happened when loading rexx.img...

For the moment, I keep all the debug stuff that I added in several source files.
Controlled with these definitions:
#define debug_encoding 0 (in RexxCore.h)
#define check_TE debug_encoding // Check Text and Encoding (in StringClass.cpp)


[ooRexx5 retrofit]

::constant is not evaluating the constant value, thus breaking the solution with
an extended String::Evaluate.
TODO: If possible, retrofit the ooRexx5 implementation which evaluates correctly
the constant expression.
ConstantGetterCode


[Encoded strings]

The encoding of a string literal is the encoding of its definition package.
It is set when the string literal is first evaluated.
Once a string literal has received its encoding, it does not change even if the
package encoding is changed later. Only string literals not yet evaluated will
be impacted. It is possible to explicitly change the encoding using the
~setEncoding method or using the ~encoding = new_encoding assignment.
The same goes for the default encoding. Once a calculated string has received
its encoding, it does not change even if the default encoding is changed later.


Consequence of the previous rule, the hexadecimal and binary strings are no longer
declared Byte encoded. Now their encoding is given by their definition package.
Idem for the BIFs/BIMs D2C and X2C, their results are no longer declared Byte encoded.
Since they have no assigned encoding, their results encoding depend on the default
encoding.
Examples:
    "41"x=                      -- 'A'
    "41"x~hasEncoding=          -- 1    The encoding is stored
    "41"x~encoding=             -- (The UTF8_Encoding class)    This is the encoding of the definition package
    "41"~x2c=                   -- 'A'
    "41"~x2c~hasEncoding=       -- 0    No stored encoding
    "41"~x2c~encoding=          -- (The UTF8_Encoding class)    This is the default encoding


For the proper management of the encoding of string literals, the globalStrings
directory is no longer used by the parser when building an image.
Now, each source (package) manages its own directory, even when building an image.
For the moment, all the packages that are included in rexx.img are byte encoded,
so this change is not needed. But maybe in the future, I may have packages with
different encodings in rexx.img.


It's now possible to reset the encoding of a string, mutable buffer or package
by passing .nil when using
    target~encoding = .nil
    target~setEncoding(.nil)
After reset, the encoding is no longer stored and the default encoding is returned.
A RexxText has always an encoding, so an error is raised when passing .nil.
This same error is raised when the target is a string linked to a RexxText.
Examples:
    s = "Noel"
    s~description=                          -- 'UTF-8 ASCII (4 bytes)'
    oldEncoding = s~setEncoding(.nil)
    oldEncoding=                            -- (The UTF8_Encoding class)
    s~description=                          -- 'UTF-8 ASCII by default (4 bytes)'
    s~setEncoding(oldEncoding)
    s~description=                          -- 'UTF-8 ASCII (4 bytes)'

    t = "NoÃ«l"
    t~description=                          -- 'UTF-8 not-ASCII (4 characters, 4 codepoints, 5 bytes, 0 error)'
    t~setEncoding(.nil)                     -- Encoding: 'The NIL object' is not supported
    s = t~string
    s~description=                          -- 'UTF-8 not-ASCII (4 characters, 4 codepoints, 5 bytes, 0 error)'
    s~setEncoding(.nil)                     -- Encoding: 'The NIL object' is not supported


The method ~setEncoding returns .nil when the target has no stored encoding.
That allows to reset properly the encoding when restoring the previous value.
Note: the method ~encoding never returns .nil. It returns the default encoding
when no encoding is stored.
Examples:
    .context~package~hasEncoding=                       -- 0                            The encoding is not stored
    .context~package~encoding=                          -- (The UTF8_Encoding class)    It's the default encoding
    oldEncoding = .context~package~setEncoding("byte")
    oldEncoding=                                        -- (The NIL object)
    .context~package~hasEncoding=                       -- 1                            The encoding is stored
    .context~package~encoding=                          -- (The Byte_Encoding class)
    .context~package~setEncoding(oldEncoding)=          -- (The Byte_Encoding class)    Previous encoding
    .context~package~hasEncoding=                       -- 0                            Return to non-stored encoding
    .context~package~encoding=                          -- (The UTF8_Encoding class)    It's the default encoding


New methods:
    .String~detach
    .RexxText~detach
The string is detached from its text counterpart.
The text becomes an empty text "".
Useful when working with big strings, to reclaim memory.
No need to call ~detach on both targets. There is a forward to the counterpart.
Examples:
    s = "Noel"
    t = s~text
    t=              -- T'Noel'
    s~hasText=      -- 1
    s~detach
    s~hasText=      -- 0
    t=              -- T''

    t = "NoÃ«l"
    s = t~string
    t=              -- T'NoÃ«l'
    s~hasText=      -- 1
    t~detach
    s~hasText=      -- 0
    t=              -- T''


New methods:
    .String~byte
    .RexxText~byte
Returns a copy of the string or text, with encoding = The Byte_Encoding.
The Byte_Encoding is a raw encoding with few constraints. It's often used for
diagnostic or repair. It can be always absorbed when doing a concatenation or a
comparison. BUT it's impossible to transcode from/to it without errors if the
string contains not-ASCII characters. Here, no transcoding, it's a copy as-is
whose encoding is The Byte_Encoding.
Examples:
    "50C3"x~description=                    -- 'UTF-8 not-ASCII (2 characters, 2 codepoints, 2 bytes, 1 error)'
    "PÃ¨re"~text~startsWith("50C3"x)=        -- Invalid UTF-8 string (raised by utf8proc)
    "50C3"x~byte~description=               -- 'Byte not-ASCII (2 characters, 2 codepoints, 2 bytes, 0 error)'
    "PÃ¨re"~text~startsWith("50C3"x~byte)=   -- 0 (not aligned)


New methods:
    .String~bytes
    .RexxText~bytes
Returns a ByteSupplier which provides each byte in decimal.
Examples:
    "Noel"~bytes==
        a ByteSupplier
         1 :  78
         2 :  111
         3 :  101
         4 :  108
    "NoÃ«l"~bytes==
        a ByteSupplier
         1 :  78
         2 :  111
         3 :  195
         4 :  171
         5 :  108


New native methods:
    .String~!setEncoding
    .String~!setText
to store directly these informations on String instances.
Currently I have a dual storage (managed by extension, and managed by these methods).
In the end, only the native storage will remain.


===============================================================================
2024 Apr 12

[interpreter]

Add support for dynamic target when sending messages.
The target is calculated based on the initial target and the arguments
values/types of the message. It's still a single-dispatch.
The ~~ form of message is not impacted: it returns the object that received the
message (the initial target), not the calculated target.


New method .Object~dynamicTarget which returns the target in function of the arguments:
    RexxObject *RexxObject::dynamicTargetRexx(RexxObject **arguments, size_t argCount, size_t named_argCount)
    {
        return this->dynamicTarget(arguments, argCount, named_argCount);
    }
By default, the dynamic target is the receiver object.
Native classes can override the virtual method dynamicTarget.
For the moment, it's not possible to override this method with an ooRexx method.
Examples:
    (1,2)~dynamicTarget=                       -- initial target: [ 1, 2]
    (1,2)~dynamicTarget("string")=             -- initial target: [ 1, 2]
    (1,2)~dynamicTarget("string", "teáºŒt")=     -- initial target: [ 1, 2]


The forward instruction does not depend on the dynamic target calculation.
If you need to forward using the dynamic target then do:
    forward message "DYNAMICTARGET" continue
    forward to (result)


[Encoded strings]

+---------------------------------------------------------------+
|                   3rd important milestone                     |
| The String messages become polymorphic on RexxString/RexxText |
+---------------------------------------------------------------+
If at least one positional argument is a RexxText then the String message is
sent to the RexxText counterpart of the String instance, otherwise the String
message is sent to the String instance.

The RexxString class overrides the virtual method dynamicTarget:
    RexxObject *RexxString::dynamicTarget(RexxObject **arguments, size_t count, size_t named_count)
    {
        if (hasRexxTextArguments(arguments, count, named_count))
        {
            RexxText *text = this->requestText();
            return text;
        }
        return this;
    }
Examples:
    "Noel"~dynamicTarget=                       -- initial target: 'Noel'
    "Noel"~dynamicTarget("string")=             -- initial target: 'Noel'
    "Noel"~dynamicTarget("string", "teáºŒt")=     -- text counterpart of the initial target: T'Noel'  because "teáºŒt" is a RexxText


Examples of dynamic target with ~center:
    "Ã©"~c2x=; "Ã©"~class=                        -- 'C3A9'   (The RexxText class)
    "test"~center(10, "Ã©")=                     -- T'Ã©Ã©Ã©testÃ©Ã©Ã©'

    "C3A9"x=; result~description=               -- T'Ã©'     'UTF-8 not-ASCII (1 character, 1 codepoint, 2 bytes, 0 error)'
    "test"~center(10, "C3A9"x)=                 -- T'Ã©Ã©Ã©testÃ©Ã©Ã©'

    x2c("C3A9")=; result~description=           -- 'Ã©'      'UTF-8 not-ASCII by default (2 bytes)'
    -- next error is ok: the pad is a string made of 2 bytes
    "test"~center(10, x2c("C3A9"))=             -- Incorrect pad or character argument specified; found "Ã©"


Examples of dynamic target with ~left:
    "test"~left(10)=                            -- 'test      '
    "test"~left(10, ".")=                       -- 'test......'
    "test"~left(10, "ðŸ¦–")=                     -- T'testðŸ¦–ðŸ¦–ðŸ¦–ðŸ¦–ðŸ¦–ðŸ¦–'


The ~~ form of message is not impacted: it always returns the initial target
    "test"~right(10, "Ã©")~left(20, "Ã¨")=        -- T'Ã©Ã©Ã©Ã©Ã©Ã©testÃ¨Ã¨Ã¨Ã¨Ã¨Ã¨Ã¨Ã¨Ã¨Ã¨'
    "test"~~right(10, "Ã©")~left(20, "Ã¨")=       -- T'testÃ¨Ã¨Ã¨Ã¨Ã¨Ã¨Ã¨Ã¨Ã¨Ã¨Ã¨Ã¨Ã¨Ã¨Ã¨Ã¨'
    "test"~right(10, "Ã©")~~left(20, "Ã¨")=       -- T'Ã©Ã©Ã©Ã©Ã©Ã©test'
    "test"~~right(10, "Ã©")~~left(20, "Ã¨")=      -- 'test'


[doers]

RexxText inherit from TextDoer.
Examples:
    "c2x"~text~do("a")=                     -- 61  (was Object "c2x" does not understand message "DO")
    "Ã§a va ?"~characters~each=              -- [T'Ã§',T'a',T' ',T'v',T'a',T' ',T'?']
    "Ã§a va ?"~characters~each("c2x")=       -- ['C3A7', 61, 20, 76, 61, 20,'3F']


A RexxBlock has the same encoding as its definition package.
Examples:
    {.context~package~encoding}~()=         -- (The UTF8_Encoding class)

    oldEncoding = .context~package~setEncoding("byte")
    {.context~package~encoding}~()=         -- (The Byte_Encoding class)
    .context~package~setEncoding(oldEncoding)

    -- was: Incorrect pad or character argument specified; found "Ã©"
    -- because the package encoding of the block was The Byte_Encoding (default)
    -- and the string literal "Ã©" was not converted to a RexxText instance.
    -- Now the package encoding of the block is The UTF8_Encoding and it works:
    ("un", "deux")~each{item~right(10, "Ã©")}==
        an Array (shape [2], 2 items)
         1 : T'Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©un'
         2 : T'Ã©Ã©Ã©Ã©Ã©Ã©deux'


[RosettaCode executor]

Validation of the new dynamic target by running the RosettaCode scripts.
rexx runRosettaCode.rex -run > out.txt 2>&1
    1 error with CENTER because of 'parse arg' which converts a RexxText to String
        [156] Cholesky-decomposition/cholesky-decomposition.rexx
    1 error because WORDS not supported by RexxText
        [226] Deal-cards-for-FreeCell/deal-cards-for-freecell.rexx
    Duration: 55s (was 53) (was 49)


===============================================================================
2024 Apr 10

[Encoded strings]

+-----------------------------------------------------------+
|                  2nd important milestone                  |
| The string BIFs become polymorphic on RexxString/RexxText |
+-----------------------------------------------------------+
If at least one positional argument is a RexxText then the string BIFs forward
to RexxText, otherwise the string BIFs forward to RexxString.
Enhanced BIFs:
    ABBREV
    CENTER      implemented on RexxText
    CENTRE      implemented on RexxText
    CHANGESTR
    COMPARE     implemented on RexxText
    COPIES      implemented on RexxText
    COUNTSTR
    D2C         implemented on RexxText
    DELSTR
    DELWORD
    INSERT
    LASTPOS
    LEFT        implemented on RexxText
    LENGTH      implemented on RexxText
    LOWER       implemented on RexxText
    OVERLAY
    POS         implemented on RexxText
    REVERSE     implemented on RexxText
    RIGHT       implemented on RexxText
    SPACE
    STRIP       implemented on RexxText
    SUBSTR      implemented on RexxText
    SUBWORD
    UPPER       implemented on RexxText
    VERIFY
    WORD
    WORDINDEX
    WORDLENGTH
    WORDPOS
    WORDS
    X2C         implemented on RexxText
Examples:
    -- CENTER
    CENTER("Noel", 10, "*")=                        -- '***Noel***'
    CENTER("Noel", 10, "ðŸ¤¶")=                       -- T'ðŸ¤¶ðŸ¤¶ðŸ¤¶NoelðŸ¤¶ðŸ¤¶ðŸ¤¶'  because "ðŸ¤¶" is a RexxText
    CENTER("NoÃ«l", 10, "*")=                        -- T'***NoÃ«l***'            because "NoÃ«l" is a RexxText
    CENTER("NoÃ«l"~string, 10, "*")=                 --  '**NoÃ«l***'
    CENTER("NoÃ«l", 10, "ðŸ¤¶")=                       -- T'ðŸ¤¶ðŸ¤¶ðŸ¤¶NoÃ«lðŸ¤¶ðŸ¤¶ðŸ¤¶'
    CENTER("NoÃ«l"~string, 10, "ðŸ¤¶")=                -- T'ðŸ¤¶ðŸ¤¶ðŸ¤¶NoÃ«lðŸ¤¶ðŸ¤¶ðŸ¤¶'  because "ðŸ¤¶" is a RexxText
    CENTER("NoÃ«l", 10, "ðŸ¤¶"~string)=                -- T'ðŸ¤¶ðŸ¤¶ðŸ¤¶NoÃ«lðŸ¤¶ðŸ¤¶ðŸ¤¶'  because "NoÃ«l" is a RexxText
    CENTER("Noel", 10, "ðŸ¤¶"~string)=                -- CENTER positional argument 3 must be a single character; found "ðŸ¤¶"
    CENTER("NoÃ«l"~string, 10, "ðŸ¤¶"~string)=         -- CENTER positional argument 3 must be a single character; found "ðŸ¤¶"

    -- Other BIFs
    ABBREV("Printer","Pri")=                        --  1
    ABBREV("Printer ðŸ–¨","Pri")=                     -- Object "Printer ðŸ–¨" does not understand message "ABBREV"
    CHANGESTR("p", "mpNoelpp", "m", 2)=             -- 'mmNoelmp'
    CHANGESTR("ðŸŽ…", "ðŸ¤¶ðŸŽ…NoÃ«lðŸŽ…ðŸŽ…", "ðŸ¤¶", 2)=   -- Object "ðŸ¤¶ðŸŽ…NoÃ«lðŸŽ…ðŸŽ…" does not understand message "CHANGESTR"
    COMPARE("straSssSSssse", "stra", "S")=          -- 6
    COMPARE("straÃŸssÃŸÃŸssse", "stra", "ÃŸ")=          -- 6
    COPIES("ðŸ¤¶", 4)=                                -- T'ðŸ¤¶ðŸ¤¶ðŸ¤¶ðŸ¤¶'
    COUNTSTR("m", "mpmp")=                          --  2
    COUNTSTR("ðŸ¤¶", "ðŸ¤¶ðŸŽ…ðŸ¤¶ðŸŽ…")=                 -- Object "ðŸ¤¶ðŸŽ…ðŸ¤¶ðŸŽ…" does not understand message "COUNTSTR"
    D2C(65)=                                        -- 'A'
    D2C(65~text)=                                   -- T'A'
    DELSTR("Noel", 3, 2)=                           -- 'No'
    DELSTR("NoÃ«l", 3, 2)=                           -- Object "NoÃ«l" does not understand message "DELSTR"
    DELWORD("Pere Noel p", 2, 2)=                   -- 'Pere '
    DELWORD("PÃ¨re NoÃ«l ðŸŽ…", 2, 2)=                  -- Object "PÃ¨re NoÃ«l ðŸŽ…" does not understand message "DELWORD"
    INSERT("123", "abc", 5, 6, "+")=                -- 'abc++123+++'
    INSERT("123", "abc", 5, 6, "ðŸŽ…")=               -- Object "abc" does not understand message "INSERT"
    LASTPOS("m", "mMere Noelm")=                    -- 11
    LASTPOS("ðŸ¤¶", "ðŸ¤¶MÃ¨re NoÃ«lðŸ¤¶")=                 -- Object "ðŸ¤¶MÃ¨re NoÃ«lðŸ¤¶" does not understand message "LASTPOS"
    LEFT("abc d",8,".")=                            -- 'abc d...'
    LEFT("abc d",8,"ðŸ¤¶")=                           -- T'abc dðŸ¤¶ðŸ¤¶ðŸ¤¶'
    LENGTH("PÃ¨re NoÃ«l ðŸŽ…"~string)=                  -- 16
    LENGTH("PÃ¨re NoÃ«l ðŸŽ…")=                         -- 11
    LOWER("PÃˆRE NOÃ‹L")=                             -- T'pÃ¨re noÃ«l'
    OVERLAY("123","abc",5,6,"+")=                   -- 'abc+123+++'
    OVERLAY("123","abc",5,6,"ðŸ¤¶")=                  -- Object "abc" does not understand message "OVERLAY"
    POS("Frei", "BundesstraÃŸe im Freiland")=        -- 17
    REVERSE("NoÃ«l")=                                -- T'lÃ«oN'
    RIGHT("12",5,"0")=                              --  00012
    RIGHT("12",5,"ðŸ¶")=                             -- T'ðŸ¶ðŸ¶ðŸ¶12'
    SPACE("abc  def  ",2,"+")=                      -- 'abc++def'
    SPACE("abc  def  ",2,"âŠ•")=                      -- Object "abc  def  " does not understand message "SPACE"
    STRIP("12.0000", "T", '.0')=                    --  12
    STRIP("12.Ã¸Ã¸Ã¸Ã¸", "T", '.Ã¸')=                   -- T'12'    where 'Ã¸'~c2x='C3B8'.
    STRIP(("12.Ã¸Ã¸" || "C3"x || "Ã¸Ã¸")~string, "T", '.Ã¸'~string)=    --  12  Every byte of the last parameter is searched and removed
    STRIP("12.Ã¸Ã¸" || "C3"x || "Ã¸Ã¸", "T", '.Ã¸')=                    -- Invalid UTF-8 string (raised by utf8proc)
    STRIP(("12.Ã¸Ã¸" || "C3"x || "Ã¸Ã¸")~transcodeTo("ISO-8859-1", replacementCharacter:"#"), "T", '.Ã¸'~transcodeTo("ISO-8859-1"))=   -- T'12.??#'
    SUBSTR("abc",2,6,".")=                          -- 'bc....'
    SUBSTR("abc",2,6,"ðŸ¤¶")=                         -- T'bcðŸ¤¶ðŸ¤¶ðŸ¤¶ðŸ¤¶'
    SUBWORD("Now is   the time",2,2)=               -- 'is   the'
    SUBWORD("Now is   the ðŸ•‘",2,2)=                 -- Object "Now is   the ðŸ•‘" does not understand message "SUBWORD"
    UPPER("pÃ¨re noÃ«l")=                             -- T'PÃˆRE NOÃ‹L'
    VERIFY("ABCDEF","ABC","N",2,3)=                 --  4
    VERIFY("ABCDEF","ABC","N"~text,2,3)=            -- Object "ABCDEF" does not understand message "VERIFY" (yes! ANY parameter is tested, including the option)
    WORD("Now is the time",3)=                      -- 'the'
    WORD("Now is the ðŸ•‘",3)=                        -- Object "Now is the ðŸ•‘" does not understand message "WORD"
    WORDINDEX("Now is the time",3)=                 --  8
    WORDINDEX("Now is the ðŸ•‘",3)=                   -- Object "Now is the ðŸ•‘" does not understand message "WORDINDEX"
    WORDLENGTH("Now is the time",4)=                --  4
    WORDLENGTH("Now is the ðŸ•‘",4)=                  -- Object "Now is the ðŸ•‘" does not understand message "WORDLENGTH"
    WORDPOS("the","Now is the time")=               --  3
    WORDPOS("the","Now is the ðŸ•‘")=                 -- Object "Now is the ðŸ•‘" does not understand message "WORDPOS"
    WORDS("Now is the time")=                       --  4
    WORDS("Now is the ðŸ•‘")=                         -- Object "Now is the ðŸ•‘" does not understand message "WORDS"
    X2C(41)=                                        -- 'A'
    X2C(41~text)=                                   -- T'A'


Still not sure:
When the target is a String, should the BIF d2c and x2c return a RexxText when
the result is not-ASCII and the evaluation context encoding is not Byte?
That would be consistent with the rules for string literal (R1, R2).
Currently, assuming the package encoding is UTF-8:
"FF"x is a RexxText but x2c("FF") is a String.
And what about "FF"~x2c? currently it's a String.
Examples:
    "FF"x=;result~description=                      -- T'[FF]'      'UTF-8 not-ASCII (1 character, 1 codepoint, 1 byte, 1 error)'
    x2c("FF")=;result~description=                  -- '[FF]'       'UTF-8 not-ASCII by default (1 byte)'
    "FF"~x2c=;result~description=                   -- '[FF]'       'UTF-8 not-ASCII by default (1 byte)'
    "FF"~text~x2c=;result~description=              -- T'[FF]'      'UTF-8 not-ASCII (1 character, 1 codepoint, 1 byte, 1 error)'
    "FF"~text("cp1252")~x2c=;result~description=    -- T'[FF]'      'windows-1252 not-ASCII (1 character, 1 codepoint, 1 byte, 0 error)'
    ---
    "41"x=;result~description=                      -- 'A'          'UTF-8 ASCII (1 byte)'
    x2c("41")=;result~description=                  -- 'A'          'UTF-8 ASCII by default (1 byte)'
    "41"~x2c=;result~description=                   -- 'A'          'UTF-8 ASCII by default (1 byte)'
    "41"~text~x2c=;result~description=              -- T'A'         'UTF-8 ASCII (1 character, 1 codepoint, 1 byte, 0 error)'
    "41"~text("cp1252")~x2c=;result~description=    -- T'A'         'windows-1252 ASCII (1 character, 1 codepoint, 1 byte, 0 error)'


[RosettaCode executor]

Validation of the new BIF implementation by running the RosettaCode scripts.
rexx runRosettaCode.rex -run > out.txt 2>&1
    1 error because TRANSLATE not supported by RexxText
        [25] Align-columns/align-columns-3.rexx
    1 error with CENTER because of 'parse arg' which converts a RexxText to String
        [156] Cholesky-decomposition/cholesky-decomposition.rexx
    1 error because WORDS not supported by RexxText
        [226] Deal-cards-for-FreeCell/deal-cards-for-freecell.rexx
    Duration: 53s (was 49)


===============================================================================
2024 Apr 10

[Extended interpreter]

The script 'executor' now supports the option --encoding <encodingName>
to override the default encoding.
Usage:
    executor (-l libray | -p package)* --encoding encodingName [-f] filename [arguments]
    executor (-l libray | -p package)* --encoding encodingName  -e  string   [arguments]
    executor -v
Examples:
    rexx executor --encoding cp1252 -e "say .encoding~defaultEncoding"      -- The WINDOWS1252_Encoding class
    rexx executor --encoding cp1252 -e "say .context~package~name"          -- /local/rexx/oorexx/executor/sandbox/jlf/packages/executor.REX
    rexx executor --encoding cp1252 -e "say .context~package~encoding"      -- The WINDOWS1252_Encoding class
    rexx executor --encoding cp1252 -e "say 'NoÃ«l'~class"                   -- The String class
    rexx executor --encoding utf8 -e "say 'NoÃ«l'~class"                     -- The RexxText class


===============================================================================
2024 Apr 08

[Encoded strings]

Start native integration of RexxText in the interpreter.
    RexxText *RexxInternalObject::textValue()
    RexxText *RexxObject::textValue()
    RexxText *RexxInternalObject::makeText()
    RexxText *RexxInternalObject::primitiveMakeText()
    RexxText *RexxObject::makeText()
    RexxText *RexxObject::requestText()

    static RexxText *nullText;
    static RexxText *newText(RexxString *s);                To rework!
    static RexxText *newText(const char *s, size_t l);      To rework!
    inline RexxText *new_text(RexxString *s)
    inline RexxText *new_text(const char *s, size_t l)
    inline RexxText *new_text(const char *s)

    Metaclass RexxTextClass to mark the static field RexxText::nullText.


===============================================================================
2024 Apr 03

[Encoded strings]

No longer apply the rule R3 during the automatic conversion of String literals
to RexxText instances. If the package encoding is not a byte encoding then any
not-ASCII String literal is converted to a RexxText, whatever its encoding.
Reason: inconsistency between
    "noel" "FF"x~~setEncoding("cp1252")=        -- 'noel [FF]' because concatenation of 2 String instances
    "noÃ«l" "FF"x~~setEncoding("cp1252")=        -- Encoding: cannot append... because concatenation of a RexxText with a String
Now:
    "FF"x=                                      -- T'[FF]'  (was a String thanks to R3)
    "noel" "FF"x~~setEncoding("cp1252")=        -- Encoding: cannot append windows-1252 not-ASCII '[FF]' to UTF-8 ASCII by default 'noel'   (was 'noel [FF]')
Unchanged:
    "noÃ«l" "FF"x=                               -- T'noÃ«l [FF]'     no error because the Byte_Encoding is always absorbed
    "FF"x "noÃ«l"=                               -- T'[FF] noÃ«l'     idem
    "noÃ«l" "FF"x~~setEncoding("cp1252")=        -- Encoding: cannot append windows-1252 not-ASCII '[FF]' to UTF-8 not-ASCII 'noÃ«l'
    "FF"x~~setEncoding("cp1252") "noÃ«l"=        -- Encoding: cannot append UTF-8 not-ASCII 'noÃ«l' to windows-1252 not-ASCII '[FF]'


The string literals are compressed by RexxSource::commonString.
Because of that, the encoding of s1 is overwritten by the encoding of s2.
Script:
    say .context~package~encoding   -- The UTF8_Encoding class
    s1 = "AB"
    say s1~encoding                 -- The UTF8_Encoding class when s2 is not set, The Byte_Encoding class when s2 is set
    s2 = "41 42"x                   -- "AB"
    say s2~encoding                 -- The Byte_Encoding class
This is the same problem that I detected already with interpret.
Not a blocking problem.
Maybe I will need to manage a table per encoding, will see.


===============================================================================
2024 Apr 03

Got a random crash when running the test
    make list_invalid_utf8
Added a GC protection in StringUtil::packHex and RexxSource::packLiteral,
but the crash still occurs randomly.
After several runs in Xcode:
    #0	0x000000010074bfb8 in RexxBehaviour::getOperatorMethod(unsigned long)               <-- EXC_BAD_ACCESS
    #1	0x000000010074ba98 in callOperatorMethod(RexxObject*, unsigned long, RexxObject*)
    #2	0x0000000100753c84 in RexxInstructionDo::checkControl(RexxActivation*, RexxExpressionStack*, RexxDoBlock*, bool)
    #3	0x0000000100753164 in RexxInstructionDo::execute(RexxActivation*, RexxExpressionStack*)
Protect the result returned by callOperatorMethod, when needed (in DoInstruction.cpp):
Add a GC protection in RexxInstructionDo::execute and RexxInstructionDo::controlSetup.


===============================================================================
2024 Apr 01

[Encoded strings]

Why did I put ppString for RexxText in extension/trace.cls???
Now it's in extension/text.cls, much more logical!
[later]
jlf, learn to read yourself!
"moved outside of text.cls to not trace these methods when tracing the package text.cls"
ok, I move it back to extension/trace.cls
BUT I rename trace.cls to notrace.cls


Replace
    ::attribute text get
by
    ::method text
because it takes an argument 'textEncoding' which allows to set an encoding.
It would be wrong to implement it as a getter attribute method.


A package has an encoding:
.Package
    encoding
    encoding=
    hasEncoding
Rules for the calculation of a package default encoding:
Case 1: package not requesting "text.cls", directly or indirectly.
    Most of the legacy packages don't support an automatic conversion to text.
    The package's default encoding is Byte (not .Encoding~defaultEncoding).
Case 2: package requesting "text.cls", directly or indirectly.
    We assume that the requester supports an automatic conversion to text.
    The package's default encoding is .Encoding~defaultEncoding.


New method setEncoding on String, MutableBuffer, Package and RexxText, to change
the current encoding and return the previous encoding.
The bytes are not impacted, it's just an update of the encoding annotation.
Example, assuming the default encoding is UTF-8:
    "Noel"~setEncoding("windows-1252")=     -- (The UTF8_Encoding class)    (previous encoding)
    "NoÃ«l"~setEncoding("byte")=             -- (The UTF8_Encoding class)    (previous encoding)
Example, when the default encoding is Byte:
    oldEncoding = .encoding~setDefaultEncoding("byte")
    "Noel"~setEncoding("windows-1252")=     -- (The Byte_Encoding class)    (previous encoding)
    "NoÃ«l"~setEncoding("byte")=             -- (The Byte_Encoding class)    (previous encoding)
    .encoding~setDefaultEncoding(oldEncoding)


New methods on the class Encoding, to change the current encoding and return
the previous encoding:
    setDefaultEncoding
    setDefaultInputEncoding
    setDefaultOutputEncoding


Relax the constraints for the Byte_Encoding in the methods compatibleEncoding
and asEncodingFor: The Byte_Encoding can be always absorbed.
Reason: The Byte_Encoding is often used for diagnostic or repair.
Examples:
    "PÃ¨re"~c2g=                             -- '50 C3A8 72 65'
    "PÃ¨re"~text~startsWith("50C3"x~byte)=   -- false (not aligned) (was Encoding: cannot compare Byte not-ASCII 'P\C3' with UTF-8 not-ASCII 'PÃ¨re')
    "PÃ¨re"~text~startsWith("50C3A8"x~byte)= -- true (was Encoding: cannot compare Byte not-ASCII 'PÃ¨' with UTF-8 not-ASCII 'PÃ¨re')


+-------------------------------------------+
|          1st important milestone          |
| Activation of the automatic conversion    |
| of String literals to RexxText instances  |
+-------------------------------------------+
This is managed in RexxString::evaluate
Rules:
if string~isASCII then value = string                               -- R1 don't convert to RexxText if the string literal is ASCII (here, NO test of encoding, just testing the bytes)
else if .context~package~encoding~isByte then value = string        -- R2 don't convert to RexxText if the encoding of its definition package is the Byte_Encoding or a subclass of it (legacy package).
-- else if string~isCompatibleWithByteString then value = string    -- R3 (no longer applied) don't convert to RexxText if the string literal is compatible with a Byte string.
else value = string~text                                            -- R4 convert to RexxText
Example, assuming the package encoding is UTF-8:
    "Noel"~class=                                       -- (The String class)       R1

    oldEncoding = .context~package~setEncoding("byte")
    "NoÃ«l"~class=                                       -- (The String class)       R2
    .context~package~setEncoding(oldEncoding)

    -- The rule R3 is no longer applied
    -- The only way to test it is to use an hexadecimal (or binary) string literal.
    -- [later] The hexadecimal string literals are no longer Byte encoded, so this test is no longer a good test
    "NoÃ«l"~c2x=                                         -- '4E 6F C3AB 6C'
    '4E 6F C3AB 6C'x~encoding=                          -- (The UTF8_Encoding class) (was (The Byte_Encoding class) so R3 could apply, but we no longer apply it)
    '4E 6F C3AB 6C'x~class=                             -- (The RexxText class)     R4

    "NoÃ«l"~class=                                       -- (The RexxText class)     R4
    "NoÃ«l"~string~class=                                -- (The String class)       R4 The string literal is a RexxText, the method ~string returns a String with encoding UTF-8
    "NoÃ«l"~~setEncoding("byte")~class=                  -- (The RexxText class)     R4 The string literal is a RexxText, its encoding is changed from UTF-8 to Byte
    "NoÃ«l"~~setEncoding("byte")~string~class=           -- (The String class)       R4 The string literal is a RexxText, its encoding is changed from UTF-8 to Byte, the method ~string returns a String with encoding Byte


Deactivate (again) the constraint "self~isCompatibleWithByteString" when converting
a RexxText to a String (.Unicode~unckeckedConversionToString = .true).
Reason: after activation of the automatic conversion to RexxText, I get these
errors if I keep the constraint "self~isCompatibleWithByteString".
    say "NoÃ«l"              -- raise an error "UTF-8 not-ASCII 'NoÃ«l' cannot be converted to a String instance"
    xrange("00"x,"ff"x)     -- raise an error "UTF-8 not-ASCII '[FF]' cannot be converted to a String instance"
The constraint "self~isCompatibleWithByteString" was put in place to detect when
a RexxText instance is "lost" during conversion to string. Now that we have a
common interface on String and RexxText, plus an automatic conversion to RexxText,
this "loss" should occur less often. But still occurs.
Examples, assuming the default encoding and the package encoding are UTF-8:
    "NoÃ«l"~length=          -- 4
    "NoÃ«l"~text~length=     -- 4
    "NoÃ«l"~string~length=   -- 5
    length("NoÃ«l")=         -- 5, should be 4    (with the constraint, would raise UTF-8 not-ASCII 'NoÃ«l' cannot be converted to a String instance)
    length("NoÃ«l"~string)=  -- 5


----------
ABANDONNED
(incompatible with the decision to assign the encoding of the definition package
to the string literals)
----------
The strings created by D2C, X2C are declared Byte encoded.
It's because it's not unusual to create ill-formed encoded strings with these BIF/BIM.
The Byte_Encoding is a raw encoding with few constraints, BUT it's impossible
to transcode from/to it without errors if the string contains not-ASCII characters.
That's why, often, a more specialized byte encoding is applied on the byte string,
to interpret the bytes differently.
Implementation notes:
    D2C: RexxNumberString::d2xD2c calls StringUtil::packHex
    X2C: StringUtil::packHex
Examples:
    "Ã©"~encoding=                                   -- (The UTF8_Encoding class)

    -- D2C
    "Ã©"~c2d=                                       -- 50089
    d2c(50089)=                                     -- 'Ã©'
    50089~d2c=                                      -- 'Ã©'
    d2c(50089)~encoding=                            -- (The UTF8_Encoding class)    (was (The Byte_Encoding class))
    50089~d2c~encoding=                             -- (The UTF8_Encoding class)    (was (The Byte_Encoding class))

    -- X2C
    "Ã©"~c2x=                                        -- 'C3A9'
    x2c("C3A9")=                                    -- 'Ã©'
    "C3A9"~x2c=                                     -- 'Ã©'
    x2c("C3A9")~encoding=                           -- (The UTF8_Encoding class)    (was (The Byte_Encoding class))
    "C3A9"~x2c~encoding=                            -- (The UTF8_Encoding class)    (was (The Byte_Encoding class))

    -- Valid Byte string, but invalid UTF-8 string
    "C3"~x2c~class=                                 -- (The String class)
    "C3"~x2c~encoding=                              -- (The UTF8_Encoding class)    (was (The Byte_Encoding class))
    -- Apply an UTF-8 view through the String interface
    "C3"~x2c~~setEncoding("utf8")~description=      -- 'UTF-8 not-ASCII (1 byte)'
    "C3"~x2c~~setEncoding("utf8")~errors=           -- 'UTF-8 encoding: byte sequence at byte-position 1 is truncated, expected 2 bytes.'
    -- Apply an UTF-8 view through the RexxText interface
    "C3"~x2c~text("utf8")~description=              -- 'UTF-8 not-ASCII (1 character, 1 codepoint, 1 byte, 1 error)'
    "C3"~x2c~text("utf8")~errors=                   -- 'UTF-8 encoding: byte sequence at byte-position 1 is truncated, expected 2 bytes


----------
ABANDONNED
(incompatible with the decision to assign the encoding of the definition package
to the string literals)
----------
The hexadecimal and binary strings are declared Byte encoded, for the same reasons
as D2C, X2C.
Implementation notes:
    RexxSource::packLiteral (Scanner.cpp)
Examples:
    -- The encoding of a string literal is the encoding of its definition package.
    "Ã©"~encoding=                                   -- (The UTF8_Encoding class)

    -- The encoding of an hexadecimal string is the Byte encoding.
    "Ã©"~c2x=                                        -- 'C3A9'
    "C3A9"x=                                        -- T'Ã©'
    "C3A9"x~encoding=                               -- (The UTF8_Encoding class)    (was (The Byte_Encoding class))

    -- The encoding of a binary string is the Byte encoding.
    "Ã©"~c2x~x2b=                                    -- 1100001110101001
    "11000011 10101001"b=                           -- T'Ã©'
    "11000011 10101001"b~encoding=                  -- (The UTF8_Encoding class)    (was (The Byte_Encoding class))


Implementation of RexxText~Strip:
    "NoÃ«l"~strip=                       -- T'NoÃ«l'
    "\tNoÃ«l "~unescape~strip=           -- T'NoÃ«l'
    "NoÃ«l"~strip("b", "Ã«")=             -- T'NoÃ«l'
    "NoÃ«"~strip("b", "Ã«")=              -- T'No'
    "ðŸ¤¶NoÃ«lðŸŽ…"~strip("b", "lÃ«ðŸŽ…ðŸ¤¶")=  -- T'No'
    "\u{NBSP}\u{EN SPACE}\u{EM SPACE}\u{HAIR SPACE}\u{FIGURE SPACE}\u{THIN SPACE}"~unescape~strip=          -- T'Â â€‚â€ƒâ€Šâ€‡â€‰'
    "\u{NBSP}\u{EN SPACE}\u{EM SPACE}\u{HAIR SPACE}\u{FIGURE SPACE}\u{THIN SPACE}"~unescape~strip(lump:)=   -- T''


New methods on String for compatibility with RexxText (inherit StringRexxTextInterface).
Most of these methods forward to string~text.
    ::method errors
    ::method isCompatibleWithASCII
    ::method isCompatibleWithByteString
    ::method isUpper
    ::method isLower
    ::method codepoints
    ::method maximumCodepoint
    ::method maximumUnicodeCodepoint
    ::method UnicodeCharacters
    ::method characters
    ::method character
    ::method transcodeTo
    ::method UTF8
    ::method WTF8
    ::method UTF16
    ::method UTF16BE
    ::method UTF16LE
    ::method WTF16
    ::method WTF16BE
    ::method WTF16LE
    ::method UTF32
    ::method UTF32BE
    ::method UTF32LE
    ::method Unicode
    ::method UnicodeN
    ::method Unicode8
    ::method Unicode16
    ::method Unicode32
    ::method c2u
    ::method u2c
    ::method c2g
    ::method checkHexadecimalValueCompatibility
    ::method checkNumericValueCompatibility
    ::method checkLogicalValueCompatibility
    ::method unescape
    ::method transform
    ::method transformer
    ::method title
    ::method isNFC
    ::method NFC
    ::method isNFD
    ::method NFD
    ::method isNFKC
    ::method NFKC
    ::method isNFKD
    ::method NFKD
    ::method isCasefold
    ::method casefold
    ::method isMarkStripped
    ::method isIgnorableStripped
    ::method isCCStripped
    ::method isNAStripped
    ::method graphemes
    ::method grapheme


Implementation of the abstract method 'transform' for Byte_Encoding and its subclasses.
Parameters:
    normalization = 0           Ignored, there is no normalization for byte strings.
    casefold = .false           if .true then apply ~lower
    lump= .false                Ignored
    stripMark = .false          if .true then replace the accented letters by their base letter
    stripIgnorable= .false      Ignored
    stripCC = .false            if .true then remove the codepoints < 20x
    stripNA = .false            if .true then remove the unassigned codepoints
Examples:
    -- casefold
    "PÃ¨re NoÃ«l"~transcodeTo("windows-1252")=                                                     -- T'P?re No?l'
    "PÃ¨re NoÃ«l"~transcodeTo("windows-1252")~c2x=                                                 -- '50 E8 72 65 20 4E 6F EB 6C'
    '50 E8 72 65 20 4E 6F EB 6C'x~byte~transform(casefold:)=                                     -- T'p?re no?l'
    '50 E8 72 65 20 4E 6F EB 6C'x~byte~transform(casefold:)~encoding=                            -- (The Byte_Encoding class)
    '50 E8 72 65 20 4E 6F EB 6C'x~byte~transform(casefold:)~utf8=                                -- Cannot convert Byte not-ASCII character 232 (E8) at byte-position 2 to UTF-8
    '50 E8 72 65 20 4E 6F EB 6C'x~byte~transform(casefold:)~~setEncoding("windows-1252")~utf8=   -- T'pÃ¨re noÃ«l'

    -- stripMark depends on the encoding
    "80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F 90 93 94 95 96 97 98 99 9A 9F A0 A1 A2 A3 A4 A5"x~text("ibm-437")~utf8=                           -- T'Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÆ’Ã¡Ã­Ã³ÃºÃ±Ã‘'
    "80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F 90 93 94 95 96 97 98 99 9A 9F A0 A1 A2 A3 A4 A5"x~text("ibm-437")~transform(stripMark:)~utf8=     -- T'CueaaaaceeeiiiAAEooouuyOUfaiounN'
    "83 8A 9A 9F C0 C1 C2 C3 C4 C5 C7 C8 C9 CA CB CC CD CE CF D1 D2 D3 D4 D5 D6 D8 D9 DA DB DC DD E0 E1 E2 E3 E4 E5 E7 E8 E9 EA EB EC ED EE EF F1 F2 F3 F4 F5 F6 F8 F9 FA FB FC FD FF"x~text("ibm-1252")~utf8=                        -- T'Æ’Å Å¡Å¸Ã€ÃÃ‚ÃƒÃ„Ã…Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã˜Ã™ÃšÃ›ÃœÃÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã±Ã²Ã³Ã´ÃµÃ¶Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¿'
    "83 8A 9A 9F C0 C1 C2 C3 C4 C5 C7 C8 C9 CA CB CC CD CE CF D1 D2 D3 D4 D5 D6 D8 D9 DA DB DC DD E0 E1 E2 E3 E4 E5 E7 E8 E9 EA EB EC ED EE EF F1 F2 F3 F4 F5 F6 F8 F9 FA FB FC FD FF"x~text("ibm-1252")~transform(stripMark:)~utf8=  -- T'fSsYAAAAAACEEEEIIIINOOOOOOUUUUYaaaaaaceeeeiiiinoooooouuuuyy'
    "C0 C1 C2 C3 C4 C5 C7 C8 C9 CA CB CC CD CE CF D1 D2 D3 D4 D5 D6 D8 D9 DA DB DC DD E0 E1 E2 E3 E4 E5 E7 E8 E9 EA EB EC ED EE EF F1 F2 F3 F4 F5 F6 F8 F9 FA FB FC FD FF"x~text("iso-8859-1")~utf8=                            -- T'Ã€ÃÃ‚ÃƒÃ„Ã…Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã˜Ã™ÃšÃ›ÃœÃÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã±Ã²Ã³Ã´ÃµÃ¶Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¿'
    "C0 C1 C2 C3 C4 C5 C7 C8 C9 CA CB CC CD CE CF D1 D2 D3 D4 D5 D6 D8 D9 DA DB DC DD E0 E1 E2 E3 E4 E5 E7 E8 E9 EA EB EC ED EE EF F1 F2 F3 F4 F5 F6 F8 F9 FA FB FC FD FF"x~text("iso-8859-1")~transform(stripMark:)~utf8=      -- T'AAAAAACEEEEIIIINOOOOOOUUUUYaaaaaaceeeeiiiinoooooouuuuyy'
    "83 8A 8E 9A 9E 9F C0 C1 C2 C3 C4 C5 C7 C8 C9 CA CB CC CD CE CF D1 D2 D3 D4 D5 D6 D8 D9 DA DB DC DD E0 E1 E2 E3 E4 E5 E7 E8 E9 EA EB EC ED EE EF F1 F2 F3 F4 F5 F6 F8 F9 FA FB FC FD FF"x~text("windows-1252")~utf8=                            -- T'Æ’Å Å½Å¡Å¾Å¸Ã€ÃÃ‚ÃƒÃ„Ã…Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã˜Ã™ÃšÃ›ÃœÃÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã±Ã²Ã³Ã´ÃµÃ¶Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¿'
    "83 8A 8E 9A 9E 9F C0 C1 C2 C3 C4 C5 C7 C8 C9 CA CB CC CD CE CF D1 D2 D3 D4 D5 D6 D8 D9 DA DB DC DD E0 E1 E2 E3 E4 E5 E7 E8 E9 EA EB EC ED EE EF F1 F2 F3 F4 F5 F6 F8 F9 FA FB FC FD FF"x~text("windows-1252")~transform(stripMark:)~utf8=      -- T'fSZszYAAAAAACEEEEIIIINOOOOOOUUUUYaaaaaaceeeeiiiinoooooouuuuyy'

    -- several transformations
    "PÃ¨re NoÃ«l"~transcodeTo("windows-1252")~transform(casefold:, stripMark:)~utf8=                      -- T'pere noel'
    '50 E8 72 65 20 4E 6F EB 6C'x~~setEncoding("windows-1252")~transform(casefold:, stripMark:)~utf8=   -- T'pere noel'
    -- next: the transform is done on Byte string, which has no rule for stripMark.
    -- the accents are not removed.
    '50 E8 72 65 20 4E 6F EB 6C'x~byte~transform(casefold:, stripMark:)~~setEncoding("windows-1252")~utf8=   -- T'pÃ¨re noÃ«l'


===============================================================================
2024 Mar 17

[Encoded strings]

For consistency with other methods, add the optional named argument 'buffer' to
    []
    c2g
    c2x
    x2b
    x2d
Examples:
    buffer = .MutableBuffer~new
    "TÃªte Ã  tÃªte"~text[2, 5, :buffer]=  -- M'Ãªte Ã '
    "A"~text~c2g(:buffer)=              -- M'Ãªte Ã 41'
    "A"~text~c2x(:buffer)=              -- M'Ãªte Ã 4141'
    "41"~text~x2b(:buffer)=             -- M'Ãªte Ã 414101000001'
    "41"~text~x2d(:buffer)=             -- M'Ãªte Ã 41410100000165'


Rename
    .Unicode~memorizeConversions
to
    .Unicode~memorizeTranscodings
because I suddenly decided that "Conversions" is ambiguous
(this word could also be applicable to the normalization transformations).


For compatibility with Python, add support for \N{Unicode name}.
Example:
    "\N{for all} x \N{there exists} y such that x+y=0"~text~unescape=       -- T'âˆ€ x âˆƒ y such that x+y=0'


Add support for code point labels.
Examples:
    .unicode~character("<control-000A>")=           -- ( ""    U+000A Cc 0 "", "LINE FEED", "NEW LINE", "END OF LINE", "LF", "NL", "EOL" )
    "hello\N{<control-000A>}bye"~text~unescape=     -- T'hello[0A]bye'
    "hello\U{<control-000A>}bye"~text~unescape=     -- T'hello[0A]bye'


Modify the display of UnicodeCharacter properties to show the codepoint values
in U+ and 0x notation.
Example:
    .Unicode["ðŸ¤¶"]~properties=
Impacted lines:
    'codepoint'             : 'U+1F936'
    'toLowerFull'           : 'U+1F936'
    'toLowerSimple'         : 'U+1F936'
    'toTitleFull'           : 'U+1F936'
    'toTitleSimple'         : 'U+1F936'
    'toUpperFull'           : 'U+1F936'
    'toUpperSimple'         : 'U+1F936'
    'Unicode'               : '0x36F90100'
    'UTF16BE'               : '0xD83EDD36'
    'UTF16LE'               : '0x3ED836DD'
    'UTF32BE'               : '0x0001F936'
    'UTF32LE'               : '0x36F90100'
    'UTF8'                  : '0xF09FA4B6'


Modification of the rule for buffer encoding neutrality.
    old: If left is a        buffer with no encoding then use the right encoding.
    new: If left is an empty buffer with no encoding then use the right encoding.
Impacted methods:
    .Encoding~compatibleEncoding
    .StringIndexer~asEncodingFor
Examples:
    buffer = .MutableBuffer~new
    -- This is an empty buffer with no explicit encoding:
    -- The rule for encoding neutrality will apply.
    buffer~description=                                                     -- 'UTF-8 ASCII by default (0 byte)'
    "Test"~text~utf16~left(2, :buffer)=                                     -- M'[00]T[00]e'
    -- The buffer encoding is now UTF-16BE.
    buffer~description=                                                     -- 'UTF-16BE (4 bytes)'

    buffer = .MutableBuffer~new("not empty")
    buffer~description=                                                     -- 'UTF-8 ASCII by default (9 bytes)'
    -- Here, the rule for encoding neutrality does not apply.
    "Test"~text~utf16~left(2, :buffer)=                                     -- Encoding: cannot append UTF-16BE to UTF-8 ASCII by default 'not empty'


New method ~u2c on String and RexxText.
Create a Unicode32 text from a sequence of U+xxxx.
The U+ string/text must be compatible with a byte encoding (Byte or subclass,
UTF-8 ASCII, WTF-8 ASCII).
In other words, will not support a sequence of U+xxxx encoded in UTF-16 or UTF-32.
Examples:
    -- U+ string
    "U+004E u+006F U+00EB U+006C U+1F936 U+1F385"~u2c~description=          -- 'Unicode32 (6 characters, 6 codepoints, 24 bytes, 0 error)'
    "U+004E u+006F U+00EB U+006C U+1F936 U+1F385"~u2c~c2x=                  -- '4E000000 6F000000 EB000000 6C000000 36F90100 85F30100'
    "U+004E u+006F U+00EB U+006C U+1F936 U+1F385"~u2c~utf8=                 -- T'NoÃ«lðŸ¤¶ðŸŽ…'

    -- U+ text
    "U+004E u+006F U+00EB U+006C U+1F936 U+1F385"~text~u2c~description=     -- 'Unicode32 (6 characters, 6 codepoints, 24 bytes, 0 error)'
    "U+004E u+006F U+00EB U+006C U+1F936 U+1F385"~text~u2c~c2x=             -- '4E000000 6F000000 EB000000 6C000000 36F90100 85F30100'
    "U+004E u+006F U+00EB U+006C U+1F936 U+1F385"~text~u2c~utf8=            -- T'NoÃ«lðŸ¤¶ðŸŽ…'

    buffer = .MutableBuffer~new
    "U+0031 U+0032"~text~u2c(:buffer)=                                      -- M'1[000000]2[000000]'
    -- The buffer encoding is now Unicode32.
    buffer~description=                                                     -- 'Unicode32 (8 bytes)'

    -- Examples of invalid U+ string/text
    "U+004E u+006F U+00EB U+006C U+1F936 U+1F385"~text~utf16~u2c=           -- UTF-16BE '[00]U[00]+[00]0[00]0[00]4[00]E[00] ...' is not compatible with an U+ string.
    "A+004E"~u2c=                                                           -- Expecting U+ or u+ followed by 4..6 hex digits, got 'A+004E'
    "u+4E"~u2c=                                                             -- Expecting U+ or u+ followed by 4..6 hex digits, got 'u+4E'
    "u+000004E"~u2c=                                                        -- Expecting U+ or u+ followed by 4..6 hex digits, got 'u+000004E'


New supported methods on RexxText:
- d2c       forward to String, return a Text or a MutableBuffer
- d2x       forward to String, return a String or a MutableBuffer
Examples:
    "65"~text~d2c=              -- T'A'
    "65"~text~d2x=              -- 41
    buffer = .MutableBuffer~new
    "65"~text~d2c(:buffer)=     -- M'A'
    "65"~text~d2x(:buffer)=     -- M'A41'
    buffer~encoding = "utf16"
    "65"~text~d2c(:buffer)=     -- Encoding: cannot append UTF-8 ASCII by default 'A' to UTF-16BE 'A41'


Review of methods for string representation.
        String      RexxText
b2x       x            x
c2d       x            x
c2x       x            x
d2c       x            x
d2x       x            x
x2b       x            x
x2c       x            x
x2d       x            x
---
c2g                    x
c2u                    x
u2c       x            x


Partial implementation of translate (ASCII string only):
Examples:
    "hello"~text~translate=              -- 'HELLO'
    "hello"~text~translate(,,"x")=       -- 'xxxxx'
    "hello"~text~translate(,"el","x")=   -- 'hxxxo'


===============================================================================
2024 Mar 16

[Doers]

Simplification of .doers~compose
No longer try to pass a named argument "item" because I had an error
    "named argument ITEM is not an expected argument name"
(I should test the doer~arity to decide if I can pass it, but not sure it's
worth doing this)


===============================================================================
2023 Dec 04

[Encoded strings]

Reworked the implementation of caselessMatchChar, matchChar.

"BundesschnellstraÃŸe"~text~caselessMatchChar(18, "s")=           -- now 0: "ÃŸ" casefolded to "ss" doesn't match "s"
"BAFFLE"~text~caselessMatchChar(5, "ï¬„")=                        -- now 0: "L" casefolded to "l" doesn't match "ï¬„" casefolded to "ffl" (no more iteration on each character of "ffl")
"baï¬„e"~text~matchChar(3, "f", normalization:.Unicode~NFKD)=     -- now 0: "ï¬„" transformed to "ffl" doesn't match "f"

After rework, I have these other differences:

-- Case 1 sounds good (no more iteration on each character of "ffl")
"BAFFLE"~text~caselessMatchChar(3, "ï¬„")=        -- 0    was 1 "ï¬„" becomes "ffl" (3 graphemes), there is a match on "f" at 3
"BAFFLE"~text~caselessPos("ï¬„", aslist:, aligned:0)=
    a List (1 items)
     0 : [+3.3,+6.6]
-- I get the same result as before by explicitely decomposing the ligature "ï¬„" to "ffl" BEFORE :
"BAFFLE"~text~caselessMatchChar(3, "ï¬„"~text~transform(normalization:.Unicode~NFKD))=    -- 1
-- here, it's ok because the match is on several characters
"BAFFLE"~text~caselessMatch(3, "ï¬„")=            -- 1


-- Case 2 sounds good (no more iteration on each character of "ffl")
"BAFFLE"~text~caselessMatchChar(5, "ï¬„")=        -- 0    was 1 "ï¬„" becomes "ffl" (3 graphemes), there is a match on "l" at 5
"BAFFLE"~text~caselessMatch(5, "ï¬„")=            -- 0


-- Case 3 sounds good (no more iteration on each character of "ffl")
"baï¬„e"~text~caselessMatchChar(3, "F")=          -- 0    was 1 "ï¬„" at 3 (1 grapheme) becomes "ffl" (3 graphemes), there is a match on "f"


-- Case 4 sound good (hum... did I really think that the character "ï¬„" at pos 3 can match an "l"?)
"baï¬„e"~text~caselessMatchChar(3, "L")=          -- 0    was 1 "ï¬„" at 3 (1 grapheme) becomes "ffl" (3 graphemes), there is a match on "l"


===============================================================================
2023 Nov 28

[Encoded strings]

https://github.com/unicode-org/icu4x/issues/4365
Segmenter does not work correctly in some languages
        let text = "as `à¦¨à¦®à¦¸à§à¦•à¦¾à§°, à¦†à¦ªà§‹à¦¨à¦¾à§° à¦•à¦¿ à¦–à¦¬à§°?`
    hi `à¤¹à¥ˆà¤²à¥‹, à¤•à¥à¤¯à¤¾ à¤¹à¤¾à¤² à¤¹à¥ˆà¤‚?`
    mai `à¤¨à¤®à¤¸à¥à¤¤à¥‡ à¤…à¤¹à¤¾à¤ à¤•à¥‡à¤¨à¤¾ à¤›à¤¥à¤¿?`
    mr `à¤¨à¤®à¤¸à¥à¤•à¤¾à¤°, à¤•à¤¸à¥‡ à¤†à¤¹à¤¾à¤¤?`
    ne `à¤¨à¤®à¤¸à¥à¤¤à¥‡, à¤•à¤¸à¥à¤¤à¥‹ à¤¹à¥à¤¨à¥à¤¹à¥à¤¨à¥à¤›?`
    or `à¬¨à¬®à¬¸à­à¬•à¬¾à¬° à¬¤à­à¬®à­‡ à¬•à­‡à¬®à¬¿à¬¤à¬¿ à¬…à¬›?`
    sa `à¤¹à¥‡ à¤¤à¥à¤µà¤‚ à¤•à¤¿à¤¦à¤‚ à¤…à¤¸à¤¿?`
    te `à°¹à°¾à°¯à±, à°Žà°²à°¾ à°‰à°¨à±à°¨à°¾à°°à±?`";
icu4c: 151
rust: 161
---
ICU4X and ICU4C are just using different definitions of EGCs; ICU4C has had a
tailoring for years which has just been incorporated into Unicode 15.1, whereas
ICU4X implements the 15.0 version without that tailoring.
The difference is the handling of aksaras in some indic scripts:
in Unicode 15.1 (and in any recent ICU4C) à¤•à¥à¤¯à¤¾ is one EGC, but it is two EGCs
(à¤•à¥, à¤¯à¤¾) in untailored Unicode 15.0 (and in ICU4X).
---
executor: 151
s="as `à¦¨à¦®à¦¸à§à¦•à¦¾à§°, à¦†à¦ªà§‹à¦¨à¦¾à§° à¦•à¦¿ à¦–à¦¬à§°?`"'0D'x"hi `à¤¹à¥ˆà¤²à¥‹, à¤•à¥à¤¯à¤¾ à¤¹à¤¾à¤² à¤¹à¥ˆà¤‚?`"'0D'x"mai `à¤¨à¤®à¤¸à¥à¤¤à¥‡ à¤…à¤¹à¤¾à¤ à¤•à¥‡à¤¨à¤¾ à¤›à¤¥à¤¿?`"'0D'x"mr `à¤¨à¤®à¤¸à¥à¤•à¤¾à¤°, à¤•à¤¸à¥‡ à¤†à¤¹à¤¾à¤¤?`"'0D'x"ne `à¤¨à¤®à¤¸à¥à¤¤à¥‡, à¤•à¤¸à¥à¤¤à¥‹ à¤¹à¥à¤¨à¥à¤¹à¥à¤¨à¥à¤›?`"'0D'x"or `à¬¨à¬®à¬¸à­à¬•à¬¾à¬° à¬¤à­à¬®à­‡ à¬•à­‡à¬®à¬¿à¬¤à¬¿ à¬…à¬›?`"'0D'x"sa `à¤¹à¥‡ à¤¤à¥à¤µà¤‚ à¤•à¤¿à¤¦à¤‚ à¤…à¤¸à¤¿?`"'0D'x"te `à°¹à°¾à°¯à±, à°Žà°²à°¾ à°‰à°¨à±à°¨à°¾à°°à±?`"
s~text~length=  -- 151


https://boyter.org/posts/unicode-support-what-does-that-actually-mean/
According wikipedia the character Å¿ is a long s. Which means if you want to
support unicode you need to ensure that if someone does a case insensitive
comparison then the following examples are all string equivalent.
Å¿ecret == secret == Secret
Å¿atisfaction == satisfaction == Å¿atiÅ¿faction == SatiÅ¿faction == SatiSfaction === Å¿atiSfaction
---
"Å¿"~text~casefold=                                      -- "s"
"Å¿ecret"~text~caselessEquals("secret")=                 -- 1
"Å¿ecret"~text~caselessEquals("Secret")=                 -- 1
"Å¿atisfaction"~text~caselessEquals("satisfaction")=     -- 1
"satisfaction"~text~caselessEquals("Å¿atiÅ¿faction")=     -- 1
"Å¿atiÅ¿faction"~text~caselessEquals("SatiÅ¿faction")=     -- 1
"SatiÅ¿faction"~text~caselessEquals("SatiSfaction")=     -- 1
"SatiSfaction"~text~caselessEquals("Å¿atiSfaction")=     -- 1


===============================================================================
2023 Nov 21

[Encoded strings]

To rework? matchChar sometimes returns .true whereas pos returns 0.
Examples in demoTextCompatibility:

KO? 2023.12.04: yes
"BundesschnellstraÃŸe"~text~caselessMatchChar(18, "s")=      -- 1
"BundesschnellstraÃŸe"~text~caselessPos("s", aslist:, aligned:0)=
    a List (5 items)
     0 : [+6.6,+7.7]
     1 : [+7.7,+8.8]
     2 : [+14.14,+15.15]
     3 : [+18.18,-18.19]
     4 : [-18.19,+19.20]


KO? 2023.12.04: yes
"BAFFLE"~text~caselessMatchChar(5, "ï¬„")=                    -- 1
"BAFFLE"~text~caselessPos("ï¬„", aslist:, aligned:0)=
    a List (1 items)
     0 : [+3.3,+6.6]


KO? 2023.12.04: yes
"baï¬„e"~text~matchChar(3, "f", normalization:.Unicode~NFKD)=     -- 1
"baï¬„e"~text~pos("f", normalization:.Unicode~NFKD, aslist:, aligned:0)=
    a List (2 items)
     0 : [+3.3,-3.4]
     1 : [-3.4,-3.5]


===============================================================================
2023 Nov 17

[Encoded strings]

Rework the implementation of caselessCompare, to get the right answer here:
"sss"~text~caselessCompare("", "ÃŸ")=                --  3 (not  4 because the 3rd  's' matches only half of the casefolded pad "ÃŸ" which is "ss")
"straÃŸssÃŸÃŸssse"~text~caselessCompare("stra", "ÃŸ")=  -- 12 (not 13 because the last 's' matches only half of the casefolded pad "ÃŸ" which is "ss")

Analysis using Unicode scalars:

-----------------------------------------
CASE 1 : aligned in self, aligned in arg1
-----------------------------------------

"straÃŸssÃŸÃŸssse"~text~compare("stra", "ÃŸ")=          --  6
    "straÃŸssÃŸÃŸssse"~text~unicode~c2g=
         1  2  3  4  5  6  7  8  9  0  1  2  3      -- (external character indexes)
         s  t  r  a  ÃŸ  s  s  ÃŸ  ÃŸ  s  s  s  e
         73 74 72 61 DF 73 73 DF DF 73 73 73 65     -- (unicode scalars)
    -------------------------------------------
    "straÃŸÃŸÃŸÃŸÃŸÃŸÃŸÃŸÃŸ"~text~unicode~c2g=
         1  2  3  4  5  6  7  8  9  0  1  2  3      -- (external character indexes)
         s  t  r  a  ÃŸ  ÃŸ  ÃŸ  ÃŸ  ÃŸ  ÃŸ  ÃŸ  ÃŸ  ÃŸ
         73 74 72 61 DF DF DF DF DF DF DF DF DF     -- (unicode scalars)
                        |
                        first different unicode scalar

/*
Debug output: the indexer supports the named parameter debug
"straÃŸssÃŸÃŸssse"~text~indexer~compare("stra", "ÃŸ", debug:.true)=
    selfTextTransformer~iSubtext~string = straÃŸssÃŸÃŸssse
    selfTextTransformer~iSubtext~c2g = 73 74 72 61 C39F 73 73 C39F C39F 73 73 73 65
    selfTextTransformedString~length = 16
    textTextTransformer~iSubtext~string = straÃŸÃŸÃŸÃŸÃŸÃŸÃŸÃŸÃŸ
    textTextTransformer~iSubtext~c2g = 73 74 72 61 C39F C39F C39F C39F C39F C39F C39F C39F C39F
    textTextTransformedString~length = 22
    posB1 = 7
    posC1 = +6.7
    posB2 = 7
    posC2 = +6.7
     6
*/


---------------------------------------------
CASE 2 : aligned in self, not aligned in arg1
---------------------------------------------

"straÃŸssÃŸÃŸssse"~text~caselessCompare("stra", "ÃŸ")=                              -- 12
    "straÃŸssÃŸÃŸssse"~text~unicode~c2g=
         1  2  3  4  5     6  7  8     9     0  1  2  3                         -- (external character indexes)
         s  t  r  a  ÃŸ     s  s  ÃŸ     ÃŸ     s  s  s  e
         73 74 72 61 DF    73 73 DF    DF    73 73 73 65                        -- (unicode scalars)
    "straÃŸssÃŸÃŸssse"~text~casefold~unicode~c2g=
         1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6                         -- (internal byte indexes)
         s  t  r  a  s  s  s  s  s  s  s  s  s  s  s  e
         73 74 72 61 73 73 73 73 73 73 73 73 73 73 73 65                        -- (unicode scalars)
    ----------------------------------------------------
    "straÃŸÃŸÃŸÃŸÃŸÃŸÃŸÃŸÃŸ"~text~unicode~c2g=
         1  2  3  4  5     6     7     8     9     0     1     2     3          -- (external character indexes)
         s  t  r  a  ÃŸ     ÃŸ     ÃŸ     ÃŸ     ÃŸ     ÃŸ     ÃŸ     ÃŸ     ÃŸ
         73 74 72 61 DF    DF    DF    DF    DF    DF    DF    DF    DF         -- (unicode scalars)
    "straÃŸÃŸÃŸÃŸÃŸÃŸÃŸÃŸÃŸ"~text~casefold~unicode~c2g=
         1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2       -- (internal byte indexes)
         s  t  r  a  ÃŸ     ÃŸ     ÃŸ     ÃŸ     ÃŸ     ÃŸ     ÃŸ     ÃŸ     ÃŸ
         73 74 72 61 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73      -- (unicode scalars)
                                                   |  |
                                                   |  +-- 65 at (13,16) <> 73 at (-10,+16) but can't be 13 because would match only the first 73 of ÃŸ at (10,15)
                                                   +-- yes, 12.

/*
Debug output: the indexer supports the named parameter debug
"straÃŸssÃŸÃŸssse"~text~indexer~caselessCompare("stra", "ÃŸ", debug:.true)=
    selfTextTransformer~iSubtext~string = strassssssssssse
    selfTextTransformer~iSubtext~c2g = 73 74 72 61 73 73 73 73 73 73 73 73 73 73 73 65
    selfTextTransformedString~length = 16
    textTextTransformer~iSubtext~string = strassssssssssssssssss
    textTextTransformer~iSubtext~c2g = 73 74 72 61 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73
    textTextTransformedString~length = 22
    posB1 = 16
    posC1 = +13.16
    posB2 = 16
    posC2 = -10.16
     12
*/

-- Another way to test: at which moment the growing padded string on the right will no longer be found at pos 1
--   1234567890123
    "straÃŸssÃŸÃŸssse"~text~caselessPos("straÃŸ")=          -- 1
--   straÃŸ
    "straÃŸssÃŸÃŸssse"~text~caselessPos("straÃŸÃŸ")=         -- 1
--   straÃŸÃŸ
    "straÃŸssÃŸÃŸssse"~text~caselessPos("straÃŸÃŸÃŸ")=        -- 1
--   straÃŸÃŸ ÃŸ
    "straÃŸssÃŸÃŸssse"~text~caselessPos("straÃŸÃŸÃŸÃŸ")=       -- 1
--   straÃŸÃŸ ÃŸÃŸ
    "straÃŸssÃŸÃŸssse"~text~caselessPos("straÃŸÃŸÃŸÃŸÃŸ")=      -- 1
--   straÃŸÃŸ ÃŸÃŸÃŸ
    "straÃŸssÃŸÃŸssse"~text~caselessPos("straÃŸÃŸÃŸÃŸÃŸÃŸ")=     -- 0    The last ÃŸ doesn't match "se" at 12
--   straÃŸÃŸ ÃŸÃŸÃŸ ÃŸ


---------------------------------------------
CASE 3 : not aligned in self, aligned in arg1
---------------------------------------------

"stra"~text~caselessCompare("straÃŸssÃŸÃŸssse", "ÃŸ")=  -- 9
    1  2  3  4  5     6     7     8     9     0     1     2     3               -- (external character indexes)
    s  t  r  a  ÃŸ     ÃŸ     ÃŸ     ÃŸ     ÃŸ     ÃŸ     ÃŸ     ÃŸ     ÃŸ
    1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2            -- (internal byte indexes)
    73 74 72 61 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73           -- (unicode scalars of the casefolded string)
    -----------------------------------------------------------------
    1  2  3  4  5     6  7  8     9     0  1  2  3                              -- (external character indexes)
    s  t  r  a  ÃŸ     s  s  ÃŸ     ÃŸ     s  s  s  e
    1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6                              -- (internal byte indexes)
    73 74 72 61 73 73 73 73 73 73 73 73 73 73 73 65                             -- (unicode scalars of the casefolded string)
                                        |        |
                                        |        + 73 at (-10,16) <> 65 at (13,16)
                                        +-- yes, 9.

/*
Debug output: the indexer supports the named parameter debug
"stra"~text~indexer~caselessCompare("straÃŸssÃŸÃŸssse", "ÃŸ", debug:.true)=
    selfTextTransformer~iSubtext~string = strassssssssssssssssss
    selfTextTransformer~iSubtext~c2g = 73 74 72 61 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73
    selfTextTransformedString~length = 22
    textTextTransformer~iSubtext~string = strassssssssssse
    textTextTransformer~iSubtext~c2g = 73 74 72 61 73 73 73 73 73 73 73 73 73 73 73 65
    textTextTransformedString~length = 16
    posB1 = 16
    posC1 = -10.16
    posB2 = 16
    posC2 = +13.16
     9
*/

"straÃŸ"        ~text~caselessCompare("straÃŸssÃŸÃŸssse", "ÃŸ")=  -- 9
"straÃŸÃŸ"       ~text~caselessCompare("straÃŸssÃŸÃŸssse", "ÃŸ")=  -- 9
"straÃŸÃŸÃŸ"      ~text~caselessCompare("straÃŸssÃŸÃŸssse", "ÃŸ")=  -- 9
"straÃŸÃŸÃŸÃŸ"     ~text~caselessCompare("straÃŸssÃŸÃŸssse", "ÃŸ")=  -- 9
"straÃŸÃŸÃŸÃŸÃŸ"    ~text~caselessCompare("straÃŸssÃŸÃŸssse", "ÃŸ")=  -- 9
"straÃŸÃŸÃŸÃŸÃŸÃŸ"   ~text~caselessCompare("straÃŸssÃŸÃŸssse", "ÃŸ")=  -- 9
"straÃŸÃŸÃŸÃŸÃŸÃŸÃŸ"  ~text~caselessCompare("straÃŸssÃŸÃŸssse", "ÃŸ")=  -- 9
"straÃŸÃŸÃŸÃŸÃŸÃŸÃŸÃŸ" ~text~caselessCompare("straÃŸssÃŸÃŸssse", "ÃŸ")=  -- 9

"straÃŸ"        ~text~caselessCompareTo("straÃŸssÃŸÃŸssse")=  -- -1
"straÃŸÃŸ"       ~text~caselessCompareTo("straÃŸssÃŸÃŸssse")=  -- -1
"straÃŸÃŸÃŸ"      ~text~caselessCompareTo("straÃŸssÃŸÃŸssse")=  -- -1
"straÃŸÃŸÃŸÃŸ"     ~text~caselessCompareTo("straÃŸssÃŸÃŸssse")=  -- -1
"straÃŸÃŸÃŸÃŸÃŸ"    ~text~caselessCompareTo("straÃŸssÃŸÃŸssse")=  -- -1     up to 9 characters, it's lesser
"straÃŸÃŸÃŸÃŸÃŸÃŸ"   ~text~caselessCompareTo("straÃŸssÃŸÃŸssse")=  -- 1      from 10 characters, it's greater
"straÃŸÃŸÃŸÃŸÃŸÃŸÃŸ"  ~text~caselessCompareTo("straÃŸssÃŸÃŸssse")=  -- 1
"straÃŸÃŸÃŸÃŸÃŸÃŸÃŸÃŸ" ~text~caselessCompareTo("straÃŸssÃŸÃŸssse")=  -- 1

"stra"     ~caselessCompare("strasssssse", "s")=    -- 11
"stra"~text~caselessCompare("strasssssse", "s")=    -- 11
"strasssssse"     ~caselessCompare("stra", "s")=    -- 11
"strasssssse"~text~caselessCompare("stra", "s")=    -- 11

"strÃ "     ~caselessCompare("strÃ sssssse", "s")=    -- 12
"strÃ "~text~caselessCompare("strÃ sssssse", "s")=    -- 11
"strÃ sssssse"     ~caselessCompare("strÃ ", "s")=    -- 12
"strÃ sssssse"~text~caselessCompare("strÃ ", "s")=    -- 11


-------------------------------------------------
CASE 4 : not aligned in self, not aligned in arg1
-------------------------------------------------

iota_dt = "\u{GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS}"~text~unescape
("a" iota_dt~casefold "b")~compare("a" iota_dt, normalization: 0)=  -- 3

/*
Debug output: the indexer supports the named parameter debug
("a" iota_dt~casefold "b")~indexer~compare("a" iota_dt, normalization: 0, debug:.true)=
    selfTextTransformer~iSubtext~string = a Î¹ÌˆÌ b
    selfTextTransformer~iSubtext~c2g = 61 20 CEB9CC88CC81 20 62
    selfTextTransformedString~length = 10
    textTextTransformer~iSubtext~string = a Î
    textTextTransformer~iSubtext~c2g = 61 20 CE90 20 20
    textTextTransformedString~length = 6
    posB1 = 4
    posC1 = -3.4
    posB2 = 4
    posC2 = -3.4
     3
*/


===============================================================================
2023 Oct 31

Installed Xcode 15.0.1
and now I get this error when trying to debug:
    MacBook Pro 2021 cannot run rexx.
    Domain: IDEFoundationErrorDomain
    Code: 3
    Recovery Suggestion: MacBook Pro 2021 runs macOS 13.5.2, which is lower than
    rexxâ€™s minimum deployment target of 14.0. Change your projectâ€™s minimum
    deployment target or upgrade MacBook Pro 2021â€™s version of macOS.
I modified Cmakelist.txt to always set CMAKE_OSX_DEPLOYMENT_TARGET
    #if( APPLE AND BUILD_OSX_UNIVERSAL_BINARIES )
    if( APPLE )
      set( CMAKE_OSX_DEPLOYMENT_TARGET 10.13.6 CACHE STRING  "" FORCE)
    endif()
NO EFFECT! WHY?
I use an Xcode project of type External Build System.
There is NO WAY to set a minimum deployment target in the GUI.
[later]
https://developer.apple.com/forums/thread/96361
This URL describes EXACTLY my problem and there is NO solution!
Ã‡a me pompe l'air :-((

https://cmake.org/cmake/help/latest/variable/CMAKE_OSX_DEPLOYMENT_TARGET.html
Environment variable
MACOSX_DEPLOYMENT_TARGET


===============================================================================
2023 Oct 28

[Unicode]

Upgrade to utf8proc version 2.9.0 with Unicode 15.1.0 support.

Unicode 15.1 adds 627 characters, for a total of 149,813 characters.
    .unicode~version=               -- 15.1.0
    call loadUnicodeCharacterNames
    .unicode~characters=            -- (an UnicodeCharacterSupplier count=44185 size=918000)
    call expandUnicodeCharacterIntervals
    .unicode~characters=            -- (an UnicodeCharacterSupplier count=149878 size=918000)

Note:
149813 is the number of character names in the file DerivedName.txt.
I get 149878 characters instead of 149813 (+65) because I include the control characters (they have only an alias, not a name)
    00..1F	32 control characters
    7F..9F	33 control characters

.unicode~characters~select{item~categoryName=="Cc"}==
    an Array (shape [65], 65 items)
     1  : ( ""    U+0000 Cc 0 "", "NULL", "NUL" )
     2  : ( ""    U+0001 Cc 0 "", "START OF HEADING", "SOH" )
     3  : ( ""    U+0002 Cc 0 "", "START OF TEXT", "STX" )
     4  : ( ""    U+0003 Cc 0 "", "END OF TEXT", "ETX" )
    ...


===============================================================================
2023 Oct 28

[Unicode]

Upgrade to ICU4X 1.3.2 for Windows ARM64
Currently no way to get the version of ICU4X, Unicode and CLDR using C++ FFI.
https://github.com/unicode-org/icu4x/discussions/4229


===============================================================================
2023 Oct 08

[Encoded strings]

Update the ICU4X binaries: release 1.3.2
Bad surprise: the dynamic library grows from 7 MB to 23-25 MB (yes!)
Still less than ICU but...


ICU4X FFI compilation error
    /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/classes/support/m17n/icu4x/ffi/diplomat/cpp/include/ICU4XLocale.hpp:244:33: error: ambiguous deduction for template arguments of 'Ok'
        diplomat_result_out_value = diplomat::Ok(std::monostate());
                                    ^
    /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/classes/support/m17n/icu4x/ffi/diplomat/cpp/include/diplomat_runtime.hpp:57:3: note: candidate function [with T = std::monostate]
      Ok(T&& i): inner(std::move(i)) {}
      ^
    /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/classes/support/m17n/icu4x/ffi/diplomat/cpp/include/diplomat_runtime.hpp:61:3: note: candidate function [with T = std::monostate, X = std::monostate, $2 = void]
      Ok(T i): inner(i) {}
      ^
---
https://github.com/unicode-org/icu4x/issues/4109
https://github.com/unicode-org/icu4x/issues/4135
---
For a total of 123 header files, 60 are in error.
I put the inclusion of these 60 headers in commment.


Still can't build ICU4X under Windows ARM because of error when running
    cargo install cargo-make
ring@0.16.21 is blocking since 1 year now.
And worst, the guy in charge of ring closed this ticket, saying that ring.17
will solve the problem. WHEN???
https://github.com/briansmith/ring/issues/1551
https://github.com/sagiegurari/cargo-make/issues/799
---
update 26/10/2023
ring 17 now appears in the build, but error about clang: "program not found".
The BUILDING.md file says "For Windows ARM64 targets (aarch64-pc-windows-msvc),
the Visual Studio Build Tools â€œVS 2022 C++ ARM64 build toolsâ€ and "clang"
components must be installed."
==> must install "C++ Clang Compiler for Windows (download 2.0 GB, install 8.34 GB)
==> now build ok


===============================================================================
2023 Oct 06

[Encoded strings]

Update library uni-algo from v1.0.0 to v1.1.0
https://github.com/uni-algo/uni-algo

.Unicode~unialgo_version=           -- '1.1.0'


===============================================================================
2023 Oct 04

[Encoded strings]

Reactivate the constraint "self~isCompatibleWithByteString" when converting a
RexxText to a String. It can be disabled by setting
    .Unicode~unckeckedConversionToString = .false
Currently, the only case where this constraint is disabled is when testing
the regular expressions in diary_examples.rex.


Some checks of encoding compatibiliy were missing.
Added in:
- compareText: caselessCompare, compare
- compareToText: caselessCompareTo, compareTo
- endsWithText: caselessEndsWith, endsWith
- matchCharText: caselessMatchChar, matchChar
- matchText: caselessMatch, match
- posText: caselessPos, pos


New supported methods:
- abs       forward to String, return a String
- b2x       forward to String, return a String
- bitAnd    forward to String, return a String
- bitOr     forward to String, return a String
- bitXor    forward to String, return a String
Examples:
    (-1)~text~abs=          -- 1
    ("-x")~text~abs=        -- ABS method target must be a number; found "-x".
    ("-Ã©")~text~abs=        -- UTF-8 not-ASCII '-Ã©' is not compatible with a Rexx numeric value.

    100~text~b2x=           -- 4
    "x"~text~b2x=           -- Only 0, 1, and whitespace characters are valid in a binary string; character found "x".
    "Ã©"~text~b2x=           -- UTF-8 not-ASCII 'Ã©' is not compatible with a Rexx numeric value.

    "12"x~text~bitAnd=                                  -- '[12]'   ("12"x)
    "73"x~text~bitAnd("27"x~text)=                      -- '#'      ("23"x)
    "13"x~text~bitAnd("5555"x~text)=                    -- '[11]U'  ("1155"x)
    "13"x~text~bitAnd("5555"x~text,"74"x~text)=         -- '[11]T'  ("1154"x)
    "pQrS"~text~bitAnd(,"DF"x~text("byte"))=            -- "PQRS"

    "12"x~text~bitOr=                                   -- '[12]'       ("12"x)
    "15"x~text~bitOr("24"x~text)=                       -- 5            ("35"x)
    "15"x~text~bitOr("2456"x~text)=                     -- '5V'         ("3556"x)
    "15"x~text~bitOr("2456"x~text,"F0"x~text("byte"))=  -- '5?'         ("35F6"x)
    "1111"x~text~bitOr(,"4D"x~text)=                    -- ']]'         ("5D5D"x)
    "pQrS"~text~bitOr(,"20"x~text)=                     -- "pqrs"

    "12"x~text~bitXor=                                  -- '[12]'       ("12"x)
    "12"x~text~bitXor("22"x~text)=                      -- 0            ("30"x)
    "1211"x~text~bitXor("22"x~text)=                    -- '0[11]'      ("3011"x)
    "1111"x~text~bitXor("444444"x~text)=                -- 'UUD'        ("555544"x)
    "1111"x~text~bitXor("444444"x~text,"40"x~text)=     -- 'UU[04]'     ("555504"x)
    "1111"x~text~bitXor(,"4D"x~text)=                   -- '\\'         ("5C5C"x)
    "C711"x~text~bitXor("222222"x~text," "~text)=       -- '?3[02]'     ("E53302"x)


Implementation of caselessStartsWith, startsWith:
(forwards to caselessPos or pos, and returns .true if result == 1)
(was already implemented, waiting for 'pos' implementation)
Examples:
    "PÃ¨re"~text~c2g=                                -- '50 C3A8 72 65'
    "PÃ¨re"~text~startsWith("50"x)=                  -- true
    "PÃ¨re"~text~startsWith("50C3"x)=                -- Invalid UTF-8 string     (utf8proc error because "50C3"x is an invalid UTF-8 encoding)
    "PÃ¨re"~text~startsWith("50C3"x~text("byte"))=   -- Encoding: cannot compare Byte not-ASCII 'P?' with UTF-8 not-ASCII 'PÃ¨re'
    "PÃ¨re"~text~startsWith("50C3A8"x)=              -- true

    "Ã©ÃŸï¬„"~text~c2g=                                 -- 'C3A9 C39F EFAC84'
    "Ã©ÃŸï¬„"~text~casefold~c2g=                        -- 'C3A9 73 73 66 66 6C'
    "Ã©ÃŸï¬„"~text~caselessStartsWith("Ã‰")=             -- true
    "Ã©ÃŸï¬„"~text~caselessStartsWith("Ã‰s")=            -- false
    "Ã©ÃŸï¬„"~text~caselessStartsWith("Ã‰ss")=           -- true
    "Ã©ÃŸï¬„"~text~caselessStartsWith("Ã‰ssf")=          -- false
    "Ã©ÃŸï¬„"~text~caselessStartsWith("Ã‰ssff")=         -- false
    "Ã©ÃŸï¬„"~text~caselessStartsWith("Ã‰ssffl")=        -- true

    "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~startsWith("noÃ«lðŸ‘©")=                       -- false
    "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~startsWith("noÃ«lðŸ‘©", aligned:.false)=       -- true
    "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~startsWith("noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€")=                  -- false
    "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~startsWith("noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€", aligned:.false)=  -- true
    "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~startsWith("noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§")=                 -- true


===============================================================================
2023 Oct 03

[Encoded strings]

Move the routine createCharacterTranscodingTable from byte_common.cls to
byte_encoding.cls. It's used only by Byte_Encoding and its subclasses.


The 'text' method of UnicodeCharacter has been replaced by 'transcodeTo'.
Reason 1: the byte encodings were not supported correctly.
Reason 2: the fact a transcoding is needed is against the definition of the
'text' method (apply a view on the bytes without modifying them).


Finalize the support of replacement character during transcoding.
A replacement character can be .nil or "" or a character.
When a character, it can be a String or a RexxText made of one codepoint or a UnicodeCharacter.
In all cases, the corresponding codepoint is used. This codepoint is transcoded to the target encoding.

Behavior when a source codepoint does not have a matching target codepoint:
- When the replacement character is .nil, an error is raised.
- When the replacement character is "", the source codepoint is ignored (not transcoded)
- Otherwise the source codepoint is replaced by the replacement character.

Reminder: if the 'strict' named argument is false (default) then the fallback
codepoint transcodings are used, if any. So when 'strict' is false, potentially
more source could be transcoded.

Examples:
    -- The Windows-1252 encoding has some fallback codepoint transcodings.
    -- HOP is one of them: 81x --> +U0081 only when strict:.false
    ("No" || "EB"x || "l" || "81"x)~text("windows-1252")~utf8(strict:.false)=   -- T'NoÃ«lÂ (strict:.false is the default)
    ("No" || "EB"x || "l" || "81"x)~text("windows-1252")~utf8(strict:.false)~unicodecharacters==
        an Array (shape [5], 5 items)
         1 : ( "N"   U+004E Lu 1 "LATIN CAPITAL LETTER N" )
         2 : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
         3 : ( "Ã«"   U+00EB Ll 1 "LATIN SMALL LETTER E WITH DIAERESIS" )
         4 : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
         5 : ( "Â"    U+0081 Cc 0 "", "HIGH OCTET PRESET", "HOP"
    ("No" || "EB"x || "l" || "81"x)~text("windows-1252")~utf8(strict:.true)=    -- Cannot convert windows-1252 not-ASCII character 129 (81) at byte-position 5 to UTF-8.

    "NoÃ«l\u{HOP}"~text("utf8")~unescape~transcodeTo("byte")=                    -- Cannot convert UTF-8 not-ASCII codepoint 235 (EB) at position 3 to Byte.
    "NoÃ«l\u{HOP}"~text("utf8")~unescape~transcodeTo("windows-1252")=            -- T'No?l?'
    "NoÃ«l\u{HOP}"~text("utf8")~unescape~transcodeTo("windows-1252")~c2x=        -- '4E 6F EB 6C 81'
    "NoÃ«l\u{HOP}"~text("utf8")~unescape~transcodeTo("windows-1252", strict:)=   -- Cannot convert UTF-8 not-ASCII codepoint 129 (81) at position 5 to windows-1252.

    -- "byte" encoding: only 00..7F can be transcoded
    ("No" || "EB"x || "l" || "81"x)~text("byte")~utf8=                                                      -- Cannot convert Byte not-ASCII character 235 (EB) at byte-position 3 to UTF-8.
    ("No" || "EB"x || "l" || "81"x)~text("byte")~utf8(replacementCharacter:"")=                             -- T'Nol'
    ("No" || "EB"x || "l" || "81"x)~text("byte")~utf8(replacementCharacter:"#")=                            -- T'No#l#'      1 replacement character for Ã« because "Ã«" is 'EB'x
    ("No" || "EB"x || "l" || "81"x)~text("byte")~utf8(replacementCharacter:"ðŸŽ…")=                           -- T'NoðŸŽ…lðŸŽ…'
    ("No" || "EB"x || "l" || "81"x)~text("byte")~utf8(replacementCharacter:"ðŸŽ…"~text)=                      -- T'NoðŸŽ…lðŸŽ…'
    ("No" || "EB"x || "l" || "81"x)~text("byte")~utf8(replacementCharacter:.unicode["Father Christmas"])=   -- T'NoðŸŽ…lðŸŽ…'

    "NoÃ«l"~text("byte")~utf8(replacementCharacter:"")=                          -- T'Nol'
    "NoÃ«l"~text("byte")~utf8(replacementCharacter:"#")=                         -- T'No##l'         2 replacement characters for Ã« because "Ã«" is 'C3 AB'x
    "NoÃ«l"~text("byte")~utf8(replacementCharacter:"ðŸŽ…")=                        -- T'NoðŸŽ…ðŸŽ…l'
    "NoÃ«l"~text("byte")~utf8(replacementCharacter:"ðŸŽ…ðŸŽ…")=                     -- The transcoded replacement character must have at most one codepoint, got UTF-8 not-ASCII (2 characters, 2 codepoints, 8 bytes, 0 error) 'ðŸŽ…ðŸŽ…'.
    "NoÃ«l"~text("byte")~utf8(replacementCharacter:"ðŸŽ…ðŸŽ…"~text)=                -- The transcoded replacement character must have at most one codepoint, got UTF-8 not-ASCII (2 characters, 2 codepoints, 8 bytes, 0 error) 'ðŸŽ…ðŸŽ…'.

    "NoÃ«l"~text("utf8")~transcodeTo("byte")=                                    -- Cannot convert UTF-8 not-ASCII codepoint 235 (EB) at position 3 to Byte.
    "NoÃ«l"~text("utf8")~transcodeTo("byte", replacementCharacter:"")=           -- T'Nol'
    "NoÃ«l"~text("utf8")~transcodeTo("byte", replacementCharacter:"#")=          -- T'No#l'
    "NoÃ«l"~text("utf8")~transcodeTo("byte", replacementCharacter:"ðŸŽ…")=         -- The replacement character UTF-8 not-ASCII 'ðŸŽ…' cannot be transcoded to Byte.

    "NoÃ«lðŸ¤¶"~text("utf8")~transcodeTo("unicode", replacementCharacter:"ðŸŽ…")=        -- T'N[000000]o[000000]?[000000]l[000000]??[0100]'
    "NoÃ«lðŸ¤¶"~text("utf8")~transcodeTo("unicode", replacementCharacter:"ðŸŽ…")~c2x=    -- '4E000000 6F000000 EB000000 6C000000 36F90100'
    "NoÃ«lðŸ¤¶"~text("utf8")~transcodeTo("unicode", replacementCharacter:"ðŸŽ…")~c2u=    -- 'U+004E U+006F U+00EB U+006C U+1F936'

    "NoÃ«lðŸ¤¶"~text("utf8")~transcodeTo("unicode8", replacementCharacter:"")=          -- T'No?l'
    "NoÃ«lðŸ¤¶"~text("utf8")~transcodeTo("unicode8", replacementCharacter:"")~c2x=      -- '4E 6F EB 6C'
    "NoÃ«lðŸ¤¶"~text("utf8")~transcodeTo("unicode8", replacementCharacter:"#")=         -- T'No?l#'
    "NoÃ«lðŸ¤¶"~text("utf8")~transcodeTo("unicode8", replacementCharacter:"#")~c2x=     -- '4E 6F EB 6C 23'
    "NoÃ«lðŸ¤¶"~text("utf8")~transcodeTo("unicode8", replacementCharacter:"ðŸŽ…")=       -- The replacement character UTF-8 not-ASCII 'ðŸŽ…' cannot be transcoded to Unicode8.

    "NoÃ«lðŸ¤¶"~text("utf8")~transcodeTo("unicode16", replacementCharacter:"")=         -- T'N[00]o[00]?[00]l[00]'
    "NoÃ«lðŸ¤¶"~text("utf8")~transcodeTo("unicode16", replacementCharacter:"#")=        -- T'N[00]o[00]?[00]l[00]#[00]'
    "NoÃ«lðŸ¤¶"~text("utf8")~transcodeTo("unicode16", replacementCharacter:"#")~c2x=    -- '4E00 6F00 EB00 6C00 2300'
    "NoÃ«lðŸ¤¶"~text("utf8")~transcodeTo("unicode16", replacementCharacter:"#")~c2u=    -- 'U+004E U+006F U+00EB U+006C U+0023'
    "NoÃ«lðŸ¤¶"~text("utf8")~transcodeTo("unicode16", replacementCharacter:"ðŸŽ…")=      -- The replacement character UTF-8 not-ASCII 'ðŸŽ…' cannot be transcoded to Unicode16.

    "NoÃ«lðŸ¤¶"~text("utf8")~transcodeTo("unicode32")=         -- T'N[000000]o[000000]?[000000]l[000000]6?[0100]'
    "NoÃ«lðŸ¤¶"~text("utf8")~transcodeTo("unicode32")~c2x=     -- '4E000000 6F000000 EB000000 6C000000 36F90100'
    "NoÃ«lðŸ¤¶"~text("utf8")~transcodeTo("unicode32")~c2u=     -- 'U+004E U+006F U+00EB U+006C U+1F936'


The method c2u is no longer abstract for the byte encodings.
Now, a byte encoding is converted on the fly to UnicodeN in non strict mode,
replacing any unsupported character by .Unicode~replacementCharacter.
Idem for the method unicodeCharacters.
Examples:
    "FF FE FD FC"x~text("byte")~c2x=                                               -- 'FF FE FD FC'
    "FF FE FD FC"x~text("byte")~c2g=                                               -- 'FF FE FD FC'
    "FF FE FD FC"x~text("byte")~codepoints==
        a CodePointSupplier
         1 :  255
         2 :  254
         3 :  253
         4 :  252
    "FF FE FD FC"x~text("byte")~c2u=                                               -- 'U+FFFD U+FFFD U+FFFD U+FFFD'
    "FF FE FD FC"x~text("byte")~unicodeCharacters==
        an Array (shape [4], 4 items)
         1 : ( "ï¿½"   U+FFFD So 1 "REPLACEMENT CHARACTER" )
         2 : ( "ï¿½"   U+FFFD So 1 "REPLACEMENT CHARACTER" )
         3 : ( "ï¿½"   U+FFFD So 1 "REPLACEMENT CHARACTER" )
         4 : ( "ï¿½"   U+FFFD So 1 "REPLACEMENT CHARACTER" )

    "FF FE FD FC"x~text("utf8")~c2x=                                               -- 'FF FE FD FC'
    "FF FE FD FC"x~text("utf8")~c2g=                                               -- 'FF FE FD FC'
    "FF FE FD FC"x~text("utf8")~c2u=                                               -- 'U+FFFD U+FFFD U+FFFD U+FFFD'
    "FF FE FD FC"x~text("utf8")~codepoints==
        a CodePointSupplier
         1 :  65533
         2 :  65533
         3 :  65533
         4 :  65533

    "FF FE FD FC"x~text("unicode8")~c2x=                                           -- 'FF FE FD FC'
    "FF FE FD FC"x~text("unicode8")~c2g=                                           -- 'FF FE FD FC'
    "FF FE FD FC"x~text("unicode8")~codepoints==
        a CodePointSupplier
         1 :  255
         2 :  254
         3 :  253
         4 :  252
    "FF FE FD FC"x~text("unicode8")~c2u=                                           -- 'U+00FF U+00FE U+00FD U+00FC'
    "FF FE FD FC"x~text("unicode8")~unicodecharacters==
        an Array (shape [4], 4 items)
         1 : ( "Ã¿"   U+00FF Ll 1 "LATIN SMALL LETTER Y WITH DIAERESIS" )
         2 : ( "Ã¾"   U+00FE Ll 1 "LATIN SMALL LETTER THORN" )
         3 : ( "Ã½"   U+00FD Ll 1 "LATIN SMALL LETTER Y WITH ACUTE" )
         4 : ( "Ã¼"   U+00FC Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS" )

    ("No" || "EB"x || "l" || "81"x)~text("byte")~c2x=                           -- '4E 6F EB 6C 81'
    ("No" || "EB"x || "l" || "81"x)~text("byte")~c2g=                           -- '4E 6F EB 6C 81'
    ("No" || "EB"x || "l" || "81"x)~text("byte")~c2u=                           -- 'U+004E U+006F U+FFFD U+006C U+FFFD'
    ("No" || "EB"x || "l" || "81"x)~text("byte")~unicodecharacters==
        an Array (shape [5], 5 items)
         1 : ( "N"   U+004E Lu 1 "LATIN CAPITAL LETTER N" )
         2 : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
         3 : ( "ï¿½"   U+FFFD So 1 "REPLACEMENT CHARACTER" )
         4 : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
         5 : ( "ï¿½"   U+FFFD So 1 "REPLACEMENT CHARACTER" )

    ("No" || "EB"x || "l" || "81"x)~text("windows-1252")~c2x=                   -- '4E 6F EB 6C 81'
    ("No" || "EB"x || "l" || "81"x)~text("windows-1252")~c2g=                   -- '4E 6F EB 6C 81'
    ("No" || "EB"x || "l" || "81"x)~text("windows-1252")~c2u=                   -- 'U+004E U+006F U+00EB U+006C U+0081'
    ("No" || "EB"x || "l" || "81"x)~text("windows-1252")~unicodecharacters==
        an Array (shape [5], 5 items)
         1 : ( "N"   U+004E Lu 1 "LATIN CAPITAL LETTER N" )
         2 : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
         3 : ( "Ã«"   U+00EB Ll 1 "LATIN SMALL LETTER E WITH DIAERESIS" )
         4 : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
         5 : ( "Â"    U+0081 Cc 0 "", "HIGH OCTET PRESET", "HOP" )


===============================================================================
2023 Sep 28

[Encoded strings]

Better names for inflating and deflating transformations:
    https://www.unicode.org/reports/tr10/#Expansions
    https://www.unicode.org/reports/tr10/#Contractions
See also
    http://www.unicode.org/reports/tr35/tr35-collation.html#Context_Sensitive_Mappings

RexxTextTransformer: the next step could be collation folding... But that sounds
way more complicated than what is implemented currently.
https://www.unicode.org/reports/tr10/#Collation_Folding
    Ignorable characters need special handling (jlf: the problem is not ignoring
    ignorable characters, it's already supported with stripIgnorable. The problem
    is "In some contexts, however, fully ignorable characters may have an effect
    on comparison, or characters that are not ignorable at the given strength
    level may be treated as ignorable."
https://unicode-org.atlassian.net/browse/ICU-22422
    Markus Scherer:
    This is â€œeasy except for the complicated casesâ€, around normalization,
    contractions, expansions, and prefix matching.
    It probably requires a fair bit of design and code, and maybe more data
    (computed/cached, or prebuilt).


===============================================================================
2023 Sep 27

[Encoded strings]

Add the named parameters 'stripCC' and 'stripNA' to all the methods supporting
the named parameter 'normalization'. This is utf8proc specific.
- stripCC: remove control characters (see utf8proc doc for more information:
  HorizontalTab (HT) and FormFeed (FF) are transformed into space)
- stripNA: remove unassigned codepoints
Example:
    .unicode["ESA"]=        -- ( "Â‡"    U+0087 Cc 0 "", "END OF SELECTED AREA", "ESA"
    .unicode["NBSP"]=       -- ( "Â "   U+00A0 Zs 1 "NO-BREAK SPACE", "NBSP" )
    .unicode["SSA"]=        -- ( "Â†"    U+0086 Cc 0 "", "START OF SELECTED AREA", "SSA"
    .unicode["U+0378"]=     -- ( "Í¸"   U+0378 Cn 1 "" )     unassigned

    "\U{SSA}Mrs.\U{NBSP}ðŸ¤¶ a\u0378nd Mr.\U{NBSP}ðŸŽ…\U{ESA}"~text~unescape=                                         -- T'Â†Mrs.Â ðŸ¤¶ aÍ¸nd Mr.Â ðŸŽ…
    "\U{SSA}Mrs.\U{NBSP}ðŸ¤¶ a\u0378nd Mr.\U{NBSP}ðŸŽ…\U{ESA}"~text~unescape~c2g=                                     -- 'C286 4D 72 73 2E C2A0 F09FA4B6 20 61 CDB8 6E 64 20 4D 72 2E C2A0 F09F8E85 C287'
    "\U{SSA}Mrs.\U{NBSP}ðŸ¤¶ a\u0378nd Mr.\U{NBSP}ðŸŽ…\U{ESA}"~text~unescape~transform(stripNA:)~c2g=                 -- 'C286 4D 72 73 2E C2A0 F09FA4B6 20 61      6E 64 20 4D 72 2E C2A0 F09F8E85 C287'
    "\U{SSA}Mrs.\U{NBSP}ðŸ¤¶ a\u0378nd Mr.\U{NBSP}ðŸŽ…\U{ESA}"~text~unescape~transform(stripNA:, stripCC:)~c2g=       -- '     4D 72 73 2E C2A0 F09FA4B6 20 61      6E 64 20 4D 72 2E C2A0 F09F8E85     '

    "\U{SSA}Mrs.\U{NBSP}ðŸ¤¶ a\u0378nd Mr.\U{NBSP}ðŸŽ…\U{ESA}"~text~unescape~pos("and")=                              -- 0
    "\U{SSA}Mrs.\U{NBSP}ðŸ¤¶ a\u0378nd Mr.\U{NBSP}ðŸŽ…\U{ESA}"~text~unescape~pos("and", stripNA:)=                    -- 9
    "\U{SSA}Mrs.\U{NBSP}ðŸ¤¶ a\u0378nd Mr.\U{NBSP}ðŸŽ…\U{ESA}"~text~unescape~pos("and", stripNA:, stripCC:)=          -- 9    yes! 9, not 8 because it's the EXTERNAL position

    "\U{SSA}Mrs.\U{NBSP}ðŸ¤¶ a\u0378nd Mr.\U{NBSP}ðŸŽ…\U{ESA}"~text~unescape~caselessPos("mr.")=                      -- 14
    "\U{SSA}Mrs.\U{NBSP}ðŸ¤¶ a\u0378nd Mr.\U{NBSP}ðŸŽ…\U{ESA}"~text~unescape~caselessPos("mr.", stripNA:)=            -- 14   yes! 14, not 13
    "\U{SSA}Mrs.\U{NBSP}ðŸ¤¶ a\u0378nd Mr.\U{NBSP}ðŸŽ…\U{ESA}"~text~unescape~caselessPos("mr.", stripNA:, stripCC:)=  -- 14   yes! 14, not 12

    "\U{SSA}Mrs.\U{NBSP}ðŸ¤¶ a\u0378nd Mr.\U{NBSP}ðŸŽ…\U{ESA}"~text~unescape~caselessPos("\U{SSA}"~text~unescape)=              -- 1
    "\U{SSA}Mrs.\U{NBSP}ðŸ¤¶ a\u0378nd Mr.\U{NBSP}ðŸŽ…\U{ESA}"~text~unescape~caselessPos("\U{SSA}"~text~unescape, stripCC:)=    -- 0

    "\U{SSA}Mrs.\U{NBSP}ðŸ¤¶ a\u0378nd Mr.\U{NBSP}ðŸŽ…\U{ESA}"~text~unescape~caselessPos("a\u0378nd"~text~unescape)=                        -- 9
    "\U{SSA}Mrs.\U{NBSP}ðŸ¤¶ a\u0378nd Mr.\U{NBSP}ðŸŽ…\U{ESA}"~text~unescape~caselessPos("a\u0378nd"~text~unescape, stripCC:)=              -- 9
    "\U{SSA}Mrs.\U{NBSP}ðŸ¤¶ a\u0378nd Mr.\U{NBSP}ðŸŽ…\U{ESA}"~text~unescape~caselessPos("a\u0378nd"~text~unescape, stripNA:)=              -- 9    yes! 9, not 0 because \u0378 is removed both in the needle and in thehaystack
    "\U{SSA}Mrs.\U{NBSP}ðŸ¤¶ a\u0378nd Mr.\U{NBSP}ðŸŽ…\U{ESA}"~text~unescape~caselessPos("a\u0378nd"~text~unescape, stripNA:, stripCC:)=    -- 9    yes! 9, not 8


caselessEndsWith, endsWith: returns false if the start of the 'other' string is
not aligned with a character.
Examples
    "#Ã©ÃŸï¬„#â€¦"~text~endsWith("â€¦")=                      -- true
    "#Ã©ÃŸï¬„#â€¦"~text~caselessEndsWith("â€¦")=              -- true

    "#Ã©ÃŸï¬„#â€¦"~text~endsWith("fl#â€¦")=                   -- false, ï¬„ remains ï¬„
    "#Ã©ÃŸï¬„#â€¦"~text~caselessEndsWith("FL#â€¦")=           -- false, ï¬„ becomes ffl but FL is not aligned with ffl

    "#Ã©ÃŸï¬„#â€¦"~text~endsWith("ï¬„#â€¦")=                   -- true
    "#Ã©ÃŸï¬„#â€¦"~text~caselessEndsWith("ï¬„#â€¦")=           -- true

    "#Ã©ÃŸï¬„#â€¦"~text~endsWith("ffl#â€¦")=                  -- false, ï¬„ remains ï¬„
    "#Ã©ÃŸï¬„#â€¦"~text~caselessEndsWith("FFL#â€¦")=          -- true,  ï¬„ becomes ffl and FFL is aligned with ffl

    "#Ã©ÃŸï¬„#â€¦"~text~endsWith("sï¬„#â€¦")=                  -- false, ÃŸ remains ÃŸ
    "#Ã©ÃŸï¬„#â€¦"~text~caselessEndsWith("Sï¬„#â€¦")=          -- false, ÃŸ becomes ss but s is not aligned with ss

    "#Ã©ÃŸï¬„#â€¦"~text~endsWith("ÃŸï¬„#â€¦")=                  -- true
    "#Ã©ÃŸï¬„#â€¦"~text~caselessEndsWith("ÃŸï¬„#â€¦")=          -- true

    "#Ã©ÃŸï¬„#â€¦"~text~endsWith("ssï¬„#â€¦")=                 -- false, ÃŸ remains ÃŸ
    "#Ã©ÃŸï¬„#â€¦"~text~caselessEndsWith("SSï¬„#â€¦")=         -- true,  ÃŸ becomes ss

    "#Ã©ÃŸï¬„#â€¦"~text~endsWith("Ã©ÃŸï¬„#â€¦")=                 -- true
    "#Ã©ÃŸï¬„#â€¦"~text~caselessEndsWith("Ã‰SSFFL#â€¦")=       -- true

    "#Ã©ÃŸï¬„#â€¦"~text~endsWith("#Ã©ÃŸï¬„#â€¦")=                -- true
    "#Ã©ÃŸï¬„#â€¦"~text~caselessEndsWith("#Ã‰SSFFL#â€¦")=      -- true

    "#e\U{COMBINING ACUTE ACCENT}ÃŸï¬„#â€¦"~text~unescape~c2g=                                                                   -- '23 65CC81 C39F EFAC84 23 E280A6'
      "\U{COMBINING ACUTE ACCENT}ÃŸï¬„#â€¦"~text~unescape~c2g=                                                                   -- '     CC81 C39F EFAC84 23 E280A6'
    "#e\U{COMBINING ACUTE ACCENT}ÃŸï¬„#â€¦"~text~unescape~endsWith("\U{COMBINING ACUTE ACCENT}ÃŸï¬„#â€¦"~text~unescape)=             -- false, not aligned with e\U{COMBINING ACUTE ACCENT}

    "#e\U{COMBINING ACUTE ACCENT}ÃŸï¬„#â€¦"~text~unescape~casefold~c2g=                                                          -- '23 65CC81 73 73 66 66 6C 23 E280A6'
      "\U{COMBINING ACUTE ACCENT}SSFFL#â€¦"~text~unescape~casefold~c2g=                                                        -- '     CC81 73 73 66 66 6C 23 E280A6'
    "#e\U{COMBINING ACUTE ACCENT}ÃŸï¬„#â€¦"~text~unescape~caselessEndsWith("\U{COMBINING ACUTE ACCENT}SSFFL#â€¦"~text~unescape)=   -- false, not aligned with e\U{COMBINING ACUTE ACCENT}


New 'RexxTextTransformer' class:
    - Converts positions in a transformed string to positions in the corresponding
      untransformed string. This is used for the caselessXXX methods which takes
      or returns positions.
    - Supports inflating and deflating transformations.
      jlf 2023 Sep 28: better names are expansion and contraction.
    - The transformation can be made on a part of the string (from startC, for
      lengthC characters).
    - The methods for the transformation are the same as for RexxText:
      NFC, NFD, NFKC, NFKD, casefold, transform. The result is the instance of
      RexxTextTransformer, not the transformed text.
    - Only one call to a transformation method can be done. This is because the
      parameters of the transformation are memorized to re-apply internally the
      transformation character by character, when moving the cursors.
    - The 'transformer' method lets create an instance of RexxTextTransformer
      from a text.

    Example:
        - full text        = original text (untransformed)
        - external subtext = part of the full text to transform
        - internal subtext = transformed part of the full text

        The method ib2xc converts an internal byte (ib) position in the internal
        subtext (iSubtext) to an external character (xc) position in the external
        full text.
        ib2xc supports only growing positions. The only way to go backward is to
        use backupPos/restorePos or resetPos.

                                     --                          Transformed part of the full text
                                     --                       +-------------------------------------+               -- GLOBAL INDEXES (offsetC=3, offsetB=7)
                                     --  01   | 02   | 03     | 04 | 05     | 06    | 07       | 08 | 09            -- (external character indexes) <--------+
                                     --  1 2  | 3 4  | 5 6 7  | 8  | 9 0    | 1 2   | 3 4 5    | 6  | 7 8 9         -- (external byte indexes)               |
            "Ã©ÃŸï¬„#Ã©ÃŸï¬„#â€¦"~text~c2g   --  C3A9 | C39F | EFAC84 | 23 | C3A9   | C39F  | EFAC84   | 23 | E280A6        -- (external bytes)                      |
                                     --  Ã©    | ÃŸ    | ï¬„     | #  | Ã©      | ÃŸ     | ï¬„       | #  | â€¦             -- (full text)                           ^
                                     --  1 2  | 3 4  | 5 6 7  | 8  | 9 0 1  | 2  3  | 4  5  6  | 7  | 8 9 0         -- (internal byte indexes, offset=7)     |
                                     --  C3A9 | C39F | EFAC84 | 23 | 65CC81 | 73 73 | 66 66 6C | 23 | E280A6        -- (internal bytes)                      |
                                                              +-------------------------------------+                                                        |
                                                                                                                    -- RELATIVE INDEXES                      |
                                                            --  01 | 02     | 03    | 04       | 05                 -- (external character indexes) <--------+
                                                            --  1  | 2 3    | 4 5   | 6 7 8    | 9                  -- (external byte indexes)               |
            "#Ã©ÃŸï¬„#"~text~c2g=                              --  23 | C3A9   | C39F  | EFAC84   | 23                 -- (external bytes)                      |
                                                            --  #  | Ã©      | ÃŸ     | ï¬„       | #                  -- (external subtext)                    ^
                                                                                                                                                             |
                                                                                                                    -- RELATIVE INDEXES                      |
                                                            --  01 | 02     | 03 04 | 05 06 07 | 08                 -- (internal character indexes)          |
                                                            --  1  | 2 3 4  | 5  6  | 7  8  9  | 0                  -- (internal byte indexes) ------>-------+
            "#Ã©ÃŸï¬„#"~text~NFD(casefold:)~c2g=               --  23 | 65CC81 | 73 73 | 66 66 6C | 23                 -- (internal bytes)
                                                            --  #  | Ã©      | s  s  | f  f  l  | #                  -- (internal subtext)

            transformer = "Ã©ÃŸï¬„#Ã©ÃŸï¬„#â€¦"~text~transformer(4, 5)~NFD(casefold:)
            transformer~fulltext=       -- T'Ã©ÃŸï¬„#Ã©ÃŸï¬„#â€¦'
            transformer~xSubtext=       -- T'#Ã©ÃŸï¬„#'
            transformer~iSubtext=       -- T'#eÌssffl#'

            -- ib2xc supports only growing positions
            transformer~ib2xc(1)=       -- 4    the internal byte position 1 in the internal subtext corresponds to the 4th external character in the full text
            transformer~ib2xc(7)=       -- 7
            transformer~ib2xc(2)=       -- Error RexxTextTransformer: You specified a byte position (2) lower than the previous one (7).

            -- The previous error is avoided by backuping/restoring the current position
            transformer~resetPos        -- reset to allow iteration again from internal byte position 1
            transformer~ib2xc(1)=       -- 4
            transformer~backupPos
            transformer~ib2xc(7)=       -- 7
            transformer~restorePos
            transformer~ib2xc(2)=       -- 5

            transformer~resetPos
            do i=1 to transformer~iSubtext~string~length; say "byte pos" i~right(2) "    character pos=" transformer~ib2xc(i)~string~left(20) transformer~ib2xc(i, aligned:.false); end
            /*
                byte pos  1     character pos= 4                    +4.8    -- the 8th internal byte is aligned with the 4th external character
                byte pos  2     character pos= 5                    +5.9
                byte pos  3     character pos= The NIL object       -5.10   -- the 10th internal byte is part of the 5th external character, but is not aligned with it.
                byte pos  4     character pos= The NIL object       -5.11
                byte pos  5     character pos= 6                    +6.12
                byte pos  6     character pos= The NIL object       -6.13
                byte pos  7     character pos= 7                    +7.14
                byte pos  8     character pos= The NIL object       -7.15
                byte pos  9     character pos= The NIL object       -7.16
                byte pos 10     character pos= 8                    +8.17
            */
            /*
                More details on positions mappings.
                transformer~iSubtext is the transformed part of the full text.
                The internal relative byte position 1 becomes the internal global byte position 8:
                    There are 7 bytes (offsetB=7) before the part to transform: 1 + 7 = 8.
                    It's the same offsetB=7 for external and internal bytes, because this part is not transformed.
                    Remember:
                    It doesn't make sense to return the external byte position, because some internal byte positions
                    have no corresponding external byte position. For example the internal global byte position 11.
                    For diagnostics and analysis, only internal byte positions are relevant.
                The external relative character position 1 becomes the external global character position 4:
                    There are 3 characters (offsetC=3) before the part to transform: 1 + 3 = 4.
                    It's the same offsetC=3 for external and internal characters, because this part is not transformed.
                    Remember:
                    The user works only with external global character positions.
                    It wouldn't make sense to return internal character positions.
                Example of alignment:
                    The internal relative byte position 1 becomes the internal global byte position 8,
                    is part of the 4th external character and is aligned with it.
                Example of non-alignment:
                    The internal relative byte position 3 becomes the internal global byte position 10,
                    is part of the 5th external character and is not aligned with it.
            */


===============================================================================
2023 Sep 22

[Named arguments]

Remove the possibility to indicate a minimum length.
The rules were too constraining, in particular this one: "No named parameter
name must start with the name of another named parameter". This rule was set
to have better error messages in case of ambiguity because of the minimum length.
And I found recently that it can be tedious to keep the minimum length aligned
in all the methods using the same named arguments.


===============================================================================
2023 Sep 18

[Encoded strings]

Relax the constraint "self~isCompatibleWithByteString" when converting a RexxText
to a String.
That allows to go further in the tests of regular expression.


===============================================================================
2023 Sep 14

[Encoded strings]

Fix implementation of caselessPos, pos for ligatures.
The results were not good for some byte indexes when using aligned:.false


===============================================================================
2023 Sep 11

[Encoded strings]

casefold now supports the option stripMark.

Rework the implementation of caselessPos, pos.
- Thanks to Raku and Chrome, I realize that a matching should be succesful only
  if all the bytes of a grapheme are matched.
- New named argument 'asList', to return a list of positions
  (similar to Raku's method .indices).
- New named argument overlap: (same as Raku)
  If the optional named argument 'overlap' is specified, the search continues
  from the position directly following the previous match, otherwise the search
  will continue after the previous match.

Remember:
aligned=.false is intended for analysis of matchings and [non-]regression tests.
Otherwise, I don't see any use.
When aligned:.false, a returned position has the form +/-posC.posB where posB is
the position of the matched byte in the transformed haystack, and posC is the
corresponding grapheme position in the untransformed haystack.
Don't use trunc(abs(position)) because you may need up to numeric digits 40:
    position max can be +/-(2**64-1)||"."||(2**64-1)
Use instead:
    if position~matchChar(1, "+-") then parse var position 2 posC "." posB


Additional test cases to cover corner cases for caselessPos, pos.


===============================================================================
2023 Sep 07

[Error messages]

Regression after alignment of CMakeLists.txt:
Cannot open REXX message catalog rexx.cat.  Not in NLSPATH or bin.
Error code= 35.1
---
Fixed by defining NLSPATH="$builder_delivery_dir/bin/rexx.cat"


===============================================================================
2023 Sep 06

[Encoded strings]

Update library uni-algo from v0.8.1 to v1.0.0
https://github.com/uni-algo/uni-algo

.Unicode~unialgo_version=           -- '1.0.0'


[build]

After installation of a new version of CMake (3.27.4) under MacOs, I have plenty
of warnings:
    CMake Deprecation Warning at samples/CMakeLists.txt:48 (cmake_policy):
      Compatibility with CMake < 3.5 will be removed from a future version of
      CMake.

      Update the VERSION argument <min> value or use a ...<max> suffix to tell
      CMake that the project does not need compatibility with older versions.
Fixed by changing
    cmake_policy(VERSION 2.8...3.3)
to
    cmake_policy(VERSION 2.8...3.5)
in all the CMakeLists.txt


[build]
Continue to align CMakeLists.txt with ooRexx5:
- use relative paths for bin, include, lib, etc...
- no longer put samples binaries in bin.


[build]
I don't know how to get ride of this warning under macOS:
    [ 70%] Linking CXX shared library lib/librexx.dylib
    ld: warning:
    dylib (/local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/classes/support/m17n/icu4x/target/aarch64-apple-darwin/release/libicu_capi_cdylib.dylib)
    was built for newer macOS version (12.0) than being linked (11.0)
My system is Ventura 13.5!!!!
Why does it complain about 11.0????
I updated the Xcode command line tools with
    xcode-select --install
but the warning is still displayed.
Ã‡a me pompe l'air :-((
Later:
The warning disappeared after deactivating these lines in the builder script setenv-macos-arm64:
#export MACOSX_DEPLOYMENT_TARGET=10.13
#export CXXFLAGS="-stdlib=libc++ -mmacosx-version-min=$MACOSX_DEPLOYMENT_TARGET $CXXFLAGS"
#export LDFLAGS="-stdlib=libc++ -mmacosx-version-min=$MACOSX_DEPLOYMENT_TARGET $LDFLAGS"
(For the records, changing 10.13 to 12 did not fix the warning, I still don't know from where came this 11.0)

Other problem:
when I do a build with existing binaries, I get this error (not blocking the delivery):
    -- Up-to-date: /Users/Shared/local/rexx/oorexx/build/executor.master/sandbox/jlf/trunk/macos-arm64/clang/release/delivery/share/ooRexx/native.api/stackOverflow
    error: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/install_name_tool:
           for: /Users/Shared/local/rexx/oorexx/build/executor.master/sandbox/jlf/trunk/macos-arm64/clang/release/delivery/share/ooRexx/native.api/stackOverflow
           (for architecture arm64) option "-add_rpath @executable_path/../lib" would duplicate path, file already has LC_RPATH for: @executable_path/../lib
    error: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/install_name_tool:
           no LC_RPATH load command with path: /Users/Shared/local/rexx/oorexx/build/executor.master/sandbox/jlf/trunk/macos-arm64/clang/release/build/lib
           found in: /Users/Shared/local/rexx/oorexx/build/executor.master/sandbox/jlf/trunk/macos-arm64/clang/release/delivery/share/ooRexx/native.api/stackOverflow
           (for architecture arm64), required for specified option "-delete_rpath /Users/Shared/local/rexx/oorexx/build/executor.master/sandbox/jlf/trunk/macos-arm64/clang/release/build/lib"
for these binaries:
    native.api/stackOverflow
    native.api/runRexxProgram
    native.api/callrexx1
    native.api/callrexx2
    native.api/libwpipe1
    native.api/libwpipe2
    native.api/libwpipe3
ooRexx5 doesn't have this problem.
Ã‡a me pompe l'air :-((


===============================================================================
2023 Sep 06

[Encoded strings]

Rework the implementation of caselessPos, pos.
Was not returning the right position when the length of the string changed
internally. Now the results are identical to Raku's (with a few exceptions).

"BundesstraÃŸe im Freiland"~text~pos("Freiland")=                -- 17
"BundesstraÃŸe im Freiland"~text~caselessPos("freiland")=        -- 17


===============================================================================
2023 Sep 02

Makefiles for tests are now available for nmake (Windows):
- "Makefile" renamed "GNUmakefile".
  Under Macos and Linux, make will use in priority GNUmakefile, ignoring
  "Makefile".
- New "Makefile" for each test directory.
  Under Windows, nmake will ignore GNUmakefile and use Makefile.
Usage for macOS and Linux:
    cdtests
    cd collection
    make all
    cd ../encoding
    make all
    cd ../extension
    make all
  Usage for Windows:
    idem, with nmake.
The regressions are detected by comparing the output with a reference output.


Make the demos usable for [non-]regression tests.


===============================================================================
2023 Sep 01

[ooRexxShell]

New command "test regression":
- activate the mode "demo fast"
- set .ooRexxShell~testRegression to .true
Example:
    cat script.rex | oorexxshell test regression

New property .ooRexxShell~testRegression set to .false by default. It can be set
to true when running [non-]regression tests, to deactivate the outputs that
could be different at each execution.
When .ooRexxShell~testRegression is .true then the command "infos next" is
deactivated (because it displays the duration and the count of active
coactivities).
A script can have conditional sections based on this property.


The commands '<' and 'goto' support an optional 'when condition'.
First need: use some demos for non-regression.
Some parts of the demos must be deactivated because their results change at each
execution (duration, concurrent trace).

The condition is the rest of the line after 'when'.
It's evaluated with the INTERPRET instruction.

Example for Executor:
    goto label          -- always executed
    goto label when 1   -- always executed
    goto label when 0   -- never executed
    < file s/x/10/ s/y/20/ when \.ooRexxShell~testRegression

Example for official ooRexx:
(must use 'return' or set the variable 'result')
    goto label                  -- always executed
    goto label when return 1    -- always executed
    goto label when result=1    -- always executed
    goto label when return 0    -- never executed
    goto label when result=0    -- never executed


===============================================================================
2023 Aug 29

[Encoded strings]

Implementation of caselessContains, contains:
(forwards to caselessPos or pos, and returns .true if result <> 0)
(was already implemented, waiting for 'pos' implementation)
Examples:
    "PÃ¨re NoÃ«l PÃ¨re NoÃ«l"~text~contains("oÃ«")=                   -- .true
    "PÃ¨re NoÃ«l PÃ¨re NoÃ«l"~text~contains("oÃ«", , 7)=              -- .false
    "PÃ¨re NoÃ«l PÃ¨re NoÃ«l"~text~contains("oÃ«", , 8)=              -- .true
    "PÃ¨re NoÃ«l PÃ¨re NoÃ«l"~text~contains("oÃ«", 8)=                -- .true
    "PÃ¨re NoÃ«l PÃ¨re NoÃ«l"~text~contains("oÃ«", 8, 10)=            -- .false
    "PÃ¨re NoÃ«l PÃ¨re NoÃ«l"~text~contains("oÃ«", 8, 11)=            -- .true
    "PÃ¨re NoÃ«l PÃ¨re NoÃ«l"~text~caselessContains("OÃ‹", 8, 11)=    -- .true

    "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~contains("ðŸ‘§ðŸŽ…")=                           -- 0
    "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~contains("ðŸ‘§ðŸŽ…", aligned:.false)=           -- .true
    "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~contains("ðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…", aligned:.false)=  -- .true


===============================================================================
2023 Aug 28

[Encoded strings]

Add a named argument 'aligned' to caselessPos, pos:
- If aligned=.true (default) then return the first character position in the
  untransformed haystack such as all the bytes of the transformed needle are
  matched with corresponding bytes in the transformed haystack AND the first
  and last byte positions are aligned with character positions.
  If no match then return 0.
- If aligned=.false then return a couple (array) of numbers +/-posC.posB where
  posB is the position of the matched byte in the transformed haystack, and posC
  is the corresponding grapheme position in the untransformed haystack.
  A number is negative if the byte position is not aligned with the corresponding
  character position.
  The first number is the start of the matching.
  The second number is the end of the matching + 1.

aligned=.false is intended for analysis of matchings and [non-]regression tests.
Otherwise, I don't see any use.

Example:
    "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~pos("ðŸ‘§ðŸŽ…")=                           -- 0
    "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~pos("ðŸ‘§ðŸŽ…", aligned:.false)=           -- [-5.27,+7.35]
    "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~pos("ðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…", aligned:.false)=  -- [+5.6,+7.35]


The methods NFC, NFD, NFKC, NFKD and casefold are no longer abstract.
They call the method 'transform' which is now declared abstract.
For the moment, only the UTF-8 indexer implements 'transform'.


Comparison operators:
Take into account the default normalization managed by the .Unicode class
- NFC when strict
- NFKD when not strict
Example:
    ("baï¬„e"~text == "baffle"~text) =    -- false
    ("baï¬„e"~text = "baffle"~text) =     -- true
Reminder: the non-strict mode supports all the Unicode spaces, not just U+0032.
    string1 = " Le\u{IDEOGRAPHIC SPACE}PÃ¨\u{ZERO-WIDTH-SPACE}re\u{HYPHEN}NoÃ«l"~text~unescape
    string2 = "Le\u{OGHAM SPACE MARK}PÃ¨re\u{EN DASH}No\u{ZERO-WIDTH-SPACE}Ã«l "~text~unescape
    (string1 == string2) =              -- false
    (string1 = string2) =               -- true


===============================================================================
2023 Aug 26

[Encoded strings]

New non-regression test file tests/encoding/diary_examples.rex which contains
all the diary's examples related to encoded strings.
Usage:
    cd tests/encoding
    make diary_examples


Reverse the decision that makes c2g available only to Unicode indexers.
c2g is also useful and relevant for Byte indexers, even if the word "grapheme"
is rather a Unicode concept.
c2u and UnicodeCharacters remain limited to Unicode indexers.


The method codepointIndexB is refactored: unique implementation for all the
encodings.

The method characterIndexB is refactored: unique implementation for all the
encodings.


New method characterIndexC which retrieves the character index corresponding to
a given byte position, using a binay search. The result is negative when the
byte index is not aligned with the character index.
---
t = "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text; t~c2g=    -- '6E 6F C3AB 6C F09F91A9E2808DF09F91A8E2808DF09F91A9E2808DF09F91A7 F09F8E85'
t = "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text; do indexB=1 to t~string~length + 2; indexC = t~indexer~characterIndexC(indexB); character = t~character(abs(indexC)); say "indexB" indexB~right(3) "--> indexC" indexC~right(4) "    " character~c2x; end
    indexB   1 --> indexC    1      6E
    indexB   2 --> indexC    2      6F
    indexB   3 --> indexC    3      C3AB
    indexB   4 --> indexC   -3      C3AB
    indexB   5 --> indexC    4      6C
    indexB   6 --> indexC    5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB   7 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB   8 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB   9 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB  10 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB  11 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB  12 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB  13 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB  14 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB  15 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB  16 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB  17 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB  18 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB  19 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB  20 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB  21 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB  22 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB  23 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB  24 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB  25 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB  26 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB  27 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB  28 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB  29 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB  30 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
    indexB  31 --> indexC    6      F09F8E85
    indexB  32 --> indexC   -6      F09F8E85
    indexB  33 --> indexC   -6      F09F8E85
    indexB  34 --> indexC   -6      F09F8E85
    indexB  35 --> indexC    7
    indexB  36 --> indexC    7

New non-regression test file tests/encoding/test_character_index.rex
Usage:
    cd tests/encoding
    make test_character_index


Implementation of caselessCompare, compare.
Implementation of caselessEndsWith, endsWith.

Rework implementation of caselessMatchChar, matchChar.
The character at position n and the chars are normalized. Any character can
become several decomposed characters (for example the ligatures). These
decomposed characters are iterated over and compared letter by letter.
    "BAFFLE"~text~caselessMatchChar(3, "ï¬„")=               -- 1      "ï¬„" becomes "ffl" (3 graphemes), there is a match on "f" at 3
    "BAFFLE"~text~caselessMatchChar(5, "ï¬„")=               -- 1      "ï¬„" becomes "ffl" (3 graphemes), there is a match on "l" at 5
    "baffle"~text~caselessMatchChar(5, "L")=                -- 1      there is a match on "l" at 5 (forward to string)
    "baï¬„e"~text~caselessMatchChar(3, "ï¬„")=                -- 1      "ï¬„" at 3 (1 grapheme) becomes "ffl" (3 graphemes), there is a match on "l"
    "baï¬„e"~text~caselessMatchChar(3, "F")=                 -- 1      "ï¬„" at 3 (1 grapheme) becomes "ffl" (3 graphemes), there is a match on "f"
    "baï¬„e"~text~caselessMatchChar(3, "L")=                 -- 1      "ï¬„" at 3 (1 grapheme) becomes "ffl" (3 graphemes), there is a match on "l"
    "baï¬„e"~text~caselessMatchChar(4, "E")=                 -- 1      the grapheme at 4 is "e", not "f". There is a match with "e"


Rework implementation of caselessCompareTo, compareTo.
Implementation of caselessPos, pos.


===============================================================================
2023 Aug 26

[Encoded strings]

Crash when executing
.unicode~character("ZERO_WIDTH-SPACE")=
---
# Problematic frame:
# C  [librexx.4.dylib+0x3bfec]  RexxString::checkIsASCII()+0xc
---
RexxMutableBuffer::translate
The argument pad is NULL.
Fixed.


===============================================================================
2023 Aug 23

[Encoded strings]

The default normalization is now managed by the Unicode class:
- NFC when strict
- NFKD when not strict


The methods doing comparisons now accept the named argument 'strict':
- By default, the comparisons are made in strict mode (i.e. like ==).
  This is aligned with the classic Rexx.
- lump and stripIgnorable are false when strict, and true when not strict.
- stripMark is not impacted by the strict mode. It's up to the Rexx user to
  explicitely decide if the accents are removed.
  By default, the accents are not removed. This is aligned with the classic Rexx.


===============================================================================
2023 Aug 22

[Encoded strings]

Rename the method "characterIndex" to "characterIndexB".
Rename the method "codepointIndex" to "codepointIndexB".
Rename the method "nextCodepointIndex" to "nextCodepointIndexB".
Rename the method "previousCodepointIndex" to "previousCodepointIndexB".

Continue to eliminate any reference to "G"rapheme, when applicable:
Rename "indexG" to "indexC".
"C" means "C"haracter, by opposition to "B"yte. A character can be either a
codepoint or an EGC, in function of the context.


===============================================================================
2023 Aug 21

[Encoded strings]

More work on transcoding:

Rename the class "Unicode_Encoding" to "UnicodeN_Encoding".
"UnicodeN" is now accepted as an encoding name, in complement of "Unicode".

The method "maximumUnicodeCodepoint" is no longer private.
- For Byte encodings, returns the maximum Unicode codepoint if the text was converted to Unicode.
- For Unicode encodings, it's the same value as maximumCodepoint.

The methods ~encode and ~codepointSizeInBytes now accept the same positional
arguments as ~checkCodepoint to let report the byte position in case of error
during a transcoding.
old:    use strict arg codepoint
new:    use strict arg codepoint, codepointIndexB=.nil, previousCodepoint=.nil, previousCodepointIndexB=.nil


===============================================================================
2023 Aug 17

[Encoded strings]

The methods "convertToByte" and "convertToUnicode" become private.
A new method "transcodeTo" is added, which delegates to the private methods.
All the combinations of encodings are supported, except from byte to byte:
    from/to  |     byte        |     unicode
    ---------+-----------------+-------------
    byte     |  not supported  |    supported
    unicode  |  supported      |    supported


===============================================================================
2023 Aug 10

[Encoded strings]

Refinement of the rules for comparison.
Same logic as concatenation, with one difference: the cases where Unicode is
demoted to Byte are allowed (because a comparison can be made in any order).
Reminder: Since the strings remain unchanged, the comparison is made on the
encoded strings, not on the codepoints. This is the same approach as Ruby.
Unlike Ruby, the strings are normalized on the fly (temporary strings).
Currently, only valid UTF-8 strings can be normalized (utf8proc limitation).
Under the hood, utf8proc converts the UTF-8 string to an array of 32-bit
codepoints, apply the transformations and then convert back in place to UTF-8.

New program to test all the combinations of encodings.
    cdunicode
    rexx test_encoding_combinations.rex > test_encoding_combinations-output.txt
For each combination, test
    ASCII,ASCII,
    not-ASCII,ASCII
    ASCII,not-ASCII.
    not-ASCII,not-ASCII.

Summary:
    16 encodings
    256 encoding combinations * 4 asciiness combinations = 1024 cases
    1024 cases * 3 checks = 3072 results of which 2328 errors
    78 flagged buffer encodings <-- to review
        [later]
        After review of the cases where the flag "*" is displayed, I see that
        the returned buffer encoding is always the same as the original buffer
        encoding. And that's good.
        Note for me: it's the same encoding because of the assumption that the
        right string will be ASCII. In this case, the left side wins (i.e. the
        original buffer encoding). If the assumption is wrong then an error will
        be raised when the real concatenation is done. And that's good.


===============================================================================
2023 Aug 09

[Collection]

New class method .Collection.product2
    use strict arg collection1, collection2=(collection1), action={(item1, item2)}
Cartesian product of 2 collections.
The first collection is mandatory, the second collection is optional (use collection1 by default).
The action is called for each couple (item1, item2).
The arguments passed to the action are item1, index1, item2, index2.
The default action is to return the couple (item1, item2).
The result is an array of all the results returned by the action.

New class method .Collection.product3
    use strict arg collection1, collection2=(collection1), collection3=(collection2), action={(item1, item2, item3)}
Cartesian product of 3 collections.

.Collection~product2((1,2))=                     -- [[ 1, 1],[ 1, 2],[ 2, 1],[ 2, 2]]
.Collection~product2((1,2), ("a", "b", "c"))=    -- [[ 1,'a'],[ 1,'b'],[ 1,'c'],[ 2,'a'],[ 2,'b'],[ 2,'c']]
.Collection~product2((1,2), (10, 20)){say index1":"item1 index2":"item2}=
    1:1 1:10
    1:1 2:20
    2:2 1:10
    2:2 2:20
    an Array (no shape, 0 items)
.Collection~product3((1,2))=                    -- [[ 1, 1, 1],[ 1, 1, 2],[ 1, 2, 1],[ 1, 2, 2],[ 2, 1, 1],[ 2, 1, 2],[ 2, 2, 1],[ 2, 2, 2]]


===============================================================================
2023 Aug 07

[Encoded strings]

Add conversion from a Unicode encoding to a Byte encoding.
    "PÃ¨re NoÃ«l"~text~convertToByte("cp437")~c2x=                                -- '50 8A 72 65 20 4E 6F 89 6C'
    '50 8A 72 65 20 4E 6F 89 6C'x~text("cp437")~utf8~c2x=                       -- '50 C3A8 72 65 20 4E 6F C3AB 6C'
    '50 8A 72 65 20 4E 6F 89 6C'x~text("cp437")~convertToUnicode("utf8")~c2x=   -- '50 C3A8 72 65 20 4E 6F C3AB 6C'

    "PÃ¨re NoÃ«l ðŸŽ… 10â‚¬"~text; do encoding over .Byte_Encoding~subclasses~~append(.Byte_Encoding); say encoding~name~left(13)":" text~convertToByte(encoding, replace:"FF"x)~c2x; end
        ISO-8859-1   : 50 E8 72 65 20 4E 6F EB 6C 20 FF 20 31 30 FF
        ibm-1252     : 50 E8 72 65 20 4E 6F EB 6C 20 FF 20 31 30 FF
        windows-1252 : 50 E8 72 65 20 4E 6F EB 6C 20 FF 20 31 30 80
        IBM437       : 50 8A 72 65 20 4E 6F 89 6C 20 FF 20 31 30 FF
        Byte         : 50 FF 72 65 20 4E 6F FF 6C 20 FF 20 31 30 FF


===============================================================================
2023 Aug 04

[Encoded strings]

Rename "grapheme" to "character" in the RexxText interface because the concept
of grapheme is not applicable to byte encodings.

-- Compatibility with initial interface
::method graphemes; forward message "characters"
::method grapheme; forward message "character"

c2g, c2u and UnicodeCharacters are now abstract method at the top level.
They are implemented only for the Unicode indexers.


Update the demo executor-demo-text-unicode.rex
- Strict/non-strict RexxText equality
- caselessCompareTo
- caselessEquals
- caselessMatch
- caselessMatchChar
- matchChar using an optional NFKD transformation
- functional
- generator


===============================================================================
2023 Aug 04

[Encoded strings]

c2g and c2u no longer return a result if the text is not Unicode.
(same as UnicodeCharacters)


Fix regression in .Encoding~forConcatenation.
Rules when Left encoding and Right encoding are compatible with ASCII:
    A side is candidate when it can absorb the other side.
    Only ASCII characters from 00 to 7F can be absorbed (Ruby approach).
    When both sides are candidate then
    - give priority to unicode over byte-encoding
    - give priority to the left encoding
New rule for buffer:
    [update 2023 Mar 17] This rule applies only to an EMPTY buffer.
    If left is an empty buffer with no encoding then use the right encoding.
    This rule doesn't apply to a right buffer, only a left empty buffer has this
    encoding neutrality.


ICU ucm files for encodings
Some characters have TWO mappings: |0 |1
The definition is given in icu4c/source/tools/toolutil/ucm.h
 * f flag for roundtrip (0), fallback (1), sub mapping (2), reverse fallback (3)
Still not clear what to do with this fallback flag.


New method 'appendEncoded' on MutableBuffer.
The native method 'append' remains unaware of encodings. I tried to replace
'append' by 'appendEncoded' but that's a bad idea. The method 'append' is used
everywhere, some stack overflows happen.

New method 'appendEncoded' on RexxText, which forwards 'append'.
This is to offer the same interface as MutableBuffer.

    --- Following expressions return the same result correctly tagged 'ISO-8859-1'
    b = .MutableBuffer~new; "Pere"~text("windows-1252")~append(" "~text("windows-1252"), :b)~appendEncoded("NoÃ«l"~text("iso-8859-1"), :b)=; result~description=
    b = .MutableBuffer~new; "Pere"~text("windows-1252")~appendEncoded(" "~text("windows-1252"), :b)~appendEncoded("NoÃ«l"~text("iso-8859-1"), :b)=; result~description=
    b = .MutableBuffer~new; b~appendEncoded("Pere"~text("windows-1252"), " "~text("windows-1252"), "NoÃ«l"~text("iso-8859-1"))=; result~description=

    -- Following expressions (not using 'appendEncoded') return the same result as above, but wrongly tagged 'windows-1252' or 'UTF-8'
    b = .MutableBuffer~new; "Pere"~text("windows-1252")~append(" "~text("windows-1252"), :b)~append("NoÃ«l"~text("iso-8859-1"), :b)=; result~description=
    b = .MutableBuffer~new; b~append("Pere"~text("windows-1252"), " "~text("windows-1252"), "NoÃ«l"~text("iso-8859-1"))=; result~description=


===============================================================================
2023 Jul 14

[Encoded strings]

All encodings have now an indicator isCompatibleWithASCII.
Currently true for Byte, UTF-8, WTF-8 and Unicode-8 encodings.
That allows to replace
    if (encoding~isByte | encoding~isUTF8 | encoding~isWTF8 | encoding~isUnicode8)
by
    if (encoding~isCompatibleWithASCII)
The concatenation of strings having 2 different byte encodings is now possible
if both encodings are compatible with ASCII and if both strings are ASCII only.


More work on encoding aliases.
Update the giant comment which lists encoding names and their aliases.


===============================================================================
2023 Jun 30

Update the ICU4X binaries: release 1.2

Still can't build ICU4X under Windows ARM
because of error when running
    cargo install cargo-make
ring@0.16.21 is blocking since more than 8 months
https://github.com/briansmith/ring/issues/1551


===============================================================================
2023 Jun 29

[Encoded strings]

Rename .Encoding~supported
    to .Encoding~list
because I never remember the name "supported"
and because Ruby uses Encoding.list


Add candidate encodings supported by Ruby, Iana, Java.
This is only a giant comment which lists encoding names and their aliases.

Rework the existing encodings (new names, more aliases).
New encoding ibm-437.
The encoding iso-8859-1 has now a Unicode mapping for all the characters.


===============================================================================
2023 Jun 28

[Encoded strings]

Bitkey is now 2 bytes (4 hex digits) always.

For debug, give temporarily access to the flags stored on an indexer.
"PÃ¨re NoÃ«l"~text~nfc(casefold:, stripMark:)~indexer~flags=
    a Directory (10 items)
    'FLAG_CASEFOLD'        :  1
    'FLAG_LUMP'            : -1
    'FLAG_NFC'             :  1
    'FLAG_NFD'             : -1
    'FLAG_NFKC'            : -1
    'FLAG_NFKD'            : -1
    'FLAG_STRIP_CC'        : -1
    'FLAG_STRIP_IGNORABLE' : -1
    'FLAG_STRIP_MARK'      :  1
    'FLAG_STRIP_NA'        : -1

Transform:
If the original string is different from the transformed string
and if the mask is just one flag
then we can set this flag to 0 on the original string.


===============================================================================
2023 Jun 11

[Encoded strings]

Unescape: Add support for
    \xXX                1 byte denoted by 2 hex digits ('x' lowercase)      supported by Ruby
    \XXXXX              2 bytes denoted by 4 hex digits ('X' uppercase)     supported by ? (added to be aligned with uU)


===============================================================================
2023 May 31

[Encoded strings]

The method RexxText~characters now returns graphemes instead of UnicodeCharacters.
Use the new method RexxText~UnicodeCharacters to get UnicodeCharacters. This method
raises an error "no returned value" when used with non-Unicode encodings (like "Byte").

New method String~characters and MutableBuffer~characters to support a same
interface with RexxText.


[Functional]

Add support for functional methods to RexxText.
The only needed methods on RexxText are
    ~characters
    ~subwords   (still to implement)
    ~chunks     (still to implement)

Example inspired by https://elixir-lang.org/
Frequency of each character, ignoring the accents:
"Notre pÃ¨re NoÃ«l ðŸŽ…"~text~transform(stripMark:)~reduce(by: "characters", initial: .stem~new~~put(0)){accu[item] += 1}=
    a Stem (9 items)
    'ðŸŽ…' :  1
    ' '    :  3
    'e'    :  4
    'l'    :  1
    'N'    :  2
    'o'    :  2
    'p'    :  1
    'r'    :  2
    't'    :  1
Note:
I have to explicitely convert the item to a string, otherwise error
    UTF-8 not-ASCII 'ðŸŽ…' cannot be converted to a String instance.
It's because the class Stem wants an index of class String:
    /local/rexx/oorexx/executor/sandbox/jlf/packages/extension/text.cls
       392 *-* raise syntax 23.900 array(self~descriptionForError "cannot be converted to a String instance")
    <No package>
           *-* Compiled method "REQUEST" with scope "Object".
    <No package>
           *-* Compiled method "[]" with scope "Stem".
    /local/rexx/oorexx/executor/incubator/ooRexxShell/oorexxshell.rex
         1 *-* accu[item] += 1


[Generator]

Add support for generator methods to RexxText.
The only needed methods on RexxText are
    ~characters
    ~subwords   (still to implement)

g="NoÃ«l ðŸŽ…"~text~generateC
ooRexx[sh]> g~()=       -- T'N'
ooRexx[sh]> g~()=       -- T'o'
ooRexx[sh]> g~()=       -- T'Ã«'
ooRexx[sh]> g~()=       -- T'l'
ooRexx[sh]> g~()=       -- T' '
ooRexx[sh]> g~()=       -- T'ðŸŽ…'
ooRexx[sh]> g~()=       -- [no result]


===============================================================================
2023 May 30

[Encoded strings]

Update library uni-algo from v0.7.1 to v0.8.1
https://github.com/uni-algo/uni-algo

.Unicode~unialgo_version=           -- '0.8.1'


===============================================================================
2023 May 29

[Unicode]

For convenience, additional way to search a character:
-- with a routine
.UnicodeCharacter("bed")=           -- ( "ðŸ›"   U+1F6CF So 1 "BED" )
.UnicodeCharacter("bed", h:)=       -- ( "à¯­"   U+0BED Nd 1 "TAMIL DIGIT SEVEN" )
-- with the operator []
.UnicodeCharacter["bed"]=           -- ( "ðŸ›"   U+1F6CF So 1 "BED" )
.UnicodeCharacter["bed", h:]=       -- ( "à¯­"   U+0BED Nd 1 "TAMIL DIGIT SEVEN" )

This comes in complement of:
.Unicode["bed", h:]=                -- ( "à¯­"   U+0BED Nd 1 "TAMIL DIGIT SEVEN" )
.Unicode~character("bed", h:)=      -- ( "à¯­"   U+0BED Nd 1 "TAMIL DIGIT SEVEN" )


New method UnicodeCharacter~properties at class level: return a list of property names.
.UnicodeCharacter~properties=
    ['aliases','bidiClass','bidiClassName','bidiMirrored','boundClass','boundClassName',
     'category','categoryName','charWidth','codepoint','combiningClass','controlBoundary',
     'decompositionTypeName','decompositionType','ignorable','isLower','isUpper','name',
     'toLowerFull','toLowerSimple','toTitleFull','toTitleSimple','toUpperFull',
     'toUpperSimple','Unicode','UTF16BE','UTF16LE','UTF32BE','UTF32LE','UTF8']


===============================================================================
2023 May 24

[Unicode]

For convenience, it's now possible to search directly a character if it's made of one codepoint only:
.Unicode~character("a")=    -- ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
.Unicode~character("Ã ")=    -- ( "Ã "   U+00E0 Ll 1 "LATIN SMALL LETTER A WITH GRAVE" )
.Unicode~character("aÌ€")=    -- Error: The character 'aÌ€' is made of several codepoints: U+0061 U+0300

For the last example, you can get an array of characters:
"aÌ€"~text~UnicodeCharacters==
    an Array (shape [2], 2 items)
     1 : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
     2 : ( "Ì€"    U+0300 Mn 0 "COMBINING GRAVE ACCENT" )


New method UnicodeCharacter~properties at instance level: Return a directory of properties.
.Unicode~character("U+000D")~properties=
    a Directory (30 items)
    'aliases'               : [(CARRIAGE RETURN),(CR)]
    'bidiClass'             :  16
    'bidiClassName'         : 'B'
    'bidiMirrored'          :  0
    'boundClass'            :  2
    'boundClassName'        : 'CR'
    'category'              :  26
    'categoryName'          : 'Cc'
    'charWidth'             :  0
    'codepoint'             :  13
    'combiningClass'        :  0
    'controlBoundary'       :  1
    'decompositionType'     :  0
    'decompositionTypeName' : 'None'
    'ignorable'             :  0
    'isLower'               :  0
    'isUpper'               :  0
    'name'                  : ''
    'toLowerFull'           :  13
    'toLowerSimple'         :  13
    'toTitleFull'           :  13
    'toTitleSimple'         :  13
    'toUpperFull'           :  13
    'toUpperSimple'         :  13
    'Unicode'               : T'[0D]'
    'UTF16BE'               : T'[000D]'
    'UTF16LE'               : T'[0D00]'
    'UTF32BE'               : T'[0000000D]'
    'UTF32LE'               : T'[0D000000]'
    'UTF8'                  : T'[0D]'


===============================================================================
2023 April 10

[Named arguments]

Discovered a major regression when running Example 12.2. Message object usage.
Successive calls of the method ~start are creating messages that use the same
array of arguments.
 	rexx.dll!RexxMessage::RexxMessage(RexxObject * _target, RexxString * msgName, RexxObject * scope, RexxObject * * _arglist, unsigned __int64 _argcount, unsigned __int64 _named_argcount) Line 81	C++
 	rexx.dll!RexxObject::startCommon(RexxObject * message, RexxObject * * arguments, unsigned __int64 argCount, unsigned __int64 named_argCount) Line 1948	C++
 	rexx.dll!RexxObject::start(RexxObject * * arguments, unsigned __int64 argCount, unsigned __int64 named_argCount) Line 1925	C++
 	rexx.dll!CPPCode::run(RexxActivity * activity, RexxMethod * method, RexxObject * receiver, RexxString * messageName, RexxObject * * argPtr, unsigned __int64 count, unsigned __int64 named_count, ProtectedObject & result) Line 124	C++
 	rexx.dll!RexxMethod::run(RexxActivity * activity, RexxObject * receiver, RexxString * msgname, RexxObject * * argPtr, unsigned __int64 count, unsigned __int64 named_count, ProtectedObject & result) Line 325	C++
 	rexx.dll!RexxObject::messageSend(RexxString * msgname, RexxObject * * arguments, unsigned __int64 count, unsigned __int64 named_count, ProtectedObject & result, bool processUnknown) Line 822	C++
>	rexx.dll!RexxExpressionStack::send(RexxString * message, unsigned __int64 count, unsigned __int64 namedCount, ProtectedObject & result) Line 69	C++
The common memory area comes from the expression stack.
ooRexx 4.2 is ok
    RexxMessage *RexxObject::startCommon(RexxObject *message, RexxObject **arguments, size_t argCount)
    {
        ...
        /* Create the new message object.    */
        RexxMessage *newMessage = new RexxMessage(this, messageName, startScope, new (argCount, arguments) RexxArray);
        ...
because the operator new makes a copy:
    void *   RexxArray::operator new(size_t size,
        size_t items,                      /* items in the array                */
        RexxObject **first )               /* array of items to fill array      */
    {
        RexxArray *newArray = new_array(items);         /* get a new array                   */
        if (items != 0)                      /* not a null array?                 */
        {
            /* copy the references in            */
            memcpy(newArray->data(), first, (sizeof(RexxObject *) * items));
            ...
Fixed in Executor by creating a new array.


===============================================================================
2023 March 26

[Encoded strings]

Integration of the library uni-algo v0.7.1
https://github.com/uni-algo/uni-algo

Prerequisite:
Compiler supporting C++17.
Only the file that includes the uni-algo headers need to be compiled with C++17.
The rest of the interpreter stay compiled with C++11.

More complete than utf8proc.
utf8proc is better for the transformations applied during normalization.


===============================================================================
2023 March 20

[Encoded strings]

Rework implementation of caselessMatch to support correctly
"BundesstraÃŸe im Freiland"~text~caselessMatch(14, "im")     -- .true

Prepare the support of full case mappings (rules defined in SpecialCasing.txt).
utf8proc supports only the simple case mappings:
toLowerSimple, toUpperSimple and toTitleSimple return only one codepoint.


===============================================================================
2023 March 08

[Encoded strings]

Implementation of caselessMatchChar, matchChar
"NoÃ«lle"~text~matchChar(2, "aeiouy")=                       -- 1
"NoÃ«lle"~text~matchChar(3, "aeiouy")=                       -- 0
"NoÃ«lle"~text~matchChar(3, "aeÃ«iouy")=                      -- 1    include the accents in the list of accepted characters
"NoÃ«lle"~text~matchChar(3, "aeiouy", stripMark:)=           -- 1    or remove the accents from the tested string
"NoÃ«lle"~text~matchChar(6, "aeiouy")=                       -- 1

"BundesschnellstraÃŸe"                                       -- at 14: "s", at 18:"ÃŸ"
 1234567890123456789
"BundesschnellstraÃŸe"~text~matchChar(14, "s")=              -- 1
"BundesschnellstraÃŸe"~text~matchChar(18, "s")=              -- 0
"BundesschnellstraÃŸe"~text~matchChar(18, "sÃŸ")=             -- 1
"BundesschnellstraÃŸe"~text~caselessMatchChar(18, "s")=      -- 1    "ÃŸ" becomes "ss" which is 2 graphemes. The first grapheme at 18 matches "s"
"BundesschnellstraÃŸe"~text~caselessMatchChar(19, "s")=      -- 0    "ÃŸ" becomes "ss" which is 2 graphemes. The grapheme at 19 is "e", not the second "s"
"BundesschnellstraÃŸe"~text~caselessMatchChar(19, "e")=      -- 1    "ÃŸ" becomes "ss" which is 2 graphemes. The grapheme at 19 is "e", not the second "s"

The ligature disappears in NFK[CD] but not in NF[CD]
"baï¬„e"~text~NFKC=                                            -- T'baffle'
"baï¬„e"~text~NFKD=                                            -- T'baffle'
"baï¬„e"~text~matchChar(3, "f")=                               -- 0     "ï¬„" is ONE grapheme because NFC
"baï¬„e"~text~matchChar(3, "ï¬„")=                              -- 1     "ï¬„" is ONE grapheme because NFC
"baï¬„e"~text~matchChar(3, "ï¬„", normalization:.Unicode~NFKD)= -- 1     "ï¬„" becomes "ffl" (3 graphemes). There is a match because the first grapheme is "f"
"baï¬„e"~text~matchChar(3, "f", normalization:.Unicode~NFKD)=  -- 1     "ï¬„" becomes "ffl" (3 graphemes). There is a match because the first grapheme is "f"
"baï¬„e"~text~matchChar(4, "f", normalization:.Unicode~NFKD)=  -- 0     "ï¬„" becomes "ffl" (3 graphemes). The grapheme at 4 is "e", not the second "f"
"baï¬„e"~text~matchChar(4, "e", normalization:.Unicode~NFKD)=  -- 1     "ï¬„" becomes "ffl" (3 graphemes). The grapheme at 4 is "e", not the second "f"

The ligature disappears when casefolded
"baï¬„e"~text~casefold=                                        -- T'baffle'
"BAFFLE"~text~caselessMatchChar(3, "ï¬„")=                     -- 1      "ï¬„" becomes "ffl" (3 graphemes), there is a match on "f" at 3
"BAFFLE"~text~caselessMatchChar(5, "ï¬„")=                     -- 1      "ï¬„" becomes "ffl" (3 graphemes), there is a match on "l" at 5
"BAFFLE"~text~caselessMatchChar(5, "L")=                      -- 1      there is a match on "l" at 5 (forward to String)


Implementation of caselessEquals, equals
"Å’UF"~text~caselessEquals("Å“uf")=           -- 1
"Å“uf"~text~caselessEquals("Å’UF")=           -- 1
"StraÃŸe"~text~caselessEquals("strasse")=    -- 1
"strasse"~text~caselessEquals("StraÃŸe")=    -- 1


Reminder: a caseless method is transforming its arguments using CaseFold.
The default normalization is NFC, it's possible to change it with the argument
normalization
    .unicode~NFC    (default)
    .unicode~NFD
    .unicode~NFKC
    .unicode~NFKD
There is no value NFKC_CF because it can be done using the caseless methods by
passing NFKC + stripIgnorable.


Some ligatures are not decomposed by NFKC.
"Å’UF"~text~caselessEquals("oeuf")=                                  -- 0
"Å’UF"~text~caselessEquals("oeuf", normalization:.Unicode~NFKC)=     -- 0

https://github.com/unicode-org/icu4x/issues/3151#issuecomment-1458494311
Å’UF and Å“uf are primary-equal to oeuf, whereas they are not identifier caseless matches.
For general-purpose matching that does not have stability requirements,
something collation-based is more appropriate.
Todo with ICU4X...

https://www.unicode.org/L2/L2023/23005.htm#174-C4
Recently the UTC approved (in consensus 174-C4) a change to the collation of
punctuation marks that look like the ASCII ' and ", which has the effect that
O'Connor (APOSTROPHE) will now be primary-equal to Oâ€™Connor (RIGHT SINGLE QUOTATION MARK)
Todo with ICU4X...


Implementation of caselessMatch and match to rework to support this case where
the casefold transformation invalidates the position 14:
"BundesstraÃŸe im Freiland"~text~caselessMatch(14, "im")=        -- returns false, must be true
 123456789012345678901234
"BundesstraÃŸe im Freiland"~text~caselessMatch(15, "im")=        -- returns true, must be false
An easy implementation is to extract the substring and then apply the transformations and then compare.
That will be in contradiction with this sentence in RexxRef, but acceptable for
a prototype:
"The caselessMatch method is useful for efficient string parsing as it does not
require new string objects be extracted from the target string."


===============================================================================
2023 January 30

Update the ICU4X binaries: release 1.1


Wanted to build ICU4X under Windows ARM
but error when running
cargo install cargo-make
error C2065: 'BN_ULLONG': undeclared identifier

https://github.com/briansmith/ring/issues/1167
THE thread to read to (try to) understand the problem.
The conclusion is:
ring is planning on a 0.16.21 release which will also fix the build for aarch64-pc-windows-msvc

https://github.com/briansmith/ring/issues/1551
0.16.21 release

https://github.com/briansmith/ring/pull/1554
Enable Windows on ARM builds for 0.16.x

https://github.com/rust-lang/rustup/issues/2612
aarch64 windows
See the last comments... Rings is blocking and seems to be hardly maintained...
2023 Feb 23: ticket closed. Which problem dit it fix??? ring is still impossible to build.

https://github.com/briansmith/ring/issues/1614
jlf 23/07/2023 The saga continues.. Soon one year that 'ring' is blocking, it's pathetic.
In the meantime, I deactivate the use of ICU4X in the build of Executor for Windows ARM..
2023 Aug 31: comment from briansmith saying "I'm actively working on a solution. Stay tuned."


REMEMBER
Done
----
download rustup-init.exe from https://www.rust-lang.org/tools/install
run rustup-init.exe
[later]
rustup self update
rustup update

Still todo
----------
cargo install cargo-make
cargo install cargo-readme
E:
cd \local\Unicode\ICU4X\git
cargo build -p icu_capi_cdylib --all-features --release
copy target\release\icu_capi_cdylib.dll (and .exp, .lib, .pdb)


===============================================================================
2022 December 22

[update 2022 Feb24]
Next section is WRONG.
No need to install a recent clang.
I had this error because of this declaration in setenv-macos:
    MACOSX_DEPLOYMENT_TARGET=10.9
After changing the value to 10.13, as written in the error message, no problem.

Building on my new MBP...
Not possible to compile ICU4X headers under macOS Monterey 12.6.2 with the compiler
bundled with Xcode.
Apple clang version 14.0.0 (clang-1400.0.29.202
The error message says "introduced in macOS 10.13"

    [ 18%] Building CXX object CMakeFiles/rexx.dir/interpreter/classes/TextClass.cpp.o
    In file included from /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/classes/TextClass.cpp:676:
    In file included from /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/classes/support/m17n/icu4x/ffi/diplomat/cpp/include/ICU4XAnyCalendarKind.hpp:10:
    /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/classes/support/m17n/icu4x/ffi/diplomat/cpp/include/diplomat_runtime.hpp:114:40: error: 'get<diplomat::Err<ICU4XError>, diplomat::Ok<std::monostate>, diplomat::Err<ICU4XError>>' is unavailable: introduced in macOS 10.13
          return result<T2, E>(Err<E>(std::get<Err<E>>(std::move(this->val))));
                                           ^
    /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/classes/support/m17n/icu4x/ffi/diplomat/cpp/include/ICU4XLocale.hpp:258:36: note: in instantiation of function template specialization 'diplomat::result<std::monostate, ICU4XError>::replace_ok<std::string>' requested here
      return diplomat_result_out_value.replace_ok(std::move(diplomat_writeable_string));
                                       ^
    /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX13.1.sdk/usr/include/c++/v1/variant:1535:17: note: 'get<diplomat::Err<ICU4XError>, diplomat::Ok<std::monostate>, diplomat::Err<ICU4XError>>' has been explicitly marked unavailable here
    constexpr _Tp&& get(variant<_Types...>&& __v) {
                    ^
    1 error generated.
    make[2]: *** [CMakeFiles/rexx.dir/interpreter/classes/TextClass.cpp.o] Error 1
    make[1]: *** [CMakeFiles/rexx.dir/all] Error 2
    make: *** [all] Error 2

No choice... Must install a recent clang!
https://github.com/llvm/llvm-project/releases/tag/llvmorg-15.0.6


===============================================================================
2022 December 09

[Encoded strings]

Split the big file "stringEncoding.cls" in several files.
New encodings can be added without modifying the existing sources.

ooRexxShell has been modified to let detect missing and circular ::requires.
After this change, it appears that the regular expressions are no longer supported.
That's because ooRexxShell hid the fact a ::requires was missing in stringChunkExtended.cls
Now fixed.

Utility dotsymbols.rex
Display a unique sorted list of the dot symbols of the file <filename>.
Works only with the debug version of Executor.
Used to find missing ::requires after splitting"stringEncoding.cls".


===============================================================================
2022 November 26

Remove dependency on ziglyph
Can't upgrade to ziglyph for zig 0.10.0 with Unicode 15.0.0 support
because zig maintainers introduced a dependency on ___ulock_wait2
which is not supported by my MacOs version (High Sierre 10.13.6).
https://github.com/ziglang/zig/issues/13313#issuecomment-1304802222

Update 2023 Feb 21
https://github.com/ziglang/zig/issues/14405
macOS 10.15: dyld: lazy symbol binding failed: Symbol not found: ___ulock_wait2


===============================================================================
2022 November 20

[Encoded strings]

New set of examples that I use also for non-regression (too lazy to use the test framework).
cdsamples
cd encoding
make force all

The generated txt files are compared with the reference txt files.
Easy to see if something changed.


===============================================================================
2022 November 20

[Encoded strings]

For consistency, all the conversion methods accept the named argument 'strict',
even if it's not needed for the unicode encodings.
Previously, was supported only for the byte encodings.
The default value of 'strict' is now .false.

The conversion methods accept the named argument 'memorize(3)'.
Its default value is given by .unicode~memorizeTranscodings (was memorizeConversions) which is .false by default.
Example:
    s = "hello"
    t = s~text
    utf16 = t~utf16(mem:)
    utf32 = t~utf32(mem:)
    t~utf16~"==":.object(utf16)=         -- 1
    t~utf32~"==":.object(utf32)=         -- 1

    /*
    CP1252 to UTF-8, UTF-16, UTF-32
    "Un Å“uf de chez MaPouleâ„¢ coÃ»te Â±0.40â‚¬"
    */
    str_cp1252 = "Un " || "9C"x || "uf de chez MaPoule" || "99"x || " co" || "FB"x || "te " || "B1"x || "0.40" || "80"x
    txt_cp1252 = str_cp1252~text("cp1252")
    utf8  = txt_cp1252~utf8(mem:)
    utf16 = txt_cp1252~utf16(mem:)
    utf32 = txt_cp1252~utf32(mem:)
    txt_cp1252~utf8 ~"==":.object(utf8) =         -- 1
    txt_cp1252~utf16~"==":.object(utf16)=         -- 1
    txt_cp1252~utf32~"==":.object(utf32)=         -- 1


When an optional buffer is passed, must check that its encoding is compatible.
Done for the conversion methods.
Example:
    b = .mutablebuffer~new      -- No encoding yet
    "hello"~text~utf16(:b)      -- now the buffer's encoding is UTF-16
    "bye"~text~utf8(:b)         -- Encoding: cannot append UTF-8 to UTF-16BE '[00]h[00]e[00]l[00]l[00]o'.


===============================================================================
2022 November 11

[Named arguments]

Shorthand syntax
    name:       without value, pass .true
    :varname    without name, pass varname:varname

See _notes.txt for additional thoughts about the syntax '...'


===============================================================================
2022 November 08

[Encoded strings]

Additional arguments are supported by NFC, NFD, NFKC, NFKD, Casefold:
    lump
        Lumps certain different codepoints together.
        All the concerned characters become the same character, but still remain distinct characters.
        E.g. HYPHEN U+2010 and MINUS U+2212 to ASCII "-"
             all space characters (general category Zs) to U+0020
    stripIgnorable
        Strips the characters whose property Default_Ignorable_Code_Point = true
        such as SOFT-HYPHEN or ZERO-WIDTH-SPACE
    stripCC
        Strips and/or converts control characters:
        characters 00-1F and 7F-9F, except 09 which is replaced by 20.
    stripMark
        Strips all character markings:
        characters whose category is Mc Me Mn (i.e. accents)
            Mc Spacing Mark
            Me Enclosing Mark
            Mn Nonspacing Mark
        This option works only with normalization.
    stripNA
        Strips the characters whose category is Cn Unassigned
        Note that the value gc=Cn does not actually occur in UnicodeData.txt,
        because that data file does not list unassigned code points.

Remark: the normalization NFKC_Casefold (short alias NFKC_CF) is done with
    ~NFKC(Casefold: .true, stripIgnorable: .true)


[Encoded strings]

Two RexxText values are considered equal if their extended grapheme clusters are canonically equivalent.
This is the definition of Swift.
Q&A https://lists.isocpp.org/sg16/2018/08/0121.php
TODO: confirm that it's NFC, and only that.
The definition of canonical equivalence by the Unicode standard seems not limited to NFC.
https://unicode.org/notes/tn5/

The strict comparison operators now use the NFC normalization (update: use .Unicode~defaultNormalization(strict:.true)).
After normalization, they delegate to the String's strict comparison operators.

The non-strict comparison operators now use the NFC normalization (update: use .Unicode~defaultNormalization(strict:.false))
plus
    stripIgnorable:.true
    lump:.true
After normalization + transformations, they delegate to the String's non-strict comparison operators.
Thanks to the lump transformation, all the Unicode spaces are supported.

Examples:
textNFC = "NoÃ«l"~text~NFC
textNFC~UnicodeCharacters==
    an Array (shape [4], 4 items)
     1 : ( "N"   U+004E Lu 1 "LATIN CAPITAL LETTER N" )
     2 : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
     3 : ( "Ã«"   U+00EB Ll 1 "LATIN SMALL LETTER E WITH DIAERESIS" )
     4 : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
textNFD="NoÃ«l"~text~NFD
textNFD~UnicodeCharacters==
    an Array (shape [5], 5 items)
     1 : ( "N"   U+004E Lu 1 "LATIN CAPITAL LETTER N" )
     2 : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
     3 : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )
     4 : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )
     5 : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
(textNFC == textNFD)=                                               -- 1
(textNFC = textNFD)=                                                -- 1
(" "textNFC == textNFD" ")=                                         -- 0 because strict
(" "textNFC = textNFD" ")=                                          -- 1
(" "textNFC = (textNFD"\u{NBSP}")~unescape)=                        -- 1
(" "textNFC = (textNFD"\u{ZWSP}")~unescape)=                        -- 1
("-"textNFC = ("\u{OBLIQUE HYPHEN}"textNFD"\u{ZWSP}")~unescape)=    -- 1

"pere noel"~text~caselessCompareTo("PÃ¨re NoÃ«l")=                    -- -1 (lesser)
"pere noel"~text~caselessCompareTo("PÃ¨re NoÃ«l", stripMark:.true)=   --  0 (equal because the accents are ignored)


[Encoded strings]

Some transformations will make invalid the positions or lengths passed by the user.
They must not be used under the hood.

lump: ok, no impact on positions or lengths.

stripIgnorable
    "\u{SOFT-HYPHEN} or \u{ZERO-WIDTH-SPACE}"~text~unescape=                    -- T'Â­ or â€‹'
    result~length=                                                              -- 6
    "\u{SOFT-HYPHEN} or \u{ZERO-WIDTH-SPACE}"~text~unescape~NFC(stripIgnorable: .true)=  -- T' or '
    result~length=                                                              -- 4

casefold
    "ÃŸ becomes ss"~text=                                                        -- T'ÃŸ becomes ss'
    result~length=                                                              -- 12
    "ÃŸ becomes ss"~text~NFC(casefold: .true)=                                   -- T'ss becomes ss'
    result~length=                                                              -- 13


The difficulty to manage string indexes with transformations

    The caseless methods with character position or length
        caselessAbbrev                  (info, length) --> boolean
        caselessChangeStr               (needle, newneedle, count) --> string      no position, but the returned string can't be a transformed string
                                                                                   "AbaBabAB"~changeStr("ab","xY")=          -- 'AbaBxYAB'
                                                                                   "AbaBabAB"~caselessChangeStr("ab","xY")=  -- 'xYxYxYxY'
        caselessCompare                 (string, pad) --> 0 if identical, otherwise position of the first character that does not match
        caselessCompareTo               (string, n, length) --> -1, 0 or 1         full UTF-8
        caselessContains                (other, start, length) --> boolean         (new 5)
        caselessLastPos                 (needle, start, length) --> char position
        caselessMatch                   (start, other, n, length) --> boolean      full UTF-8
        caselessMatchChar               (n, chars) --> boolean
        caselessPos                     (needle, start, length) --> char position

    The caseless methods without position
        caselessContainsWord            (phrase, start) --> boolean                (new 5) start is a word index, so not impacted by transformations
        caselessCountStr                (needle) --> count
        caselessEndsWith                (other) --> boolean                        (new 5)
        caselessEquals                  (other) --> boolean                        QUESTIONABLE : STRICTLY equal, so not sure that we can say "ÃŸ" is strictly equal to "ss"
        caselessStartsWith              (other) --> boolean                        (new 5)
        caselessWordPos                 (phrase, start) --> word number or 0       start is a word index, so not impacted by transformations


[Encoded strings]

Add support for ISO-8859-1 encoding (alias Latin1).
Example:
    -- all the supported characters: ranges 20-7E and A0-FF
    text = xrange("20"x, "7E"x, "A0"x, "FF"x)~text("ISO-8859-1")

    -- The ? are just ISO-8859-1 encoded characters that can't be displayed as-is in a console UTF-8 (copy-paste of the console output)
    -- After conversion to UTF-8, all is good.
    text=       -- T' !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~???????????????????????????????????????????????????????????????????????????????????????????????[FF]'
    text~utf8=  -- T' !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿'

    -- ranges 00-1F and 7F-9F are undefined
    -- an error is triggered even with the option strict: .false, because there is no fallback mapping
    text = xrange("20"x, "FF"x)~text("ISO-8859-1")
    text~utf8(strict: .false)=                      -- Error ISO-8859-1 encoding: cannot convert ISO-8859-1 not-ASCII character 127 (7F) at byte-position 96 to UTF-8.


===============================================================================
2022 November 07

[Unicode]

Reactivate oodialog.wchar.
/DUNICODE was missing, now it's really the Unicode DLL which is built.
This is an old version of ooDialog (around early 2010).

Demo:
cdunicode           (as-is, no space, it's an alias)
cd oorexx
rexx ooRexxTry.rex  (no need of wchar as in 2012)

copy-paste in the code area:
.unicode~loadDerivedName("load", .true)
call dump2 "pÃ¨re NoÃ«l"~text~UnicodeCharacters
say "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~description
call dump2 "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…" ~text~UnicodeCharacters


===============================================================================
2022 November 06

[Unicode]

Upgrade to utf8proc version 2.8.0 with Unicode 15.0.0 support.

Can't upgrade to ziglyph for zig 0.10.0 with Unicode 15.0.0 support.
    Runtime error:
        dyld: lazy symbol binding failed: Symbol not found: ___ulock_wait2
          Referenced from: /local/zig/zig-macos-x86_64-0.10.0/zig (which was built for Mac OS X 11.7)
          Expected in: /usr/lib/libSystem.B.dylib
    My MacOs version is High Sierre 10.13.6
    Zig maintainers said they will not fix that.
    https://github.com/ziglang/zig/issues/13313

    https://github.com/ziglang/zig/commit/2d03f389881fbbbd2aa197de523c96d2f7593b7d
    darwin: bump minimum supported version to 11.7.1


===============================================================================
2022 November 06

[Encoded string]

Refactoring
    Prefix the native methods by the library name (utf8proc_, ziglyph_ or icu4x_).
    That will make more easy the comparison of similar services.

    Remove the native methods 'NFC', 'NFD', 'NFKC', 'NFKD' and 'NFKC_Casefold':
    all replaced by 'utf8proc_transform'.

    ~Casefold is now limited to case fold.
    Previously, NKFC + case fold was applied (because the method NFKC_Casefold of utf8proc was called).

    NFC, NFD, NFKC and NFKD now supports the named argument 'casefold' (default = .false).

Examples
    "PÃ¨re NoÃ«l ÃŸ ãŽ’"~text~casefold=                      -- T'pÃ¨re noÃ«l ss ãŽ’'
    "PÃ¨re NoÃ«l ÃŸ ãŽ’"~text~NFKC=                          -- T'PÃ¨re NoÃ«l ÃŸ MHz'
    "PÃ¨re NoÃ«l ÃŸ ãŽ’"~text~NFKC(casefold:.true)=          -- T'pÃ¨re noÃ«l ss mhz'

Performance
    NFC, NFD, NFKC, NFKD and Casefold now supports the named argument 'returnString'.
    - When true, the returned value is a String.
    - When false (default), the returned value is a RexxText.
    Maybe this optimization will be replaced by a more general optimization: RexxText indexation on need.

    2 cached values are managed in case of memorization:
    - one for the main transformation,
    - one for the main transformation + case fold.
    That makes 9 possible cached value and 5 indicators per indexer (so per string).
        isCasefold                  CasefoldString
        isNFC       NFCString       NFCCasefoldString
        isNFD       NFDString       NFDCasefoldString
        isNFKC      NFKCString      NFKCCasefoldString
        isNFKD      NFKDString      NFKDCasefoldString

    The memorization can be activated globally:
    .Unicode~memorizeTransformations = .true

Examples
    -- Direct access to utf8proc, returns a string
    s = "PÃ¨re NoÃ«l ÃŸ ãŽ’"; do 10000; .Unicode~utf8proc_transform(s, norm:3, casefold:.true); end          -- Duration:   0.05
    ---
    t = "PÃ¨re NoÃ«l ÃŸ ãŽ’"~text; do 10000; t~NFKC(casefold:.true); end                                     -- Duration:   7.70
    t = "PÃ¨re NoÃ«l ÃŸ ãŽ’"~text; do 10000; t~NFKC(casefold:.true, returnString:.true); end                 -- Duration:   0.33
    t = "PÃ¨re NoÃ«l ÃŸ ãŽ’"~text; do 10000; t~NFKC(casefold:.true, returnString:.true, mem:.true); end      -- Duration:   0.11
    -- The cache for NFKC  + casefold is different from the cache for NFKC only:
    t = "PÃ¨re NoÃ«l ÃŸ ãŽ’"~text; do 10000; t~NFKC; end                                                     -- Duration:   6.50
    t = "PÃ¨re NoÃ«l ÃŸ ãŽ’"~text; do 10000; t~NFKC(returnString:.true); end                                 -- Duration:   0.30
    t = "PÃ¨re NoÃ«l ÃŸ ãŽ’"~text; do 10000; t~NFKC(returnString:.true, mem:.true); end                      -- Duration:   0.10


===============================================================================
2022 November 05

[Encoded strings]

New methods on RexxText
    caselessContains        (not ready: posText)
    caselessCompareTo
    caselessMatch
    caselessMatchChar       (not ready: matchCharText)
    caselessEndsWith        (not ready: endsWithText)
    caselessPos             (not ready: posText)
    caselessStartsWith      (not ready: posText)
    compareTo
    contains                (not ready: posText)
    endsWith                (not ready: endsWithText)
    match
    matchChar               (not ready: matchCharText)
    pos                     (not ready: posText)
    startsWith              (not ready: posText)

For caseless, apply NFC Casefold to all the text/string arguments.
Compared to the ooRexx methods, the purpose of these methods is to convert the grapheme indexes to/from byte indexes.
The real work is done by the ooRexx methods, called with the right byte indexes.
From a byte index returned by an ooRexx method, a grapheme index is derived.


Examples:
                                                --  1  2    3  4  5  6  7  8 9  10 (grapheme indexes)
                                                --  1  2 3  4  5  6  7  8  9 10 11 (byte indexes)
    "pÃ¨re NoÃ«l"~text~c2x=                       -- '70 C3A8 72 65 20 4E 6F C3AB 6C'
                                                --  p  Ã¨    r  e     N  o  Ã«    l
    "pÃ¨re NoÃ«l"~match(7, "NoÃ«l")=               -- .true (byte indexes)
    "pÃ¨re NoÃ«l"~text~match(6, "NoÃ«l")=          -- .true (grapheme indexes)
    "pÃ¨re NoÃ«l"~match(11, "NoÃ«l", 5)=           -- .true (byte indexes)
    "pÃ¨re NoÃ«l"~text~match(9, "NoÃ«l", 4)=       -- .true (grapheme indexes)

    "pÃ¨re NoÃ«l"~text~caselessMatch(6, "NOÃ‹L")=  -- .true

    -- the first "Ã¤XÃ¼" is NFC, the second "aÌˆXÌˆuÌˆ" is NFD
    nfcString = "Ã¤XÃ¼"
        nfcText = nfcString~text
        nfcText~c2x=                            -- 'C3A4 58 C3BC'
        nfcText~UnicodeCharacters==
            an Array (shape [3], 3 items)
             1 : ( "Ã¤"   U+00E4 Ll 1 "LATIN SMALL LETTER A WITH DIAERESIS" )
             2 : ( "X"   U+0058 Lu 1 "LATIN CAPITAL LETTER X" )
             3 : ( "Ã¼"   U+00FC Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS" )
    nfdString = "aÌˆXuÌˆ"
        nfdText = nfdString~text
        nfdText~c2x=                            -- '61 CC88 58 75 CC88'
        nfdText~UnicodeCharacters==
            an Array (shape [5], 5 items)
             1 : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
             2 : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )
             3 : ( "X"   U+0058 Lu 1 "LATIN CAPITAL LETTER X" )
             4 : ( "u"   U+0075 Ll 1 "LATIN SMALL LETTER U" )
             5 : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )

    nfcString~match(1, nfdString)=              -- 0 (because binary representation is different)
    nfcText  ~match(1, nfdText)=                -- 1
    nfdText  ~match(1, nfcText)=                -- 1

    -- match with "X"

    nfcString~match(3, nfdString, 4, 1)=        -- 1 (byte indexes)
    nfcText  ~match(2, nfdText,   2, 1)=        -- 1 (grapheme indexes)

    nfdString~match(4, nfcString, 3, 1)=        -- 1 (byte indexes)
    nfdText  ~match(2, nfcText,   2, 2)=        -- 1 (grapheme indexes)

Same arguments checking than String, but applied on the normalized texts, using grapheme indexes
    "hello"~match(5, "lo", 2, 2)=               -- Invalid length argument (because length 2 from pos 2 is beyond the end of "lÃ´"
    "hellÃ´"~text~match(5, "lÃ´",2, 2)=           -- idem (good)

    "hello"~match(4, "")=                       -- Invalid position argument specified; found "1" (it's the default value)
    "hellÃ´"~text~match(4, "")=                  -- idem (good)


===============================================================================
2022 November 01

[ICU4X]

Make ICU4X optional.
#ifdef HAVE_ICU4X
...
#endif
Should let build Executor under Linux, for which I did not build the ICU4X binaries.

                            MacOs                   Windows
                            librexx.4.dylib         rexx.dll
release without ICU4X       2 224 776               1 907 712
release with ICU4X          2 224 776               1 907 712
debug   without ICU4X       4 040 104               4Â 615Â 680
debug   with ICU4X          4 040 104               4 616 704

Same size with/without ICU4X because I don't have yet some code which depends on ICU4X.
The ICU4X headers contains source code that is compiled, the compiler/linker removes the unused code.


===============================================================================
2022 October 30

[Unicode]

Link problem with Ziglyph under Windows in debug mode.
Workaround: build Ziglyph in release mode, always.

    [ 11%] Building cziglyph...
    E:\Local\zig\zig-windows-x86_64-0.9.1\zig.EXE
        build-lib
        Y:\local\rexx\oorexx\executor\sandbox\jlf\trunk\interpreter\classes\support\m17n\cziglyph\src\cziglyph.zig
        -lc
        -lc++
        --cache-dir E:\Local\rexxlocal\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\debug\64\build\lib\cziglyph\zig-cache
        --global-cache-dir C:\Users\JL Faucher\AppData\Local\zig
        --name cziglyph
        -static
        -fcompiler-rt
        -target x86_64-windows-msvc
        -mcpu x86_64
        --pkg-begin ziglyph
        Y:\local\rexx\oorexx\executor\sandbox\jlf\trunk\interpreter\classes\support\m17n\ziglyph\src\ziglyph.zig
        --pkg-end
        --enable-cache


    [ 62%] Linking CXX shared library bin\rexx.dll
       Creating library lib\rexx.lib and object lib\rexx.exp
    cziglyph.lib(cziglyph.obj) : error LNK2019: unresolved external symbol NtClose referenced in function std.os.windows.CloseHandle
    cziglyph.lib(cziglyph.obj) : error LNK2019: unresolved external symbol NtCreateFile referenced in function std.target.Arch.isWasm
    cziglyph.lib(cziglyph.obj) : error LNK2019: unresolved external symbol NtLockFile referenced in function std.target.Arch.isWasm
    cziglyph.lib(cziglyph.obj) : error LNK2019: unresolved external symbol NtWaitForKeyedEvent referenced in function std.meta.assumeSentinel.176
    cziglyph.lib(cziglyph.obj) : error LNK2019: unresolved external symbol NtCreateKeyedEvent referenced in function std.fmt.formatValue.226
    bin\rexx.dll : fatal error LNK1120: 5 unresolved externals


===============================================================================
2022 October 28

[Unicode]

Integration of ICU4X
http://blog.unicode.org/2022/09/announcing-icu4x-10.html
https://github.com/unicode-org/icu4x

Prerequisite:
Compiler supporting C++20.
Only the file that includes the ICU4X headers need to be compiled with C++20.
The rest of the interpreter stay compiled with C++11.
The sources of Executor/ooRexx can't be compiled with C++20 without modifications.

For the moment, there is no delivery of binaries by the project ICU4X.
To simplify the build of Executor, the dynamic library of ICU4X is delivered
with the sources of Executor, ready to use without any installation.
Only the release version of ICU4X is provided.
Only the binaries for MacOs and Windows 64-bit are provided, I don't have Linux.
    7 261 556   libicu_capi_cdylib.dylib
    6Â 224Â 384   icu_capi_cdylib.dll

Regarding the decision to use a dynamic linking instead of a static linking, see
    https://github.com/unicode-org/icu4x/discussions/2791
The attached file shows huge files sizes when using static linking.


===============================================================================
2022 October 22

[Named arguments]

I was curious to see the impact of strlen in NamedArguments::checkNameMatching.
If I avoid to call strlen when the length is known (typically when working with
RexxString), I get better performances, especially for the case "worst long names".

samples/benchmark/named_arguments-benchmark.rex
before                              now
100000 calls                        100000 calls
positional=           0.15          positional=           0.15
optimal short names=  0.42          optimal short names=  0.42
worst short names=    0.57          worst short names=    0.47
ratio short names=    1.36          ratio short names=    1.12
optimal long names=   0.49          optimal long names=   0.44
worst long names=     0.93          worst long names=     0.76
ratio long names=     1.90          ratio long names=     1.73


===============================================================================
2022 October 18

[Named arguments]

New rule regarding an abbreviatable name:
    A compound name cannot be abbreviated to a stem name.
The goal of this rule, combined with the other rules already defined, is to not decapitate the tail of a compound symbol.
Only the last tail part can be abbreviated.

stem.key1 cannot be abbreviated like that (because the optional part contains a period):
    (1)     s
    (2)     st
    (3)     ste
    (4)     stem
stem.key1 cannot be abbreviated like that (because of the new rule: stem. is a stem name):
    (5)     stem.
stem.key1 can be abbreviated like that:
    (6)     stem.k
    (7)     stem.ke
    (8)     stem.key
    (9)     stem.key1

stem.key1.key2 cannot be abbreviated like that (because the optional part contains a period):
    (1)     s
    (2)     st
    (3)     ste
    (4)     stem
    (5)     stem.
    (6)     stem.k
    (7)     stem.ke
    (8)     stem.key
    (9)     stem.key1
stem.key1.key2 can be abbreviated like that:
    (10)    stem.key1.                              <-- the new rule is not applicable here
    (11)    stem.key1.k
    (12)    stem.key1.ke
    (13)    stem.key1.key
    (14)    stem.key1.key2


Remember:
Any block source is transformed at parse-time to make it start with
    use auto named args
So any abbreviated named argument passed by the caller will create a local variable
of the same name. That's why the 'K' index exists in this example:
{call dump2 stem.; say "-----"; use named arg stem.key1(6); call dump2 stem.}~(stem.k:1)
    a Stem (1 items)
    'K' :  1                <-- this entry has been created by 'use auto named arg' when processing stem.k:1
    -----
    a Stem (2 items)
    'K'    :  1
    'KEY1' :  1             <-- this entry has been created by 'use named arg stem.key1(6)' when processing stem.k:1
I was surprised by this entry 'K', until I remember the source transformation...
To improve? not sure... Works as designed.


===============================================================================
2022 October 15

[Named arguments]

New constraint regarding the miminum length of an abbreviatable name:
    must be <= name's length
The complete rule is:
    The minimum length of an abbreviatable name must be a whole number > 0 and <= name's length.
Example:
    {use named arg minimum(10)}                     -- error Use named arg: The minimum length of an abbreviatable name must be a whole number > 0 and <= name's length


New rule regarding an abbreviatable name:
    The optional part of an abbreviatable name cannot contain a period.
Example:
    {use named arg stem.key1.key2(9)}               -- error Use named arg: The optional part of an abbreviatable name cannot contain a period


Better diagnosis when name collision/ambiguity.
Rule:
    No named parameter name must start with the name of another named parameter.
    Exception: a stem name (single period as last character) can be used as prefix in several compound names.
Examples:
    {use named arg normalization(1), nfl(2)}        -- error Use named arg: The name 'NORMALIZATION(1)' collides with 'NFL(2)'
    {use named arg commands, command}               -- error Use named arg: The name 'COMMAND' collides with 'COMMANDS'
    {use named arg commands(7), command}            -- error Use named arg: The name 'COMMANDS' collides with 'COMMANDS(7)'
    {use named arg stem., stem.key1, stem.key2}     -- no error
    {use named arg stem, stem.key1, stem.key2}      -- error Use named arg: The name 'STEM' collides with 'STEM.KEY1'


Reworked the method NamedArguments::checkNameMatching.
The name matching is slightly slower for short names, but 4 times faster for long names.
samples/benchmark/named_arguments-benchmark.rex
before                              now
100000 calls                        100000 calls
positional=           0.19          positional=           0.21
optimal short names=  0.35          optimal short names=  0.48
worst short names=    0.40          worst short names=    0.60
ratio short names=    1.14          ratio short names=    1.25
optimal long names=   0.99          optimal long names=   0.47
worst long names=     4.04          worst long names=     0.94
ratio long names=     4.08          ratio long names=     2.00


===============================================================================
2022 October 15

New native method .Unicode~transform
Mainly for internal use, will replace the current native methods NFC, NFD, NFKC, NFKD.
The purpose of this method is to support additional transformations provided by utf8proc.
Takes a byte string as input (UTF-8 encoded), returns a new transformed byte string as output (UTF-8).

Examples:

    string = "\u{BEL}Le\u{IDEOGRAPHIC SPACE}\u{OGHAM SPACE MARK}\u{ZERO-WIDTH-SPACE}PÃ¨re\t\u{HYPHEN}\u{SOFT-HYPHEN}\u{EN DASH}\u{EM DASH}NoÃ«l\x{EFB790}\r\n"
    text = string~text~unescape
    text~UnicodeCharacters==
        an Array (shape [22], 22 items)
         1  : ( ""    U+0007 Cc 0 "", "ALERT", "BEL" )                                                  <-- removable with STRIPCC:.true
         2  : ( "L"   U+004C Lu 1 "LATIN CAPITAL LETTER L" )
         3  : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )
         4  : ( "ã€€"  U+3000 Zs 2 "IDEOGRAPHIC SPACE" )                                                 <-- replaceable by " " with LUMP:.true
         5  : ( "áš€"   U+1680 Zs 1 "OGHAM SPACE MARK" )                                                  <-- replaceable by " " with LUMP:.true
         6  : ( "â€‹"    U+200B Cf 0 "ZERO WIDTH SPACE", "ZWSP" )                                          <-- removable by STRIPIGNORABLE:.TRUE
         7  : ( "P"   U+0050 Lu 1 "LATIN CAPITAL LETTER P" )
         8  : ( "Ã¨"   U+00E8 Ll 1 "LATIN SMALL LETTER E WITH GRAVE" )
         9  : ( "r"   U+0072 Ll 1 "LATIN SMALL LETTER R" )
         10 : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )
         11 : ( ""    U+0009 Cc 0 "", "CHARACTER TABULATION", "HORIZONTAL TABULATION", "HT", "TAB" )    <-- replaceable by " " with STRIPCC:.true
         12 : ( "â€"   U+2010 Pd 1 "HYPHEN" )                                                            <-- replaceable by "-" with LUMP:.true
         13 : ( "Â­"   U+00AD Cf 1 "SOFT HYPHEN", "SHY" )                                                <-- removable by STRIPIGNORABLE:.true
         14 : ( "â€“"   U+2013 Pd 1 "EN DASH" )                                                           <-- replaceable by "-" with LUMP:.true
         15 : ( "â€”"   U+2014 Pd 1 "EM DASH" )                                                           <-- replaceable by "-" with LUMP:.true
         16 : ( "N"   U+004E Lu 1 "LATIN CAPITAL LETTER N" )
         17 : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
         18 : ( "Ã«"   U+00EB Ll 1 "LATIN SMALL LETTER E WITH DIAERESIS" )
         19 : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
         20 : ( "ï·"   U+FDD0 Cn 1 "" )                                                                 <-- removeable with STRIPNA:.true
         21 : ( ""    U+000D Cc 0 "", "CARRIAGE RETURN", "CR" )
         22 : ( ""    U+000A Cc 0 "", "LINE FEED", "NEW LINE", "END OF LINE", "LF", "NL", "EOL" )       <-- CR+LF replaceable by " " with STRIPCC:.true

    text=                                                               -- T'[07]Leã€€áš€â€‹PÃ¨re[09]â€Â­â€“â€”NoÃ«lï·[0D0A]'

    -- Performs unicode case folding, to be able to do a case-insensitive string comparison.
    .Unicode~utf8proc_transform(text~string, casefold:.true)=           --  '[07]leã€€áš€â€‹pÃ¨re[09]â€Â­â€“â€”noÃ«lï·[0D0A]'

    -- Strip "default ignorable characters" such as SOFT-HYPHEN or ZERO-WIDTH-SPACE
    .Unicode~utf8proc_transform(text~string, stripIgnorable:.true)=     --  '[07]Leã€€áš€PÃ¨re[09]â€â€“â€”NoÃ«lï·[0D0A]'

    -- Lumps certain characters together. See lump.md for details:
    -- https://github.com/JuliaStrings/utf8proc/blob/master/lump.md
    -- E.g. HYPHEN U+2010 and MINUS U+2212 to ASCII "-"
    -- jlf: I was expecting to have only one space and one "-" but that's not the case
    -- Seems working as designed... All the concerned characters become the same character, but still remain distinct characters.
    .Unicode~utf8proc_transform(text~string, lump:.true)=               --  '[07]Le  â€‹PÃ¨re[09]-Â­--NoÃ«lï·[0D0A]'
         4  : ( " "   U+0020 Zs 1 "SPACE", "SP" )
         5  : ( " "   U+0020 Zs 1 "SPACE", "SP" )
         6  : ( "â€‹"    U+200B Cf 0 "ZERO WIDTH SPACE", "ZWSP" )
         12 : ( "-"   U+002D Pd 1 "HYPHEN-MINUS" )
         13 : ( "Â­"   U+00AD Cf 1 "SOFT HYPHEN", "SHY" )
         14 : ( "-"   U+002D Pd 1 "HYPHEN-MINUS" )
         15 : ( "-"   U+002D Pd 1 "HYPHEN-MINUS" )

    -- NLF2LF: Convert LF, CRLF, CR and NEL into LF
    .Unicode~utf8proc_transform(text~string, NLF:1)=                    --  '[07]Leã€€áš€â€‹PÃ¨re[09]â€Â­â€“â€”NoÃ«lï·[0A]'

    -- NLF2LS: Convert LF, CRLF, CR and NEL into LS (U+2028 Zl 0 "LINE SEPARATOR")
    .Unicode~utf8proc_transform(text~string, NLF:2)=                    --  '[07]Leã€€áš€â€‹PÃ¨re[09]â€Â­â€“â€”NoÃ«lï·
'

    -- NLF2PS: convert LF, CRLF, CR and NEL into PS (U+2029 Zp 0 "PARAGRAPH SEPARATOR")
    .Unicode~utf8proc_transform(text~string, NLF:3)=                    --  '[07]Leã€€áš€â€‹PÃ¨re[09]â€Â­â€“â€”NoÃ«lï·
'

    -- Strips and/or converts control characters.
    .Unicode~utf8proc_transform(text~string, stripCC:.true)=            --  'Leã€€áš€â€‹PÃ¨re â€Â­â€“â€”NoÃ«lï· '

    -- Strips all character markings.
    -- This includes non-spacing, spacing and enclosing (i.e. accents).
    -- This option works only with normalization.
    .Unicode~utf8proc_transform(text~string, stripMark:.true, normalization:1)=  --  '[07]Leã€€áš€â€‹Pere[09]â€Â­â€“â€”Noelï·[0D0A]'

    -- Strips unassigned codepoints.
    .Unicode~utf8proc_transform(text~string, stripNA:.true)=            --  '[07]Leã€€áš€â€‹PÃ¨re[09]â€Â­â€“â€”NoÃ«l[0D0A]'

    -- Application of several options (abbreviated names)
    .Unicode~utf8proc_transform(text~string, casef:.true, lump:.true, norm:1, stripi:.true, stripc:.true, stripm:.true, stripn:.true)= --  'le  pere ---noel '
        an Array (shape [17], 17 items)
         1  : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
         2  : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )
         3  : ( " "   U+0020 Zs 1 "SPACE", "SP" )               <-- LUMP (was IDEOGRAPHIC SPACE)
         4  : ( " "   U+0020 Zs 1 "SPACE", "SP" )               <-- LUMP (was OGHAM SPACE MARK)
         5  : ( "p"   U+0070 Ll 1 "LATIN SMALL LETTER P" )
         6  : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )
         7  : ( "r"   U+0072 Ll 1 "LATIN SMALL LETTER R" )
         8  : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )
         9  : ( " "   U+0020 Zs 1 "SPACE", "SP" )               <-- STRIPCC (was TAB)
         10 : ( "-"   U+002D Pd 1 "HYPHEN-MINUS" )              <-- LUMP (was HYPHEN)
         11 : ( "-"   U+002D Pd 1 "HYPHEN-MINUS" )              <-- LUMP (was EN DASH)
         12 : ( "-"   U+002D Pd 1 "HYPHEN-MINUS" )              <-- LUMP (was EM DASH)
         13 : ( "n"   U+006E Ll 1 "LATIN SMALL LETTER N" )
         14 : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
         15 : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )
         16 : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
         17 : ( " "   U+0020 Zs 1 "SPACE", "SP" )               <-- STRIPCC (was CR+LF)


===============================================================================
2022 October 04

[Encoded strings]

Undo m17n strong types.
Undo String B[yte]/C[har] API.
I abandoned since several years the idea of modifying the String class to support graphemes.
The String class is, and will remain, byte-oriented.

The new path I would like to explore is the support of graphemes by the BIF...
I have already a tiny support for center() and left(), only triggered in case of
pad character made of several bytes.

The generalization would be to route the BIF either towards String or towards RexxText,
in function of the compatibility of the arguments with String:
BIF(str1, str2, ..., strN)
    --> forward to String (byte-oriented) if str's encoding is Byte or UTF-8 (with ASCII characters only)
    --> forward to RexxText otherwise

My goal:
Assuming default encoding is UTF-8
    length("Noel")=     -- 4 because "Noel"~length = 4
    length("NoÃ«l")=     -- 4 because "NoÃ«l"~text~length = 4
    "NoÃ«l"~length=      -- 5 because String remains byte-oriented, not impacted by the default encoding

    s = "0041004200430044"x
    length(s)=                        -- 8 because encoding UTF-8 ASCII is compatible with String
    s~encoding = "UTF16"
    s~length                          -- 8 because String is always byte-oriented (ignores the encoding)
    length(s)=                        -- 4 because forwards to Text (encoding UTF-16BE is not compatible with String)
    s~text~utf8=                      -- ABCD

    s = "0000004100000042"x
    length(s)                         -- 8 because encoding UTF-8 ASCII is compatible with String
    s~encoding = "UTF32"
    s~length                          -- 8 because String is always byte-oriented (ignores the encoding)
    length(s)=                        -- 2 because forwards to Text (encoding UTF-32 is not compatible with String)
    s~text~utf8=                      -- AB


===============================================================================
2022 September 20

Extensions of the class Object:
Need to be more modular, to allow loading these extensions only.
Moved from extensions.cls to a new file object.cls

Compatibility with ooRexx5:
Retrofit .Package~findProgram


[Extended interpreter]

The script 'executor' now supports the options -e and -v, like rexx,
and also options to load a library or a package:
    executor (-l libray | -p package)* [-f] filename [arguments]
    executor (-l libray | -p package)*  -e  string   [arguments]
    executor -v

Differences, compared to rexx -e:
- .syscargs has a value
- The labels are not supported (limitation of the instruction interpret)
- The directives :: are not supported. Use the options -l or -p.
- If no RESULT value then returns the RC value (rexx doesn't return the RC value)
  (Oct 03, 2022: Align with rexx, return the RC value only in case of error)

Examples:

executor -e "call dump2 .syscargs" he said "good bye" and left.
    an Array (shape [5], 5 items)
     1 : 'he'
     2 : 'said'
     3 : 'good bye'
     4 : 'and'
     5 : 'left.'

executor -l rxunixsys -e "say SysUname("version")"
    Darwin Kernel Version 17.7.0: Fri Oct 30 13:34:27 PDT 2020; root:xnu-4570.71.82.8~1/RELEASE_X86_64

executor -p regex/regex.cls -e "say .Pattern~compile('^\m{email}$')~matches(arg(1))" postmaster@oorexx.org
    1

-- The option -f is optional, except when the filename starts with "-"
executor -f factorial.rex 10
    3628800

executor factorial.rex 10
    3628800

-- RC value is returned when no RESULT
executor -e "true"                  -- RC == 0
executor -e "false"                 -- RC == 1      rexx returns 0 (Oct 03, 2022: Align with rexx, now Executor returns 0)
executor -e "true; return 10"       -- RC == 10
executor -e "false; return 10"      -- RC == 10


===============================================================================
2022 September 19

[RosettaCode executor]

Align with RosettaCodeData commit of February 18 2020 (Family day update)
https://github.com/acmeism/RosettaCodeData

Activate the solutions whose name begins with "D".

This query gives the number of RosettaCodeData solutions provided per langage, sorted ascending.
Rexx is in good position... Go is the winner.
"/local/RosettaCodeData/git/Lang"~pipe(.fileTree "recursive.1.breadthFirst" | .select {item~isDirectory} | .lineCount {item~parent} | .sort | .console {item~right(6)} "index")
   ...
   601 '/local/RosettaCodeData/git/Lang/Sidef'
   612 '/local/RosettaCodeData/git/Lang/Ada'
   630 '/local/RosettaCodeData/git/Lang/Zkl'
   632 '/local/RosettaCodeData/git/Lang/Scala'
   634 '/local/RosettaCodeData/git/Lang/REXX'
   638 '/local/RosettaCodeData/git/Lang/Mathematica'
   654 '/local/RosettaCodeData/git/Lang/PicoLisp'
   661 '/local/RosettaCodeData/git/Lang/Java'
   663 '/local/RosettaCodeData/git/Lang/J'
   667 '/local/RosettaCodeData/git/Lang/Haskell'
   671 '/local/RosettaCodeData/git/Lang/D'
   676 '/local/RosettaCodeData/git/Lang/Ruby'
   677 '/local/RosettaCodeData/git/Lang'
   696 '/local/RosettaCodeData/git/Lang/C'
   708 '/local/RosettaCodeData/git/Lang/Phix'
   709 '/local/RosettaCodeData/git/Lang/Perl'
   726 '/local/RosettaCodeData/git/Lang/Kotlin'
   727 '/local/RosettaCodeData/git/Lang/Python'
   730 '/local/RosettaCodeData/git/Lang/Racket'
   730 '/local/RosettaCodeData/git/Lang/Julia'
   731 '/local/RosettaCodeData/git/Lang/Tcl'
   741 '/local/RosettaCodeData/git/Lang/Perl-6'
   745 '/local/RosettaCodeData/git/Lang/Go'
   <end>


===============================================================================
2022 September 19

[Encoded strings]

Several solutions in RosettaCode are in error because the pad character used
with the function 'center' is a UTF-8 string made of several bytes.
The function center now supports utf-8 pad made of 1 grapheme.
When the pad is not a 1 byte character then the interpreter converts the string
to a RexxText and sends it the message "center".
The returned value is the String associated to the RexxText.
The invariants of the method 'center' are true for the RexxText, but not true for
the String (which is normal).
    pad = "â•"
    pad~description=                                    -- 'UTF-8 not-ASCII (1 grapheme, 1 codepoint, 3 bytes, 0 error)'
    pad~c2x=                                            -- 'E29590'
    center("hello", 20, pad)=                           -- 'â•â•â•â•â•â•â•helloâ•â•â•â•â•â•â•â•'
    center("hello", 20, pad)~text~description=          -- 'UTF-8 not-ASCII (20 graphemes, 20 codepoints, 50 bytes, 0 error)'

Idem for the function 'left'
    pad = "â•"
    left("hello", 20, pad)=                             -- 'helloâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
    left("hello", 20, pad)~text~description=            -- 'UTF-8 not-ASCII (20 graphemes, 20 codepoints, 50 bytes, 0 error)'

todo:
apply this change to all the functions and methods that take a pad argument.
2022 Oct, 4: a more general approach can be used, see notes on Oct 4.
2024 Apr, 10: the string BIFs are polymorphic on RexxString/RexxText.


===============================================================================
2022 September 19

[Extended interpreter]

New scripts executor, executor.bat, executor.rexx
Allow to execute a rexx script which depends on extensions, without modifying it.
This is similar to what ooRexxShell allows, but with less loaded packages.
The warm-up duration is still too long: around  1.8 sec on my old MacBook Pro mid-2010
Intel Core2 Duo CPU P8600 @ 2.40GHz.
Usage:
    executor <my script> <arg1> <arg2> ...


===============================================================================
2022 September 19

[RosettaCode executor]

Executor stack overflow for Ackermann-function/ackermann-function-1.rex
regina can execute it, oorexx5 can execute it after replacing variable #
Modify the C stack size:
- old: #define TOTAL_STACK_SIZE 1024*512
- new: #define TOTAL_STACK_SIZE 1024*512*4
Multiplying by 2 was not enough...
Why do I need THAT?
Ok under MacOs, crash under Windows.

2023.06.27
oorexx [bugs:#1911] The interpreter is using too small of a stacksize.
The build of the interpreter uses a 500Kb stack size that is hardcoded into the
PlatformDefinitions.h file for both Windows and *ix platforms. This size is also
specified as the /STACK option for linking the .exe files on Windows. This value
is actually smaller than the default 1Mb limit that Windows uses. This should be
reworked so that the value used comes from the CMakeList.txt definitions and is
inline with more modern limits.


===============================================================================
2022 September 15

[Encoded strings]

When using the script Unicode/scripts/dump_encoded.rex, I discovered a problem
of circular dependency that was not visible from ooRexxShell:
    unicode.cls <--> stringEncoding.cls
Because of the circular dependency, the encoding classes were not visible from
unicode.cls, and an error was raised:
    REX0476E: Error 97.1:  Object ".ENCODING" does not understand message "DEFAULTOUTPUTENCODING".
Fixed by moving the routine ppCodepoint in encodeString.cls and removing the requires
of unicode.cls. Now the dependency graph is:
    unicode.cls --> stringEncoding.cls
Remember:
In ooRexxShell, the routines 'declareAllPublicClasses' and 'declareAllPublicRoutines'
make visible all the public classes and routines required directly (normal ooRexx behavior),
and also recursively (this is why the visibility problem related to the circular dependency
was not visible from ooRexxShell).


===============================================================================
2022 September 14

[Encoded strings]

Now that an encoding can be set/get on a string without requesting a RexxText,
it's possible to avoid the creation of intermediary RexxText.

New method ~requestTextOrString which doesn't force the creation of a text from
a string. If a text is associated to the string, then this text is returned,
otherwise the string is returned.
Careful! Sometimes you really need to have a text... For example when checking
the length of a pad character.


New methods on RexxText
    center
    centre
Examples:
    "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~description=                  -- 'UTF-8 not-ASCII (6 graphemes, 12 codepoints, 34 bytes, 0 error)'
    "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~center(10)=                   -- T'  noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…  '
    "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~center(10)~description=       -- 'UTF-8 not-ASCII (10 graphemes, 16 codepoints, 38 bytes, 0 error)'
    pad = "â•"
    pad~description=                                          -- 'UTF-8 not-ASCII (1 grapheme, 1 codepoint, 3 bytes, 0 error)'
    pad~c2x=                                                  -- 'E29590'
    "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~center(10, pad)=              -- T'â•â•noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…â•â•'
    "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~center(10, pad)~description=  -- 'UTF-8 not-ASCII (10 graphemes, 16 codepoints, 46 bytes, 0 error)'


===============================================================================
2022 September 09

[Unicode]

Remove .Unicode~unknownCharacter
Not needed so far, and moreover brings trouble when iterating over the characters
because must exclude it using ~drop(1).


===============================================================================
2022 September 09

[Encoded strings]

text~title is now implemented with utf8proc for all the Unicode encodings
(before, was implemented with ziglyph for UTF-8 only)


Add these methods, implemented with ziglyph:
    .Unicode~stringToCaseFold
    .Unicode~stringToLower
    .Unicode~stringToUpper
For the moment, they are not accessible from a RexxText.
From a RexxText, the implementation is based on utf8proc.


For one character, utf8proc and ziglyph provide different results for upper/title
    .Unicode~characters~select{utf8proc = item~utf8~upper; ziglyph= .Unicode~ziglyph_stringToUpper(item~utf8~string); utf8proc \== ziglyph}==
        an Array (shape [1], 1 items)
         1 : ( "ÃŸ"   U+00DF Ll 1 "LATIN SMALL LETTER SHARP S" )
    utf8proc returns ( "áºž"   U+1E9E Lu 1 "LATIN CAPITAL LETTER SHARP S" )
    ziglyph  returns ( "ÃŸ"   U+00DF Ll 1 "LATIN SMALL LETTER SHARP S" )
Both are wrong, should be "SS"
Unicode standard 14 section 5.18 Case Mappings:
    Default casing                                         Tailored casing
    (small sharp) ÃŸ <--- ÃŸ (capital sharp)                 (small sharp) ÃŸ <--> áºž (capital sharp)
    (small sharp) ÃŸ ---> SS
                 ss <--> SS                                             ss <--> SS
When using the default Unicode casing operations, capital sharp s will lowercase
to small sharp s, but not vice versa: small sharp s uppercases to â€œSSâ€.
A tailored casing operation is needed in circumstances requiring small sharp s
to uppercase to capital sharp s.

For some characters, utf8proc and ziglyph provide the same wrong results for upper/lower
"DiyarbakÄ±r"~text~upper=                    -- T'DIYARBAKIR'   should be DÄ°YARBAKIR
.Unicode~stringToUpper("DiyarbakÄ±r")=       --  'DIYARBAKIR'
"DÄ°YARBAKIR"~text~casefold=                 -- T'diÌ‡yarbakir'   should be diyarbakÄ±r
.Unicode~stringToCaseFold("DÄ°YARBAKIR")=    --  'diÌ‡yarbakir'
"DÄ°YARBAKIR"~text~lower=                    -- T'diyarbakir'
.Unicode~stringToLower("DÄ°YARBAKIR")=       --  'diyarbakir'


Start working on encoding~previousCodepointIndex:
    "ðŸŽ…noÃ«l"~text~c2x=  -- 'F09F8E85 6E 6F C3AB 6C'
    .utf8_encoding~previousCodepointIndex("ðŸŽ…noÃ«l", 0)=   -- 0
    .utf8_encoding~previousCodepointIndex("ðŸŽ…noÃ«l", 1)=   -- 1
    .utf8_encoding~previousCodepointIndex("ðŸŽ…noÃ«l", 2)=   -- 1
    .utf8_encoding~previousCodepointIndex("ðŸŽ…noÃ«l", 3)=   -- 1
    .utf8_encoding~previousCodepointIndex("ðŸŽ…noÃ«l", 4)=   -- 1
    .utf8_encoding~previousCodepointIndex("ðŸŽ…noÃ«l", 5)=   -- 1
    .utf8_encoding~previousCodepointIndex("ðŸŽ…noÃ«l", 6)=   -- 5
    .utf8_encoding~previousCodepointIndex("ðŸŽ…noÃ«l", 7)=   -- 6
Currently, only Byte_encoding and UTF8_encoding supports this new method.
Still lot of work to detect the same errors as nextCodepointIndex.


===============================================================================
2022 September 08

[Encoded strings]

Set/get an encoding on a string without having an associated RexxText
(similar to MutableBuffer)
s = "nonsense"
s~encoding =                      -- returns the default encoding: (The UTF8_Encoding class)
s~hasText =                       -- 0
s~encoding = .UTF16BE_Encoding    -- tag the string: encoded UTF16BE
s~encoding =                      -- (The UTF16BE_Encoding class)
s~hasText =                       -- still no associated RexxText: 0
t = s~text                        -- associates a RexxText to the string
s~hasText =                       -- the string has an associated text: 1
t~encoding =                      -- the encoding of the text is the one of the string: (The UTF16BE_Encoding class)
t~utf8 =                          -- T'æ¹¯æ¹³æ•®ç¥'      Soup
-- Setting/getting the encoding of the string will set/get the encoding of the associated RexxText
s~encoding = .UTF16LE_Encoding
t~encoding =                      -- the encoding of the text has been changed: (The UTF16LE_Encoding class)
t~utf8 =                          -- T'æ½®ç®æ¹¥æ•³'      tide


===============================================================================
2022 September 07

[Encoded strings]

Add method MutableBuffer~isASCII
Implementation more complex than for String, because mutable.
Try to avoid to rescan the whole buffer, when possible.
The native methods that modify the buffer are never scanning the buffer, they
are just setting the boolean indicators is_ASCII_checked and is_ASCII.
It's only the Rexx method ~isASCII which scans the whole buffer, if needed.
Impacted methods:
    append
    caselessChangeStr
    changeStr
    delete
    delWord
    insert
    overlay
    replaceAt
    setBufferSize
    space
    translate

b = .MutableBuffer~new("pere")
b~isASCII =                             -- 1
b~insert("noÃ«l", 5)=                    -- M'pere noÃ«l'
b~isASCII =                             -- 0
b~setBufferSize(7)=                     -- M'pere no'
b~isASCII=                              -- 1
b~append("Ã«", "l")=                     -- M'pere noÃ«l'
b~isASCII=                              -- 0
b~replaceAt("e", 8, 2)=                 -- M'pere noel'
b~isASCII=                              -- 1
b~changeStr("noel", "noÃ«l")=            -- M'pere noÃ«l'
b~isASCII=                              -- 0
b~delete(8,2)=                          -- M'pere nol'
b~isASCII=                              -- 1
b~overlay("Ã«l", 8)=                     -- M'pere noÃ«l'
b~isASCII=                              -- 0
b~delWord(2)=                           -- M'pere '
b~isASCII=                              -- 1
b~translate("Ã¨" || "91"x, "er ")=       -- M'pÃ¨Ã‘'    ("Ã¨" is "C3A8"x so "e"-->"C3"x, "r"-->A8"x and " "-->"91"x
b~isASCII=                              -- 0


===============================================================================
2022 September 07

[Compatibility with classic rexx]

The Roseta Code script "Check-that-file-exists/check-that-file-exists-2.rexx"
uses ~ as a negator character.
Regina supports the following characters as negators:
    \ Backslash (ANSI Standard)
    ^ Caret
    ~ Tilde
    Â¬ Logical Not
Add support for ^ and Â¬
Not possible to use ~ as a negator character

^0=     -- 1
^1=     -- 0
Â¬0=     -- 1
Â¬1=     -- 0
^Â¬^0=   -- 1
^Â¬^Â¬0=  -- 0

The operators /= and /== are supported in TSO/E REXX as alternatives to \= and \==, respectively.
The Roseta Code script "Determine-if-a-string-is-numeric/determine-if-a-string-is-numeric.rexx"
uses /==
Add support for /= and /==

"a" /= " a " =      -- 0
"a" /== " a " =     -- 1
"a" /== "a" =       -- 0


===============================================================================
2022 August 31

[Unicode]

Integration of Ziglyph.
Ziglyph is an alternative to utf8proc, with more functionalities.
https://github.com/jecolon/ziglyph
https://zig.news/dude_the_builder/ziglyph-unicode-wrangling-llj

Prerequisite: install zig and set PATH.
https://ziglang.org/


[update 09/09/2022: text~title is now implemented with utf8proc for all the Unicode encodings]

To demonstrate the integration, added title-casing using Ziglyph implementation.
"hello john"~text~title=            -- T'Hello John'

Available only for UTF-8 and WTF-8.
"hello"~text~utf16~title=           -- Method TITLE is ABSTRACT and cannot be directly invoked.

If the UTF-8 string is ill-formed then an error is raised by Ziglyph.
"DC00 D801 DC01"x~text~title=       -- StringToTitle raised an error.


===============================================================================
2022 August 18

[Encoded strings]

Added Unicode case folding.
See https://www.w3.org/TR/charmod-norm/
Case folding is the process of making two texts which differ only in case identical for comparison purposes.
Implemented with utf8proc, which applies an NFKC normalization on the case-folded string.

Methods on RexxText:
    ~Casefold   ~isCasefold

"ÃŸ"~text~casefold=               -- T'ss'
"ãŽ’"~text~casefold=              -- T'mhz'   (jlf Nov 8, 2022: now unchanged because no longer NFKC)

("sTrasse", "straÃŸe", "STRASSE")~each{item~text~casefold}==
    an Array (shape [3], 3 items)
     1 : T'strasse'
     2 : T'strasse'
     3 : T'strasse'

-- utf8proc doesn't support language-sensitive case-folding.
-- Example:
-- The name of the second largest city in Turkey is "DiyarbakÄ±r", which contains both the dotted and dotless letters i.
"DiyarbakÄ±r"~text~upper=        -- T'DIYARBAKIR'   should be DÄ°YARBAKIR
"DÄ°YARBAKIR"~text~casefold=     -- T'diÌ‡yarbakir'   should be diyarbakÄ±r

The Julia developers, who uses utf8proc, have decided to remain locale-independent.
See https://github.com/JuliaLang/julia/issues/7848


===============================================================================
2022 August 07

[Encoded strings]

Added normalization NFC, NFD, NFKC, NFKD.
http://unicode.org/faq/normalization.html
Implemented with utf8proc.

Methods on RexxText:
    ~NFC    ~isNFC
    ~NFD    ~isNFD
    ~NFKC   ~isNFKC
    ~NFKD   ~isNFKD

Possible values for isNFxx:
    -1  unknown
     0  no
     1  yes
A same text can be in several normalization forms.
Text exclusively containing ASCII characters (U+0000..U+007F) is left unaffected
by all of the Normalization Forms: The 4 indicators isNFxx are 1.

The methods NFxx sets the corresponding indicator isNFxx
- on the source text : 0 or 1 (test if both strings are equal)
- on the result text : 1

The normalized text can be memorized on the original text:
    text = "pÃ¨re NoÃ«l"~text
    textNFD = text~nfd(memorize:.true)      -- abbreviation mem:.true
From now, the returned NFD is always the memorized text:
    text~nfd == textNFD=                    -- .true


/*
    Some remarks about the string used in this demo:
    - the first "Ã¤Ã¶Ã¼" is NFC, the second "aÌˆoÌˆuÌˆ" is NFD
    - "xÌ‚" is two codepoints in any normalization.
    - "Ï”" normalization forms are all different.
    - "ï·º" is one of the worst cases regarding the expansion factor in NFKS/NFKS: 18x
    - "baï¬„e"~text~subchar(3)=     -- T'ï¬„'
      "baï¬„e"~text~upper=          -- T'BAï¬„E', not BAFFLE
      The ligature disappears in NFK[CD] but not in NF[CD]
*/
"Ã¤Ã¶Ã¼ aÌˆoÌˆuÌˆ xÌ‚ Ï” ï·º baï¬„e"~text~UnicodeCharacters==
    an Array (shape [22~], 22 items)
     1  : ( "Ã¤"   U+00E4 Ll 1 "LATIN SMALL LETTER A WITH DIAERESIS" )
     2  : ( "Ã¶"   U+00F6 Ll 1 "LATIN SMALL LETTER O WITH DIAERESIS" )
     3  : ( "Ã¼"   U+00FC Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS" )
     4  : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     5  : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
     6  : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )
     7  : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
     8  : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )
     9  : ( "u"   U+0075 Ll 1 "LATIN SMALL LETTER U" )
     10 : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )
     11 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     12 : ( "x"   U+0078 Ll 1 "LATIN SMALL LETTER X" )
     13 : ( "Ì‚"    U+0302 Mn 0 "COMBINING CIRCUMFLEX ACCENT" )
     14 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     15 : ( "Ï”"   U+03D4 Lu 1 "GREEK UPSILON WITH DIAERESIS AND HOOK SYMBOL" )
     16 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     17 : ( "ï·º"   U+FDFA Lo 1 "ARABIC LIGATURE SALLALLAHOU ALAYHE WASALLAM" )
     18 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     19 : ( "b"   U+0062 Ll 1 "LATIN SMALL LETTER B" )
     20 : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
     21 : ( "ï¬„"   U+FB04 Ll 1 "LATIN SMALL LIGATURE FFL" )
     22 : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )

"Ã¤Ã¶Ã¼ aÌˆoÌˆuÌˆ xÌ‚ Ï” ï·º baï¬„e"~text~description=      -- 'UTF-8 not-ASCII (18 graphemes, 22 codepoints, 34 bytes, 0 error)'
"Ã¤Ã¶Ã¼ aÌˆoÌˆuÌˆ xÌ‚ Ï” ï·º baï¬„e"~text~upper=            -- T'Ã„Ã–Ãœ AÌˆOÌˆUÌˆ XÌ‚ Ï” ï·º BAï¬„E

/*
    NFD
    Normalization Form D
    Canonical Decomposition
    Characters are decomposed by canonical equivalence, and multiple combining characters are arranged in a specific order.
*/
"Ã¤Ã¶Ã¼ aÌˆoÌˆuÌˆ xÌ‚ Ï” ï·º baï¬„e"~text~nfd~UnicodeCharacters==
    an Array (shape [26], 26 items)
     1  : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
     2  : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )
     3  : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
     4  : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )
     5  : ( "u"   U+0075 Ll 1 "LATIN SMALL LETTER U" )
     6  : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )
     7  : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     8  : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
     9  : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )
     10 : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
     11 : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )
     12 : ( "u"   U+0075 Ll 1 "LATIN SMALL LETTER U" )
     13 : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )
     14 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     15 : ( "x"   U+0078 Ll 1 "LATIN SMALL LETTER X" )
     16 : ( "Ì‚"    U+0302 Mn 0 "COMBINING CIRCUMFLEX ACCENT" )
     17 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     18 : ( "Ï’"   U+03D2 Lu 1 "GREEK UPSILON WITH HOOK SYMBOL" )
     19 : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )
     20 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     21 : ( "ï·º"   U+FDFA Lo 1 "ARABIC LIGATURE SALLALLAHOU ALAYHE WASALLAM" )
     22 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     23 : ( "b"   U+0062 Ll 1 "LATIN SMALL LETTER B" )
     24 : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
     25 : ( "ï¬„"   U+FB04 Ll 1 "LATIN SMALL LIGATURE FFL" )
     26 : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )

"Ã¤Ã¶Ã¼ aÌˆoÌˆuÌˆ xÌ‚ Ï” ï·º baï¬„e"~text~nfd~description=  -- 'UTF-8 not-ASCII (18 graphemes, 26 codepoints, 39 bytes, 0 error)'
"Ã¤Ã¶Ã¼ aÌˆoÌˆuÌˆ xÌ‚ Ï” ï·º baï¬„e"~text~nfd~upper=        -- T'AÌˆOÌˆUÌˆ AÌˆOÌˆUÌˆ XÌ‚ Ï’Ìˆ ï·º BAï¬„E'

/*
    NFC
    Normalization Form C
    Canonical Decomposition, followed by Canonical Composition
    Characters are decomposed and then recomposed by canonical equivalence.
*/
"Ã¤Ã¶Ã¼ aÌˆoÌˆuÌˆ xÌ‚ Ï” ï·º baï¬„e"~text~nfc~UnicodeCharacters==
    an Array (shape [19], 19 items)
     1  : ( "Ã¤"   U+00E4 Ll 1 "LATIN SMALL LETTER A WITH DIAERESIS" )
     2  : ( "Ã¶"   U+00F6 Ll 1 "LATIN SMALL LETTER O WITH DIAERESIS" )
     3  : ( "Ã¼"   U+00FC Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS" )
     4  : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     5  : ( "Ã¤"   U+00E4 Ll 1 "LATIN SMALL LETTER A WITH DIAERESIS" )
     6  : ( "Ã¶"   U+00F6 Ll 1 "LATIN SMALL LETTER O WITH DIAERESIS" )
     7  : ( "Ã¼"   U+00FC Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS" )
     8  : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     9  : ( "x"   U+0078 Ll 1 "LATIN SMALL LETTER X" )
     10 : ( "Ì‚"    U+0302 Mn 0 "COMBINING CIRCUMFLEX ACCENT" )
     11 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     12 : ( "Ï”"   U+03D4 Lu 1 "GREEK UPSILON WITH DIAERESIS AND HOOK SYMBOL" )
     13 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     14 : ( "ï·º"   U+FDFA Lo 1 "ARABIC LIGATURE SALLALLAHOU ALAYHE WASALLAM" )
     15 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     16 : ( "b"   U+0062 Ll 1 "LATIN SMALL LETTER B" )
     17 : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
     18 : ( "ï¬„"   U+FB04 Ll 1 "LATIN SMALL LIGATURE FFL" )
     19 : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )

"Ã¤Ã¶Ã¼ aÌˆoÌˆuÌˆ xÌ‚ Ï” ï·º baï¬„e"~text~nfc~description=  -- 'UTF-8 not-ASCII (18 graphemes, 19 codepoints, 31 bytes, 0 error)'
"Ã¤Ã¶Ã¼ aÌˆoÌˆuÌˆ xÌ‚ Ï” ï·º baï¬„e"~text~nfc~upper=        -- T'Ã„Ã–Ãœ Ã„Ã–Ãœ XÌ‚ Ï” ï·º BAï¬„E'

/*
    NFKD
    Normalization Form KD
    Compatibility Decomposition (K is used to stand for compatibility to avoid confusion with the C standing for composition)
    Characters are decomposed by compatibility, and multiple combining characters are arranged in a specific order.
*/
"Ã¤Ã¶Ã¼ aÌˆoÌˆuÌˆ xÌ‚ Ï” ï·º baï¬„e"~text~nfkd~UnicodeCharacters==
    an Array (shape [45], 45 items)
     1  : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
     2  : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )
     3  : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
     4  : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )
     5  : ( "u"   U+0075 Ll 1 "LATIN SMALL LETTER U" )
     6  : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )
     7  : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     8  : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
     9  : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )
     10 : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
     11 : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )
     12 : ( "u"   U+0075 Ll 1 "LATIN SMALL LETTER U" )
     13 : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )
     14 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     15 : ( "x"   U+0078 Ll 1 "LATIN SMALL LETTER X" )
     16 : ( "Ì‚"    U+0302 Mn 0 "COMBINING CIRCUMFLEX ACCENT" )
     17 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     18 : ( "Î¥"   U+03A5 Lu 1 "GREEK CAPITAL LETTER UPSILON" )
     19 : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )
     20 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     21 : ( "Øµ"   U+0635 Lo 1 "ARABIC LETTER SAD" )
     22 : ( "Ù„"   U+0644 Lo 1 "ARABIC LETTER LAM" )
     23 : ( "Ù‰"   U+0649 Lo 1 "ARABIC LETTER ALEF MAKSURA" )
     24 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     25 : ( "Ø§"   U+0627 Lo 1 "ARABIC LETTER ALEF" )
     26 : ( "Ù„"   U+0644 Lo 1 "ARABIC LETTER LAM" )
     27 : ( "Ù„"   U+0644 Lo 1 "ARABIC LETTER LAM" )
     28 : ( "Ù‡"   U+0647 Lo 1 "ARABIC LETTER HEH" )
     29 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     30 : ( "Ø¹"   U+0639 Lo 1 "ARABIC LETTER AIN" )
     31 : ( "Ù„"   U+0644 Lo 1 "ARABIC LETTER LAM" )
     32 : ( "ÙŠ"   U+064A Lo 1 "ARABIC LETTER YEH" )
     33 : ( "Ù‡"   U+0647 Lo 1 "ARABIC LETTER HEH" )
     34 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     35 : ( "Ùˆ"   U+0648 Lo 1 "ARABIC LETTER WAW" )
     36 : ( "Ø³"   U+0633 Lo 1 "ARABIC LETTER SEEN" )
     37 : ( "Ù„"   U+0644 Lo 1 "ARABIC LETTER LAM" )
     38 : ( "Ù…"   U+0645 Lo 1 "ARABIC LETTER MEEM" )
     39 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     40 : ( "b"   U+0062 Ll 1 "LATIN SMALL LETTER B" )
     41 : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
     42 : ( "f"   U+0066 Ll 1 "LATIN SMALL LETTER F" )
     43 : ( "f"   U+0066 Ll 1 "LATIN SMALL LETTER F" )
     44 : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
     45 : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )

"Ã¤Ã¶Ã¼ aÌˆoÌˆuÌˆ xÌ‚ Ï” ï·º baï¬„e"~text~nfkd~description= -- 'UTF-8 not-ASCII (37 graphemes, 45 codepoints, 69 bytes, 0 error)'
"Ã¤Ã¶Ã¼ aÌˆoÌˆuÌˆ xÌ‚ Ï” ï·º baï¬„e"~text~nfkd~upper=       -- T'AÌˆOÌˆUÌˆ AÌˆOÌˆUÌˆ XÌ‚ Î¥Ìˆ ØµÙ„Ù‰ Ø§Ù„Ù„Ù‡ Ø¹Ù„ÙŠÙ‡ ÙˆØ³Ù„Ù… BAFFLE

/*
    NFKC
    Normalization Form KC
    Compatibility Decomposition, followed by Canonical Composition
    Characters are decomposed by compatibility, then recomposed by canonical equivalence.
*/
"Ã¤Ã¶Ã¼ aÌˆoÌˆuÌˆ xÌ‚ Ï” ï·º baï¬„e"~text~nfkc~UnicodeCharacters==
    an Array (shape [38], 38 items)
     1  : ( "Ã¤"   U+00E4 Ll 1 "LATIN SMALL LETTER A WITH DIAERESIS" )
     2  : ( "Ã¶"   U+00F6 Ll 1 "LATIN SMALL LETTER O WITH DIAERESIS" )
     3  : ( "Ã¼"   U+00FC Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS" )
     4  : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     5  : ( "Ã¤"   U+00E4 Ll 1 "LATIN SMALL LETTER A WITH DIAERESIS" )
     6  : ( "Ã¶"   U+00F6 Ll 1 "LATIN SMALL LETTER O WITH DIAERESIS" )
     7  : ( "Ã¼"   U+00FC Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS" )
     8  : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     9  : ( "x"   U+0078 Ll 1 "LATIN SMALL LETTER X" )
     10 : ( "Ì‚"    U+0302 Mn 0 "COMBINING CIRCUMFLEX ACCENT" )
     11 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     12 : ( "Î«"   U+03AB Lu 1 "GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA" )
     13 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     14 : ( "Øµ"   U+0635 Lo 1 "ARABIC LETTER SAD" )
     15 : ( "Ù„"   U+0644 Lo 1 "ARABIC LETTER LAM" )
     16 : ( "Ù‰"   U+0649 Lo 1 "ARABIC LETTER ALEF MAKSURA" )
     17 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     18 : ( "Ø§"   U+0627 Lo 1 "ARABIC LETTER ALEF" )
     19 : ( "Ù„"   U+0644 Lo 1 "ARABIC LETTER LAM" )
     20 : ( "Ù„"   U+0644 Lo 1 "ARABIC LETTER LAM" )
     21 : ( "Ù‡"   U+0647 Lo 1 "ARABIC LETTER HEH" )
     22 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     23 : ( "Ø¹"   U+0639 Lo 1 "ARABIC LETTER AIN" )
     24 : ( "Ù„"   U+0644 Lo 1 "ARABIC LETTER LAM" )
     25 : ( "ÙŠ"   U+064A Lo 1 "ARABIC LETTER YEH" )
     26 : ( "Ù‡"   U+0647 Lo 1 "ARABIC LETTER HEH" )
     27 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     28 : ( "Ùˆ"   U+0648 Lo 1 "ARABIC LETTER WAW" )
     29 : ( "Ø³"   U+0633 Lo 1 "ARABIC LETTER SEEN" )
     30 : ( "Ù„"   U+0644 Lo 1 "ARABIC LETTER LAM" )
     31 : ( "Ù…"   U+0645 Lo 1 "ARABIC LETTER MEEM" )
     32 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
     33 : ( "b"   U+0062 Ll 1 "LATIN SMALL LETTER B" )
     34 : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
     35 : ( "f"   U+0066 Ll 1 "LATIN SMALL LETTER F" )
     36 : ( "f"   U+0066 Ll 1 "LATIN SMALL LETTER F" )
     37 : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
     38 : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )

"Ã¤Ã¶Ã¼ aÌˆoÌˆuÌˆ xÌ‚ Ï” ï·º baï¬„e"~text~nfkc~description= -- 'UTF-8 not-ASCII (37 graphemes, 38 codepoints, 61 bytes, 0 error)'
"Ã¤Ã¶Ã¼ aÌˆoÌˆuÌˆ xÌ‚ Ï” ï·º baï¬„e"~text~nfkc~upper=       -- T'Ã„Ã–Ãœ Ã„Ã–Ãœ XÌ‚ Î« ØµÙ„Ù‰ Ø§Ù„Ù„Ù‡ Ø¹Ù„ÙŠÙ‡ ÙˆØ³Ù„Ù… BAFFLE'


-- The normalization forms are implemented only for UTF-8 and WTF-8.
"D800 DC01"x~text("utf16")~nfd~UnicodeCharacters==  -- Method NFD is ABSTRACT and cannot be directly invoked.
"D800 DC01"x~text("utf16")~utf8~nfd~UnicodeCharacters==
    an Array (shape [1], 1 items)
     1 : ( "ð€"   U+10001 Lo 1 "LINEAR B SYLLABLE B038 E" )
"\uD800\uDC01"~text("wtf8")~unescape~nfd~UnicodeCharacters==
    an Array (shape [1], 1 items)
     1 : ( "ð€"   U+10001 Lo 1 "LINEAR B SYLLABLE B038 E" )

-- If the WTF-8 string is not a valid UTF-8 string then an error is raised by utf8proc
"D800"x     ~text("wtf16")~wtf8~nfd~UnicodeCharacters==    -- Invalid UTF-8 string
"\uD800"~text("wtf8")~unescape~nfd~UnicodeCharacters==     -- Invalid UTF-8 string


===============================================================================
2022 August 03

[Encoded strings]

Create a new folder packages/encoding.
The Unicode data files are moved in this folder.

Split the (now big) file extension/string.cls into several files:
    encoding/stringEncoding.cls     encoding & indexer
    encoding/unicode.cls            Unicode properties & services
    extension/string.cls            all except encoding
    extension/text.cls              RexxText


[Encoded strings]

https://discourse.julialang.org/t/stupid-question-on-unicode/27674/10
    Should I support this when unescaping?
    (High surrogate followed by low surrogate)
    Surrogate pairs are a UTF-16-specific construct.
    However, string escapes arenâ€™t byte sequences of a particular encoding.
    They are somewhat arbitrary substitutions / macros.

        "\uD83D\uDE3F"~text~unescape~errors==
        an Array (shape [6], 6 items)
         1 : 'UTF-8 sequence at byte-position 1 has an invalid continuation byte 160 (A0x) at byte-position 2 (high surrogate).'
         2 : 'UTF-8 sequence at byte-position 2 has an invalid start byte 160 (A0x) (non-shortest form).'
         3 : 'UTF-8 sequence at byte-position 3 has an invalid start byte 189 (BDx) (non-shortest form).'
         4 : 'UTF-8 sequence at byte-position 4 has an invalid continuation byte 184 (B8x) at byte-position 5 (low surrogate).'
         5 : 'UTF-8 sequence at byte-position 5 has an invalid start byte 184 (B8x) (non-shortest form).'
         6 : 'UTF-8 sequence at byte-position 6 has an invalid start byte 191 (BFx) (non-shortest form).'

        "\uD83D\uDE3F"~text~wtf8~unescape~errors==
        an Array (shape [3], 3 items)
         1 : 'WTF-8 encoding: high surrogate 55357 (U+D83D) at byte-position 1 followed by low surrogate 56895 (U+DE3F) at byte-position 4 is not allowed.'
         2 : 'UTF-8 sequence at byte-position 2 has an invalid start byte 160 (A0x) (non-shortest form).'
         3 : 'UTF-8 sequence at byte-position 3 has an invalid start byte 189 (BDx) (non-shortest form).'

    Yes, I should support it when the encoding is WTF-8, because the concatenation manages correctly this case:
        ("\uD83D"~text~wtf8~unescape || "\uDE3F"~text~wtf8~unescape)~UnicodeCharacters==
        an Array (shape [1], 1 items)
         1 : ( "ðŸ˜¿"  U+1F63F So 2 "CRYING CAT FACE" )

        ("\uD83D"~text~wtf8~unescape || "\uDE3F"~text~wtf8~unescape)~description=
        'WTF-8 not-ASCII (1 grapheme, 1 codepoint, 4 bytes, 0 error)'

    Done, now "\uD83D\uDE3F"~text~wtf8~unescape=    -- "ðŸ˜¿"


[Encoded strings]

https://discourse.julialang.org/t/indexing-strings-by-unicode-code-point-instead-of-code-unit/55248
    Discussion about the non-need to index by grapheme.
    They say there is no real application where you need that.
    But the parse instruction with positional patterns is a good example of real application.
    With the indexation by grapheme, it will support transparently NFC or NFD.

    (not yet implemented, just an illustration)
    parse value "Ã¤Ã¶Ã¼  100"~text with key 6 value     -- key="Ã¤Ã¶Ã¼  ", value=100

    -- NFC
    "Ã¤Ã¶Ã¼  100"~text~UnicodeCharacters==
        an Array (shape [8], 8 items)
         1 : ( "Ã¤"   U+00E4 Ll 1 "LATIN SMALL LETTER A WITH DIAERESIS" )
         2 : ( "Ã¶"   U+00F6 Ll 1 "LATIN SMALL LETTER O WITH DIAERESIS" )
         3 : ( "Ã¼"   U+00FC Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS" )
         4 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
         5 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
         6 : ( "1"   U+0031 Nd 1 "DIGIT ONE" )
         7 : ( "0"   U+0030 Nd 1 "DIGIT ZERO" )
         8 : ( "0"   U+0030 Nd 1 "DIGIT ZERO" )

    -- NFD
    "aÌˆoÌˆuÌˆ  100"~text~UnicodeCharacters==
        an Array (shape [11], 11 items)
         1  : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
         2  : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )
         3  : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
         4  : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )
         5  : ( "u"   U+0075 Ll 1 "LATIN SMALL LETTER U" )
         6  : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )
         7  : ( " "   U+0020 Zs 1 "SPACE", "SP" )
         8  : ( " "   U+0020 Zs 1 "SPACE", "SP" )
         9  : ( "1"   U+0031 Nd 1 "DIGIT ONE" )
         10 : ( "0"   U+0030 Nd 1 "DIGIT ZERO" )
         11 : ( "0"   U+0030 Nd 1 "DIGIT ZERO" )


===============================================================================
2022 July 20

[Unicode]

I realize that I can pass options when filtering the unicode characters.
Same options as when sending the message "matcher" to a string.

-- Options: not wholestring, trace with prefix "> "
.unicode~characters("father", w:0, t:1, p:">")
> description: stringChunkPattern="father" wholeString=0 caseless=1
> stringPattern="father"
> matcher: expose description stringPattern; use strict arg string; return string~caselessPos(stringPattern) <> 0
0.9 sec

-- Same options with a regular expression.
-- "/father" is faster than "/.*father.*" but still very slow compared to "father"
.unicode~characters("/father", w:0, t:1, p:"> ")
> description: stringChunkPattern="/father" wholeString=0 caseless=1
> stringPattern="father"
> pattern = .Pattern~compile(stringPattern, .RegexCompiler~new(.RegexCompiler~caseless))
> matcher: expose description pattern; use strict arg string; return pattern~find(string)~matched
17 sec

Note that "/.*father.*" in mode not wholestring is just unusable: 419 sec under MBP 2010 Intel Core 2 Duo
[2022 Dec 22] Still unusable under MBP 2021 M1 Pro: 78s (only 5.37 faster)


===============================================================================
2022 July 17

[Unicode]

For convenience, add an optional parameter 'filter' to the method .unicode~characters
    .unicode~characters("*rex*")==
is equivalent to
    matcher = "*rex*"~matcher; .unicode~characters~select{expose matcher; matcher~(item~name)}==

Regular expressions are supported:
    .unicode~characters("/^math.*psi$")==
returns all the characters whose name starts with "math" and ends with "psi"
     1  : ( "ðš¿"   U+1D6BF Lu 1 "MATHEMATICAL BOLD CAPITAL PSI" )
     2  : ( "ð›™"   U+1D6D9 Ll 1 "MATHEMATICAL BOLD SMALL PSI" )
     3  : ( "ð›¹"   U+1D6F9 Lu 1 "MATHEMATICAL ITALIC CAPITAL PSI" )
     4  : ( "ðœ“"   U+1D713 Ll 1 "MATHEMATICAL ITALIC SMALL PSI" )
     5  : ( "ðœ³"   U+1D733 Lu 1 "MATHEMATICAL BOLD ITALIC CAPITAL PSI" )
     6  : ( "ð"   U+1D74D Ll 1 "MATHEMATICAL BOLD ITALIC SMALL PSI" )
     7  : ( "ð­"   U+1D76D Lu 1 "MATHEMATICAL SANS-SERIF BOLD CAPITAL PSI" )
     8  : ( "ðž‡"   U+1D787 Ll 1 "MATHEMATICAL SANS-SERIF BOLD SMALL PSI" )
     9  : ( "ðž§"   U+1D7A7 Lu 1 "MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL PSI" )
     10 : ( "ðŸ"   U+1D7C1 Ll 1 "MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL PSI" )

The regular expressions are implemented with 100% ooRexx code, and as such
can be particularly inefficient...
When applied to a collection of 43885 Unicode characters, we have:
    .unicode~characters("/.*father.*")    -- 30.5 sec
The same filter without regular expression:
    .unicode~characters("*father*")       -- 0.9 sec

Something to clarify:
Why such a difference of duration for the following pieces of code?
In the end, it's the same code in both cases:
matcher = "/.*father.*"~matcher; supplier = .unicode~characters; collectedItems = .Array~new; do while supplier~available; item = supplier~item; if matcher~(item~name) then collectedItems~append(item); supplier~next; end; collectedItems==
64 sec
matcher = "/.*father.*"~matcher; .unicode~characters~select{expose matcher; matcher~(item~name)}==
31 sec


===============================================================================
2022 July 13

[Encoded strings]

Rework ~unescape to be closer to other languages:
\u{...} and \U{...} are equivalent
\u{X..X} is now hexadecimal, no more decimal codepoint. The first character must be 0..9.
\uXXXX is now supported
\UXXXXXXXX is now supported

Ex:
"\u{bed} is different from \u{0bed}"~text~unescape=                         -- T'ðŸ› is different from à¯­'
.unicode~character("bed")=                                                  -- ( "ðŸ›"   U+1F6CF So 1 "BED" )
.unicode~character("bed", hexadecimal:.true)=                               -- ( "à¯­"   U+0BED Nd 1 "TAMIL DIGIT SEVEN" )
.unicode~character("U+0bed")=                                               -- ( "à¯­"   U+0BED Nd 1 "TAMIL DIGIT SEVEN" )
"The \u{t-rex} shows his \u{flexed biceps}!"~text~unescape=                 -- T'The ðŸ¦– shows his ðŸ’ª!'
"\u0031 + \u0032\u0033 = \u0032\u0034"~text~unescape=                       -- T'1 + 23 = 24'
"\U00000031 + \U00000032\U00000033 = \U00000032\U00000034"~text~unescape=   -- T'1 + 23 = 24'

===============================================================================
2022 July 01

[pipes]

Allow to pass parameters when starting/resuming a copipe.
Loosely inspired by PIPE Command Programming Interface
http://www.casita.net/vmworkshop/vm.marist.edu/~pipeline/
Part 4. Copipes
Fitting stage
    A pipeline set that runs as a copipe contains one or more fitting stages, each of which
    defines a point at which the application can send data into the pipeline or receive data
    from the pipeline depending upon the position of the fitting stage in the pipeline.

    A fitting stage can either read data from the pipeline or write data into the pipeline, but it
    cannot do both. A fitting that writes data from the application into the pipeline is a first
    stage; it has the behaviour typical of an input device driver. A fitting that reads data from
    the pipeline into the application is not a first stage; it has the behaviour typical of an
    output device driver.

A .yield stage is equivalent to a fitting stage, that allows to both read from and write into the pipeline.
The arguments passed on resume are available in
    pipeContext~args        -- array (can be empty)
    pipeContext~namedArgs   -- directory (can be empty)

Example
    /*
      Example of copipe with 1 fitting stage.
      pipeContext~args is an array of one item (because one positional argument of type string is passed).
      The current pipe item is concatenated with this array, the result is an array of one item.
      Notice that pipeContext~args has a different value before and after the stage .yield:
        before .yield, it's the initial argument
        after .yield, it's one of the resume arguments.
    */
    p = 1~3~copipe(.inject {item pipeContext~args} | .yield | .inject {item pipeContext~args} | .console)
    p~statusText=       -- not started
    p~("initial")=      -- nothing displayed                        return ['1 initial']
    p~statusText=       -- suspended
    p~("resume1")=      -- display 1 : ['1 initial resume1']        return ['2 initial']
    p~statusText=       -- suspended
    p~("resume2")=      -- display 2 : ['2 initial resume2']        return ['3 initial']
    p~statusText=       -- suspended
    p~("resume3")=      -- display 3 : ['3 initial resume3']        no result
    p~statusText=       -- ended
    p~("resume4")=      -- nothing displayed                        no result
    p~statusText=       -- ended

Example
    /*
      Example of copipe with 2 fitting stages.
      Same pipeline, add a second .yield stage at the end of the pipe.
      The first .yield is used to pass the data that will be written into the pipeline.
      The returned value is an intermediate value.
      The second .yield is used to read the final data from the pipeline.
      The passed value is not used, could pass nothing.
      "resume2", "resume4" and "resume6" is neither displayed nor returned.

                            1~3~copipe(.inject {item pipeContext~args} | .yield | .inject {item pipeContext~args} | .console | .yield)
                            not started
      "initial"     write   1                                             X read suspended
      "resume1"             1                                             X write                                               X read suspended
      "resume2"             1                                                                                                   X write
                            2                                             X read suspended
      "resume3"             2                                             X write                                               X read suspended
      "resume4"             2                                                                                                   X write
                            3                                             X read suspended
      "resume5"             3                                             X write                                               X read suspended
      "resume6"             ended
    */
    p = 1~3~copipe(.inject {item pipeContext~args} | .yield | .inject {item pipeContext~args} | .console | .yield)
    p~statusText=       -- not started
    p~("initial")=      -- nothing displayed                        return ['1 initial']
    p~statusText=       -- suspended
    p~("resume1")=      -- display 1 : ['1 initial resume1']        return ['1 initial resume1']
    p~statusText=       -- suspended
    p~("resume2")=      -- nothing displayed                        return ['2 initial']
    p~statusText=       -- suspended
    p~("resume3")=      -- display 2 : ['2 initial resume3']        return ['2 initial resume3']
    p~statusText=       -- suspended
    p~("resume4")=      -- nothing displayed                        return ['3 initial']
    p~statusText=       -- suspended
    p~("resume5")=      -- display 3 : ['3 initial resume5']        return ['3 initial resume5']
    p~statusText=       -- suspended
    p~("resume6")=      -- nothing displayed                        no result
    p~statusText=       -- ended

Example
    /*
      Example of copipe with 2 fitting stages.
      The pipe is applied to a folder path.
      The first .yield is used to pass the text that the file's path must contain.
      The second .yield is used to return the current file.
      The files are collected in an array built outside the pipe.
    */
    p = (.yield | .fileTree | .select {item~path~contains(pipeContext~args[1]~string)} | .yield)
    co = "~"~copipe(p); co~(); co~("rexx"); co~iterator~each==
        an Array (shape [2], 2 items)
         1 : (/Users/jlfaucher/.oorexxshell.ini)
         2 : (/Users/jlfaucher/.oorexxshell_history)


===============================================================================
2022 June 12

[Pretty-print]

ppOptions.expandCollection is now an integer (was a boolan).
When the collection ~items is <= ppOptions.expandCollection then the collection
is displayed as a condensed array.
todo: add support for self-referencing collections.

Still work in progress...


===============================================================================
2022 June 07

[pipes]

.inject:
Fixed the creation of dataflow in case of recursion.
-- Memorize only the last datapacket
1~pipe(.inject {item+1} "rec.1" "mem" | .console "index" ":" "item" "dataflow")
    1 : 2 source:1,1 | inject:1,2
    1 : 3 source:1,1 | inject:1,3
-- Memorize the intermediate datapackets
1~pipe(.inject {item+1} "rec.1.mem" "mem" | .console "index" ":" "item" "dataflow")
    1 : 2 source:1,1 | inject:1,2
    1 : 3 source:1,1 | inject:1,2 | inject:1,3


To rework:
Infinite loop despite the .take pipestage.
It's because of the partition.
1~5~pipe(.inject {{::co expose item; loop i=item; call yield i; end}} "iterateAfter" | .take 5 {dataflow["source"]~item} | .console "dataflow", mem:1)


===============================================================================
2022 June 06

[pipes]

Solution to the quiz of Ruurd
https://groups.io/g/netrexx/topic/exploring_netrexx_pipelines/91542970
"~/Downloads/coords.txt"~pipe(.linesIn | .inject { parse var item X"="V1 Y"="V2; (X="lat")~?(V1 V2, V2 V1) } | .console)
Input:
    lon=4.8177 lat=52.25365
    lon=4.81744 lat=52.25364
    lon=4.81732 lat=52.25362
    ...
    lon=4.62636 lat=52.26284
    lon=4.62606 lat=52.26303
    lon=4.62558 lat=52.26329
Output:
    1 : '52.25365 4.8177'
    2 : '52.25364 4.81744'
    3 : '52.25362 4.81732'
    ...
    1690 : '52.26284 4.62636'
    1691 : '52.26303 4.62606'
    1692 : '52.26329 4.62558'


[pipes]

~pipe
~copipe
New named parameter 'memorize' to activate the option 'memorize' on all the pipeStages.
The positional parameter 'profile' becomes a named parameter.

The pipestage "fileLines" has been renamed "linesIn", and extended to support as input
a filename or a .File instance or any object understanding the message "lineIn".
The input is either the current item or an argument. The argument can be a doer returning the input.
Example:
    -- Here the input is a filename calculated by concatenating the item with the suffix ".rex"
    "my_script"~pipe(.linesIn {item".rex"} | .console)
    -- Here the item is used as input. List the 5 first lines of each file *.rex in current directory.
    "."~pipe(.fileTree "mem" | .endsWith[".rex"] | .linesIn | .take 5 {dataflow["fileTree"]~item} | .console)

The index forwarded for the new item calculated by the following pipeStages is no longer hardcoded 1.
Now it's the index received from the previous pipeStage.
    reverse
    upper
    lower
    changeStr
    delStr
    left
    right
    insert
    overlay
    x2c

.inject:
The index injected for the item received from the previous pipeStage is no longer hardcoded 1.
Now it's the index received from the previous pipeStage.
Example:
    .array~of(1, , 2, , 3)~pipe(.inject "after" {.array~of(item*10, item*20)} "iterateAfter" "memorize" | .console "dataflow")
        source:1,1 | inject[->-]:1,1
        source:1,1 | inject:1,10
        source:1,1 | inject:2,20
        source:3,2 | inject[->-]:3,2    now the index injected is the index received: here 3 instead of 1
        source:3,2 | inject:1,20
        source:3,2 | inject:2,40
        source:5,3 | inject[->-]:5,3    now the index injected is the index received: here 5 instead of 1
        source:5,3 | inject:1,30
        source:5,3 | inject:2,60

The datapackets are annotated to provide context.
    [->-] The pipeStage is just forwarding. See for example 'append'.
    [eof] The pipeStage is running on EOF event. See for example 'sort' and 'append'.
Example:
    -- The argument mem:1 activates the memorization on all the pipe stages: full dataflow
    5~1~pipe(.append {(7,6)} "iterate" | .inject {10*item} "after" "before" | .sort | .append {(0,-1)} "iterate" | .console "mem" "dataflow", mem:1)
        source:5,1 | append[->-]:5,1 | inject[->]:5,1 | sort[eof]:5,1 | append[->-]:5,1
        source:5,1 | append[->-]:5,1 | inject[->-]:5,1 | sort[eof]:5,1 | append[->-]:5,1
        source:4,2 | append[->-]:4,2 | inject[->]:4,2 | sort[eof]:4,2 | append[->-]:4,2
        source:4,2 | append[->-]:4,2 | inject[->-]:4,2 | sort[eof]:4,2 | append[->-]:4,2
        source:3,3 | append[->-]:3,3 | inject[->]:3,3 | sort[eof]:3,3 | append[->-]:3,3
        source:3,3 | append[->-]:3,3 | inject[->-]:3,3 | sort[eof]:3,3 | append[->-]:3,3
        source:2,4 | append[->-]:2,4 | inject[->]:2,4 | sort[eof]:2,4 | append[->-]:2,4
        source:2,4 | append[->-]:2,4 | inject[->-]:2,4 | sort[eof]:2,4 | append[->-]:2,4
        source:1,5 | append[->-]:1,5 | inject[->]:1,5 | sort[eof]:1,5 | append[->-]:1,5
        source:1,5 | append[->-]:1,5 | inject[->-]:1,5 | sort[eof]:1,5 | append[->-]:1,5
        append[eof]:2,6 | inject[->]:2,6 | sort[eof]:2,6 | append[->-]:2,6
        append[eof]:2,6 | inject[->-]:2,6 | sort[eof]:2,6 | append[->-]:2,6
        append[eof]:1,7 | inject[->]:1,7 | sort[eof]:1,7 | append[->-]:1,7
        append[eof]:1,7 | inject[->-]:1,7 | sort[eof]:1,7 | append[->-]:1,7
        source:5,1 | append[->-]:5,1 | inject:5,10 | sort[eof]:5,10 | append[->-]:5,10
        source:4,2 | append[->-]:4,2 | inject:4,20 | sort[eof]:4,20 | append[->-]:4,20
        source:3,3 | append[->-]:3,3 | inject:3,30 | sort[eof]:3,30 | append[->-]:3,30
        source:2,4 | append[->-]:2,4 | inject:2,40 | sort[eof]:2,40 | append[->-]:2,40
        source:1,5 | append[->-]:1,5 | inject:1,50 | sort[eof]:1,50 | append[->-]:1,50
        append[eof]:2,6 | inject:2,60 | sort[eof]:2,60 | append[->-]:2,60
        append[eof]:1,7 | inject:1,70 | sort[eof]:1,70 | append[->-]:1,70
        append[eof]:1,0
        append[eof]:2,-1


===============================================================================
2022 June 01

[rgf_util NumberComparator]

Modify NumberComparator ~compareWithNonNumbers and ~compareWithNonNumbersDescending to convert the arguments to strings.
That fixes this error raised when displaying a relation which contains classes:
a Relation (194 items)
Object "The MutableBufferIterator class" does not understand message "CASELESSCOMPARETO".

Note: I use this comparator because it works both for numbers and not numbers.


===============================================================================
2022 May 08

[functional]

String map was implemented by 2 methods: mapC for characters, mapW for words, but no 'map'.
Added a 'map' method which supports a named argument 'by' to indicate how the split is done.
3 kinds of split are supported: by:"characters", by:"chunks", by:"words".
Add the named parameter separator(3)="" used when concatenating the mappings.
    String~map
    String~mapC
    String~mapW
    MutableBuffer~mapC
    MutableBuffer~mapCR
    MutableBuffer~mapW
    MutableBuffer~mapWR
Examples:
    'he said "bye bye" and left.'~map(by:"characters", sep:" "){index":<"item">"}=   -- '1:<h> 2:<e> 3:< > 4:<s> 5:<a> 6:<i> 7:<d> 8:< > 9:<"> 10:<b> 11:<y> 12:<e> 13:< > 14:<b> 15:<y> 16:<e> 17:<"> 18:< > 19:<a> 20:<n> 21:<d> 22:< > 23:<l> 24:<e> 25:<f> 26:<t> 27:<.>'
    'he said "bye bye" and left.'~map(by:"chunks", sep:" "){index":<"item">"}=       -- '1:<he> 2:<said> 3:<bye bye> 4:<and> 5:<left.>'
    'he said "bye bye" and left.'~map(by:"words", sep:" "){index":<"item">"}=        -- '1:<he> 2:<said> 3:<"bye> 4:<bye"> 5:<and> 6:<left.>'

String ~upto ~downto
    Default value for arguments by, for, action.
    The numeric settings are propagated.
    digits() no longer passed as argument.
    index is a new argument passed to the action.
Example:
    1~100(by:3e-100, for:-5){say digits() index item}
    display:
        103 1 99.9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999988
        103 2 99.9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999991
        103 3 99.9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999994
        103 4 99.9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999997
        103 5 100.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

New facade methods:
    MutableBuffer~reduce
    MutableBuffer~map
    MutableBuffer~mapR


===============================================================================
2022 February 13

[Encoded strings]

New method unescape, available only for Byte, UTF-8 and WTF-8.
    \b                  backspace (BS)
    \t                  horizontal tab (HT)
    \n                  linefeed (LF)
    \f                  form feed (FF)
    \r                  carriage return (CR)
    \u{Unicode name}    Character name in the Unicode database
    \u{N..N}            Unicode character denoted by 1-8 hex digits. The first character must be a digit 0..9.
    \u{U+X..X}          Unicode character denoted by 1-n hex digits
    \x{X..X}            sequence of 1..n hexadecimal digits
Examples:
    "hello\u{space}John\n"~text~unescape=           -- T'hello John[0A]'
    "hello\u{20}John\n"~text~unescape=
    "hello\u{U+20}John\n"~text~unescape=

    -- \u is not supported for Byte encoding, you can use \x
    "hello\u{U+20}John\n"~text("byte")~unescape=    -- Byte encoding: \u not supported.
    "hello\x{20}John\n"~text("byte")~unescape       -- T'hello John[0A]'

    -- No implementation for UTF-16, WTF-16, UTF-32.
    "hello\u{U+20}John\n"~text~utf16~unescape=      -- Method UNESCAPE is ABSTRACT and cannot be directly invoked.


===============================================================================
2021 December 19

Unicode 14 support using utf8proc 2.7.0
Unicode 14.0 adds 838 characters, for a total of 144,697 characters.
These additions include 5 new scripts, for a total of 159 scripts, as well as 37 new emoji characters.
    .unicode~version=               -- 14.0.0
    call loadUnicodeCharacterNames
    .unicode~characters=            -- (an UnicodeCharacterSupplier count=43885 size=918001)
                                    -- (an UnicodeCharacterSupplier count=43056 size=918001) with Unicode 13
    call expandUnicodeCharacterIntervals
    .unicode~characters=            -- (an UnicodeCharacterSupplier count=144763 size=918001)
                                    -- (an UnicodeCharacterSupplier count=143925 size=918001) with Unicode 13

Note:
144697 is the number of character names in the file DerivedName.txt.
I get 144763 characters instead of 144697 (+66) because I include the control characters (they have only an alias, not a name)
    -1       1 character (not part of Unicode)
    00..1F	32 control characters
    7F..9F	33 control characters

.unicode~characters~select{item~categoryName=="Cc"}==
    an Array (shape [65], 65 items)
     1  : ( ""    U+0000 Cc 0 "", "NULL", "NUL" )
     2  : ( ""    U+0001 Cc 0 "", "START OF HEADING", "SOH" )
     3  : ( ""    U+0002 Cc 0 "", "START OF TEXT", "STX" )
     4  : ( ""    U+0003 Cc 0 "", "END OF TEXT", "ETX" )
    ...


===============================================================================
2021 December 11

String reduce was implemented by 2 methods: reduceC for characters, reduceW for words, but no 'reduce'.
Added a 'reduce' method which supports a named argument 'by' to indicate how the split is done.
3 kinds of split are supported: by:"characters", by:"chunks", by:"words".
Examples:
    'he said "bye bye" and left.'~reduce(by:"characters", initial:.set~new, action:"put")=
        a Set (15 items)
        ' ' : ' '
        '"' : '"'
        '.' : '.'
        'a' : 'a'
        'b' : 'b'
        'd' : 'd'
        'e' : 'e'
        'f' : 'f'
        'h' : 'h'
        'i' : 'i'
        'l' : 'l'
        'n' : 'n'
        's' : 's'
        't' : 't'
        'y' : 'y'

    'he said "bye bye" and left.'~reduce(by:"chunks", initial:.set~new, action:"put")=
        a Set (5 items)
        (and)     : (and)
        (bye bye) : (bye bye)       -- chunk surrounded by quotes
        (he)      : (he)
        (left.)   : (left.)
        (said)    : (said)

    'he said "bye bye" and left.'~reduce(by:"words", initial:.set~new, action:"put")=
        a Set (6 items)
        '"bye'  : '"bye'
        'and'   : 'and'
        'bye"'  : 'bye"'
        'he'    : 'he'
        'left.' : 'left.'
        'said'  : 'said'


===============================================================================
2021 November 01

New Unicode script to dump the characters of an encoded file.
unicode/scripts/dump_encoded.rex

TODO:
.stream~linein is not working correctly with UTF-16, UTF-32
The detection of EOL is not good, should test the bytes listed below, in function of the encoding.
("U+0A", "U+0D")~pipe(.inject { .unicode[item] } | .inject { ("utf8", "utf16be", "utf16le", "utf32be", "utf32le")~each{ expose item; arg(1)":"arg(1)~(item)~c2x } } | .console)
    1 : ['utf8:0A','utf16be:000A','utf16le:0A00','utf32be:0000000A','utf32le:0A000000']
    2 : ['utf8:0D','utf16be:000D','utf16le:0D00','utf32be:0000000D','utf32le:0D000000']
Additional constraint: respect the character boundaries.

Dump files generated in the folder unicode/bbedit-save_as for the following cases supported by the editor BBEdit under MacOs:
    UTF-8
    UTF-8 with BOM
    UTF-16
    UTF-16 no BOM
    UTF-16LE
    UTF-16LE no BOM

Files showing the problem with .stream~linein:
    utf16_crlf-dump.txt:         end of string is 000D 00 (remaining of 000D 000A where only 0A was recognized)
    utf16_lf-dump.txt:           end of string is 00 (remaining of 000A where only 0A was recognized)
    utf16_nobom_crlf-dump.txt:   same as utf16_crlf-dump.txt
    utf16_nobom_lf-dump.txt:     same as utf16_lf-dump.txt
    utf16le_crlf-dump.txt:       end of first string is 0D00. Then all the following strings are wrongly extracted (not aligned on 16-bit boundary)
    utf16le_lf-dump.txt:         end of first string is correct. But then all the following strings are wrongly extracted (not aligned on 16-bit boundary)
    utf16le_nobom_crlf-dump.txt: same as utf16le_crlf-dump.txt
    utf16le_nobom_lf-dump.txt:   same as utf16le_lf-dump.txt


===============================================================================
2021 November 01

[Encoded strings]

New methods:
.MutableBuffer
    encoding
    encoding=

.UnicodeCharacter~text
An optional encoding can be passed (was limited to "default").
This is a little optim to avoid an intermediate RexxText in default encoding.
.unicode["father christmas"]~text("utf16")  -- direct creation of UTF16 RexxText
.unicode["father christmas"]~text~utf16     -- UTF8 (default) RexxText, then UTF16 RexxText

Started to work on .RexxText~unescape to support "...\u{character name}..." in any encoding, but not finished.
today:   "Father christmas"~text~utf16 .unicode["father christmas"]~text("utf16")
target:  "Father christmas \u{father christmas}"~text~utf16~unescape


===============================================================================
2021 September 30

[Encoded strings]

New methods:
.String
    join (was concatenateSeparated)

.MutableBuffer
    join (was concatenateSeparated)

.Unicode
    []  (equivalent to .Unicode~character)

.UnicodeCharacter
    makeRexxText
    text
    wtf8
    wtf16
    wtf16be
    wtf16le

.RexxText
    join
    left
    right
    x2d

Examples:

-- https://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries
-- no break before ZWJ (GB9), but break after if not emoji modifier sequence or emoji zwj sequence (GB11)
.unicode["zwj"]~text~join("ab", "cd", .unicode["woman"], .unicode["father christmas"])~c2g=  -- '61 62E2808D 63 64E2808D F09F91A9E2808DF09F8E85'
.unicode["zwj"]~text~join("ab", "cd", .unicode["woman"], .unicode["father christmas"])~graphemes==
a GraphemeSupplier
 1 : T'a'
 2 : T'bâ€'
 3 : T'c'
 4 : T'dâ€'
 5 : T'ðŸ‘©â€ðŸŽ…'

"noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~UnicodeCharacters==
    an Array (shape [12], 12 items)
     1  : ( "n"   U+006E Ll 1 "LATIN SMALL LETTER N" )
     2  : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
     3  : ( "Ã«"   U+00EB Ll 1 "LATIN SMALL LETTER E WITH DIAERESIS" )
     4  : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
     5  : ( "ðŸ‘©"  U+1F469 So 2 "WOMAN" )
     6  : ( "â€"    U+200D Cf 0 "ZERO WIDTH JOINER", "ZWJ" )
     7  : ( "ðŸ‘¨"  U+1F468 So 2 "MAN" )
     8  : ( "â€"    U+200D Cf 0 "ZERO WIDTH JOINER", "ZWJ" )
     9  : ( "ðŸ‘©"  U+1F469 So 2 "WOMAN" )
     10 : ( "â€"    U+200D Cf 0 "ZERO WIDTH JOINER", "ZWJ" )
     11 : ( "ðŸ‘§"  U+1F467 So 2 "GIRL" )
     12 : ( "ðŸŽ…"  U+1F385 So 2 "FATHER CHRISTMAS" )

-- https://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries
-- Do not break within emoji modifier sequences or emoji zwj sequences (GB11).
"noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~graphemes==
    a GraphemeSupplier
     1 : T'n'
     2 : T'o'
     3 : T'Ã«'
     4 : T'l'
     5 : T'ðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§'
     6 : T'ðŸŽ…'

do i=0 to 9; "left("i") = " || "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~left(i)=; end
    T'left(0) = '
    T'left(1) = n'
    T'left(2) = no'
    T'left(3) = noÃ«'
    T'left(4) = noÃ«l'
    T'left(5) = noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§'
    T'left(6) = noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
    T'left(7) = noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ… '
    T'left(8) = noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…  '
    T'left(9) = noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…   '

do i=0 to 9; "right("i") = " || "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~right(i)=; end
    T'right(0) = '
    T'right(1) = ðŸŽ…'
    T'right(2) = ðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
    T'right(3) = lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
    T'right(4) = Ã«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
    T'right(5) = oÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
    T'right(6) = noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
    T'right(7) =  noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
    T'right(8) =   noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
    T'right(9) =    noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'


===============================================================================
2021 September 30

[Encoded strings]

Performance improvement:
Add support for an optional buffer everywhere it makes sense.
That allows to accumulate characters, without creating intermediate RexxText objects,
thus eliminating the validity checks of the intermdiate values. The validity is checked
at the end, when the buffer's string is converted to a RexxText.

Illustration:
    -- Concatenate all the characters loaded with 'call loadUnicodeCharacterNames': 2.8 times faster
    call loadUnicodeCharacterNames
    buffer = .MutableBuffer~new; .unicode~characters~reduce(initial: buffer){item~utf8(b: accu)}  -- Duration:  3.887519 sec (was 10.910638 sec)
    s = buffer~string~text
    -- Same with all the intervals expanded: 27 times faster
    call expandUnicodeCharacterIntervals
    buffer = .MutableBuffer~new; .unicode~characters~reduce(initial: buffer){item~utf8(b: accu)}  -- Duration: 69.157462 sec (was 1927.544056 sec)
    s = buffer~string~text


===============================================================================
2021 September 29

Illustration of the very poor performances of the prototype:
MacBook Pro mid-2010 Intel(R) Core(TM)2 Duo CPU     P8600  @ 2.40GHz

Concatenate all the characters loaded with 'call loadUnicodeCharacterNames'.
    call loadUnicodeCharacterNames
    .unicode~characters=        -- (an UnicodeCharacterSupplier count=43056 size=918001)
Each time a character is concatenated, the whole string is analyzed.
For 43055 characters, that makes 1+2+3+...+43055 = 43055 * (43055 + 1) / 2 = 926 888 040 characters to analyze.
    s = .unicode~characters~take(200)~reduce(initial:""){accu || item~utf8}     -- Duration: 1.594796 sec
    s = .unicode~characters~take(400)~reduce(initial:""){accu || item~utf8}     -- Duration: 4.127699 sec
    s = .unicode~characters~take(600)~reduce(initial:""){accu || item~utf8}     -- Duration: 8.247686 sec
    s = .unicode~characters~take(800)~reduce(initial:""){accu || item~utf8}     -- Duration: 14.516004 sec
    s = .unicode~characters~take(1000)~reduce(initial:""){accu || item~utf8}    -- Duration: 24.784061 sec
    s = .unicode~characters~take(1200)~reduce(initial:""){accu || item~utf8}    -- Duration: 34.575463 sec
    s = .unicode~characters~take(1400)~reduce(initial:""){accu || item~utf8}    -- Duration: 45.256977 sec
    s = .unicode~characters~take(1600)~reduce(initial:""){accu || item~utf8}    -- Duration: 57.467253 sec
    s = .unicode~characters~take(1800)~reduce(initial:""){accu || item~utf8}    -- Duration: 75.098176 sec
    s = .unicode~characters~take(2000)~reduce(initial:""){accu || item~utf8}    -- Duration: 90.681681 sec
    ...
    s = .unicode~characters~take(3000)~reduce(initial:""){accu || item~utf8}    -- Duration: 222.078949 sec
The duration is exponential.
Better adjustment with Mathematica:
    f = Fit[{1.594796, 4.127699, 8.247686, 14.516004, 24.784061, 34.575463, 45.256977, 57.467253, 75.098176, 90.681681}, {1, x, x^2}, x]
        -0.11805 + 0.411648 x + 0.869843 x^2
    f /. x-> 43055/200
        40399.9 sec
        11.22 hours (probably longer than that...)

More efficient calculation:
    buffer = .MutableBuffer~new; .unicode~characters~reduce(initial: buffer){accu~append(item~utf8~string)}     -- Duration: 10.910638 sec
    buffer~length=              -- 142652
    s = buffer~string~text      -- Duration: 2.004553 sec
    s~description               -- 'UTF-8 not-ASCII (40300 graphemes, 43055 codepoints, 142652 bytes, 0 error)'

Reverse of this string of 43 055 codepoints, 142 652 bytes:
    s~reverse                   -- Duration: 7.902785 sec
    s~string~reverse            -- Duration: 0.000619 sec

Still more stress with all the intervals expanded:
    call expandUnicodeCharacterIntervals
    .unicode~characters=        -- (an UnicodeCharacterSupplier count=143925 size=918001)
    buffer = .MutableBuffer~new; .unicode~characters~reduce(initial: buffer){accu~append(item~utf8~string)}  -- Duration: 1927.544056 sec... That was unexpected!! 32 min ???
    buffer~length=              -- 518075
    s = buffer~string~text      -- Duration: 13.808336 sec
    s~description=              -- 'UTF-8 not-ASCII (141169 graphemes, 143924 codepoints, 518075 bytes, 0 error)'
    s~reverse                   -- Duration: 191.105303 sec (!), and then 113 sec, and then 58.28 sec, and then 51.88 sec...
    s~string~reverse            -- Duration: 0.001525 sec


===============================================================================
2021 September 28

[Encoded strings]

New methods:
.RexxText
    reverse

Examples:

-- Correct reverse
"noÃ«l"~text~c2x=            -- '6E 6F C3AB 6C'
"noÃ«l"~text~reverse~c2x=    -- '6C C3AB 6F 6E'
"noÃ«l"~text~reverse=        -- T'lÃ«on'

-- Wrong reverse
"noÃ«l"~c2x=             -- '6E6FC3AB6C'
"noÃ«l"~reverse~c2x=     -- '6CABC36F6E'
"noÃ«l"~reverse=         -- 'l??on'


===============================================================================
2021 September 27

[Encoded strings]

New native methods:
.Unicode
    codepointToLower
    codepointToUpper
    codepointToTitle
    codepointIsLower
    codepointIsUpper

New methods:
.RexxText
    lower
    upper
    isLower
    isUpper
    characters

Examples:

"aÃ Ã¢Ã¤eÃ©Ã¨ÃªÃ«iÃ®Ã¯oÃ´Ã¶uÃ»Ã¼"~text~isUpper=              -- .false
"aÃ Ã¢Ã¤eÃ©Ã¨ÃªÃ«iÃ®Ã¯oÃ´Ã¶uÃ»Ã¼"~text~isLower=              -- .true
"AÃ€Ã‚Ã„EÃ‰ÃˆÃŠÃ‹IÃŽÃOÃ”Ã–UÃ›Ãœ"~text~isUpper=              -- .true
"AÃ€Ã‚Ã„EÃ‰ÃˆÃŠÃ‹IÃŽÃOÃ”Ã–UÃ›Ãœ"~text~isLower=              -- .false
"Le pÃ¨re NoÃ«l est fatiguÃ©..."~text~upper=       -- T'LE PÃˆRE NOÃ‹L EST FATIGUÃ‰...'
"LE PÃˆRE NOÃ‹L EST FATIGUÃ‰..."~text~lower=       -- T'le pÃ¨re noÃ«l est fatiguÃ©...'

utf8proc supports only the basic cases (those in UnicodeData.txt).
The cases described in SpecialCasing.txt are not supported by utf8proc.
Examples:

-- # The German es-zed is special--the normal mapping is to SS.
-- # Note: the titlecase should never occur in practice. It is equal to titlecase(uppercase(<es-zed>))
-- # <code>; <lower>; <title>; <upper>; (<condition_list>;)? # <comment>
-- 00DF; 00DF; 0053 0073; 0053 0053; # LATIN SMALL LETTER SHARP S
.unicode~character("LATIN SMALL LETTER SHARP S")~utf8=          -- T'ÃŸ'
.unicode~character("LATIN SMALL LETTER SHARP S")~toUpper        -- (U+1E9E Lu "LATIN CAPITAL LETTER SHARP S")
.unicode~character("LATIN SMALL LETTER SHARP S")~toUpper~utf8=  -- T'áºž'
-- T'ÃŸ' to uppercase should be T'SS':
"0053 0053"x~text("utf16")~UnicodeCharacters==
    an Array (shape [2], 2 items)
     1 : (U+0053 Lu "LATIN CAPITAL LETTER S")
     2 : (U+0053 Lu "LATIN CAPITAL LETTER S")

-- # Preserve canonical equivalence for I with dot. Turkic is handled below.
-- 0130; 0069 0307; 0130; 0130; # LATIN CAPITAL LETTER I WITH DOT ABOVE
.unicode~character("LATIN CAPITAL LETTER I WITH DOT ABOVE")~utf8=           -- T'Ä°'
.unicode~character("LATIN CAPITAL LETTER I WITH DOT ABOVE")~toLower=        -- (U+0069 Ll "LATIN SMALL LETTER I")
.unicode~character("LATIN CAPITAL LETTER I WITH DOT ABOVE")~toLower~utf8=   -- T'i'
-- T'Ä°' to lowercase should be T'iÌ‡':
"0069 0307"x~text("utf16")~UnicodeCharacters==
    an Array (shape [2], 2 items)
     1 : (U+0069 Ll "LATIN SMALL LETTER I")
     2 : (U+0307 Mn "COMBINING DOT ABOVE")

-- # Turkish and Azeri
-- # I and i-dotless; I-dot and i are case pairs in Turkish and Azeri
-- # The following rules handle those cases.
-- 0130; 0069; 0130; 0130; tr; # LATIN CAPITAL LETTER I WITH DOT ABOVE
-- 0130; 0069; 0130; 0130; az; # LATIN CAPITAL LETTER I WITH DOT ABOVE

-- # Note: the following case is already in the UnicodeData.txt file.
-- # 0131; 0131; 0049; 0049; tr; # LATIN SMALL LETTER DOTLESS I
.unicode~character("LATIN SMALL LETTER DOTLESS I")~utf8=            -- T'Ä±'
.unicode~character("LATIN SMALL LETTER DOTLESS I")~toUpper=         -- (U+0049 Lu "LATIN CAPITAL LETTER I")
.unicode~character("LATIN SMALL LETTER DOTLESS I")~toUpper~utf8=    -- T'I'


-- Which characters have their title character different from their upper character?
.unicode~characters~select{item~toTitle <> item~toUpper}~each{item~toTitle~utf8 item~ToUpper~utf8 item~utf8 item~string}==
    an Array (shape [58], 58 items)
     1  : T'Ç… Ç„ Ç„ U+01C4 Lu "LATIN CAPITAL LETTER DZ WITH CARON"'
     2  : T'Ç… Ç„ Ç… U+01C5 Lt "LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON"'
     3  : T'Ç… Ç„ Ç† U+01C6 Ll "LATIN SMALL LETTER DZ WITH CARON"'
     4  : T'Çˆ Ç‡ Ç‡ U+01C7 Lu "LATIN CAPITAL LETTER LJ"'
     5  : T'Çˆ Ç‡ Çˆ U+01C8 Lt "LATIN CAPITAL LETTER L WITH SMALL LETTER J"'
     6  : T'Çˆ Ç‡ Ç‰ U+01C9 Ll "LATIN SMALL LETTER LJ"'
     7  : T'Ç‹ ÇŠ ÇŠ U+01CA Lu "LATIN CAPITAL LETTER NJ"'
     8  : T'Ç‹ ÇŠ Ç‹ U+01CB Lt "LATIN CAPITAL LETTER N WITH SMALL LETTER J"'
     9  : T'Ç‹ ÇŠ ÇŒ U+01CC Ll "LATIN SMALL LETTER NJ"'
     10 : T'Ç² Ç± Ç± U+01F1 Lu "LATIN CAPITAL LETTER DZ"'
     11 : T'Ç² Ç± Ç² U+01F2 Lt "LATIN CAPITAL LETTER D WITH SMALL LETTER Z"'
     12 : T'Ç² Ç± Ç³ U+01F3 Ll "LATIN SMALL LETTER DZ"'
     13 : T'áƒ á² áƒ U+10D0 Ll "GEORGIAN LETTER AN"'
     14 : T'áƒ‘ á²‘ áƒ‘ U+10D1 Ll "GEORGIAN LETTER BAN"'
     15 : T'áƒ’ á²’ áƒ’ U+10D2 Ll "GEORGIAN LETTER GAN"'
     ...
     56 : T'áƒ½ á²½ áƒ½ U+10FD Ll "GEORGIAN LETTER AEN"'
     57 : T'áƒ¾ á²¾ áƒ¾ U+10FE Ll "GEORGIAN LETTER HARD SIGN"'
     58 : T'áƒ¿ á²¿ áƒ¿ U+10FF Ll "GEORGIAN LETTER LABIAL SIGN"'


===============================================================================
2021 September 22

Reorganize the cls files: moved under the 'packages' directory.
Builder updated to add the packages in PATH and to declare corresponding aliases.


===============================================================================
2021 September 22

[Encoded strings]

New native methods:
.Unicode
    codepointBidiMirrored
    codepointDecompositionType


Add character aliases.
.unicode~characters returns now a supplier, instead of the internal array of characters.
The indexes of the characters supplier are the codepoints, not the indexes of the
internal array which are codepoint+2.

.unicode~characters==
    an UnicodeCharacterSupplier
    -1    : (-1 Cn "<UNKNOWN CHARACTER>")
     0    : (U+0000 Cc "", "NULL", "NUL")
     1    : (U+0001 Cc "", "START OF HEADING", "SOH")
     2    : (U+0002 Cc "", "START OF TEXT", "STX")
     3    : (U+0003 Cc "", "END OF TEXT", "ETX")
     4    : (U+0004 Cc "", "END OF TRANSMISSION", "EOT")
     5    : (U+0005 Cc "", "ENQUIRY", "ENQ")
     ...


Add character intervals.
.UnicodeCharacterInterval
    codepointFrom
    codepointTo
    name
    isExpanded

.unicode~characterIntervals==
    an UnicodeCharacterIntervalSupplier
     1  : (U+3400..U+4DBF "CJK UNIFIED IDEOGRAPH-*" 6591 characters)
     2  : (U+4E00..U+9FFC "CJK UNIFIED IDEOGRAPH-*" 20988 characters)
     3  : (U+F900..U+FA6D "CJK COMPATIBILITY IDEOGRAPH-*" 365 characters)
     4  : (U+FA70..U+FAD9 "CJK COMPATIBILITY IDEOGRAPH-*" 105 characters)
     5  : (U+17000..U+187F7 "TANGUT IDEOGRAPH-*" 6135 characters)
     6  : (U+18B00..U+18CD5 "KHITAN SMALL SCRIPT CHARACTER-*" 469 characters)
     7  : (U+18D00..U+18D08 "TANGUT IDEOGRAPH-*" 8 characters)
     8  : (U+1B170..U+1B2FB "NUSHU CHARACTER-*" 395 characters)
     9  : (U+20000..U+2A6DD "CJK UNIFIED IDEOGRAPH-*" 42717 characters)
     10 : (U+2A700..U+2B734 "CJK UNIFIED IDEOGRAPH-*" 4148 characters)
     11 : (U+2B740..U+2B81D "CJK UNIFIED IDEOGRAPH-*" 221 characters)
     12 : (U+2B820..U+2CEA1 "CJK UNIFIED IDEOGRAPH-*" 5761 characters)
     13 : (U+2CEB0..U+2EBE0 "CJK UNIFIED IDEOGRAPH-*" 7472 characters)
     14 : (U+2F800..U+2FA1D "CJK COMPATIBILITY IDEOGRAPH-*" 541 characters)
     15 : (U+30000..U+3134A "CJK UNIFIED IDEOGRAPH-*" 4938 characters)


Informations about Unicode:
.Unicode~informations=
    a Directory (10 items)
    'characterIntervals'                 : (an UnicodeCharacterIntervalSupplier count=15 notExpanded:0 interval, 0 character)
    'characters'                         : (an UnicodeCharacterSupplier count=143925 size=918001)
    'dataDirectory'                      : (/local/rexx/oorexx/executor/sandbox/jlf/samples/extension/Unicode-13.0.0)
    'maxCodepoint'                       :  1114111
    'systemIsLittleEndian'               :  1
    'totalCharacterNameAliases'          :  468
    'totalCharactersLoaded'              :  143859
    'totalIntervalCharacters'            :  100869
    'totalIntervalCharactersNotExpanded' :  0
    'version'                            : '13.0.0'


===============================================================================
2021 September 13, updated September 22

[Encoded strings]

Add character informations.

The loading of the character names is optional.
By default, they are not loaded.
From ooRexxShell, execute: call loadUnicodeCharacterNames
By default, the character intervals are not expanded.
From ooRexxShell, execute: call expandUnicodeCharacterIntervals

The other character properties are always loaded (provided by utf8proc)

.Unicode
    characters          --> supplier of UnicodeCharacter
    character(index)    --> UnicodeCharacter (index can be a loose matching name (UAX44-LM2) or a codepoint)
    characterIntervals  --> supplier of UnicodeCharacterInterval

.UnicodeCharacter
    codepoint       --> integer -1..1114111
    name            --> string
    aliases         --> array of .UnicodeAlias

    bidiClass       --> enum 1, 2, 3, ...
    bidiClassName   --> enum 'L', 'LRE', 'LRO', ...
    boundClass      --> enum 0, 1, 2, ...
    boundClassName  --> enum 'START', 'OTHER', 'CR', ...
    category        --> enum 0, 1, 2, ...
    categoryName    --> enum 'Cn', 'Lu', 'Ll', ...
    charWidth       --> integer
    combiningClass  --> integer 0..254
    controlBoundary --> boolean
    decompType      --> enum 0, 1, 2, ...
    decompTypeName  --> enum '<none>', '<font>', '<nobreak>, ...
    ignorable       --> boolean

Examples:

-- All the Unicode characters (sparse array).
.unicode~characters==
an UnicodeCharacterSupplier
    -1    : (-1 Cn "<UNKNOWN CHARACTER>")
     0    : (U+0000 Cc "", "NULL", "NUL")
     1    : (U+0001 Cc "", "START OF HEADING", "SOH")
     2    : (U+0002 Cc "", "START OF TEXT", "STX")
     3    : (U+0003 Cc "", "END OF TEXT", "ETX")
    ...
     32   : (U+0020 Zs "SPACE", "SP")
     33   : (U+0021 Po "EXCLAMATION MARK")
     34   : (U+0022 Po "QUOTATION MARK")
    ...

-- The last 10 characters
.unicode~characters~pipe(.take "last" 10 | .console)
    917990 : (U+E01E6 Mn "VARIATION SELECTOR-247", "VS247")
    917991 : (U+E01E7 Mn "VARIATION SELECTOR-248", "VS248")
    917992 : (U+E01E8 Mn "VARIATION SELECTOR-249", "VS249")
    917993 : (U+E01E9 Mn "VARIATION SELECTOR-250", "VS250")
    917994 : (U+E01EA Mn "VARIATION SELECTOR-251", "VS251")
    917995 : (U+E01EB Mn "VARIATION SELECTOR-252", "VS252")
    917996 : (U+E01EC Mn "VARIATION SELECTOR-253", "VS253")
    917997 : (U+E01ED Mn "VARIATION SELECTOR-254", "VS254")
    917998 : (U+E01EE Mn "VARIATION SELECTOR-255", "VS255")
    917999 : (U+E01EF Mn "VARIATION SELECTOR-256", "VS256")

-- get a character by codepoint
.unicode~character(8203)=                   -- (U+200B Cf "ZERO WIDTH SPACE")
.unicode~character("U+200B")=               -- (U+200B Cf "ZERO WIDTH SPACE")
.unicode~character("u+200b")=               -- (U+200B Cf "ZERO WIDTH SPACE")

-- get a character by name.
-- loose matching name. See https://unicode.org/reports/tr44/#UAX44-LM2
.unicode~character("ZERO WIDTH SPACE")=     -- (U+200B Cf "ZERO WIDTH SPACE")
.unicode~character("ZERO_WIDTH-SPACE")=     -- (U+200B Cf "ZERO WIDTH SPACE")
.unicode~character("ZEROWIDTHSPACE")=       -- (U+200B Cf "ZERO WIDTH SPACE")
.unicode~character("zerowidthspace")=       -- (U+200B Cf "ZERO WIDTH SPACE")

-- select characters using a matcher
-- remember: it's better to initialize the matcher outside the iteration.
matcher = "*chris*"~matcher; .unicode~characters~select{expose matcher; matcher~(item~name)}==
    an Array (shape [3], 3 items)
     1 : (U+1F384 So "CHRISTMAS TREE")
     2 : (U+1F385 So "FATHER CHRISTMAS")
     3 : (U+1F936 So "MOTHER CHRISTMAS")

-- string character names
"noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~codepoints~each{uchar = .unicode~character(item); uchar~charWidth uchar~categoryName uchar~name}==
    an Array (shape [12], 12 items)
     1  : '1 Ll LATIN SMALL LETTER N'
     2  : '1 Ll LATIN SMALL LETTER O'
     3  : '1 Ll LATIN SMALL LETTER E WITH DIAERESIS'
     4  : '1 Ll LATIN SMALL LETTER L'
     5  : '2 So WOMAN'
     6  : '0 Cf ZERO WIDTH JOINER'
     7  : '2 So MAN'
     8  : '0 Cf ZERO WIDTH JOINER'
     9  : '2 So WOMAN'
     10 : '0 Cf ZERO WIDTH JOINER'
     11 : '2 So GIRL'
     12 : '2 So FATHER CHRISTMAS'

-- shortest name:
.unicode~characters~reduce{if accu~name~length > item~name~length, item~name~length <> 0 then item }=
    (U+1F402 So "OX")

-- longest name:
.unicode~characters~reduce{if accu~name~length < item~name~length then item }=
    (U+1FBA8 So "BOX DRAWINGS LIGHT DIAGONAL UPPER CENTRE TO MIDDLE LEFT AND MIDDLE RIGHT TO LOWER CENTRE")


===============================================================================
2021 September 12

[String chunks]

The functionality of splitting text by quoted/unquoted chunks is moved from
ooRexxShell to a dedicated package:
extension/stringChunk.cls               (compatible with official ooRexx)

The initial need was to parse a command line and split it the same way as a cmd
or bash shell. Also used to parse the queries in ooRexxShell.
The quotes are removed, but each character is associated to a 'quote flag' to
remember if the character was inside a quoted section.
These flags are typically used by the matchers of type string pattern, to decide
if a character can be special or not.

Description:
    routine stringChunks
    use strict arg string, withInfos=.false, breakTokens="", splitLevel=1

    Converts a string to an array of String or to an array of stringChunk.
    The type of result is indicated by the argument withInfos:
    - If withInfos == .false (default) then the result is an array of String.
    - If withInfos == .true then the result is an array of StringChunk.

    A StringChunk is a substring which references the start and end character
    in its container. It's associated to a string of booleans (quotedFlags)
    which indicate for each character if it was inside a quoted section.

    A quote is either " or '.

    An unquoted section is splitted in StringChunks delimited by whitespaces
    (anything <= 32) and break tokens.

    A quoted section is not splitted:
    - Whitespaces are kept,
    - single occurences of quotes are removed,
    - double occurrence of quotes are replaced by a single embedded quote,
    - break tokens and escape characters are ignored.

    An escape character is any character passed in the argument escapeCharacters.
    An escape character sets the quote flag of the next character to 1.
    Escape characters are removed, even if they are not followed by another
    character (truncated string).
    Example with 'a' declared escape character:
    - "a" --> ""
    - "aa" --> "a"
    - "aaa" --> "a"
    - "aaaa" --> "aa"

    If a quote is declared escape character, there is no impact: a quote is
    already an escape mechanism.

    If a space is declared escape character, there is an impact when splitLevel=0:
    the quote flag of a character following an unquoted space is set to 1, the
    unquoted spaces are removed
    Example:
        'one two "three four" five six' --> onetwothree fourfivesix
                                            00010011111111111000100

    Break tokens are passed in the argument breakTokens.
    A break token cannot contains spaces.
    The break tokens can be case sensitive (default) or case insensitive.
    Each break token can be prefixed by:
    - cs:  case sensitive
    - ci:  case insensitive
    - cl:  caseless (synonym of case insensitive)
    Any other prefix is not an error. It's just not a case prefix.

    If a quote is declared break token then it's no longer recognized as a quote.
    If an escape character is declared break token then it's no longer recognized
    as an escape character.

    The split process is controlled by the argument splitLevel:
    - If splitLevel == 0 then the string is not splitted but the quotes and
      escape characters are managed, quotedFlags is set.
        'xx aa"b b"cc"d d"ee yy' is 1 StringChunk.
    - If splitLevel == 1 (default) then adjacent quoted/unquoted sections are kept glued.
        'xx aa"b b"cc"d d"ee yy' is 3 StringChunk: xx "aab bccd dee" yy
    - If splitLevel == 2 then adjacent quoted/unquoted sections are separated.
        'xx aa"b b"cc"d d"ee yy' is splitted in 7 StringChunk: xx aa "b b" cc "d d" ee yy

    Illustration with splitLevel=1:
     11111111111111111111111111 222222222222222 333333333333333333333
    '"hello "John" how are you" good" bye "John "my name is ""BOND"""'
     0000000001111111111222222222233333333334444444444555555555566666
     1234567890123456789012345678901234567890123456789012345678901234
    arg1 = |hello John how are you|      containerStart = 01      containerEnd = 26      quotedFlags = 1111110000111111111111
    arg2 = |good bye John|               containerStart = 28      containerEnd = 42      quotedFlags = 0000111110000
    arg3 = |my name is "BOND"|           containerStart = 44      containerEnd = 64      quotedFlags = 11111111111111111

Extensions available in Executor only:
    .String~chunk           withInfos is true, splitLevel is 0 --> always returns ONE StringChunk
    .String~chunks          withInfos is true by default, splitLevel is 1 by default

Examples:
    -- splitLevel = 0: no split
    'aa"b\ b"cc"d\ d"ee\* ff'~chunks(splitLevel:0)~each{item~sayDescription(25, index, 2)}
        1  |aab\ bccd\ dee\* ff|       01 23 |aa"b\ b"cc"d\ d"ee\* ff|
        1  |0011110011110000000|

    -- splitLevel = 1: Adjacent quoted/unquoted sections are kept glued
    'aa"b\ b"cc"d\ d"ee\* ff'~chunks(splitLevel:1)~each{item~sayDescription(25, index, 2)}
        1  |aab\ bccd\ dee\*|          01 20 |aa"b\ b"cc"d\ d"ee\*|
        1  |0011110011110000|
        2  |ff|                        22 23 |ff|
        2  |00|

    -- splitLevel = 2: Adjacent quoted/unquoted sections are separated
    'aa"b\ b"cc"d\ d"ee\* ff'~chunks(splitLevel:2)~each{item~sayDescription(25, index, 2)}
        1  |aa|                        01 02 |aa|
        1  |00|
        2  |b\ b|                      03 08 |"b\ b"|
        2  |1111|
        3  |cc|                        09 10 |cc|
        3  |00|
        4  |d\ d|                      11 16 |"d\ d"|
        4  |1111|
        5  |ee\*|                      17 20 |ee\*|
        5  |0000|
        6  |ff|                        22 23 |ff|
        6  |00|

    -- Default splitLevel (1)
    -- The quote is declared break token, there is no more quoted sections, and the quote itself is returned
    'aa"b\ b"cc"d\ d"ee\* ff'~chunks(breakTokens: '"')~each{item~sayDescription(25, index, 2)}
        1  |aa|                        01 02 |aa|
        1  |00|
        2  |"|                         03 03 |"|
        2  |0|
        3  |b\|                        04 05 |b\|
        3  |00|
        4  |b|                         07 07 |b|
        4  |0|
        5  |"|                         08 08 |"|
        5  |0|
        6  |cc|                        09 10 |cc|
        6  |00|
        7  |"|                         11 11 |"|
        7  |0|
        8  |d\|                        12 13 |d\|
        8  |00|
        9  |d|                         15 15 |d|
        9  |0|
        10 |"|                         16 16 |"|
        10 |0|
        11 |ee\*|                      17 20 |ee\*|
        11 |0000|
        12 |ff|                        22 23 |ff|
        12 |00|

    -- Same as previous, plus \ which is declared escape character
    'aa"b\ b"cc"d\ d"ee\* ff'~chunks(breakTokens: '"', escapeCharacters:"\")~each{item~sayDescription(25, index, 2)}
        1  |aa|                        01 02 |aa|
        1  |00|
        2  |"|                         03 03 |"|
        2  |0|
        3  |b b|                       04 07 |b\ b|
        3  |010|
        4  |"|                         08 08 |"|
        4  |0|
        5  |cc|                        09 10 |cc|
        5  |00|
        6  |"|                         11 11 |"|
        6  |0|
        7  |d d|                       12 15 |d\ d|
        7  |010|
        8  |"|                         16 16 |"|
        8  |0|
        9  |ee*|                       17 20 |ee\*|
        9  |001|
        10 |ff|                        22 23 |ff|
        10 |00|

    -- A break token can be made of several characters, and can contain a quote
    'aa"b\ b"cc"d\ d"ee\* ff'~chunks(breakTokens: ' a"b ')~each{item~sayDescription(25, index, 2)}
        1  |a|                         01 01 |a|
        1  |0|
        2  |a"b|                       02 04 |a"b|
        2  |000|
        3  |\|                         05 05 |\|
        3  |0|
        4  |bccd\|                     07 13 |b"cc"d\|
        4  |01100|
        5  |dee\* ff|                  15 23 |d"ee\* ff|
        5  |01111111|

    -- If an escape character is also declared break token then it's no longer an escape character
    'aa"b\ b"cc"d\ d"ee\* ff'~chunks(breakTokens:"\", escapeCharacter:"\")~each{item~sayDescription(25, index, 2)}==
        1  |aab\ bccd\ dee|            01 18 |aa"b\ b"cc"d\ d"ee|
        1  |00111100111100|
        2  |\|                         19 19 |\|
        2  |0|
        3  |*|                         20 20 |*|
        3  |0|
        4  |ff|                        22 23 |ff|
        4  |00|

    -- A break token can contain characters that are declared escape character
    'aa"b\ b"cc"d\ d"ee\* ff'~chunks(breakTokens:"e\*", escapeCharacters:"\*")~each{item~sayDescription(25, index, 2)}==
        1  |aab\ bccd\ de|             01 17 |aa"b\ b"cc"d\ d"e|
        1  |0011110011110|
        2  |e\*|                       18 20 |e\*|
        2  |000|
        3  |ff|                        22 23 |ff|
        3  |00|

    -- A break token can be case insensitive (prefix ci: or cl:)
    '1Plus2'~chunks(breakTokens:"ci:plus")~each{item~sayDescription(25, index, 2)}
        1  |1|                         1 1 |1|
        1  |0|
        2  |Plus|                      2 5 |Plus|
        2  |0000|
        3  |2|                         6 6 |2|
        3  |0|


[String patterns]

The functionality of selecting text using patterns is moved from ooRexxShell
to a dedicated package:
extension/stringChunkExtended.cls       (not compatible with official ooRexx)

Description
    .StringChunk~matcher
    use strict named arg wholeString(1)=.true, caseless(1)=.true,-
                         trace(1)=.false, displayer(1)=.traceOutput, prefix(1)=""

    Pattern matching by equality (whole) or by inclusion (not whole), caseless or not.

    If the package regex.cls is loaded, then the pattern (a StringChunk) can be
    a regular expression prefixed by "/".

    When whole, and the pattern is not a regular expression, then the charecter
    "*" is recognized as a generic character when first or last character.

    When not whole, and the pattern is not a regular expression, then the character
    "^" is recognized as the metacharacter 'begining of string' when first character.

    When not whole, and the pattern is not a regular expression, then the character
    "$" is recognized as the metacharacter 'end of string' when last character.

    The returned result is a closure (matcher) which implements the pattern matching,
    or .nil if error.

    The pattern matching is tested when the closure is evaluated with a string passed
    as argument.

    Examples:

        '*' or '**'      : matches everything
        '"*"' or '"**"'  : matches exactly "*" or "**", see case stringPattern
        '***'            : matches all names containing "*", see case *stringPattern*
        '*"*"*'          : matches all names containing "*", see case *stringPattern*
        '*"**"*'         : matches all names containing "**", see case *stringPattern*
        '*stringPattern' : string~right(stringPattern~length)~caselessEquals(stringPattern)
        'stringPattern*' : string~left(stringPattern~length)~caselessEquals(stringPattern)
        '*stringPattern*': string~caselessPos(stringPattern) <> 0
        'stringPattern'  : string~caselessEquals(stringPattern)

        -- caseless equality
        matcher = "object"~matcher
        say matcher~("ObjeCt") -- true
        say matcher~("my ObjeCt") -- false

        -- caseless equality with generic character
        matcher = "*object"~matcher
        say matcher~("ObjeCt") -- true
        say matcher~("my ObjeCt") -- true

        -- caseless inclusion
        matcher = "object"~matcher(wholeString:.false)
        say matcher~("ObjeCt") -- true
        say matcher~("my ObjeCt") -- true

        -- caseless inclusion, regular expression: "object" at the begining or at the end.
        matcher = "/^object|object$"~matcher(wholeString:.false)
        say matcher~("ObjeCt") -- true
        say matcher~("my ObjeCt") -- true
        say matcher~("my ObjeCts") -- false

        -- trace
        "*stringPattern"~matcher(trace:.true)
        output:
            description: stringChunkPattern="*stringPattern" wholeString=1 caseless=1
            stringPattern="stringPattern"
            matcher: expose description stringPattern; use strict arg string; return string~right(stringPattern~length)~caselessEquals(stringPattern)

        -- trace when regular expression
        "/.*stringPattern"~matcher(trace:.true)
        output:
            description: stringChunkPattern="/.*stringPattern" wholeString=1 caseless=1
            stringPattern=".*stringPattern"
            pattern = .Pattern~compile(stringPattern, .RegexCompiler~new(.RegexCompiler~caseless))
            matcher: expose description pattern; use strict arg string; return pattern~matches(string)


===============================================================================
2021 August 22

Fix most of the warnings.
Still to do:

Windows
-------
trunk\rexxapi\common\platform\windows\SysCSStream.cpp(337): warning C4996: 'gethostbyname': Use getaddrinfo() or GetAddrInfoW() instead or define _WINSOCK_DEPRECATED_NO_WARNINGS to disable deprecated API warnings
trunk\rexxapi\common\platform\windows\SysCSStream.cpp(344): warning C4996: 'inet_addr': Use inet_pton() or InetPton() instead or define _WINSOCK_DEPRECATED_NO_WARNINGS to disable deprecated API warnings
trunk\rexxapi\common\platform\windows\SysCSStream.cpp(518): warning C4996: 'inet_addr': Use inet_pton() or InetPton() instead or define _WINSOCK_DEPRECATED_NO_WARNINGS to disable deprecated API warnings
trunk\rexxapi\common\platform\windows\SysCSStream.cpp(626): warning C4996: 'inet_ntoa': Use inet_ntop() or InetNtop() instead or define _WINSOCK_DEPRECATED_NO_WARNINGS to disable deprecated API warnings
trunk\rexxapi\server\platform\windows\APIService.cpp(121): warning C4996: 'GetVersionExA': was declared deprecated

[ 83%] Building CXX object CMakeFiles/hostemu.dir/extensions/hostemu/cmdparse.cpp.obj
cmdparse.cpp
..\..\cmdparse.cpp(1152): warning C4065: switch statement contains 'default' but no 'case' labels


MacOs
-----
trunk/common/platform/unix/SysFile.cpp:993:13: warning: 'fstat64' is deprecated: first
trunk/common/platform/unix/SysFile.cpp:1022:9: warning: 'stat64' is deprecated: first
trunk/common/platform/unix/SysFile.cpp:1055:13: warning: 'fstat64' is deprecated: first
trunk/common/platform/unix/SysFile.cpp:1080:9: warning: 'stat64' is deprecated: first
trunk/common/platform/unix/SysFile.cpp:1112:9: warning: 'fstat64' is deprecated: first


trunk/extensions/rexxutil/platform/unix/rexxutil.cpp:1852:14: warning: 'sem_init' is deprecated [-Wdeprecated-declarations]
trunk/extensions/rexxutil/platform/unix/rexxutil.cpp:1913:5: warning: 'sem_init' is deprecated [-Wdeprecated-declarations]
trunk/extensions/rexxutil/platform/unix/rexxutil.cpp:1957:13: warning: 'sem_destroy' is deprecated [-Wdeprecated-declarations]
trunk/extensions/rexxutil/platform/unix/rexxutil.cpp:2054:14: warning: 'sem_init' is deprecated [-Wdeprecated-declarations]
trunk/extensions/rexxutil/platform/unix/rexxutil.cpp:2162:10: warning: 'sem_getvalue' is deprecated [-Wdeprecated-declarations]
trunk/extensions/rexxutil/platform/unix/rexxutil.cpp:2198:13: warning: 'sem_destroy' is deprecated [-Wdeprecated-declarations]
trunk/extensions/rexxutil/platform/unix/rexxutil.cpp:3693:15: warning: 'tempnam' is deprecated: This function is provided for compatibility reasons only. Due to security concerns inherent in the design of tempnam(3), it is highly recommended that you use mkstemp(3) instead. [-Wdeprecated-declarations]
trunk/extensions/rexxutil/platform/unix/rexxutil.cpp:3697:15: warning: 'tempnam' is deprecated: This function is provided for compatibility reasons only. Due to security concerns inherent in the design of tempnam(3), it is highly recommended that you use mkstemp(3) instead. [-Wdeprecated-declarations]
trunk/extensions/rexxutil/platform/unix/rexxutil.cpp:3701:15: warning: 'tempnam' is deprecated: This function is provided for compatibility reasons only. Due to security concerns inherent in the design of tempnam(3), it is highly recommended that you use mkstemp(3) instead. [-Wdeprecated-declarations]
trunk/extensions/rexxutil/platform/unix/rexxutil.cpp:3708:13: warning: 'tempnam' is deprecated: This function is provided for compatibility reasons only. Due to security concerns inherent in the design of tempnam(3), it is highly recommended that you use mkstemp(3) instead. [-Wdeprecated-declarations]
trunk/extensions/rexxutil/platform/unix/rexxutil.cpp:5468:33: warning: 'tempnam' is deprecated: This function is provided for compatibility reasons only. Due to security concerns inherent in the design of tempnam(3), it is highly recommended that you use mkstemp(3) instead. [-Wdeprecated-declarations]

trunk/interpreter/platform/unix/SysFileSystem.cpp:173:12: warning: 'tmpnam' is deprecated:
trunk/interpreter/platform/unix/SysFileSystem.cpp:226:10: warning: 'stat64' is deprecated:
trunk/interpreter/platform/unix/SysFileSystem.cpp:495:9: warning: 'stat64' is deprecated:
trunk/interpreter/platform/unix/SysFileSystem.cpp:548:17: warning: 'stat64' is deprecated:
trunk/interpreter/platform/unix/SysFileSystem.cpp:797:14: warning: 'stat64' is deprecated:
trunk/interpreter/platform/unix/SysFileSystem.cpp:842:14: warning: 'stat64' is deprecated:
trunk/interpreter/platform/unix/SysFileSystem.cpp:858:14: warning: 'stat64' is deprecated:
trunk/interpreter/platform/unix/SysFileSystem.cpp:876:9: warning: 'stat64' is deprecated:
trunk/interpreter/platform/unix/SysFileSystem.cpp:894:9: warning: 'stat64' is deprecated:
trunk/interpreter/platform/unix/SysFileSystem.cpp:969:9: warning: 'stat64' is deprecated:
trunk/interpreter/platform/unix/SysFileSystem.cpp:991:9: warning: 'stat64' is deprecated:


===============================================================================
2021 August 11

[Encoded strings]

Added support for strings of codepoints encoded as native integers.
3 representations:
    Unicode8_Encoding
    Unicode16_Encoding
    Unicode32_Encoding.
The method ~unicode returns one of these encodings, depending on the character
with the largest Unicode codepoint (1, 2, or 4 bytes) in the source string.
Unlike the flexible representation of Python, the 3 representions are first-class.
No BOM, the endiannes is the CPU one. This is mainly for internal use.
Unicode32_Encoding can be used with utf8proc for the functions taking a buffer of 32-bit integers.


"cÃ´tÃ©"~text("unicode8")=    -- T'cÃ´tÃ© Just an interpretative layer put above the string
"cÃ´tÃ©"~text("unicode8")~pipe{item~description(s:1) ":" item~c2x}=
    'Unicode8 not-ASCII : 63 C3 B4 74 C3 A9

"cÃ´tÃ©"~text~unicode=        -- T'c?t?' UTF-8 converted to Unicode8
"cÃ´tÃ©"~text~unicode~pipe{item~description(s:1) ":" item~c2x}=
    'Unicode8 not-ASCII : 63 F4 74 E9

"noÃ«lâ€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§"~text~maximumCodepoint~pipe{"U+"item~d2x}=   -- U+1F469 is the maximum codepoint
"noÃ«lâ€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§"~text~unicode~description(t:1)=              -- For this maximum codepoint, we need Unicode32
    'Unicode32 not-ASCII (5 graphemes (1 index from index 5), 10 codepoints (0 index), 40 bytes, 0 error)'

-- The endianness of the UnicodeXX_Encoding is the one of the machine.
-- With an Intel CPU, it's little-endian.
"noÃ«lâ€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§"~text~unicode~c2x=
    '6E000000 6F000000 EB000000 6C000000 0D200000 68F40100 0D200000 69F40100 0D200000 67F40100'

-- The default endianness for UTF32 is big-endian.
"noÃ«lâ€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§"~text~utf32~c2x=
    '0000006E 0000006F 000000EB 0000006C 0000200D 0001F468 0000200D 0001F469 0000200D 0001F467'


===============================================================================
2021 August 08

[Encoded strings]

- Optimization of the indexes: no longer store the last index+1, because it's
  always equal to self~string~length + 1.
  Consequence: an index table equal to .nil doesn't imply that all the codepoints
  or graphemes have the same size. The last codepoint or last grapheme can be of
  any size.
- New demo file executor-demo-text-compatibility.txt
  This file demonstrates the compatibility of RexxText with String.
  Work in progress, many methods not yet supported,
  Unicode implementation still missing for many methods.


===============================================================================
2021 August 08

[extension.cls]

Reorganized the way I declare the extensions by inheritance.
Before, they were declared using one extension directive per class.
Now the extensions of a given class are splitted by functionality, and the same
class can appear several times.


[Collection]

The methods putAll now return the updated collection (retrofit from ooRexx5).

Removed the method .collection~table, I don't see any usage for it.

Modified the implementation of .supplier~table: no longer make a copy.
It"s up to the caller to decide if a copy is needed.
ooRexxshell has been modified to make a copy before displaying a supplier as a table.

Retrofit the method MapCollection~of from ooRexx5:
    aMapCollection~of( (key1, value1), (key2, value2), ...)
while keeping my own implementation that was available for .Directory:
    aMapCollection~of(key1, value1, key2, value2, ..., n1:v1, n2:v2, ...)
The key-value where the key is compatible with a named  argument can be passed as named argument.
The key-value where the key is not compatible with a named argument can be passed as a pair of positional arguments.
ooRexx5 wants each key-value to be an array (key, value).
I prefer to pass each key-value as 2 positional arguments, or as one named argument.
I make my implementation compatible with ooRexx5:
If the first argument is an array then assume it's the ooRexx5 way, otherwise it's mine.

Examples:

    .stem~of("un", 1, "deux", 2, trois:3, quatre:4)=
        a Stem (4 items)
        'deux'   :  2
        'QUATRE' :  4
        'TROIS'  :  3
        'un'     :  1

    .relation~of("UN", 10, "DEUX", 20, un:100, deux:200, quatre:400)=
        a Relation (5 items)
        'DEUX'   : [ 20, 200]
        'QUATRE' :  400
        'UN'     : [ 10, 100]


===============================================================================
2021 August 07

[pipes]

Ok, it's a little bit tricky...
It's about this kind of expression: recursive.3.depthFirst.cycles.memorize
that can be used as-is as ONE option for the stages .inject, .fileTree, etc...
    .fileTree recursive.3.depthFirst.cycles.memorize | .console

When the trap NOVALUE is not activated, the value is RECURSIVE.3.DEPTHFIRST.CYCLES.MEMORIZE.
All good.

But when the trap NOVALUE is activated, this expression raises NOVALUE.
It's easy to avoid the error : put all between quotes. "recursive.3.depthFirst.cycles.memorize"
    .fileTree "recursive.3.depthFirst.cycles.memorize" | .console

If I want to use a variable depth=3 instead of the hardcoded value 3, it should be
    .fileTree "recursive."depth".depthFirst.cycles.memorize" | .console
But that doesn't work:
    Logical value must be exactly "0" or "1"; found "The console class"

Not easy to understand why that happens...
It's because only the operator " " is defined for PipeStage.
The evaluation is
    ((.fileTree "recursive."depth)".depthFirst.cycles.memorize")
which is the string 'a fileTree3.depthFirst.cycles.memorize, instead of an instance of .fileTree.

What is unfortunate is the message of the raised error: it complains first about the right part,
even if the left part is itself a wrong value...
    "not a boolean value" | .console    -- Logical value must be exactly "0" or "1"; found "The console class"
    "not a boolean value" | .true       -- Logical value must be exactly "0" or "1"; found "not a boolean value"
--> I changed the order of the checks in Executor.

It's easy to avoid the error: put the whole expression in brackets.
    .fileTree ("recursive."depth".depthFirst.cycles.memorize") | .console

But since I overloaded the operator " " for PipeStage, I decided to override also the operators "" and "||".
Both concatenate their right argument to the last option of the PipeStage instance on the left.
Will see on usage if that's a good idea or not.

New behavior with operator "":
    depth = 3
    (.inject {item+1} "iterateBefore" "rec."depth".memorize" "once")~options==
    an Array (shape [4], 4 items)
     1 : (a RexxBlock)
     2 : 'iterateBefore'
     3 : 'rec.3.memorize'       <-- all good
     4 : 'once'


New behavior with operator "||":
    recursiveOption = .true
    memorizeOption = .false
    (.inject {item+1} "iterateBefore" recursiveOption~?("recursive", "") || "." || depth || memorizeOption~?(".memorize", "") "once")~options==
    an Array (shape [4], 4 items)
     1 : (a RexxBlock)
     2 : 'iterateBefore'
     3 : 'recursive.3'          <-- all good
     4 : 'once'

Application:
    recursiveOption = .true
    memorizeOption = .false
    (0, 1)~pipe(.inject {item+1} "iterateBefore" recursiveOption~?("recursive", "") || "." || depth || memorizeOption~?(".memorize", "") "once" | .console "index" ":" "item" "dataflow")
    output:
        1 : 1 source:1,0
        1 : 2 source:1,0
        1 : 3 source:1,0
        1 : 4 source:1,0
        2 : 2 source:2,1
        2 : 3 source:2,1
        2 : 4 source:2,1
        2 : 5 source:2,1

    recursiveOption = .true
    memorizeOption = .true
    (0, 1)~pipe(.inject {item+1} "iterateBefore" recursiveOption~?("recursive", "") || "." || depth || memorizeOption~?(".memorize", "") "once" | .console "dataflow")
    output:
        1 : 1 source:1,0 | inject:1,1
        1 : 2 source:1,0 | inject:1,1 | inject:1,2
        1 : 3 source:1,0 | inject:1,1 | inject:1,2 | inject:1,3
        1 : 4 source:1,0 | inject:1,1 | inject:1,2 | inject:1,3 | inject:1,4
        2 : 2 source:2,1 | inject:2,2
        2 : 3 source:2,1 | inject:2,2 | inject:2,3
        2 : 4 source:2,1 | inject:2,2 | inject:2,3 | inject:2,4
        2 : 5 source:2,1 | inject:2,2 | inject:2,3 | inject:2,4 | inject:2,5


===============================================================================
2021 August 07

Changed the order of the argument checks for the boolean operators.
In case of wrong value on both sides, the error about the right side was raised first.
It's more clear to report an error about the left side when both sides are wrong,
otherwise you have the wrong impression that only the right side is wrong
(the evaluation is from left to right).
Before:
    "not a boolean value" | .console    -- Logical value must be exactly "0" or "1"; found "The console class"
Now:
    "not a boolean value" | .console    -- Logical value must be exactly "0" or "1"; found "not a boolean value"


===============================================================================
2021 August 04

Encoded strings:
- Reworked the implementation of the replacement characters.
- New script unicode/scripts/test_replacement_characters.rex
- Reworked the creation of the indexes: now sparse arrays. This is a good
  optimization for UTF-32, where the table of codepoint indexes is always empty.

I still see some differences between what Executor does in UTF-8, and the
display by MacOs and Java. These differences are for the surrogate codepoints.
- Executor:    3 replacement characters per surrogate
- MacOs, Java: 1 replacement character per surrogate
According the Unicode standard, it must be 3 when applying the "Substitution of
Maximal Subparts" (section 3.9 Unicode Encoding Forms, table 3-9).


Added
    RexxString *primitiveMakeString(); // needed to convert "b"~text to string when calling left("b"~text, 1)
    RexxString *makeString();          // needed to convert "b"~text to string when calling "abc"~pos("b"~text)
to the C++ class RexxText.
Not sure yet if these automatic conversions will interfere with the triggering of the OP:RIGHT operators.
These methods send the message request("string") to the RexxText instance.
If the RexxText instance is not compatible with the String class then an error is raised.


First tests with incubator/regex.cls
I pass a RexxText instance and see what happens...
In theory, a RexxText instance should be substituable to a String instance.
I started to add the missing methods on RexxTextStringInterface.
For the moment, these methods works only with RexxText instances being compatible
with the String class (Byte, ASCII UTF-8, ASCII WTF-8).
    p = .Pattern~compile("a.c"~text)
    p~matches("abc"~text)=              -- 1
    p~matches("aÃ´c"~text)=              -- error: Method 'match' not yet implemented for Unicode

    p = .Pattern~compile("Ã .c"~text)    -- error: Unicode comparison not yet implemented


===============================================================================
2021 August 03

Encoded strings:
- Implemented the recommandations of W3C for the replacement characters
  (now activated).


===============================================================================
2021 August 01

Encoded strings:
- Added UTF-16LE, WTF-16LE, UTF-32BE, UTF-32LE.
- The "UTF16", "WTF16"  "UTF32" encodings check if a BOM is present
  (BOM not removed for the moment).
- Implemented the recommandations of W3C for the replacement characters
  (not yet activated).


===============================================================================
2021 July 21

Encoded strings:
.rexxText~c2x   returns a string of encoded codepoints (each word is a codepoint in hexadecimal)
.rexxText~c2u   returns a string of decoded codepoints (each word is a codepoint in notation U+XXXX)
.rexxText~c2g   returns a string of encoded graphemes (each word is a grapheme in hexadecimal)

Encoded strings:
The method .CodePointSupplier~item can now return the byte sequence of the current codepoint.
This is managed with the parameter 'decode' (default .true: returns the decoded value, false: returns the byte sequence).

Encoded strings:
New utility to check the encoding of one or several files.
Usage: rexx unicode/scripts/check_encoding <encoding> <file 1>...<file n>

Encoded strings to rework:
- During analysis, should no longer use raise/signal to catch the encoding errors.
- The routine skipInvalidByteSequence should become a local procedure of nextCodepointIndex.
- nextCodepointIndex should return a negative index in case of error.
- The value replacementCharacter should be returned by ~decode instead of ~codepoint
- Remove the array of codepoints indexes. There is no need of direct access to codepoints.


===============================================================================
2021 July 16

Encoded strings: add WTF-8 and WTF-16
These encodings let support ill-formed UTF-16 coming from systems such as
Windows or JavaScript that use UTF-16 internally but donâ€™t enforce the
well-formedness invariant that surrogates must be paired.
See https://simonsapin.github.io/wtf-8/#16-bit-code-unit


Encoded strings: rework the management of errors.
Before, an error was raised only for the first invalid character in a string.
Now, all the errors are reported but not raised. They are stored on the RexxText
and available with RexxText~errors. For the byte sequences which are invalid,
the replacement character is returned when asking the codepoint. Internally,
there is no loss of bytes.


Encoded strings: rework the encoding conversion to Unicode.
createCharacterTranscodingTable
Helper to create a table of transcoded characters, from index 0 to size-1.
By default, a transcoded character is equal to itself.
The specific transcoding table lets define specific values for some characters.
Example: Transcoding from CP1252 to Unicode
    specificTranscoding =,
        , --       00      01      02      03      04      05      06      07      08      09      0A      0B      0C      0D      0E      0F
        "80:",  "20AC",  "-81", "201A", "0192", "201E", "2026", "2020", "2021", "02C6", "2030", "0160", "2039", "0152",  "-8D", "017D",  "-8F",,
        "90:",   "-90", "2018", "2019", "201C", "201D", "2022", "2013", "2014", "02DC", "2122", "0161", "203A", "0153",  "-9D", "017E", "0178"
    tableTranscodingToUnicode = createCharacterTranscodingTable(256, specificTranscoding)
"80:" ends with colon, this is an index.
""    means no transcoding for this character. It's always an error.
"-81" means unused character with fallback transcoding. It's an error only in strict mode.


ooRexxShell:
- In demo mode, don't display stack frames nor command line when error during
  interpretation. The error is expected, the display must remain compact.
- Change the default value of trapNoMethod to false, because the error message
  is better when this trap is not activated.


===============================================================================
2021 July 03

Impact on performance of the support of global override when no override.
Distinction between ooRexxShell (106 global routines) and script (1 global routine).
ooRexx5 is not impacted.
                                    --        Executor                  ooRexx5
                                    -- ooRexxShell  script       ooRexxShell script
    do 100000; call time; end       -- 5s           4.95s        1.26s       1.27s
    do 1000000; call userid; end    -- 2.47s        2.29s        2.42s       2.25s
    do 10000000; call sign 0; end   -- 0.87s        0.86s        0.77s       0.73s
Conclusion:
- Except for 'time', the difference between Executor and ooRexx5 is low.
- The difference between 106 global routines and 1 global routine is low.

Why are the following calls super fast when compared to 'time' ?
                                    -- ooRexxShell
    do 100000; call digits; end     -- 0.01
    do 100000; call trace; end      -- 0.02

It's because the implementation of 'time' is slow...
See below, it's exactly the same kind of call in both cases.
I confirmed by returning immediatly a dummy string from the BIF 'time'.
In this case, the calls of BIF 'time' are as fast as the calls of BIF 'digits'.

rexx -e "call time"     -- call_builtin
                        -- Ignore the overridings if the flag call_nointernal is set:
                        -- not set, instructionFlags == 6 (instructionFlags&call_nointernal)
                        -- The table of global routines is queried.
    #0	0x00000001003ddfe8 in builtin_function_TIME(RexxActivation*, RexxObject**, unsigned long, unsigned long, RexxExpressionStack*) at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/expression/BuiltinFunctions.cpp:1543
    #1	0x00000001003ea1e8 in RexxInstructionCall::execute(RexxActivation*, RexxExpressionStack*) at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/instructions/CallInstruction.cpp:314
    #2	0x0000000100392fa5 in RexxActivation::run(RexxObject*, RexxString*, RexxArray*, RexxObject**, unsigned long, unsigned long, RexxInstruction*, ProtectedObject&) at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/execution/RexxActivation.cpp:691
    #3	0x000000010039ea72 in RexxCode::call(RexxActivity*, RoutineClass*, RexxString*, RexxObject**, unsigned long, unsigned long, RexxString*, RexxString*, int, ProtectedObject&) at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/execution/RexxCode.cpp:116
    #4	0x000000010034e7e6 in RoutineClass::runProgram(RexxActivity*, RexxString*, RexxString*, RexxObject**, unsigned long, unsigned long, ProtectedObject&) at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/classes/RoutineClass.cpp:345
    #5	0x00000001003d9045 in RexxStartDispatcher::run() at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/concurrency/RexxStartDispatcher.cpp:148
    #6	0x00000001003a3c13 in RexxNativeActivation::run(ActivityDispatcher&) at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/execution/RexxNativeActivation.cpp:1610
    #7	0x00000001003d0cc3 in RexxActivity::run(ActivityDispatcher&) at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/concurrency/RexxActivity.cpp:3412
    #8	0x00000001003c86c8 in ActivityDispatcher::invoke(_RXSYSEXIT*, char const*) at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/concurrency/ActivityDispatcher.cpp:121
    #9	0x0000000100378602 in ::RexxStart(size_t, PCONSTRXSTRING, const char *, PRXSTRING, const char *, int, PRXSYSEXIT, short *, PRXSTRING) at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/api/InterpreterAPI.cpp:164
    #10	0x0000000100002932 in main at /local/rexx/oorexx/executor/sandbox/jlf/trunk/utilities/rexx/platform/unix/rexx.cpp:133

rexx -e "call digits"   -- call_builtin
                        -- instructionFlags == 6
                        -- The table of global routines is queried.
    #0	0x00000001003dc64e in builtin_function_DIGITS(RexxActivation*, RexxObject**, unsigned long, unsigned long, RexxExpressionStack*) at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/expression/BuiltinFunctions.cpp:1061
    #1	0x00000001003ea1e8 in RexxInstructionCall::execute(RexxActivation*, RexxExpressionStack*) at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/instructions/CallInstruction.cpp:314
    #2	0x0000000100392fa5 in RexxActivation::run(RexxObject*, RexxString*, RexxArray*, RexxObject**, unsigned long, unsigned long, RexxInstruction*, ProtectedObject&) at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/execution/RexxActivation.cpp:691
    #3	0x000000010039ea72 in RexxCode::call(RexxActivity*, RoutineClass*, RexxString*, RexxObject**, unsigned long, unsigned long, RexxString*, RexxString*, int, ProtectedObject&) at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/execution/RexxCode.cpp:116
    #4	0x000000010034e7e6 in RoutineClass::runProgram(RexxActivity*, RexxString*, RexxString*, RexxObject**, unsigned long, unsigned long, ProtectedObject&) at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/classes/RoutineClass.cpp:345
    #5	0x00000001003d9045 in RexxStartDispatcher::run() at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/concurrency/RexxStartDispatcher.cpp:148
    #6	0x00000001003a3c13 in RexxNativeActivation::run(ActivityDispatcher&) at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/execution/RexxNativeActivation.cpp:1610
    #7	0x00000001003d0cc3 in RexxActivity::run(ActivityDispatcher&) at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/concurrency/RexxActivity.cpp:3412
    #8	0x00000001003c86c8 in ActivityDispatcher::invoke(_RXSYSEXIT*, char const*) at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/concurrency/ActivityDispatcher.cpp:121
    #9	0x0000000100378602 in ::RexxStart(size_t, PCONSTRXSTRING, const char *, PRXSTRING, const char *, int, PRXSYSEXIT, short *, PRXSTRING) at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/api/InterpreterAPI.cpp:164
    #10	0x0000000100002932 in main at /local/rexx/oorexx/executor/sandbox/jlf/trunk/utilities/rexx/platform/unix/rexx.cpp:133


Strange behavior, not happening with ooRexx5:
rexx -e "call 'time'"
is trying to execute "/usr/bin/time" as a rexx script.
Of couse, it doesn't work.
    #10	0x0000000100350412 in RoutineClass::fromFile(RexxString*) at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/classes/RoutineClass.cpp:927
    #11	0x0000000100399407 in RexxActivation::callExternalRexx(RexxString*, RexxObject**, unsigned long, unsigned long, RexxString*, ProtectedObject&) at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/execution/RexxActivation.cpp:2972
    #12	0x00000001004215a6 in SystemInterpreter::invokeExternalFunction(RexxActivation*, RexxActivity*, RexxString*, RexxObject**, unsigned long, unsigned long, RexxString*, ProtectedObject&) at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/platform/unix/ExternalFunctions.cpp:365
    #13	0x00000001003992be in RexxActivation::externalCall(RexxString*, RexxObject**, unsigned long, unsigned long, RexxString*, ProtectedObject&) at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/execution/RexxActivation.cpp:2922
    #14	0x00000001003ea262 in RexxInstructionCall::execute(RexxActivation*, RexxExpressionStack*) at /local/rexx/oorexx/executor/sandbox/jlf/trunk/interpreter/instructions/CallInstruction.cpp:321


===============================================================================
2021 July 02

A global routine with the same name as a builtin function overrides this function.
This is done by searching in TheFunctionDirectory from
    RexxExpressionFunction::evaluate
    RexxInstructionCall::execute
    RexxInstructionCall::trap
when the target is a builtin function.
If the call or function invocation uses a string literal, then the search in
TheFunctionDirectory is bypassed.

This new functionality is used to override the builtin function XRANGE, and make
if compatible with ooRexx5.
Remember: extensions.cls alone does not declare XRANGE as a global routine.
You must do it explicitely, or use ooRexxShell.

Example of builtin function override:
    call internal   -- override with internal routine
    call external   -- no override because the routine date is not global
    call global     -- override with global routine

    ::routine internal
        say date()                                    -- Internal date is 2 Jul 2021
        say "DATE"()                                  -- 2 Jul 2021
        return
        date: return "Internal date is " || "DATE"()

    ::routine external
        say date()                                    -- 2 Jul 2021
        say "DATE"()                                  -- 2 Jul 2021

    ::routine global
        .globalRoutines["DATE"] = .routines["DATE"]
        say date()                                    -- Global date is 2 Jul 2021
        say "DATE"()                                  -- 2 Jul 2021

    ::routine date
        return "Global date is " || "DATE"()

Note: despite what's written in rexxref.pdf, BEEP is not a builtin function.
It's not possible to override it.


===============================================================================
2021 June 30

Compatibility with ooRexx5:
    .String (class methods added by extension)
        alnum
        alpha
        blank
        cntrl
        digit
        graph
        lower
        print
        punct
        space
        upper
        xdigit

    Routine xrangeExt
        For the moment, I can't override the builtin function xrange by a routine.
        Hence the name "xrangeExt"...

.String helper method
    posixClassCharacters
Ex:
    "alnum"~posixClassCharacters=                   -- returns .string~alnum
    "not a character class"~posixClassCharacters=   -- returns ""


===============================================================================
2021 june 28

New entry GLOBALROUTINES in .environment, which gives access to TheFunctionDirectory.
This is a directory of global routines that are made available everywhere, like
the builtin functions. No need of ::requires directive to use them.
TheFunctionDirectory is no longer supported in ooRexx5 (deprecated).


ooRexxShell can now be used to execute scripts that depends on extensions,
without having to modify the script to add ::requires directives.
This is done by:
- declaring in .environment all the public classes of ooRexxShell, and all the
public classes of the packages imported by ooRexxShell.
- declaring in .globalRoutines all the public routines of ooRexxShell, and all
the public routines of the packages imported by ooRexxShell.
Usage:
    oorexxshell call myUnmodifiedScript


Collisions of routines detected by ooRexxShell with Executor:
    Collision detected for routine ESCAPE3
        Package stack 1
            /local/rexx/oorexx/executor/sandbox/jlf/samples/rgf_util2/rgf_util2.rex
            /local/rexx/oorexx/executor/incubator/ooRexxShell/oorexxshell.rex
        Package stack 2
            /local/rexx/oorexx/executor/sandbox/jlf/samples/extension/string.cls
            /local/rexx/oorexx/executor/sandbox/jlf/samples/extension/extensions.cls
            /local/rexx/oorexx/executor/incubator/ooRexxShell/oorexxshell.rex
    Collision detected for routine SHAPE
        Package stack 1
            /local/rexx/oorexx/executor/sandbox/jlf/samples/rgf_util2/rgf_util2.rex
            /local/rexx/oorexx/executor/incubator/ooRexxShell/oorexxshell.rex
        Package stack 2
            /local/rexx/oorexx/executor/sandbox/jlf/samples/extension/array.cls
            /local/rexx/oorexx/executor/sandbox/jlf/samples/extension/extensions.cls
            /local/rexx/oorexx/executor/incubator/ooRexxShell/oorexxshell.rex
Fixed by declaring these routines private in rgf_util2.rex.
No collision with ooRexx5 because the extensions can't be loaded.


Collisions of classes detected by ooRexxShell with ooRexx5:
    Collision detected for class BUFFER
        Package stack 1
            /local/rexx/oorexx/official/sandbox/jlf-executor/samples/pipeline/pipe.rex
            /local/rexx/oorexx/official/incubator/ooRexxShell-executor/oorexxshell.rex
Only one package stack because the collision is with the internal class "Buffer",
described in rexxpg.pdf. Not sure why this class is put in .environment, a Buffer
instance can only be created using the native code API...
Could be fixed by renaming the "Buffer" class in pipe.rex.
This collision has been fixed in Executor by not declaring the native Buffer class
in .environment.
[jlf 2025 nov 5]
Bad idea!
The Buffer class is used by ooDialog.
I have the error "positionnal argument 1 must be an instance of the Buffer class"
when running oodtree.rex. It's because the Buffer class is not found.


Another collision with the "System" class has been fixed the same way in Executor
(this class was no longer declared by official ooRexx5 in rev 10319 on 2014 July 21).


===============================================================================
2021 june 22

Remember: not documented.
    options "DUMPMEMORY"

    RexxInstructionOptions::execute
    #ifdef _DEBUG
            else if (word->strCaselessCompare("DUMPMEMORY"))
            {
                memoryObject.dumpEnable = true;
                memoryObject.dump();
            }
    #endif

    rexx -e 'options "DUMPMEMORY"'
    Console output:
        Dumping object memory to orexdump.dmp
        Creating dump key file in orexdump.key
        Dumping Old Space Segments Segment 1 from 0x104d2d020 for 3145696
        Dumping Normal Allocation Segments Segment 1 from 0x10502d050 for 16781232
        Dumping Large Allocation Segments Segment 1 from 0x10608b050 for 2101168
    2 files are created:
        orexdump.dmp    binary file (22 MB under MacOs)
        orexdump.key    text file


===============================================================================
2021 june 13

Compatibility with ooRexx5:
    .MutableBuffer~"[]"
    .MutableBuffer~append
    .Object~isNil
    .RexxInfo (partial support)
    .String~?

Helper methods
    .String~concatenate
    .String~singularPlural


===============================================================================
2021 june 11


After retrofit of the class Validate, I see some error messages are missing.
    nonNegativeNumber   88.925
    positiveNumber      88.926
    requestClassType    93.978
    logical             88.927
Align rexxmsg.xml with official ooRexx.

    Message numbers used more than once:
    <MessageNumber>735</MessageNumber>  2000
    <MessageNumber>736</MessageNumber>  2001
    <MessageNumber>737</MessageNumber>  2002
    <MessageNumber>739</MessageNumber>  2003
    <MessageNumber>740</MessageNumber>  2004
    <MessageNumber>746</MessageNumber>  2005
    <MessageNumber>747</MessageNumber>  2006
    <MessageNumber>748</MessageNumber>  2007

    To review
    Error_Incorrect_method_array_noclass
    should talk about scope

    Error_Translation_use_local_interpret	(official)
    vs
    Error_Translation_use_interpret		(executor)

    Error_Translation_use_arg_ellipsis	(official)
    vs
    Error_Translation_use_strict_ellipsis	(executr)


===============================================================================
2021 june 01

Demos:
executor-demo-array.txt
executor-demo-classic_rexx.txt
executor-demo-extensions.txt
executor-demo-text.txt
ooRexxShell-demo-helpers.txt
ooRexxShell-demo-interpreters.txt
ooRexxShell-demo-queries.txt

Each demo has 3 files:
- demo.txt          The source file of the demo
- demo-output.txt   The output of the demo
- demo.cast         The record of the demo in asciicast format (JSON file)


===============================================================================
2021 may 31

Encodeded strings.
The ooRexx programmer has the choice:
- working with String at byte level
- working with RexxText at grapheme level.
- the same instance of String is used in both cases.

    aString
     â–²  text --------> aRexxText
     â”‚                     indexer (anEncoding)
     â”‚                          codepoints (sequential access)
     â”‚                          graphemes  (direct access)
     +-----------------------<- string

First binding of utf8proc, for the detection of grapheme cluster break.
"( Í¡Â° ÍœÊ–ï»¿ Í¡Â°)"~text~description=                    -- 'UTF-8 not-ASCII ( 9 graphemes, 12 codepoints, 20 bytes )'
"( Í¡Â° ÍœÊ–ï»¿ Í¡Â°)"~text~graphemes~each{item~c2x}=       -- [ 28,'20CDA1','C2B0','20CD9C','CA96','EFBBBF','20CDA1','C2B0', 29]

Classes in relation with Unicode and encoded strings:
?c *encoding* *encoded* *indexer* *codepoint* *grapheme* *RexxText* *Unicode*
P.         'Byte_Encoding'           : (string.cls)
P.         'CP1252_Encoding'         : (string.cls)
P.         'CodePointSupplier'       : (string.cls)
PM         'EncodedString'           : (string.cls)
P.         'Encoding'                : (string.cls)
P.         'GraphemeSupplier'        : (string.cls)
P.         'RexxText'                : (REXX)
PM         'RexxTextContents'        : (string.cls)
PM         'RexxTextInitializer'     : (string.cls)
PM         'RexxTextOperators'       : (string.cls)
PM         'RexxTextPrettyPrinter'   : (string.cls)
PM         'RexxTextStringInterface' : (string.cls)
P.         'StringIndexer'           : (string.cls)
P.         'UTF16BE_Encoding'        : (string.cls)
P.         'UTF8_Encoding'           : (string.cls)
P.         'Unicode'                 : (REXX)
P.         'UnicodeCharacter'        : (string.cls)


Start working on an optimization of the alternative operators, to avoid raising
the condition "nostring" too early (isPolymorphicString).
    deux = 2~text; do 10000; n = deux + 1; end          -- 0.3s
    deux = 2~text; do 10000; n = 1 + deux; end          -- 2.0s (alternative operator)
My goal : same duration 0.3s for both.


Compatibility with ooRexx5:
.String (methods added by extension)
    append
    []
    startsWith
    caselessStartsWith
    endsWith
    caselessEndsWith

String (new methods)
    concatenate         -- ", "~concatenate(10, 20, 30)=                        -- '10, 20, 30'
    singularPlural      -- 0~2~each{item~singularPlural("tooth", "teeth")}=     -- ['0 tooth','1 tooth','2 teeth']


===============================================================================
2021 may 31

Pretty Print
------------

Experiment a way to pass options for pretty-printing.
Use a stem ppOptions and named arguments ppOptions.xxx
That way, it's possible for the caller to pass one or several options explicitely,
which are accumulated automatically in the stem.
The callee can declare explicitely the options he's expecting, with default values.



Array programming
-----------------

ppString & ppRepresentation accepts a new named argument: ppOptions.expandCollection.
When .true, all the items of type Collection are expanded.
When .false, only the items of type array are expanded (this is the default).
.local~ppstring=                                        -- 'The Local Directory'
.local~ppstring(ppOptions.expandCollection:.true)=      -- 'Directory[''[000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFF]'',''.!_?'', 0, 0123456789,''0x1037886e0'',''ABCDEFGHIJKLMNOPQRSTUVWXYZ'',(SESSION),(STDERR),(STDIN),(STDOUT),(The DEBUG INPUT monitor),(The ERROR monitor),(The GlobalVariable class),(The INPUT monitor),(The OUTPUT monitor),(The TRACE OUTPUT monitor),(a server),''abcdefghijklmnopqrstuvwxyz'',''abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'',''abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'',(an Array no shape, 0 items)]'


leftElementWise, rightElementWise:
Pass a new named parameter 'depth(1)' to the 'transform' doer.
    a = .array~new
    (1, a, (2, a, (3, a, (4, a, (5, a)))))~reduce(initial:a){accu~~append(item)}
    a=                                                      -- a1=[ 1,*a1,[ 2,*a1,[ 3,*a1,[ 4,*a1,[ 5,*a1]]]]]
    a~leftElementWise=                                      -- a1=[ 1,*a1,[ 2,*a1,[ 3,*a1,[ 4,*a1,[ 5,*a1]]]]]
    -- Replace the self-references *a1 by the current depth.
    -- The current depth is relative to the named argument d(epth) whose default value is the positive infinity:
    a~leftElementWise(depth:0, transform:{depth})=          -- [ 1,-1,[ 2,-2,[ 3,-3,[ 4,-4,[ 5,-5]]]]]
    a~leftElementWise(depth:1, transform:{depth})=          -- [ 1, 0,[ 2,-1,[ 3,-2,[ 4,-3,[ 5,-4]]]]]
    a~leftElementWise(depth:2, transform:{depth})=          -- [ 1, 1,[ 2, 0,[ 3,-1,[ 4,-2,[ 5,-3]]]]]


===============================================================================
2021 may 23

Alignment with official ooRexx:
    Hostemu
    Json
    orxncurses
    rxunixsys
    rxftp
    rxmath
    rxregexp

CMakeList.txt partially aligned with official ooRexx.


===============================================================================
2021 may 19

The problem of propagation of extension methods to some subclasses is fixed.
Now an extension made on .Object is also available on a class.

Was a bug in RexxClass::defineClassMethod, where the iteration over the subclasses
was forgetting one subclass.
old: for (size_t i = 1; i <  subclass_list_size; i++)
new: for (size_t i = 1; i <= subclass_list_size; i++)

Same problem in RexxClass::removeClassMethod


===============================================================================
2021 apr 14

Continue to work on concurrency trace:
- No longer use syslog for tracing the internals, because I waste my time searching
  how to display this tracing in the terminal.
  Also not visible with the console app.
  Now the display is sent to stderr. Simple, easy...
- Display activation, variable dictionary, reserve count and lock when tracing
  the internal semaphores.
- Still investigating the global trace with RXTRACE.


===============================================================================
2021 mar 31

Reworked the script tracer.rex to support a trace without concurrency trace.
Can be used with official ooRexx5 to generate a CSV file.
When no concurrency trace, it's not possible to get the name of the executable
for each line of the CSV file.

RXTRACE is no longer limited to "on".
It's now possible to use the same options as with the instruction trace.
An optional depth can also be specified: colon followed by a positive integer.
Ex:
RXTRACE=i rexx aScriptToTrace
RXTRACE=i:3 RXTRACE_CONCURRENCY=on rexx aScriptToTrace 2>&1 | rexx tracer -csv > out.csv

When RXTRACE is set, the trace options at package (source) level are overwritten by RXTRACE.
By default, the trace is activated everywhere.
The optional depth indicates how many RexxActivation can be traced in the call stack:
    - 0: top-level only
    - 1: top-level and executables called by top-level.
    - 2: top-level and executables called by top-level and executables called by executables called by top-level.
    - etc.
The methods in the rexx image are not traced, to avoid an infinite recursion
(which happens when tracing the trace monitor).

Changed how the package name is inferred when creating a routine with .Routine~new
Only one name is passed (the routine name), and this name was also used as programName
for the internally created RexxSource. That gave traces like that:
    >I> Routine <routineName> in package <routineName>           missing package name
    >I> Routine <packageName> in package <packageName>           I saw that when tracing initialization of packages
    >I> Routine  in package                                      I saw that for RexxBlock which is an anonymous executable
Now, for the package name, I use the programName of the parentSource (parameter context), if available.

Changed the name of the routine created to execute the prolog of a required file.
Was the full path of the file.
Now it's <prolog>.
The full name of the file is still available in the trace (package name).

Retrofit feature-requests:#791 from ooRexx5.
::OPTIONS TRACE LABELS will now also trace (or pause for) method and routine invocations.


===============================================================================
2021 mar 24

A private method is no longer declared protected by default.
That was fixed in offical ooRexx several years ago:
- On 20/07/2014, rev 10318, RexxMemory::definePrivateKernelMethod was modified to no longer call setProtected.
- On 03/07/2014, rev 10273, RexxMethod::setPrivate was modified to no longer apply the flag PROTECTED_FLAG.


===============================================================================
2021 mar 24

Optimization of String~isASCII:
The old implementation checks from start to end.
The new implementation checks from start ascending, from middle descending, from middle ascending, from end descending.
That will divide by 4 the number of iterations, while increasing the chance to find a not-ascii character faster.
Strangely, the new implementation is also faster when all the characters are ASCII.

Benchmark using a version where the flag isASCII is not stored:
big10m = "0123456789"~copies(1e6)
s = big10m                              -- 10 millions of ASCII characters, must check all of them
do 1000; s~isASCIIold; end              -- 9.3s
do 1000; s~isASCII; end                 -- 6.2s
s = "Ã©" || big10m                       -- 1 non-ASCII character followed by 10 millions of ASCII characters
do 1000; s~isASCIIold; end              -- 0.001s
do 1000; s~isASCII; end                 -- 0.001s
s = big10m || "Ã©"                       -- 10 millions of ASCII characters followed by 1 non-ASCII character
do 1000; s~isASCIIold; end              -- 9.3s
do 1000; s~isASCII; end                 -- 0.001s
big5m = "01234"~copies(1e6)
s = big5m || "Ã©" || big5m               -- 1 non-ASCII character in the middle of 10 millions of ASCII characters
do 1000; s~isASCIIold; end              -- 4.7s
do 1000; s~isASCII; end                 -- 0.001s


===============================================================================
2021 mar 15

Encoded strings (prototype).
Added support for UTF-8.
Added suppliers for codepoints and graphemes.

s = "Ã§a va ?"
s~length=                           -- 8
s~eachC{item~c2x" "}=               -- ['C3 ','A7 ', 61 , 20 , 76 , 61 , 20 ,'3F ']
s~text~encoding=                    -- (The Byte_Encoding class)
s~text~length=                      -- 8
s~text("utf8")~length==             -- 7
s~text~codepoints~each=             -- [ 231, 97, 32, 118, 97, 32, 63]
s~text~graphemes~each("c2x")=       -- ['C3A7', 61, 20, 76, 61, 20,'3F']


===============================================================================
2021 mar 13

ooRexxShell
-----------

Add support for PowerShell core (pwsh).
    ooRexx[bash]> pwsh
    pwsh[ooRexx]>

    Since pwsh is not (yet) supported natively as an address environment by ooRexx,
    the execution is delegated to the system interpreter:
    - cmd /c pwsh -command <raw command>
    - sh -c pwsh -command '<raw command>'

    As for the other shells, pwsh is a one-liner interpreter in ooRexxShell:
    pwsh[ooRexx]> $i=1; echo $i             # display 1
    If you split the previous command in 2 lines, it doesn't work:
    pwsh[ooRexx]> $i=1
    pwsh[ooRexx]> echo $i                   # display nothing because the variable i has no value

systemAddress has been aligned with ooRexx 5: default is "sh" for Linux & MacOs.
But note the default address() for executor and ooRexx 4 is still bash.

No longer use systemAddress for readline, because it returns "sh" which is not supported.
Now use readlineAddress which returns "bash", even if systemAddress is "sh".

Linux & MacOs: the list of interpreters includes the shells listed in /etc/shells.

If the input line starts with a space then no command recognition.

New command "goto":
    goto label
    ...
    label:
This commands allows to skip lines in a demo script.
The label is case insensitive.
The label can't be a drive letter (A:, B:, ..., Z:).

The count of coactivities is displayed only when <> 0.

Readline for bash: keep the spaces as entered by the user.

Trace of the security manager: add an option ".verbose".
By default, the trace is displayed only when the security manager is enabled.
In verbose mode, the trace is displayed each time the security manager is called.

"cmd" "command" and "system" are generic names to select the system interpreter.

The readline mode is deactivated for Windows because I never succeded to have a good history management.
Now we have a robust history management, but we lose the doskey macros and the filename expansion with 'tab'.

The history filename is .oorexxshell_history (was .history_oorexxshell).
Bypass a known problem with old versions of bash: the history file must not be empty.
The history is now updated incrementally (history -a, instead of history -w).

New command "demo":
demo on|off: activate|deactivate the demonstration mode.
When the demo mode is activated, the commands are displayed slowly (only when the readline mode is deactivated).
Some commands are not displayed: demo, sleep, /*, */.

New command "infos":
infos on|off: activate|deactivate the display of the duration and coactivity count.

New command "sleep":
sleep [delay]
The default delay is .ooRexxShell~defaultSleepDelay.

New command "--" to enter a monoline comment in a demo script.

New commands "/*" and "*/" to enter multilines comments in a demo script.
If the command "*/" is immediatly followed by a command sleep then the duration is
proportional to the number of lines in the comment.

For better readability, the command names are separated from their argument:
coloroff        --> color off
coloron         --> color on
debugoff        --> debug off
debugon         --> debug on
readlineoff     --> readline off
readlineon      --> readline on
securityoff     --> security off
securityon      --> security on
traceoff        --> trace off
traceon         --> trace on
trapoff         --> trap off
trapon          --> trap on

The following commands becomes queries, it's possible to filter their output, as for any query:
sf --> ?sf
tb --> ?tb
bt --> ?bt

New query "?settings":
Display the main settings of ooRexxShell.


===============================================================================
2021 mar 16

Array programming
-----------------

Fix the pretty print of self referencing array.
Before this fix, the reference id was always "a1".
    a = .array~new
    a~append("a")
    a~append(a)
    b = .array~new
    b~append("b")
    b~append(b)
    c = .array~new
    c~append(a)
    c~append(b)
    c~append(c)
    c=                  -- a1=[a2=['a',*a2],a3=['b',*a3],*a1]

leftElementWise & rightElementWise support an action that doesn't return a result.
The item for which no result is returned is discarded (sparse array).
    1~10~leftElementWise{if item // 2 == 0 then item}=      -- [.., 2,.., 4,.., 6,.., 8,.., 10]
    1~10~leftElementWise{if item // 2 == 1 then item}=      -- [ 1,.., 3,.., 5,.., 7,.., 9,..]

Add named argument 'transform(1)' to leftElementWise & rightElementWise.
This argument lets execute a doer on items that create a self reference.
If this doer doesn't return a result then the item is discarded (sparse array)
    a=v()
    a~append(a)
    a~append(1)
    a=                                  -- a1=[*a1, 1]
    a~leftElementWise(transform:{})=            -- [.., 1]


===============================================================================
2021 mar 12

Array programming
-----------------

Add named argument 'expansion' to leftElementWise & rightElementWise
This argument controls the expansion of self referencing arrays.
    a=v()
    a~append(a)
    a~append(1)
    a=                                      -- a1=[*a1, 1]
    a~leftElementWise(expansion:0)=         -- a1=[*a1, 1]
    a~leftElementWise(expansion:1)=         -- [a1=[*a1, 1], 1]
    a~leftElementWise(expansion:2)=         -- [[a1=[*a1, 1], 1], 1]
    a~leftElementWise(expansion:6)=         -- [[[[[[a1=[*a1, 1], 1], 1], 1], 1], 1], 1]
    a~leftElementWise("-", expansion:6)=    -- [[[[[[a1=[*a1,-1],-1],-1],-1],-1],-1],-1]
The named argument 'depth' controls the depth of application of the doer.
    a~leftElementWise("-", depth:4, expansion:6)=   -- [[[[[[a1=[*a1, 1], 1], 1],-1],-1],-1],-1]


Functionnal
-----------

~reduce supports 2 named arguments: action, initial
1~10~reduce(action:"+", initial:100)=   -- 155


===============================================================================
2021 mar 08

Numeric settings
----------------

The problem I want to fix:
numeric digits has no effect on the called routines/methods.
Setting the precision at package level with ::option digits is not helping when you want to test several settings interactively.
With one-liners, you can hardcode the precision where you do a calculation, but the code becomes polluted by these declarations.
If you don't want to hardcode the precision, the code is still more polluted with the use of arguments. See 2020 nov 16.

numeric digits 30
1~10000~reduce("*")=                               -- 2.84625960E+35659, the precision is the default one
1~10000~reduce{numeric digits 30; accu * item}=    -- 2.84625968091705451890641321250E+35659

How to fix:
Propagate the numeric settings of the current activation to its child activations, recursively.
Of course, that must be under control of the programmer.
By default, the behavior is to not propagate.

Solution:
- add the option PROPAGATE to NUMERIC DIGITS
- add the method .RexxContext~digitsPropagate
The option is available only with NUMERIC DIGITS but it controls the propagation of all the numeric settings.

numeric digits              -- default precision, local
numeric digits propagate    -- default precision, digits form and fuzz are propagated
numeric digits 30           -- precision is 30, local
numeric digits propagate 30 -- precision is 30, digits form and fuzz are propagated
1~10000~reduce("*")=        -- 2.84625968091705451890641321250E+35659, the precision has been propagated


Remember
--------

[2021 mar 10]
The problem described below has been fixed.
I keep the new option PROPAGATE, it's more concise than using setNumericSettingsPropagate.
Other advantage: the propagation is stopped as soon as NUMERIC DIGITS is used without PROPAGATE.
So any legacy code using NUMERIC DIGITS will stop the propagation.

Initially, I wanted to control this behavior using new methods on RexxContext.
A RexxContext is linked to a RexxActivation which holds the numeric settings of the current code execution.
So it sounded natural to add these methods which forward to the RexxActivation:
    .RexxContext~numericSettingsPropagate
    .RexxContext~setNumericSettingsPropagate(.true | .false)

Worked good when using a script:
    numeric digits 30
    say 1~10000~reduce("*")                        -- 2.84625960E+35659
    .context~setNumericSettingsPropagate(.true)
    say 1~10000~reduce("*")                        -- 2.84625968091705451890641321250E+35659
    ::requires "extension/extensions.cls"

But didn't work from ooRexxShell because of that:
- interpret ".context" returns the context of the interpret's PARENT activation,
  so it's the PARENT activation which is updated and queried, not the interpret's activation.
  (search for "CHAR_CONTEXT" in RexxActivation.cpp)
- when the interpretation of a string is ended, the settings of the interpret's activation are copied to the PARENT activation,
  so the update made to the PARENT activation (propagate .true) is overwritten by the setting of the interpret's activation (propagate .false).
  (search for "this->parent->getSettings(this->settings)" in RexxActivation.cpp)

                    call main
                    return
    [activation1]   main:
    [activation2]   interpret ".context~setNumericSettingsPropagate(.true); -- activation1 updated, not activation2
                               say .context~numericSettingsPropagate;       -- display .true because gets the setting of activation1
                               numeric digits 30;                           -- activation2 updated
                               say 1~10000~reduce("*")"                     -- display 2.84625960E+35659 because the propagation is not activated for activation2
                    [activation1's settings <-- activation2's settings]
                        activation1 digits <-- 30
                        activation1 propagate <-- .false


===============================================================================
2021 mar 08

Coactivity supplier:
The cached value of a coactivity supplier is refreshed (aligned with the coactivity) when using the method
    ~available

Typical usage of a supplier:
    do while supplier~available
        item = supplier~item
        index = supplier~index
        ...
        supplier~next
    end

g = 1~5~generate
s = g~supplier
s~item=                 -- 1
g~currentIndexItem=     -- [ 1, 1]
g~()=                   -- 2
s~item=                 -- 1 (cached value not refreshed)
s~next
s~item=                 -- 3
g~currentIndexItem=     -- [ 3, 3]
g~()=                   -- 4
s~item=                 -- 3 (cached value not refreshed)
s~available=            -- .true (cached value refreshed)
s~item=                 -- 4
g~()=                   -- 5
s~item=                 -- 4 (cached value not refreshed)
s~available=            -- .true
s~item=                 -- 5
g~()=                   -- no result
s~item=                 -- 5 (cached value not refreshed)
s~available=            -- .false (refreshed)
s~item=                 -- no result


===============================================================================
2020 dec 06

.doer~compose:
Rework how the parameters and intermediate results are managed.
For doers of type block, the convention is to pass the 1st positional argument
also as the named argument "item".
If no result is returned by the current doer, then return the previous result.
This is equivalent to the Kestrel combinator already supported by ~pipe.
Examples:
    .doer~compose({item/3}, {say item}, {item-5}, {say item})~()=
        Not enough positional arguments for method; 1 expected
    .doer~compose({item/3}, {say item}, {item-5}, {say item})~(1)=
        1
        -4
        -1.33333333
    .doer~compose({item/3}, {say item}, {item-5}, {say item})~(item:1)=
        1
        -4
        -1.33333333
    .doer~compose({item/3}, {say item}, {item-5}, {say item})~(1, item:2)=
        When the positional parameter ITEM is provided then it must be equal to the first positional argument
    .doer~compose("/"~partial(,3), {say item}, "-"~partial(,5), {say item})~(1, item:1)=
        1
        -4
        -1.33333333


===============================================================================
2020 dec 05

New method .doer~compose.
Accepts an unlimited number of doers:
.doer~compose(doerN, ..., doer2, doer1)~(x) <==> doerN~(...doer2~(doer1~(x))...)
The first doer can take any number of positional & named arguments.
The other doers take only one argument : the result of the previous doer.
Examples:
    .doer~compose("/"~partial(,5), "-", { 2 * arg(1) })~(50)=       -- -(2 * 50)/5 = -20
    binary2decimal = .doer~compose("x2d", "b2x")
    binary2decimal~(11111111)=                                      -- 255


===============================================================================
2020 dec 05

Auto named argument
Change of behavior for the named arguments not explicitely declared by the callee:
Assign the value only if the variable doesn't have a value already.
When a named argument is explicitely declared by the callee, no change of behaviour,
the value of the named argument is always stored in the variable.
Examples (remember: a block always starts with 'auto named arg')
    drop x; {expose x; say x; use auto named arg x; say x}~()           -- X X
    drop x; {expose x; say x; use auto named arg x; say x}~(x:100)      -- 100 100
    x=1;    {expose x; say x; use auto named arg x; say x}~()           -- 1 X
    x=1;    {expose x; say x; use auto named arg x; say x}~(x:100)      -- 1 100
Reason of this change :
While playing with the Y combinator, I tested this (passing the named parameter 'f').
The value of the variable 'f' was replaced by the value 'DUMMY' and of course an error was raised.
    fac = {use arg f; return {expose f; use arg n; if n==0 then return 1; else return n * f~(n-1) } }~Y
    fac(10, f:dummy)
With this change of behavior, no more error.


===============================================================================
2020 nov 25

[pipes]

New pipe stage itemToIndexItem
New pipe stage directoryCollector
Example:
envvars = .directory~new ; "printenv"~pipe(.system | .inject {parse var item var "=" value; (var, value)} | .itemToIndexItem | .directoryCollector[envvars]); envvars=
    'CC'                 : 'clang'
    'CFLAGS'             : '-O3 -arch x86_64 '
    'CMAKE_BUILD_TYPE'   : 'Release'
    'CXX'                : 'clang++'
    'CXXFLAGS'           : '-stdlib=libc++ -mmacosx-version-min=10.9 -O3 -arch x86_64 '
    'DISPLAY'            : '/private/tmp/com.apple.launchd.RpwvUwMhyj/org.macosforge.xquartz:0'
    'FIGNORE'            : ':.DS_Store:.DS_Store:.DS_Store:.DS_Store'
    'GCI_HOME'           : '/Local/rexx/GCI/gci-source.1.1'
    'GIT_ROOT'           : '/usr/local/git'

Method coactivePipe renamed copipe.
Method coactivePipeProfile renamed copipeProfile.
Example:
"printenv"~copipe(.system | .yield {parse var item var "=" value; (var, value)})~reduce(.directory~new){accu~~put(item[2], item[1])}=


===============================================================================
2020 nov 16

Fix this error:
ooRexx[bash]> 1e99~9.999999e99(by:0.5e99, for:2)==
    Exponent "9.999999E99" is too large for 2 spaces
Now returning
    an Array (shape [2], 2 items)
     1 :  1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
     2 :  1500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000


About the calculation of the factorial or fibonacci number using the Y combinator:
Rounding error when calculating fact(26) and above with default precision (9 digits).
Rounding error when calculating fib(90) and above with default precision (9 digits).
The precision can be hardcoded in the block, but how to proceed if we want to
set the precision at the moment of the call ?
Unfortunately, ooRexx doesn't allow to propagate automatically the current precision
to the called procedure/routine/method. I'm thinking to modify how the settings
are collected when an activation for a block is initialized. Currently the activation
inherits the toplevel source options settings. For a closure, I could intherit the
settings of the current activation, as written in Q2 of 2013 sep 15.
In the meantime, I can pass the precision as a parameter. I had to modify ~Y and
~YM to support several positional arguments, and to support named arguments.

    solution 1: pass the precision as a positional argument of 'fact'. This argument must be explicitely repeated during the recursion.
    fact = { use arg f ; { expose f ; use arg n, p=(digits()) ; numeric digits p ; if n == 0 then 1 ; else n * f~(n-1, p) } }~Y
    fact(100)           -- 9.33262137E+157
    fact~(100, 157)     -- 9.332621544394415268169923885626670049071596826438162146859296389521759999322991560894146397615651828625369792082722375825118521091686400000000000000000000000E+157

    solution 2: pass the precision as a named argument. This argument must be explicitely repeated during the recursion.
    fact = { use arg f ; { expose f ; use arg n ; use named arg p=(digits()) ; numeric digits p ; if n == 0 then 1 ; else n * f~(n-1, p:p) } }~Y
    fact(100)           -- 9.33262137E+157
    fact~(100, p:157)   -- 9.332621544394415268169923885626670049071596826438162146859296389521759999322991560894146397615651828625369792082722375825118521091686400000000000000000000000E+157

    solution 3: pass the precision as a named argument of ~Y or ~YM.
    fact = { use arg f ; use named arg p=(digits()) ; { expose f p; use arg n ; numeric digits p ; if n == 0 then 1 ; else n * f~(n-1) } }~Y(p:157)
    fact(100)           -- 9.332621544394415268169923885626670049071596826438162146859296389521759999322991560894146397615651828625369792082722375825118521091686400000000000000000000000E+157

The Y combinator with memoization now supports all the positional arguments, not just the first one.

    factm = { use arg f ; { expose f ; use arg n, p=(digits()) ; numeric digits p ; if n == 0 then 1 ; else n * f~(n-1, p) } }~YM
    do n=100 to 109; do p=100 to 180 by 10; say "factm~("n", "p")="factm~(n, p); end; end

    factm~(100, 100)=9.332621544394415268169923885626670049071596826438162146859296389521759999322991560894146397615651822E+157
    factm~(100, 110)=9.3326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697922E+157
    factm~(100, 120)=9.33262154439441526816992388562667004907159682643816214685929638952175999932299156089414639761565182862536979208272237579E+157
    ...
    factm~(109, 160)=1.443859583202493582204882102462797533793128203133960291598340756222233378449834820996360011956152592770840333876198180928047377147583842443341602173747200000000E+176
    factm~(109, 170)=1.4438595832024935822048821024627975337931282031339602915983407562222333784498348209963600119561525927708403338761981809280473771475838424433416021737472000000000000000000E+176
    factm~(109, 180)=144385958320249358220488210246279753379312820313396029159834075622223337844983482099636001195615259277084033387619818092804737714758384244334160217374720000000000000000000000000

The index is arg(1, "a")~tostring.

    factm~variables=
    a Directory (1 items)
    'F' : (a RexxBlock)

    factm~variables["F"]~variables=
    a Directory (7 items)
    'F'          : (a Routine)
    'SELF'       : (a Closure)
    'SUPER'      : (The Doer class)
    'TABLE'      : Table['55[0A]100','101[0A]130','63[0A]100','51[0A]170','71[0A]100',...,'18[0A]120','32[0A]120','33[0A]120','52[0A]100']
    'VERBOSE'    :  0
    'X'          : (a RexxBlock)
    'YNAMEDARGS' : Directory(an Array no shape, 0 items)


Clean CmakeLists.txt:
in the previous commit, I was not sure what to do with VERSION vs SOVERSION.
More clear with the comment of official Rev 12101:
20200727 Make sure that on Linux and MacOS the shared/dylib library versions use
API level 4. Add ORX_API_LEVEL to control the SOVERSION value; change VERSION to
SOVERSION where applicable; tested on Linux, MacOSX, Windows.
Remember:


===============================================================================
2020 june 08

Add support for these named arguments to ~upTo, ~downTo:
- by
- for
- action
1~10(by:2)=             -- [ 1, 3, 5, 7, 9]
1~100(by:3, for:-5)=    -- [ 88, 91, 94, 97, 100]
0~15(action:"d2x")=     -- [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,'A','B','C','D','E','F']

Named arguments:
Bug detected with 1~10(step:2)
which raised "named argument 2 is not an expected argument name"
Fixed in method  RexxObject::sendMessage (arrays are 1-based)


===============================================================================
2020 mar 22

Doers.cls
Use the instruction FORWARD when possible.
I noticed that the number of recursive calls is divided by 2 or 3 when using
a method of a doer instead of calling directly the routine or sending directly
the message.
Using FORWARD will not change that for the moment, but I expect to work in the
future on the tail recursion, and FORWARD (without CONTINUE) is a good candidate
to reduce the comsumption of stack frames.


===============================================================================
2020 mar 01

Named arguments:
Reworked how the count of named arguments is passed.
Now this count is passed with an additional C++ parameter.
count=3, named_count=2
              +----+----+----+----+----+----+----+
              | P1 | P2 | P3 | N1 | V1 | N2 | V2 |
              +----+----+----+----+----+----+----+


For history, keep this part where I describe the previous implementation.
<<
Internally, the named arguments are passed as an array appended to the array of
positional arguments. The count of named arguments is inserted between the two
arrays.       +----+----+----+---+----+----+----+----+
              | P1 | P2 | P3 | 2 | N1 | V1 | N2 | V2 |
              +----+----+----+---+----+----+----+----+
                               |
                             count                       <-- DEPRECATED

This representation allows to pass both arrays to the existing C++ methods,
without adding a parameter to pass the count of named arguments.
    sendMessage(RexxString *message, RexxObject **args, size_t argCount)
BUT there is a drawback...
The count of named arguments must be ALWAYS appended, even when no named arguments.
For that, sometimes, a copy of the positional arguments must be done, while no
copy is needed in official ooRexx.
These extra copies could be avoided if the count of named arguments was passed as
a supplementary C++ parameter :                                          *********************
    sendMessage(RexxString *message, RexxObject **args, size_t argCount, size_t named_argCount)
                                                                         *********************
This is the approach I used initially, many methods were impacted.
I abandonned this approach because I thought that all the native methods should
be updated to add a parameter named_argCount.
Now, I know it's not the case... Maybe I should try again.
>>


===============================================================================
2020 feb 28

Named arguments:
Simplification to pass named arguments to natives functions.

Before:
    The named arguments were passed to the C++ method as 2 C++ parameters per named argument.
        native_cpp_method(P1, P2, P3, N1, V1, N2, V2)
    The order was the order used by the caller to pass the named arguments.
    That was acceptable when only one named argument is expected, but not a good approach for a general support.
    Moreover, CPPCode::run had to support many cases to pass the C++ arguments.
Now:
    The named arguments are passed as an array: ptr and count.
        native_cpp_method(P1, P2, P3, N1, array_ptr, array_count)
    CPPCode::run has only two cases to support : with or without name arguments.
    The callee can use the helper NamedArguments.check to collect the named arguments in a useful order.
Later ?
    The helper NamedArguments.check could be run from CPPCode::run if I can find a way to associate the
    description of the named arguments to CPPCode.
    That would allow to pass only the values of named arguments, without their names, because the order
    would be the order used by the callee to declare the expected named arguments.
        native_cpp_method(P1, P2, P3, V1, V2)


All the native methods A_COUNT support named arguments.
Native methods not A_COUNT which support named arguments:
    TheObjectBehaviour        RexxObject::startWith
    TheObjectBehaviour        RexxObject::sendWith
    TheRoutineBehaviour       RoutineClass::callWithRexx
    TheRexxContextBehaviour   RexxContext::setArgs
    TheDirectoryBehaviour     RexxObject::unknownRexx
    TheStemBehaviour          RexxObject::unknownRexx
    TheIntegerBehaviour       RexxObject::unknownRexx
    TheNumberStringBehaviour  RexxObject::unknownRexx


===============================================================================
2020 feb 16

Named arguments:
Add support for optional declaration of minimum length (abbreviation):
    use named arg abbreviated(1)=(.nil)
    use named arg abbreviated (1) = (.nil)

The interpreter checks at parsetime that the names are unique.
The interpreter also checks at parsetime that the minimal lengths are discriminating.
use named arg command(1), option          -- ok: "option" is different from "command"
use named arg command(1), comOption       -- ok: "comOption" has 9 mandatory characters, no collision with "command(1)"
use named arg command(1), commands        -- ok: "commands" has 8 mandatory characters, no collision with "command(1)"
use named arg command(1), commands(7)     -- ko: "commands(7)" can be abbreviated "command" and that collides with "command(1)"
use named arg command, commands(7)        -- ko: "commands(7)" can be abbreviated "command" and that collides with "command"


was KO before enforcing the detection of doubling names:
{use named arg n,n; say n}~(n:1)
    N
This happened because the named parameter 'n' was mapped with the first argument 'n' in the USE instruction.
The second named argument 'n' was not mapped, and stayed without value.
Since the mode is not strict, the second 'n' was deleted, which deleted the assignment n=1 made for the first argument 'n'.
Now, this case cannot happen, because an error is raised at parsetime : "The named argument names are not unique".

-- remember: the blocks always start with 'use auto named arg'. That's why X is set to 1.
{use named arg option, options; .context~variables}~(x:1)=
    a Directory (1 items)
    'X' :  1

-- Add 'strict' and default value
{use strict named arg option=10, options=20; .context~variables}~(x:1)=
    named argument X is not an expected argument name
    Code= 88.917

-- Pass a good named param. No ambiguity.
{use strict named arg option=10, options=20; .context~variables}~(option:1)=
    a Directory (2 items)
    'OPTION'  :  1
    'OPTIONS' :  20

-- Pass 2 good named param
{use strict named arg option=10, options=20; .context~variables}~(options:2, option:1)=
    a Directory (2 items)
    'OPTION'  :  1
    'OPTIONS' :  2

-- The minimum length 6 creates a collision of names, detected at parsetime.
{use strict named arg option=10, options(6)}=
    The named argument names are not unique, or their abbreviation is not distinctive enough
    Code= 99.900

-- The minimum length 7 does not create a collision of names
{use strict named arg option=10, options(7)=20; .context~variables}~(options:2, option:1)=
    a Directory (2 items)
    'OPTION'  :  1
    'OPTIONS' :  2

-- The minimum length 1 on both names creates a collision of names, detected at parsetime.
{use named arg item(1), index(1)}=
    The named argument names are not unique, or their abbreviation is not distinctive enough
    Code= 99.900


===============================================================================
2020 feb 16

Add support for the named arguments in the methods provided by doers.cls:
    ~do
    ~doWith
    ~go
    ~goWith
    ~partial
New file for testing:
    named_arguments-test_with_extensions.rex
That made appear a problem with the abbreviated names: there is no way currently
to specifiy a minimal lenght with the instruction 'use named arg'.


Add method ~of to the class Directory:
.directory~of("key 1", "value 1","key 2", 2, key3:"value 3", key4:4)
    a Directory (4 items)
    'KEY3'  : 'value 3'
    'KEY4'  :  4
    'key 1' : 'value 1'
    'key 2' :  2
Add routine d(...) to create a directory with values.
A key-value where the key is compatible with a named  argument can be passed as named argument. The key is converted to uppercase.
A key-value where the key is not compatible with a named argument must be passed as a pair of positional arguments.


For compatibility with ooRexx5:
Add the methods ~contains and ~caselessContains to the class String (not native, by extension).


Pretty-print
A mutable buffer is now displayed M"value of mutable buffer"
A positive number is displayed with a space " " in front, to align with negative numbers.
The routine pp2 in rgf_util2 delegates to the method ppString if available.


===============================================================================
2019 oct 27

Reactivate the build of ooDialog.wchar.
Was left aside when switching to cmake.
Using ooRexxTry shows that more support is needed for named arguments to not crash
when no named argument passed.


Continue implementation of named arguments:

Object~starWith
supports the named argument "namedArguments".


===============================================================================
2019 oct 10

RexxBlock:
The source transformation is made at parse-time, thanks to the auto named arguments.
No more transformation at run-time.


The class RexxSourceLiteral defined in Parser.orx has been removed.
The services that were provided by this class are now provided by the class Clauser.


===============================================================================
2019 oct 01

Rework the pretty print of objects.
Array, Pipe: new pretty-print for self-referencing objects. Work in progress.


===============================================================================
2019 aug 10

Functionnal: Add aliases for convenience, change behavior of takeFirst, takeUntil.


Coactivty: Add method currentIndexItem, adapt the behavior of the supplier.


ooRexxShell: use the pretty print routines of rgf_util only if the extended version has been loaded.
No longer possible to use the official rgf_util because additional parameters are passed to some routines.


===============================================================================
2019 jan 16

RosettaCode executor : align with RosettaCodeData commit of August 17 2018.


===============================================================================
2019 jan 11

Named arguments: stable version.


===============================================================================
2019 jan 06

Switch to cmake.
ooDialog.wchar left aside for the moment.


===============================================================================
2018 dev 24

Fix crash of .method~new when source array is a sparse array


===============================================================================
2018 dev 20

Fix bug in trace output: a question mark was displayed at the end of the trace
line, when displaying a stem with 2 compound variables or more.
       >L>   "0"
     2 *-* stem.a1=0
       >>>   "0"
       >C>   STEM.A1 => "STEM.A1"
       >=>   STEM.A1 <= "0"
       >L>   "0"
     3 *-* stem.a1.b1=0
       >>>   "0"
       >C>   STEM.A1.B1 => "STEM.A1.B1"?
       >=>   STEM.A1.B1 <= "0"?
       >L>   "0"
     4 *-* stem.a1.b1.c1=0
       >>>   "0"
       >C>   STEM.A1.B1.C1 => "STEM.A1.B1.C1"??
       >=>   STEM.A1.B1.C1 <= "0"??
       >L>   "0"
     5 *-* stem.a1.b1.c1.d1=0
       >>>   "0"
       >C>   STEM.A1.B1.C1.D1 => "STEM.A1.B1.C1.D1"???
       >=>   STEM.A1.B1.C1.D1 <= "0"???


===============================================================================
2018 dec 19

Fix crash of .routine~new when source array is a sparse array


Add trace for variables dropped by use [named] arg.
    call myroutine
    ::routine myroutine
    use arg a1=1,a2=2, a3
    ::options trace i
Trace:
     1 *-* call myroutine
       >I> Routine MYROUTINE in package .../trace_arguments.rex
     8 *-* use arg a1=1,a2=2, a3
       >L>   "1"
       >>>   "1"
       >=>   A1 <= "1"
       >L>   "2"
       >>>   "2"
       >=>   A2 <= "2"
       >=>   A3 <= is dropped


Continue implementation of named arguments:

USE STRICT AUTO NAMED ARG
now raises
Error 99.900: STRICT AUTO requires the "..." argument marker at the end of the argument list
This error is raised during the parsing of the Rexx program.
Without an ellipsis, the keyword 'auto' is useless in strict mode.

The method RexxContext~setArgs is partially implemented.
Still to do: Store the named arguments on the activation.

The method Context~args= is removed, because replaced by setArgs:
More efficient to have one call to set the positional & named arguments,
instead of 2 calls Context~args= and Context~namedArgs=.

All the error messages about arguments have been modified to add the kind of argument:
positional or named.


===============================================================================
2018 nov 21

Continue implementation of named arguments:

The instruction USE NAMED is implemented.

CPPCode::run
Up to 3 named arguments can be passed to the C++ methods.

To let support stems and compound symbols as named arguments, their name is
stored on their respective objects.


===============================================================================
2018 oct 23

Continue implementation of named arguments:


Object~sendWith
supports the named argument "namedArguments".


Object~run
supports a new option "Directory" that can be passed after the option "Array".


Routine~callWith
supports the named argument "namedArguments".


The error Error_Incorrect_method_maxarg now takes 2 arguments:
kind (new) and argcount.
kind can be "positional" or "named".
Ex:
Too many positional arguments in invocation of method; 5 expected


Declaration of native methods in setup.cpp : now can declare the number of named
arguments supported by the method. The default value is -1, which means "no need
to pass named arguments".
Native methods that support 1 named argument:
  defineKernelMethod("SENDWITH"         , TheObjectBehaviour,       CPPM(RexxObject::sendWith), 2, 1);
  defineKernelMethod(CHAR_CALLWITH      , TheRoutineBehaviour,      CPPM(RoutineClass::callWithRexx), 1, 1);
  defineKernelMethod(CHAR_UNKNOWN       , TheDirectoryBehaviour,    CPPM(RexxObject::unknownRexx), 2, 1);
  defineKernelMethod(CHAR_UNKNOWN       , TheStemBehaviour,         CPPM(RexxObject::unknownRexx), 2, 1);
  defineKernelMethod(CHAR_UNKNOWN       , TheIntegerBehaviour,      CPPM(RexxObject::unknownRexx), 2, 1);
  defineKernelMethod(CHAR_UNKNOWN       , TheNumberStringBehaviour, CPPM(RexxObject::unknownRexx), 2, 1);


CPPCode::run pass named arguments to the native methods that support them.
Each named argument is passed as 2 C++ parameters : name, value.
Currently the maximum number of named arguments that can be passed is 2.


The native methods ::unknown now takes 2 additional C++ parameters for the named
arguments. Ex:
RexxObject *RexxInteger::unknown(
    RexxString *msgname,               /* unknown message name              */
    RexxArray *arguments,              /* arguments to the unknown message  */
    RexxString *name1,                 // name of 1st named argument
    RexxDirectory *namedArguments)     // value of 1st named argument


===============================================================================
2018 oct 07

Continue implementation of named arguments.
step 1: [done] caller side
step 2: [partially done 80%] from caller to callee, evaluation of the named arguments, storage in a directory.
    Message term
    Expression function
    Instruction call
    Instruction forward
step 3: [partially done 10%] callee side, give access to the directory. First need : use auto named arg.
    Context~namedArgs

For a demo, see
sandbox/jlf/samples/extension/named_arguments.output.txt


===============================================================================
2018 aug 05

Rework the pretty print of objects.
- ppRepresentation renamed ppString
- Add ppString at object level and class level
- Remove option surroundByQuotes, now it's always true.


===============================================================================
2018 apr 29

Start implementation of named arguments.
step 1: [done] caller side
step 2: [todo] from caller to callee, evaluation of the named arguments, storage in a directory.
step 3: [todo] callee side, give access to the directory. First need : use auto named arg.

call myprocedure 1, 2, 3                -- arg() == 3   Positional=1,2,3
call myprocedure 1, 2, a3:3             -- arg() == 2   Positional=1,2
call myprocedure 1, a2:2, a3:3          -- arg() == 1   Positional=1

call myprocedure 1, a2:2, a3:           -- Error Named argument: expected expression after colon
call myprocedure 1, a2:2, 3             -- Error Named argument: expected symbol followed by colon

say myprocedure(1, 2, 3)                -- arg() == 3   Positional=1,2,3
say myprocedure(1, 2, a3:3)             -- arg() == 2   Positional=1,2
say myprocedure(1, a2:2, a3:3)          -- arg() == 1   Positional=1
(same syntax supported for method call)

say myprocedure(1, 2, 3){}              -- arg() == 4   Positional=1,2,3,{}
say myprocedure(1, 2, a3:3){}           -- arg() == 3   Positional=1,2,{}
say myprocedure(1, a2:2, a3:3){}        -- arg() == 2   Positional=1,{}
(same syntax supported for method call)

-- forward array can't be used with forward arguments and/or forward namedArguments
forward array ( 1, 2, 3 )               -- arg() == 3   Positional=1,2,3
forward array ( 1, 2, a3:3 )            -- arg() == 2   Positional=1,2
forward array ( 1, a2:2, a3:3 )         -- arg() == 1   Positional=1

forward namedArguments (.directory~new~~put(1,"a1")~~put(2,"a2")) continue

No impact on predefined method & functions:
say "abcd"~left(2)                      -- "ab"
say "abcd"~left(2, ignored:value)       -- "ab"
say left("abcd", 2, ignored:value)      -- "ab"
say 1~"+"(2)                            -- 3
say 1~"+"(2, ignored:value)             -- 3


===============================================================================
2018 feb 26

Rexx supports only positional arguments.
Specifiying what could be named arguments.

A positional argument list is a serie of optional expressions, separated by commas.
    caller: put("one", 1)
    callee: use arg item, index -- order is important
The position of each argument within the argument list identifies the corresponding
parameter in the parameter list of the routine/method being invoked.
This is in contrast to named argument lists, where the correspondence between
argument and parameter is done using the parameter's name.
    caller: put(index:1, item:"one")
    callee: use named arg item, index -- order is not important

Positional and named arguments can be used in the same call.
Named arguments are after the last positional argument.
The abbreviated syntax of arguments list is still available:
f(a1,a2,n1:v1,n2:v2){...} is equivalent to f(a1,a2,{...},n1:v1,n2:v2)


Arguments:

|----+----------------------------------------------------+----|
     +--| Positional arguments |--------------------------+
     +-------------------------------| Named arguments |--+
     +--| Positional arguments |--,--| Named arguments |--+


Positional arguments:

    +-,--------------+
    V                |
|-----+------------+-+----|
      |            |
      +-expression-+


Named arguments:

    +-,-----------------------+
    V                         |
|-----argName-:-argExpression-+----|


caller: "one two three one"~reduce("put", by:"word", initial:.set~new)

callee:

use strict            arg doer                      -- Positional arguments (not impacted by the named arguments)

use             named arg by, initial=.nil          -- If 'by' is not passed by the caller then the variable 'by' is dropped.
                                                    -- If 'initial' is not passed by the caller then the variable 'initial' is set to .nil.
                                                    -- The named arguments passed by the caller and not explicitely declared by the callee are not available as local variables.
                                                    -- They are available in .Context~namedArgs.

use strict      named arg by, initial=.nil          -- 'by' is mandatory.
                                                    -- 'initial' is optional, default value is .nil.
                                                    -- Only 'by' and 'initial' are accepted.

use strict      named arg by, initial=.nil, ...     -- 'by' is mandatory.
                                                    -- 'initial' is optional, default value is .nil.
                                                    -- Any named argument is accepted.
                                                    -- The named arguments passed by the caller and not explicitely declared by the callee are not available as local variables.
                                                    -- They are available in .Context~namedArgs.

use auto        named arg                           -- Automatic creation of local variable for each named argument passed by the caller.

use auto        named arg by, initial=.nil          -- If 'by' is not passed by the caller then the variable 'by' is dropped.
                                                    -- If 'initial' is not passed by the caller then the variable 'initial' is set to .nil.
                                                    -- The named arguments passed by the caller are available as local variables.
                                                    -- They are also available in .Context~namedArgs.

use strict auto named arg by, initial=.nil          -- 'by' is mandatory.
                                                    -- 'initial' is optional, default value is .nil.
                                                    -- Only 'by' and 'initial' are accepted.
                                                    -- The keyword 'auto' is useless here. Should raise an error when strict without ellipsis ... ?
                                                    -- The named arguments passed by the caller are available as local variables.
                                                    -- They are also available in .Context~namedArgs.

use strict auto named arg by, initial=.nil, ...     -- 'by' is mandatory.
                                                    -- 'initial' is optional, default value is .nil.
                                                    -- Any named argument is accepted.
                                                    -- The named arguments passed by the caller are available as local variables.
                                                    -- They are also available in .Context~namedArgs.


------------
Message term
------------

>>-receiver-+- ~ --+-messagename--+----------+--+---------------------+---><
            +- ~~ -+              +-:-symbol-+  +-(--| Arguments |--)-+


>>-receiver[--| Arguments |--]----------------------------><


---------------
Instruction ARG
---------------

ARG template_list
Not impacted.


---------------------
Instruction PARSE ARG
---------------------

PARSE ARG template_list
Not impacted.


----------------
Instruction CALL
----------------

>>-CALL----+-name-----+----| Arguments |--------------------><
           +-(-expr-)-+


--------
Function
--------

>>-function_name(----| Arguments |----)-------------------><


-------------------
Instruction FORWARD
-------------------

Inconsistency with Message~new and Object~run.
Here, ARRAY is followed by a list of arguments.
There, "Array" is followed by a mandatory array. "Individual" is followed by a list of arguments.

exprn is a directory of named arguments.

>>-FORWARD--+------------+--+---+--------------------+--+-------------------------+---+--+------------------+--+----------------+--+-------------+----><
            +--CONTINUE--+  |   +--ARGUMENTS--expra--+  +--NAMEDARGUMENTS--exprn--+   |  +--MESSAGE--exprm--+  +--CLASS--exprs--+  +--TO--exprt--+
                            +--------------ARRAY----(--| Arguments |--)---------------+

---------------
Instruction USE
---------------
                                                       +-,----------------------+
                                                       V                        |
>>-USE--+----------+--+--------+-----NAMED-----ARG--+------name-+----------+----+--+----------+---+-----><
        +--STRICT--+  +--AUTO--+                    |           +-=--expr--+       +--,--...--+   |
                                                    +--+-------+----------------------------------+
                                                       +--...--+

When the option 'NAMED' is specified:
- name is a simple symbol, a stem or a compound symbol.
- Message term are not supported.
- Omitted names are not allowed.
There is no evaluation of a default value when a value has been provided by the caller.
The order of evaluation is the order of declaration in USE NAMED ARG (left-to-right).
The automatic variables are already created and can be used during the evaluation of a default value.


--------------
UNKNOWN method
--------------
::method unknown
    expose target -- assuming this target will receive all of the unknown messages
    use arg name, arguments
    use named arg namedArguments -- not passed as 3rd positional argument to avoid impacts
    -- send along the message with the original args and named args
    forward to (target) message (name) arguments (arguments) namedArguments (namedArguments)


-------------
Message~new
-------------

Inconsistency with the instruction 'forward'.
Here, "Array" is followed by a mandatory array.
There, ARRAY is followed by a list of arguments. ARGUMENTS is followed by a mandatory array.

>>-new(-target-,-messagename-+----------------------------------------------------+-)--><
                             +-,-"Individual"--| Arguments |----------------------+
                             +--+-------------------+--+-----------------------+--+
                                +-,-"Array"-,-expra-+  +-,-"Directory"-,-exprd-+

-------------
Message~namedArguments
-------------

Returns a directory of named arguments used to invoke the message


----------
Object~run
----------

Inconsistency with the instruction 'forward'.
Here, "Array" is followed by a mandatory array.
There, ARRAY is followed by a list of arguments. ARGUMENTS is followed by a mandatory array.

>>-run(-method-+----------------------------------------------------+-)--><
               +-,-"Individual"---| Arguments |---------------------+
               +--+-------------------+--+-----------------------+--+
                  +-,-"Array"-,-expra-+  +-,-"Directory"-,-exprd-+


---------------
Object~sendWith
---------------

>>-sendWith(-messagename-,-arguments-,-namedArguments-:-namedArguments-)---><
namedArguments: can be abreviated to 1 letter

----------------
Object~startWith
----------------

>>-startWith(-messagename-,-arguments-,-namedArguments-:-namedArguments-)---><
namedArguments: can be abreviated to 1 letter


----------------
Routine~callWith
----------------

>>-callWith(-array-,-namedArguments-:-namedArguments-)----------------------><
namedArguments: can be abreviated to 1 letter


-----------------
Context~namedArgs
Context~namedArgs=  (remember: coactivity.cls reassign the arguments passed by the resume's caller)
-----------------

Why not ~namedArguments ?
Because following the naming convention used for the method Args.
Returns a directory of named arguments used to invoke the current context.
There is no equivalent as built-in function.
The ARG built-in function doesn't give access to the named arguments.


------------------------
StackFrame~nameArguments
------------------------

Returns a directory of named arguments used to invoke the execution frame represented by the StackFrame instance.


------------
Function ARG
------------

Not impacted by named arguments.
Can't be used to retrieved named arguments.


---------------------
Security manager CALL
---------------------

The information directory contains:
NAMEDARGUMENTS: a directory of the function named arguments


-----------------------
Security manager METHOD
-----------------------

The information directory contains:
NAMEDARGUMENTS: a directory of the method named arguments


--------------------------------
Simplification of implementation
--------------------------------

'use auto named arg' will let remove runtime source transformation of blocks.
One transformation at parse time will be enough:
{[expose ...;]clause1;clause2;...} --> {[expose ...;]use auto named arg; options "NOCOMMANDS"; clause1;clause2;...}

Arity no longer needed.
The first need of the arity was in the method reduce, were 3 positional arguments
can be passed to the doer: accu, item, index.
But, when the doer is a message like '+', it's not possible to pass 3 arguments.
Must pass strictly 2 positional arguments: accu, item.
Now, the index is passed only as named argument.


===============================================================================
2017 oct 05

Summary of changes since 2016 dec 26, not yet listed.

ooRexxShell
-----------

Stand-alone: ooRexxShell has been adapted to be operational (with limited
functionalities) even if one or more loaded packages/libraries are missing.

If an ooRexx clause ends with "==" then the command line is transformed to
display the result **not condensed**.
1,2,3=
    [1,2,3]
1,2,3==
    an Array (shape [3], 3 items)
    1 : 1
    2 : 2
    3 : 3

string2args:
An unquoted chunk can be splitted in several parts, if it contains a break token.
Ex:
if "<>" is a break token then
    'a<>b' is parsed as 3 tokens: "a", "<>", "b".
    'a"<>"b' is parsed a 1 token: "a<>b"

Add query ?path v1 v2 ...
Display the value of the specified system variables, splitted by path separator.
The default variable name is PATH.
Example (under Windows):
?path
    PATH 'C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\build'
    PATH 'C:\jlf\local\rexx\bsf4oorexx\svn\trunk\bsf4oorexx.dev\source_cc\build\win\cl\release\64'
    PATH 'C:\jlf\local\rexx\bsf4oorexx\svn\trunk\bsf4oorexx.dev\bin'
    PATH 'C:\jlf\local\nsis\Nsis_longStrings'
    PATH 'C:\jlf\local\rexx\GCI\gci-source.1.1\build\win\cl\release\64'
    ... <cut>
    PATH length: 2618
?path include lib = rexx "length: "
    include 'C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\build\api'
    include 'C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\api'
    include length: 645

    lib 'C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\build\api'
    lib 'C:\jlf\local\rexx\oorexx\build\executor.master\sandbox\jlf\trunk\win\cl\release\64\delivery\api'
    lib length: 516

Add query ?v[ariables]
This is for convenience, equivalent to .context~variables=


No value
--------

The interpreter has an undocumented functionnality:
When a variable has no value, the interpreter sends the message "NOVALUE" to the
object .local["NOVALUE"].
I use this functionality to manage special variable like i, infinity, indeterminate.
i=              -- (0+1i)
infinity=       -- (The positive infinity)
indeterminate=  -- (The indeterminate value)


Operators
---------

Take note of this:
Some alternative messages are never sent by the interpreter, because there is a
shared implementation for some operators.
Ex:
"" and "||" are implemented by the same method concat.
The alternative message "||op:right" can be send, but the message "op:right" will NEVER be sent.

OP    RexxObject                          RexxInteger           RexxNumberString      RexxString            Comment
"+"   operator_plus                       plus                  plus                  plus
"-"   operator_minus                      minus                 minus                 minus
"*"   operator_multiply                   multiply              multiply              multiply
"/"   operator_divide                     divide                divide                divide
"%"   operator_integerDivide              integerDivide         integerDivide         integerDivide
"//"  operator_remainder                  remainder             remainder             remainder
"**"  operator_power                      power                 power                 power
""    operator_abuttal                    concat                concat                concatRexx            should be ::abuttal everywhere
"||"  operator_concat                     concat                concat                concatRexx
" "   operator_concatBlank                concatBlank           concatBlank           concatBlank
"="   operator_equal                      equal                 equal                 equal
"\="  operator_notEqual                   notEqual              notEqual              notEqual
">"   operator_isGreaterThan              isGreaterThan         isGreaterThan         isGreaterThan
"\>"  operator_isBackslashGreaterThan     isLessOrEqual         isLessOrEqual         isLessOrEqual         should be ::isBackslashGreaterThan everywhere
"<"   operator_isLessThan                 isLessThan            isLessThan            isLessThan
"\<"  operator_isBackslashLessThan        isGreaterOrEqual      isGreaterOrEqual      isGreaterOrEqual      should be ::isBackslashLessThan everywhere
">="  operator_isGreaterOrEqual           isGreaterOrEqual      isGreaterOrEqual      isGreaterOrEqual
"<="  operator_isLessOrEqual              isLessOrEqual         isLessOrEqual         isLessOrEqual
"=="  operator_strictEqual                strictEqual           strictEqual           strictEqual
"\==" operator_strictNotEqual             strictNotEqual        strictNotEqual        strictNotEqual
">>"  operator_strictGreaterThan          strictGreaterThan     strictGreaterThan     strictGreaterThan
"\>>" operator_strictBackslashGreaterThan strictLessOrEqual     strictLessOrEqual     strictLessOrEqual     should be ::strictBackslashGreaterThan everywhere
"<<"  operator_strictLessThan             strictLessThan        strictLessThan        strictLessThan
"\<<" operator_strictBackslashLessThan    strictGreaterOrEqual  strictGreaterOrEqual  strictGreaterOrEqual  should be ::strictBackslashLessThan everywhere
">>=" operator_strictGreaterOrEqual       strictGreaterOrEqual  strictGreaterOrEqual  strictGreaterOrEqual
"<<=" operator_strictLessOrEqual          strictLessOrEqual     strictLessOrEqual     strictLessOrEqual
"<>"  operator_lessThanGreaterThan        notEqual              notEqual              notEqual              should be ::lessThanGreaterThan everywhere
"><"  operator_greaterThanLessThan        notEqual              notEqual              notEqual              should be ::greaterThanLessThan everywhere
"&"   operator_and                        andOp                 andOp                 andOp
"|"   operator_or                         orOp                  orOp                  orOp
"&&"  operator_xor                        xorOp                 xorOp                 xorOp
"\"   operator_not                        operatorNot           operatorNot           operatorNot


Pipe
----

PipeStage Yield: new options
(['index'] ['item'] [<expression-doer>])*


Array programming
-----------------

~each now supported at Object level (APL: Ravel)
-- Seen in http://www.dyalog.com/mastering-dyalog-apl-errata.htm
-- B 51 debate: "A single number has no dimensions" .. what about â´,1 ?
-- â´,1 is 1, that's why I add this method
1~shape= []
1~each= -- [1]
1~each~shape= [1]

Indexing a vector
It is possible to extract several items in a single operation, and in any order.
An item can be selected more than once.
    vector = v(41,26,38,14,87,52,30,28,19,65,40,55,19,31,64,45,82,74)
        [41, 26, 38, 14, 87, 52, 30, 28, 19, 65, 40, 55, 19, 31, 64, 45, 82, 74]
    vector[3] or vector~atindex(3) or vector~atindex(v(3))
        38 -- a scalar
    vector~indexer(3) or vector~indexer(v(3))
        [38] -- an array
    vector~indexer(3,7,1,3,3,12) =
        [38, 30, 41, 38, 38, 55]
    'LE CHAT'~eachc~indexer(7, 5, 2, 3, 4, 6, 7)~tostring("c")=
        'THE CAT'

The index may be an array of any shape: scalar, vector, matrix, or an array of higher rank.
When a vector is indexed by an array, the result has exactly the same shape as the index
array, as if each item of the index had been replaced by the item it designates:
    index = a(3,5)~of(5,5,4,4,8,6,12,6,11,12,10,6,1,4,9)
         5  5 4  4  8
         6 12 6 11 12
        10  6 1  4  9
    vector~indexer(index) =
        87 87 14 14 28
        52 55 52 40 55
        65 52 41 14 19

Indexing an array
Similar to vector indexing, but with one index for the row and one for the column:
    matrix = a(6,3)~of(41,26,38,14,87,52,30,28,19,65,40,55,19,31,64,45,82,74)
        41 26 38
        14 87 52
        30 28 19
        65 40 55
        19 31 64
        45 82 74
    matrix[2,3] or matrix~atindex(2,3) or matrix~atindex(v(2,3))
        52 -- a scalar
    matrix~indexer(2,3) or matrix~indexer(v(2,3))
        [[14,87,52],[30,28,19]] -- line 2, line 3
    index = v(  v(1,1), v(2,2), v(3,3)  )
         [[1,1],[2,2],[3,3]
    matrix~indexer(index) =
        [41,87,19]
    matrix~indexer(a(2,3)~of(index)) =
        41 87 19
        41 87 19


Doers
-----
Asynchronous execution with go and goWith.
{loop 2; say "hello"; end}~do; {loop 2; say "world"; end}~do
    hello
    hello
    world
    world
{loop 2; say "hello"; end}~go; {loop 2; say "world"; end}~go
    hello
    world
    hello
    world


Parser
------

Argument list:
Keep the trailing omitted arguments.
    .array~of(10,20,30,,)~dimensions= -- [5] instead of [3]
This is consistent with the array literals:
    v(1,2,) is the same as 1,2,
[03/04/2021]
I just discovered that rexxref.pdf acknowledges this inconsistency:
"If the array term has trailing commas, the returned array has a bigger size
than what .Array~of(â€¦) would have returned:"
So for official ooRexx, that's normal to have this inconsistency.
[01/05/2018]
The change above has an unexpected effect on the regression tests:
base/bif: [SYNTAX 40.5] raised unexpectedly
40.5 "Missing argument in invocation of XXX; argument 2 is required"
is raised instead of
40.3 "Not enough arguments in invocation of XXX; minimum expected is 2."
--> ExpressionStack.cpp: RexxExpressionStack::expandArgs updated to raise 40.3

Array literals:
Retrofit from ooRexx5 the parsing of an expression where the expression can be
treated as a comma-separated list of subexpressions.
For an empty vector, or a vector of one element, the routine v is still needed :
()=     -- Syntax error: Incorrect expression detected at "("
v()=    -- []
(1)=    -- 1
v(1)    -- [1]

28/04/2018
Align implementation of forward arguments to keep the trailing omitted arguments
official: forward message "n" arguments ( (1,2,,) )     -- pass (1,2)
executor: forward message "n" arguments ( (1,2,,) )     -- pass (1,2,,)


String extension
----------------

Added the methods split and caselessSplit.
Similar to ~makeArray(separator), with these differences:
- Can be caseless (makeArray is always case sensitive).
- If the string ends with a separator, an empty string item is added (makeArray does not).
  This is consistent with the size of the array literals :
      1,,2,3,               -- array of size 5, 3 items (sparse array)
      "1,,2,3,"~split(",")  -- array of size 5, 5 items
- If the separator is an empty string then the result is an array containing the whole string
  (makeArray returns an array containing each character of the string).
  This is closer to the semantics of the parse instruction.
- When no separator is provided, the default value is the *current* platform end-of-line
  (makeArray is splitting on *any supported* platform end-of-line).


Compatibility with classic rexx
-------------------------------

Add support for instruction UPPER:
- same syntax as instruction DROP
- translate to upper case the value of each variable

Rename the script which executes the classic rexx scripts of Rosetta code:
RosettaCodeData.rex --> runRosettaCode.rex

Align with RosettaCodeData commit of Dec 05 2016.
The solutions starting with "A" and "B" are covered.

The Rosetta solutions are installed locally from https://github.com/acmeism/RosettaCodeData
Under Windows, Git doesn't create symbolic links.
Instead, it creates ordinary text files which contain the relative path.
Something like that: ../../Task/9-billion-names-of-God-the-integer/REXX
The script has been adapted to support this indirection through text files.


===============================================================================
2017 oct 05

RexxMessageNumbers.h
Some message numbers are used twice --> fix rexxmsg.xml.

    #define Error_Incomplete_do_loop_msg                                 725
    #define Error_Invalid_expression_message_term_msg                    725 --> 740

    #define Error_Unmatched_parenthesis_curly_msg                        735
    #define Message_Translations_internal_code_msg                       735 --> 741

    #define Error_Unexpected_curly_bracket_msg                           736
    #define Message_Translations_sourceless_method_invocation_msg        736 --> 742

    #define Error_Invalid_expression_after_tilde_msg                     737
    #define Message_Translations_sourceless_routine_invocation_msg       737 --> 743


List of message numbers not used:
    1
    2
    12
    32
    50..87
    89
    92
    94..96
    101
    134..199
    399
    403
    430
    477
    487
    495..499
    527         (used in ooRexx5)
    528         (used in ooRexx5)
    567..579
    582         (used in ooRex5)
    585         (used in ooRexx5)
    605..610
    661         (used in ooRexx5)
    662         (used in ooRexx5)
    696         (used in ooRexx5)


===============================================================================
2017 jan 09

The tokenizer has been modified to split a symbol of the form <number><after number> in two distinct tokens.
Ex : 2a is the number 2 followed by the symbol a.
Ex : 2a2b is the number 2 followed by the symbol a2b.
Ex : 2e1a2b is the number 2e1 followed by the symbol a2b.

The rule is to stop immediatly after a VALID number, where a VALID number is such as datatype(number) = "NUM".
a)  2e is scanned as number 2 followed by symbol E because datatype(2e) is CHAR, not NUM. So only 2 is a VALID number.
    In official ooRexx, this is scanned as symbol 2E.
b)  2e+ is scanned as number 2 followed by symbol E followed by operator +.
    In official ooRexx, this is scanned as symbol 2E followed by operator +.
c)  2e1 is scanned as number 2E1, same as official ooRexx.
d)  2e+1 is scanned as number 2E+1, same as official ooRexx

An abuttal operator is inserted to re-concatenate <number> with <after number>.
In this context, the precedence of this abuttal operator is very high, to ensure both tokens are always linked together.

The end-user can provide his own implementation for abuttal, using the alternative operator's message "OP:RIGHT".
This is how 2i can become 2 * .Complex~i when complex.cls is loaded.
Thanks to the high precedence in this context, 1+2i is parsed as 1+(2i) instead of (1+2)i.

Legacy programs are impacted when
a)  <after number> is a valid variable symbol and the NOVALUE condition is enabled.
b)  A label starts with a number:
    raise 2a                    -- Data must not follow the SIGNAL label name; found ""
    2a:                         -- Incorrect expression detected at ":"
    do i=1 to 5; say i; end 2a  -- Data must not follow the END control variable name; found ""
The case b) can be probably supported. Before raising the syntax error, check if the next token
is an abuttal followed by a symbol. If yes then the parser can rebuild the original label.


===============================================================================
2016 dec 26

Summary of the changes made since 2016 may 29, not yet listed.

Compatibility with classic rexx
-------------------------------

Add support for variables # @ $ Â¢
Add support for assignment V=   -- assign ""

Create a script to execute the classic rexx scripts of Rosetta code:
RosettaCodeData.rex
The solutions are installed locally from https://github.com/acmeism/RosettaCodeData

Take note of a problem with BIF center and UTF-8 string.
Error 40.23: CENTER argument 3 must be a single character; found "â•".
Here, "â•" is the Unicode character BOX DRAWINGS DOUBLE HORIZONTAL, encoded E2 95 90 in UTF-8.
I would like an intelligent support of UTF-8 here.
The length in grapheme is 1, the interpreter should not complain, even if the length in bytes is <> 1.


Extensions
----------

Add user-storage at object level.
.Object~setUserData
.Object~getUserData

Blocks: the security manager is inherited from the toplevel source.
First need in ooRexxShell, where the external command "xcommand" in the expression
{ {"xcommand"}~() }~()
must be trapped by the security manager.
[update 2021 feb 23]
By default, the commands are deactivated in a block.
Must explicitely activate the commands.
{ {options "commands"; "xcommand"}~() }~()


ooRexxShell
-----------

Add query ?r[outines]

Add option to display the source of methods/routines/packages
?cms    ?classes.methods.source
?cmis   ?classes.methods.inherited.source
?ms     ?methods.source
?ps     ?packages.source
?rs     ?routines.source

string2args : returns an array of Argument instances.
An Argument instance provides the start/end position in the container string,
and a string of flags 0/1 per character. When "1", the character is part of a
quoted chunk. This flag is used to decided if a character can be a special
character.
-- Ex:
-- 11111111111111111111111111 222222222222222 333333333333333333333
-- "hello "John" how are you" good" bye "John "my name is ""BOND"""
-- 0000000001111111111222222222233333333334444444444555555555566666
-- 1234567890123456789012345678901234567890123456789012345678901234
-- arg1 = |hello John how are you|      containerStart = 01      containerEnd = 26      quotedFlags = 1111110000111111111111
-- arg2 = |good bye John|               containerStart = 28      containerEnd = 42      quotedFlags = 0000111110000
-- arg3 = |my name is "BOND"|           containerStart = 44      containerEnd = 64      quotedFlags = 11111111111111111

Queries: The character "*" has a special meaning when first or last character,
and not quoted:
    * or **        : matches everything
    "*" or "**"    : matches exactly "*" or "**"
    *"text"*       : matches all names containing "text"
Examples:
?c bsf                          display the classes whose id is "bsf" (caseless)
?c *bsf*                        display the classes whose id contains "bsf" (caseless)

Queries: If the package regex.cls is available, then the patterns starting with
"/" are regular expressions.
?c /.*bsf.*                     display the classes whose id contains "bsf" (caseless) (regular expression)
?c == /^.M                      display the mixin classes : all lines where 2nd character is "M".
?m /.*left.*                    display the methods whose name contains "left" (caseless) (regular expression)
?m =/^...----                   Display the hidden methods: all lines containing "----" from 4th character.
?m \== /^.....G == (REXX)       Display the methods not guarded whose package is REXX:
                                all lines where 6th char <> "G" and which contains "(REXX)".


Indeterminate
-------------

Added support for indeterminate.
Any calculation with inderminate returns inderminate.
2*(indeterminate+1)+6=              -- (Indeterminate)


Infinity
--------

When a calculation with infinite is undefined, then the result is indeterminate:
complexInfinity + any infinity      -- (Indeterminate)
complexInfinity - any infinity      -- (Indeterminate)
infinity + -infinity                -- (Indeterminate)
infinity - infinity                 -- (Indeterminate)
infinity ** 0                       -- (Indeterminate)
infinity / infinity                 -- (Indeterminate)
infinity ** complexInfinity         -- (Indeterminate)
infinity ** 0                       -- (Indeterminate)
any ** complexInfinity              -- (Indeterminate)
1 ** infinity                       -- (Indeterminate)


m17n
----

Simplification of the STRONG_TYPES:
No need to make a distinction between signed and unsigned size.

Unplug the Parrot implementation.
Replaced by utf8proc (http://julialang.org/utf8proc/), not yet plugged.

MutableBuffer no longer in scope.
Managing multibyte characters while filling the buffer would be too costly.


GC
--

Some new ProtectedObject
RexxActivation.cpp      RexxActivation::processTraps    conditionObj
RaiseInstruction.cpp    RexxInstructionRaise::execute   rc


Other
-----

Apply fix for SVN bug #1402
// there is a subtle interaction between native and rexx activations when
// native calls make calls to APIs that in turn invoke Rexx code.  When conditions
// occur and the stack is being unwound, the ApiContext destructors will release
// the kernel access, which can leave us with no active Activity.

While working on this bug, I discover that the interpreter is client of his external API:

StreamNative.cpp
RexxMethod3(int, stream_lineout, CSELF, streamPtr, OPTIONAL_RexxStringObject, string, OPTIONAL_int64_t, position)
int StreamInfo::lineout(RexxStringObject data, bool _setPosition, int64_t position)
...
    const char *stringData = context->StringData(data);
    size_t length = context->StringLength(data);
...

These calls seems rather costly in term of performance.
Any API entry starts with
    ApiContext context(c);
    which calls:
        activity->enterCurrentThread();
            requestAccess();
On return from the API entry, the destructors calls:
    activity->exitCurrentThread();
        releaseAccess()


===============================================================================
2016 oct 11

Generator : provide the option ~stack for a better control of the stack size in case of recursion.
Before the change, the stack size was arbitrarily 3 when the option ~detectCycles was not used.
Now the default stack size is 0. That brings a good optimization.

Benchmark, repeated 6 times:
g=0~generate{depth}~stack(0)~recursive("b"); do 100000; g~(); end      8   8   8   8   8   8
g=0~generate{depth}~stack(1)~recursive("b"); do 100000; g~(); end     20  22  24  29  27  27
g=0~generate{depth}~stack(2)~recursive("b"); do 100000; g~(); end     20  30  30  28  28  28
g=0~generate{depth}~stack(3)~recursive("b"); do 100000; g~(); end     14  18  21  29  29  29
g=0~generate{depth}~stack(10)~recursive("b"); do 100000; g~(); end    14  27  30  29  29  29
g=0~generate{depth}~stack(100)~recursive("b"); do 100000; g~(); end   15  26  40  41  42  42


===============================================================================
2016 oct 09

Generator : don't yield when no result if this is the last yield before end.
This is similar to the behavior of Coactivity, see yieldLast.
Not applicable when iterating over a supplier (options iterateBefore, iterateAfter).
Ex :
--applicable: the last execution returns no result, we are not iterating over a supplier
1~generate{}~iterator~each=                         -- empty array instead of [.nil]
1~4~generate{if item//2=1 then item}~iterator~each= -- [1,(The NIL object),3,(The NIL object)]
-- not applicable: we are iterating over a supplier. For 2 and 4, there was a yield of "no result", and the last one is not discarded.

This decision was taken while playing with executor to see how to split a string in substrings of 3 characters.
The string below, when encoded in UTF-8, is made of 3 bytes per character.
Before applying the change, the first one-liner returned an array of 8 items, because the last one was .nil (because of the last yield).
'ã“ã‚“ã«ã¡ã¯ä¸–ç•Œ'~generate{if depth==0 then item; else do; item = item~substr(4); if item <> "" then item; end}~recursive~each{item~left(3)}~iterator~each=
'ã“ã‚“ã«ã¡ã¯ä¸–ç•Œ'~pipe{{::co expose item; loop while item <> "";call yield item~left(3); item=item~substr(4);end}}~iterator~each=
After the change, both one-liners return ['ã“','ã‚“','ã«','ã¡','ã¯','ä¸–','ç•Œ']


===============================================================================
2016 may 29

Summary of the changes made since the previous entry.

ooRexxShell
-----------

Bypass a bug in official ooRexx which delegates to system() when the passed address is bash.
The bug is that system() delegates to /bin/sh, and should be called only when the passed address is sh.
Because of this bug, the readline procedure (which depends on bash) is not working and must be deactivated
when the interpreter is the official ooRexx.

Security manager: optimization
It's no longer mandatory to implement all the methods of a security manager.
When a check is not needed, just don't provide the corresponding method.
That can reduce drastically the number of security checkpoint messages sent by the interpreter.
Example:
do 1000000;x=.true;end   -- 5.440 sec (before the optimization)
do 1000000;x=.true;end   -- 0.300 sec (now, with the optimization)
It's possible to still do better, that will be the next optimization to apply to ExpressionDotVariable.
Should be as fast as
do 1000000;x=1;end       -- 0.080 sec
by calculating at parse-time the value of the predefined variables like .true, .false, .nil
and the value of the predefined classes like .object, .class, .string, etc...

Predefined queries allow to get the list of classes, methods, packages.
A first level of filtering is done when specifying class names or method names.
If the package regex.cls is available, then the names are regular expressions.
Otherwise the names are just string patterns.
A second level of filtering is possible at output line level.


Complex numbers
---------------

Use request("complex") instead of .complex~convert.
This is the technique recommended by the ooRexx reference documentation.
But... it doesn't work when added by extension to the class String:
    1~makeComplex returns a complex (good)
    1~hasmethod("makecomplex")= returns .true (good)
    1~request("complex") doesn't work, returns .nil (not good --> fixed).
The implementation of RexxObject::requestRexx has been modified.
    old: RexxMethod *method = this->behaviour->methodLookup(make_method);
    now: RexxMethod *method = this->instanceMethod(make_method);
Behind the scene, "1" is an instance of RexxInteger. The method "makecomplex"
added by extension on String does not exist in the behaviour table of RexxInteger.
When using instanceMethod, the interpreter automatically forward to the string
representation when a method is not found :
return stringValue()->instanceMethod(method_name);


Infinity
--------

Added support for calculations.
1 + infinity = infinity (first need for the array~depth method).
infinity < 1 = .false (first need for depth of element-wise operations).
And other arithmetic operators...


Multiple extensions of operators on String
------------------------------------------

[JLF 2017 feb 22]
<<
This technique of dispatching from String is abandonned.
Was needed to support the constants i, infinity, indeterminate.
Now using novalue to get default values for i, infinity, indeterminate.
These default values are instances of .Complex, .Infinity, .Indeterminate
instead of being an instance of .String.
>>


Both Complex and Infinity define extensions on String.
The interpreter send messages for alternative operators to String.
The dispatching to Complex & Infinity is hardcoded in string.cls.
Example:
::method "+op:right"
    forward continue class (.complexString)
    if var("result") then return result
    forward class (.infinityString)
Initially, I wanted to put the dispatching inside the interpreter, by iterating
over the mixin classes inherited by String.
But after thoughts, I realize it's better to keep the dispatching in the user code.
Currently, String inherit from more than 10 mixin classes :
    StringDoer
    StringFilter
    StringIterator
    StringReducer
    StringGenerator
    StringMapper
    StringHelpers
    RepeaterCollector
    RepeaterGenerator
    LogicalExtension
    EncodedString
    OperatorDispatcher : mixin providing an extension of operators for dispatching.
    ComplexString : mixin providing an extension of operators for complex numbers.
    InfinityString : mixin providing an extension of operators for infinity.
Dispatching to all these mixin classes would be costly.
Dispatching to only 2 mixin classes is better.


Alternative operators for comparisons
-------------------------------------

[JLF 2017 sep 23]
<<
The constants i, infinity and indeterminate are now evaluated as instances of
specifc classes, not as strings.
Probably to undo:
- Sending an alternative message before a number is converted to a string.
Probably to keep:
- Sending an alternative message before an object is converted to a string.
>>

In short :
A message for alternative comparison can be sent when two strings are compared.
A string can be a RexxInteger or a RexxNumber or a RexxString.
This message is sent BEFORE a string comparison happens (i.e. before a number or
an object is converted to a string).
If no alternative operator, or no result returned then do a string comparison.
integer op integer      not impacted                    1 < 10
integer op number       not impacted                    1 < 1e20
integer op other        try alternative operator        1 < infinity            -- "INFINITY"~"<OP:RIGHT(1)
number op number        not impacted                    1e20 < 1e19
number op other         try alternative operator        1e20 < infinity         -- "INFINITY"~"<OP:RIGHT(1E20)
string op number        try alternative operator        infinity < 1            -- 1~"<OP:RIGHT"("INFINITY")
string op string        not impacted                    infinity < pi           -- true (yes... string comparison)
string op other         try alternativeOperator         infinity < -infinity    -- (The negative infinity)~"<OP:RIGHT("INFINITY")

Modification of the following methods to give a chance for an alternative operator
before promoting the first argument from an integer|number to a string,
or before requesting a string:
    RexxInteger::comp               RexxNumberString::comp              RexxString::comp
    RexxInteger::equal              RexxNumberString::equal             RexxString::equal               non-strict =
    RexxInteger::notEqual           RexxNumberString::notEqual          RexxString::notEqual            non-strict \=
    RexxInteger::isGreaterThan      RexxNumberString::isGreaterThan     RexxString::isGreaterThan       non-strict >
    RexxInteger::isLessThan         RexxNumberString::isLessThan        RexxString::isLessThan          non-strict <
    RexxInteger::isGreaterOrEqua    RexxNumberString::isGreaterOrEqual  RexxString::isGreaterOrEqual    non-scrict >=
    RexxInteger::isLessOrEqual      RexxNumberString::isLessOrEqual     RexxString::isLessOrEqual       non-strict <=

Evaluation of the expression (1 > -infinity) :
    1 is a RexxInteger.
    -infinity is evaluated as .infinity~negative.
    RexxInteger::comp
        Since .infinity~negative is not a RexxInteger, 1 is promoted to a RexxNumberString.
    RexxNumber::comp
        Since .infinity~negative is not a RexxNumberString, 1 is promoted to a RexxString.
    RexxString::comp
        A string comparison would return .false: "1" > "The negative infinity".
        But thanks to the alternative operator, the result is correct:
        .infinity~negative~">op:right"(1)= -- .true

Evaluation of the expression (infinity > 0) :
    infinity is a RexxString.
    1 is a RexxInteger.
    RexxString::comp (standard ooRexx)
        If both arguments can be converted to a number then do a numeric comparison
        otherwise do a string comparison.
        -->
        A string comparison would be done: "infinity" > "1"
    RexxString::comp (executor)
        Try the alternative operator
        when only one of the arguments can be converted to a number.
        when none of the arguments can be converted to a number and the right argument is not a string.
        -->
        An alternative operator is used: 1~">OP:RIGHT("INFINITY")


Array programming
-----------------

Methods added to Object:

rank
    APL Râ†â´â´Y
    An array may have 0 or more axes or dimensions.
    The number of axes of an array is known as its rank.
    An array with 0 axes (rank 0) is called a scalar
    An array with 1 axis (rank 1) is called a vector.
    An array with 2 axes (rank 2) is called a matrix or table.
    An array with 3 axes (rank 3) is called a cube.
    An array with more than 2 axes is called a multi-dimensional array

    ooRexx:
    Any object other than an array is a scalar.
    In particular, a string is a scalar, not an array as in APL.
    Special case which does not exist in APL : The rank of an array with no dimension yet assigned is -1.

shape
    APL Râ†â´Y (Rho)
    The shape of a scalar is an empty vector []
    The shape of an array is an array which gives the size of each dimension.
    The display of the shape has been reworked: no longer NxMx... because was not adapted to the case rank=0.
    .array~new  -- an Array (no shape, 0 items)                 rank=-1
    a()         -- an Array (shape [], 0 items)         scalar  rank=0
    a(0)        -- an Array (shape [0], 0 items)        vector  rank=1
    a(3,2)      -- an Array (shape [3,2], 0 items)      matrix  rank=2
    a(3,2,1)    -- an Array (shape [3,2,1], 0 items)    cube    rank=3

reshape
    APL Râ†Xâ´Y (Rho)
    args : new dimension(s)

depth
    APL Râ†â‰¡Y (Equal Underbar)
    Depth (â‰¡) indicates the degree of nesting within an array.
    It returns a non-negative integer which defines the maximum number of levels
    of structure to be penetrated in order to get to a simple scalar where simple means non-nested.
    The depth of an array is 1 greater than that of its most deeply nested item.
    Returns "infinity" when the array is self-referencing.

enclose
    (this method replaces ~isBoxed which is removed)
    APL Râ†âŠ‚Y (Left Shoe)
    If Y is a simple scalar, R is the simple scalar unchanged.
    Otherwise, R has a depth whose magnitude is one greater than the magnitude of the depth of Y.

disclose
    APL Râ†âŠƒY (Right Shoe)
    Disclose is the inverse of Enclose.

Element wise calculations can be limited to a given depth.

Examples:
v1=v(1,2)
v2=v(3,4)
v3=v(3,4,5)
v1+v2=                  -- [4,6]
v1+v3=                  -- error: Shapes are not equal
v1~enclose+v2=          -- [<[4,5]>,<[5,6]>]
v1~enclose+v3=          -- [<[4,5]>,<[5,6]>,<[6,7]>]
v1+v2~enclose=          -- <[4,5]>,<[5,6]>]
v1+v3~enclose=          -- [<[4,5,6]>,<[5,6,7]>]
v1~enclose+v2~enclose=  -- error Element-wise operation does not support two enclosed arrays
                        -- (probably to support, Dyalog APL supports it)


===============================================================================
2015 dec 21

RexxBlock: The removal of {::method...} allows more simplifications.

Remove tag ::closure.
The existence of an expose clause is enough to know that the block is a closure.
{::closure expose ...} --> {expose ...}

Remove option .coactive.
{::routine.coactive ...}        --> {::coactivity ...}
{::closure.coactive expose ...} --> {::coactivity expose ...}


===============================================================================
2015 dec 6

Add by extension the method "unknown" to the class .Object:
::extension Object
::method unknown unguarded
    use arg msg, args
    raise syntax 97.1 array(self, msg)

With this extension, I can forward the message "unknown" to the class (super).
Without this extension, I have a stack overflow.

First needed for the implementation of 1~10 --> 1~upTo(10):
::class RepeaterCollector
::method unknown unguarded
    use arg msg, args
    if self~dataType("N"), msg~dataType("N") then do
        if msg >= self then return self~sendWith("upto", args~~insert(msg, .nil))
        else return self~sendWith("downto", args~~insert(msg, .nil))
    end
    forward class (super)


===============================================================================
2015 dec 5

Remove support of {::method...}
After 4 years, I never needed a method as a block.

The decision has been taken after investigating how to remove the source transformation
at run-time (functionDoer). I will probably add support for implicit arguments, whose
name is given by the caller. The instruction "use implicit" will be injected at parse-time
in all block sources. Since the callee has no control over the names given by
the caller, there was a risk to break encapsulation when the callee is a method
which exposes some attributes. The caller could assign a value to any exposed
variable, just by passing the variable name as implicit name.
[update 2021 feb 23]
I had the problem with a closure, where the block becomes a method of the closure.
Now, when a variable has a value, it's not possible to overwrite this value using
an auto named argument.


===============================================================================
2015 nov 15

More work on ~upTo ~downTo

When the count is negative then only the last -count elements are generated.
Ex :
0.3~4.3(0.7, -5)=  -- [1.0,1.7,2.4,3.1,3.8]

The setting of numeric digits is adjusted to ensure a correct progression.
[2020 nov 14] This algorithm has been replaced by a more efficient calculation of the precision.
Algorithm:
    loop
        if from + step - from = step & limit + step - limit = step then leave
        numeric digits digits() + digits() % 2
    end
Ex:
1~20000000000(0.000000127, 3)=     -- [1,1.000000127,1.000000254]
1~20000000000(0.000000127, -3)=    -- [19999999999.999999681,19999999999.999999808,19999999999.999999935]

[update 2022 May 08] No longer pass the argument digit, because now propagating the setting
[deprecated] The value of digits() is passed as argument digits to the doer.
[deprecated] That allows to declare the same setting in the context of the doer, if needed.
[deprecated] Reminder: by default, the setting of numeric digits is 9 inside the doer (standard ooRexx setting).
Ex:
do i=10 to 100 by 10; n="1e"i; n~upto(n,,1){say "digits="digits() "item="item~format(,,3,0) "item="item}; end
digits=11 item=1E+010 item=10000000000
digits=21 item=1E+020 item=100000000000000000000
digits=31 item=1E+030 item=1000000000000000000000000000000
digits=41 item=1E+040 item=10000000000000000000000000000000000000000
digits=51 item=1E+050 item=100000000000000000000000000000000000000000000000000
digits=61 item=1E+060 item=1000000000000000000000000000000000000000000000000000000000000
digits=71 item=1E+070 item=10000000000000000000000000000000000000000000000000000000000000000000000
digits=81 item=1E+080 item=100000000000000000000000000000000000000000000000000000000000000000000000000000000
digits=91 item=1E+090 item=1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
digits=101 item=1E+100 item=10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000


===============================================================================
2015 nov 15

.array~of(1,2,3,4)~~insert(0,.nil)=
Crash --> fixed.


.numberString~upTo
.numberString~downTo
.numberString~numberString
Modified to support all the possibilities of controlled loop:
r=.array~new; loop i=0.3 to 4.3 by 0.7 for 5; r~append(i); end; r= -- [0.3,1.0,1.7,2.4,3.1]
The same loop:
0.3~upTo(4.3, 0.7, 5)=  -- [0.3,1.0,1.7,2.4,3.1]
0.3~4.3(0.7, 5)=        -- [0.3,1.0,1.7,2.4,3.1]


Complex numbers:
Add support for notation a+bi where a and b are numbers.
i+1 did not trigger the execution of "+op:right"
It's because 1 is a RexxIntegerClass whose behaviour can't be extended with ::extension.
By sending the alternative message "+op:right" to the string associated to the RexxIntegerClass then it works.
This is already what's done by the interpreter for the unknown message.

Complex numbers:
Add support for unary operator + -
The message "+op:right" can't be sent because there is no right operand.
+i --> the message "+op:left" is sent by the interpreter.
-i --> the message "-op:left" is sent by the interpreter.


===============================================================================
2015 nov 12

Optimize the method .array~of (instance level).
No longer support the APL-like notation.
Benchmark array initializer

do 10000; a(9)~fill(1); end
0.04

do 10000; a(3,3)~fill(1); end
0.04

do 10000; a(9)~of(1); end
0.12s (0.095 after removing the support of space-separated list)

do 10000; a(3,3)~of(1); end
0.12s (0.095 after removing the support of space-separated list)

do 10000; a(9)~of(1,2,3); end
0.37s

do 10000; a(3,3)~of(1,2,3); end
7.5s (strange... sometimes 10s)
0.89 after removing the blocks...
The fact I call directly blocks in this method is a problem for this kind of benchmark...
I have in project to transform the block sources at parse-time...


===============================================================================
2015 nov 11

Array programming:

Helper to create a vector: v(e1, e2, ..., eN)
v(1,"text", 1.5, v(),,v(-4,3) )=    -- [1,'text',1.5,(an Array 0),..,[-4,3]]

Helper to create an empty dimensionned array: a(d1, ..., dN).
a(3)        -- [..]
a(3,2)      -- type: The Array class: (shape 3x2, 0 items)
a(3,2,1)    -- type: The Array class: (shape 3x2x1, 0 items)

Array initializer: Renamed the implicit parameters passed to a doer.
"integerIndex" --> "item"
"arrayIndex"   --> "index"
When the rank is 1, the index is an integer.
    Invariant: index == item.
    Example:
    a(10)~of{item}=     -- [1,2,3,4,5,6,7,8,9,10]
    a(10)~of{index}=    -- [1,2,3,4,5,6,7,8,9,10]
When the rank is > 1, the index is an array [i1,i2,...,iRank].
    Invariant:  1 + rank**(rank-1)*(i1-1) + rank**(rank-2)*(i2-1) + ... + rank**(0)*(iRank-1) == item
    Example:
    The reduce calculates 2 values for each index.
    The 1st value is the expression as a string.
    The 2nd value is the calculation of the expression.
    [JLF 2016 apr 14] Next line no longer works because the implicit parameter 'array' is no longer passed.
    a(2,2,3)~of{index~reduce(v("1",1)){::closure expose array ; r=array~rank ; e=r-index ; v(accu[1] "+" "("r"**"e")*("item"-1)", accu[2] + (r**e)*(item-1))}}
        type: The Array class: (shape 2x2x3, 12 items)
        [1,1,1] : ['1 + (3**2)*(1-1) + (3**1)*(1-1) + (3**0)*(1-1)',1]
        [1,1,2] : ['1 + (3**2)*(1-1) + (3**1)*(1-1) + (3**0)*(2-1)',2]
        [1,1,3] : ['1 + (3**2)*(1-1) + (3**1)*(1-1) + (3**0)*(3-1)',3]
        [1,2,1] : ['1 + (3**2)*(1-1) + (3**1)*(2-1) + (3**0)*(1-1)',4]
        [1,2,2] : ['1 + (3**2)*(1-1) + (3**1)*(2-1) + (3**0)*(2-1)',5]
        [1,2,3] : ['1 + (3**2)*(1-1) + (3**1)*(2-1) + (3**0)*(3-1)',6]
        [2,1,1] : ['1 + (3**2)*(2-1) + (3**1)*(1-1) + (3**0)*(1-1)',10]
        [2,1,2] : ['1 + (3**2)*(2-1) + (3**1)*(1-1) + (3**0)*(2-1)',11]
        [2,1,3] : ['1 + (3**2)*(2-1) + (3**1)*(1-1) + (3**0)*(3-1)',12]
        [2,2,1] : ['1 + (3**2)*(2-1) + (3**1)*(2-1) + (3**0)*(1-1)',13]
        [2,2,2] : ['1 + (3**2)*(2-1) + (3**1)*(2-1) + (3**0)*(2-1)',14]
        [2,2,3] : ['1 + (3**2)*(2-1) + (3**1)*(2-1) + (3**0)*(3-1)',15]


.array~lefElementWise: supports doers of any kind, not just messages.

===============================================================================
2015 nov 08

Shorter notation for upTo and downTo:
1~10 -- same as 1~upTo(10)      [1,2,3,4,5,6,7,8,9,10]
10~1 -- same as 10~downTo(1)    [10,9,8,7,6,5,4,3,2,1]
An action can be specified:
100.5~103.6{value item}= -- ['VALUE 100.5','VALUE 101.5','VALUE 102.5','VALUE 103.5']

Array programming:
Fix the representation of sparse array (a final '..' was inserted when not needed).
Fix the calls to rightElementWise. There is no parameter letfArgIsProvided.


===============================================================================
2015 oct 23

Array operators:
All the operators support recursive arrays.
An array can be declared boxed.
A boxed array is handled as a whole when the other argument of a binary operator is also an array.

Ex:
a = .array~of(1,2,3)
b = .array~of(10,20,30)
a+b= -- [11,22,33]
b~isBoxed = .true
a+b= -- [[11,21,31],[12,22,32],[13,23,33]]


===============================================================================
2015 oct 22

Array operators:
Add support for recursive arrays.
Work in progress... Only "+" and "-" have been adapted.

Ex:
a = .array~of(1,2)
a~append(a)
a=     -- [1,2,*0]
-a=    -- [-1,-2,*0]
a+1=   -- [2,3,*0]
1+a=   -- [2,3,*0]


===============================================================================
2015 oct 20

Sparse arrays in condensed mode: display .. when a section is empty.
.array~new(1)= -- [..]
.array~new(10)= -- [..]
.array~new(20)~of{if integerIndex // 2 == 0 then integerIndex}= -- [..,2,..,4,..,6,..,8,..,10,..,12,..,14,..,16,..,18,..,20]
.array~new(20)~of{if integerIndex // 3 == 0 then integerIndex}= -- [..,3,..,6,..,9,..,12,..,15,..,18,..]
.array~new(20)~of{if integerIndex // 4 == 0 then integerIndex}= -- [..,4,..,8,..,12,..,16,..,20]


pipe.rex
dataflow_representation now supports only array of dimension 1.
Arrays with 2 dimensions or more are represented as an object Array : "an Array 2x3"


===============================================================================
2015 sept 13

GC review
stringArgument can return a new string
which should be protected
--> review all the calls of stringArgument : done

idem optionalStringArgument : done
idem ->requiredString : done
idem requiredStringArg : no problem, stored in expression stack
idem required_string : no problem, stored in expression stack
idem requestArray : done
idem REQUEST_ARRAY : done
idem makeArray : done


===============================================================================
2015 may 16

Start working on a prototype for encoded strings.
This prototype will be only Rexx code, there is no need to modify the interpreter.
The changes I made on the interpreter years ago (adding an encoding to the String
class) is not used because
ABANDONNED: I will need more than one encoding per string...
NEW: the encoding is stored on the Text associated to the string.

I will manage this additional information with Rexx code, thanks to the extensions
mechanisms.

See "Thoughts on ooRexx and Unicode.odt", in particular the conclusion of the
first chapter, page 6.

Main ideas explored with this prototype :
- No automatic conversion to Unicode by the interpreter.
- The strings crossing the I/O barriers are kept unchanged.
- ABANDONNED: A string is made of slices, where each slice has its own encoding.
- Supported encodings : byte, UTF-8, UTF-16.
- When no encoding has been explicitely specified, a default encoding is used.
- Initially, the default encoding is "byte". It can be changed at anytime.
- ABANDONNED: Strings with different encodings can be concatenated, there is no need of conversion.
  NEW: Strings with different encodings can be concatenated if their encodings are compatible.
       Example: a byte-encoded string containing only ASCII characters is compatible with UTF-8.
       If not compatible then an error is raised.
- The existing String class is kept unchanged, but its semantic becomes : "byte-oriented".
- The prototype will add a layer of services working at grapheme level, provided by the Text class.
- The Text class works on the bytes managed by the String class.
- String instances are immutable, the same for Text instances.

On my Mac, where locale returns :
    LANG="fr_FR.UTF-8"
    LC_COLLATE="fr_FR.UTF-8"
    LC_CTYPE="fr_FR.UTF-8"
    LC_MESSAGES="fr_FR.UTF-8"
    LC_MONETARY="fr_FR.UTF-8"
    LC_NUMERIC="fr_FR.UTF-8"
    LC_TIME="fr_FR.UTF-8"
    LC_ALL=

I get that under ooRexxShell :
s1 = "Ã©"
s1=                                 -- 'Ã©'
s1~length=                          -- 2
s1~c2x=                             -- C3 A9
combining_acute_accent = "cc81"x
s2 = "e" || combining_acute_accent
s2=                                 -- 'Ã©'
s2~length=                          -- 3
s2~c2x=                             -- 65 CC 81

My goal :
s1~text~length=                     -- 1 grapheme
s1~text~codepoints~count=           -- 1 codepoint
s1~text~string~length=              -- 2 bytes
s2~text~length=                     -- 1 grapheme
s2~text~codepoints~count=           -- 2 codepoints
s2~text~string~length=              -- 3 bytes

For a more complex example of combining characters, see
https://6guts.wordpress.com/2015/04/20/this-week-digging-into-nfg-fixing-use-fatal-and-more/

The ooRexx programmer has the choice :
- working with String at byte level
- working with Text at grapheme level.
- the same instance of String is used in both cases.

myString = "oÃ¹ as tu e" || .UTF8Encoding~character("combining acute accent") || "tÃ© ?"
myString=                       -- 'oÃ¹ as tu Ã©tÃ© ?'
myText = myString~text
myText=                         -- T'oÃ¹ as tu Ã©tÃ© ?'
myString~text == myText=        -- true, always return the same counterpart
myText~string == myString=      -- true, always return the same counterpart
myString~length=                -- 18
myText~length=                  -- 15

                                -- 1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18
myString~c2x=                   -- 6F C3 B9 20 61 73 20 74 75 20 65 CC 81 74 C3 A9 20 3F
                                -- o. Ã¹....  . a. s.  . t. u.  . e. acute t. Ã©....  . ?.

                                -- 1  2     3  4  5  6  7  8  9  10       11 12    13 14
myText~c2x=                     -- 6F C3B9  20 61 73 20 74 75 20 65 CC81  74 C3A9  20 3F
                                -- o. Ã¹...   . a. s.  . t. u.  . e. acut  t. Ã©...   . ?.


===============================================================================
2015 mar 8

Moved the implementation of the Y combinator from the class Doer to the class
RoutineDoer because, by definition, a combinator is a lambda with no free variable.
So can't be a message (not a lambda), nor a closure or method (can have free variables).
No reason to support the Y combinator on a coactivity, because only one result is
expected. So the only remaining candidate is a routine.


Added the implementation of the Y combinator with memoization.
::class RoutineDoer
::method YM unguarded
    use strict arg verbose=.false
    if verbose then trace i
    f = self -- to be closer to the notation (here, self is the routine to which the Y combinator is applied)
    table = .Table~new
    return {use arg a ; return a~(a)} ~ {
        ::closure expose f verbose table
        if verbose then trace i
        use strict arg x
        return f ~ { ::closure expose x verbose table
                     if verbose then trace i
                     use strict arg v
                     r = table[v]
                     if r <> .nil then return r
                     r = x~(x)~(v)
                     table[v] = r
                     return r}
    }

Application to fibonacci :
fibm = { use arg fib; return {::closure expose fib ; use arg n; if n==0 then return 0; if n==1 then return 1; if n<0 then return fib~(n+2) - fib~(n+1); return fib~(n-2) + fib~(n-1)}}~YM
fibm~(20) is calculated almost instantly,
whereas the not-memoizing version needs almost 30 sec.

Both Y and YM are subject to stack overflow.
But YM can be used by steps, to calculate very big fibonacci numbers, thanks to the memoization :
do i=1 to 100; say "fibm~("i*100")="fibm~(i*100); end
    fibm~(100)=3.54224847E+20
    fibm~(200)=2.80571176E+41
    fibm~(300)=2.22232246E+62
    ...
    fibm~(10000)=3.36447936E+2089
The first execution needs around 2.5 sec.
The following executions need less than 0.01 sec.


Added the method 'variables' to the class Closure,
which returns a directory of the variables captured by the closure.
Illustration after the calculation of fibm~(10000) :
fibm=
    (a RexxBlock)
fibm~executable=
    (a Closure)
fibm~executable~source=
    expose fib; use arg n; if n==0 then return 0; if n==1 then return 1; if n<0 then return fib~(n+2) - fib~(n+1); return fib~(n-2) + fib~(n-1)
fibm~executable~variables=
    type: The Directory class: (1 items)
    # 1: index='FIB' -> item=(a RexxBlock)
fibm~executable~variables["FIB"]~executable=
    (a Closure)
fibm~executable~variables["FIB"]~executable~source~each{say item}
    expose x verbose table
    if verbose then trace i
    use strict arg v
    r = table[v]
    if r <> .nil then return r
    r = x~(x)~(v)
    table[v] = r
    return r
fibm~executable~variables["FIB"]~executable~variables=
    type: The Directory class: (6 items)
    # 1: index='F'       -> item=(a Routine)
    # 2: index='SELF'    -> item=(a Closure)
    # 3: index='SUPER'   -> item=(The Doer class)
    # 4: index='TABLE'   -> item=(a Table (10000 items))
    # 5: index='VERBOSE' -> item=0
    # 6: index='X'       -> item=(a RexxBlock)
fibm~executable~variables["FIB"]~executable~variables["X"]~executable=
    (a Closure)
fibm~executable~variables["FIB"]~executable~variables["X"]~executable~source~each{say item}
    expose f verbose table
    if verbose then trace i
    use strict arg x
    return f ~ { ::closure expose x verbose table
                 if verbose then trace i
                 use strict arg v
                 r = table[v]
                 if r <> .nil then return r
                 r = x~(x)~(v)
                 table[v] = r
                 return r}
fibm~executable~variables["FIB"]~executable~variables["X"]~executable~variables=
    type: The Directory class: (5 items)
    # 1: index='F'       -> item=(a Routine)
    # 2: index='SELF'    -> item=(a Routine)
    # 3: index='SUPER'   -> item=(The Doer class)
    # 4: index='TABLE'   -> item=(a Table (10000 items))
    # 5: index='VERBOSE' -> item=0
fibm~executable~variables["FIB"]~executable~variables["X"]~executable~variables["F"]~source=
    use arg fib; return {::closure expose fib ; use arg n; if n==0 then return 0; if n==1 then return 1; if n<0 then return fib~(n+2) - fib~(n+1); return fib~(n-2) + fib~(n-1)}


===============================================================================
2014 may 29

The reading of https://github.com/raganwald-deprecated/homoiconic
brings interesting ideas to implement :
- Modify the implementation of ~pipe to support the T combinator
  thrush : Txy = yx : reverse evaluation.
  (makes an expression read consistently from left to right)
- Modify the implementation of ~pipe to support the K combinator
  kestrel : Kxy = x : return a constant function.
  (when no result returned by the doer, return the receiver (self))

Example without thrush :

Square (take the numbers from 1 to 100, select the odd ones, and take the sum of those).
{return arg(1) ** 2}~(1~upto(100)~select{item // 2 == 1}~reduce("+"))=
-- return 6250000

Same example with thrush :

Take the numbers from 1 to 100, keep the odd ones, take the sum of those, and then answer the square of that number.
Here, the block benefits from the implicit argument "item" and implicit return.
1~upto(100)~select{item // 2 == 1}~reduce("+")~pipe{item ** 2}=
-- return 6250000

Same example with kestrels, to log intermediate results :

1~upto(100)~select{item // 2 == 1}~pipe{say item~ppRepresentation}~reduce("+")~pipe{say item}~pipe{item ** 2}=
-- display [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63,65,67,69,71,73,75,77,79,81,83,85,87,89,91,93,95,97,99]
-- display 2500
-- return  6250000


===============================================================================
2014 apr 27

Merge revisions 9515-9978 from SourceForge main/trunk

Remove oodialog :
main/trunk/extensions/platform/windows/oodialog
main/trunk/samples/windows/oodialog


===============================================================================
2014 jan 26

[operator]
Finalization of the implementation of alternative operators.

Modification of the following methods to give a chance for an alternative operator
before forcing the second argument to a string :
    RexxInteger::concatBlank
    RexxInteger::concat
    RexxNumberString::concatBlank
    RexxNumberString::concat
    RexxString::concatRexx
    RexxString::concatBlank
If the second argument is not a string, then try the alternative operator before REQUEST_STRING.
    a = .array~of(10,20,30)
    100 a=                  -- ['100 10','100 20','100 30'] instead of '100 an Array'
    a 100=                  -- ['10 100','20 100','30 100']
    100 || a =              -- [10010,10020,10030]          instead of '100an Array'
    a || 100 =              -- [10100,20100,30100]

Modification of the following methods in CoreClasses.orx to give a chance for an alternative operator :
    .DateTime~"-"
    .DateTime~"+"
    .TimeSpan~"-"
    .TimeSpan~"+"
Illustration :
    ts1day = .TimeSpan~fromDays(1)                  -- (1.00:00:00.000000)
    ts1hour = .TimeSpan~fromHours(1)                -- (01:00:00.000000)
    date = .datetime~new(2013,1,10, 12, 30, 10)     -- (2013-01-10T12:30:10.000000)
    date + .array~of(ts1hour, ts1day)=              -- [(2013-01-10T13:30:10.000000),(2013-01-11T12:30:10.000000)]

Got a crash because I don't always return a value from an operator. In my approach of
operator overriding, not returning a value is the way to indicate that the current
implementation doesn't know how to support the current arguments. The lack of result is
managed in the new implementation of the operators, but is not managed in the rest of the
interpreter. The crash was here :
    bool RexxObject::isEqual(RexxObject *other)
    {
        ...
        else
        {
            ProtectedObject result;
            this->sendMessage(OREF_STRICT_EQUAL, other, result);
            return ((RexxObject *)result)->truthValue(Error_Logical_value_method);
        }
    }
result is NULL when the user code doesn't return a result, must be tested.
Review of all the sendMessage used internally by the interpreter, which need a test :
    RexxClass::isEqual
    RexxInteger::isEqual
    RexxNumberString::isEqual
    RexxObject::isEqual
    RexxString::hash
    RexxString::isEqual

Made a review of all my ooRexx scripts to swap the position of .nil in the tests, to
make it the first argument. Since I defined the array operators, I can have an array
as result for operators "=", "==", "<>", etc... when the first argument is an array.
Had to swap .nil in StreamClasses.orx.
Reminder : this technique of putting .nil as first argument is already used in several
places of the interpreter. The reason is explained in rexxref (section Required string
values) :
When comparing a string object with the Nil object, if the NOSTRING condition is being
trapped, then
    if string = .nil
will raise the NOSTRING condition, whereas
    if .nil = string
will not as the Nil objectâ€™s "=" method does not expect a string as an argument.

Previous work about swaping the position of .nil is not enough to avoid errors.
I have this case in pipe_extension_test.rex :
    datas = .directory~new
    datas["key1"] = .array~of("header", 1, 2, "footer")
    datas["key2"] = .array~of("header", 5, 3, -9, 12, "footer")
    datas["key3"] = .array~of("header", 4, 6, 5, "footer")
    -- The datas without the headers and footers
    datas~pipe(.inject {item} iterateBefore memorize | .drop first {dataflow["source"]~item } | .drop last {dataflow["source"]~item } | .console)
where the source of the pipe is a directory of arrays.
The code in charge of the partitioning do this test :
    if previousPartitionItem <> partitionItem then do
and an error is raised because the two arguments are array, and the result is an array.
Here, the goal is to test if the two arguments are the same object.
Conclusion :
The operators for array programming should be :
- either activated only when needed, under control of the programmer.
- or deactivated by the interpreter when the context is a scalar context (ex : when calling truthValue).
- or not defined at all when conflicting with the interpreter semantics.
I select the third option : no longer override the operators "=", "\=", "><", "<>", "==", "\==".
I provide the methods ~mapEqual, ~mapNotEqual, ~mapStrictEqual, ~mapStrictNotEqual.

Remember :
When operators for array programming are activated, the only way to use the scalar semantic
is to refer explicitly to the .Object's operators.
    a = .array~of(1,2,3)
    a == a=              -- [1,1,1]
    a~"=="(a)=           -- [1,1,1]
    a~"==":.object(a)=   -- 1 (not possible with ooRexx standard, see [method search order] on 2014 jan 06)

I have no problem with .array~ppRepresentation, whereas there is a test of equality to detect if a
recursive array is printed. Normally should raise an error because of "==" returning an array.
But it seems that 'level = stack~index(val)' is not impacted by the array operator "==".
Verification in the implementation :
    RexxObject *RexxQueue::index(RexxObject *target)
        uses : if (target->equalValue(element->value))
    class RexxObject : public RexxInternalObject {
         bool inline equalValue(RexxObject *other)
         {
             // test first for direct equality, followed by value equality.
             return (this == other) || this->isEqual(other);
         }
    bool RexxObject::isEqual( RexxObject *other )
    {
        if (this->isBaseClass()) return ((RexxObject *)this) == other;
        else  /* return truth value of a compare   */
        {
            ProtectedObject result;
            this->sendMessage(OREF_STRICT_EQUAL, other, result);
            if ((RexxObject *)result == OREF_NULL) reportException(Error_No_result_object_message, OREF_STRICT_EQUAL);
            return ((RexxObject *)result)->truthValue(Error_Logical_value_method);
        }
    }
So we have three cases for this test of equality :
a) If arg1 and arg2 are the same instance, then the equality is true
b) If arg1 is a base class (i.e. not a subclass instance or an enhanced one-off), then
   return true when arg1 and arg2 are the same instance.
c) return arg1~"=="(arg2)
Only a) and b) happen because my test is done with instances of .Array (so a base class).
That explains why I don't have an error...


[functional]
~downTo now always returns an array, like upTo.
The previous behaviour was to not return a result if the array of collected results was empty.


===============================================================================
2014 jan 15

[operator]
Change the naming convention of the alternate operator :
    "+OP:RIGHT"     -- plus
    " OP:RIGHT"     -- space
    "OP:RIGHT"      -- abbutal
    etc...

Add detection of no result : when the alternate operator returns nothing, then
don't complain about that. Behave as if the alternate implementation did not
exist, and raise the exception related to the left argument.

===============================================================================
2014 jan 14

[operator]
I had in mind to catch the exception Error_Conversion_operator raised by the
implementation of an operator, from RexxBinaryOperator::evaluate, and try an alternate
implementation. But that was difficult, because the interpreter unwinds a lot of things,
including the arguments stack. Moreover, raising an exception is costly, and I don't want
to reintroduce a loss of performance...
Finally, there is a more easy approach : if an alternate implementation exists then call it
otherwise raise the exception. That must be done in each implementation of operator.
The two methods Object::messageSend have been modified to let pass an additional parameter
'processUnknown' which is true by default (legacy behavior). When this parameter is false,
and no method is found for the message, then Object::messageSend returns false to indicate
that no implementation exists. There is no processing of the unknown message.
This is an efficient way to test if an alternate implementation exists and call it.

Example of alternative operator :

    ::class "ArrayOperators" mixinclass Object public

    ::method "+"
        if arg() == 0 then return self~map("+")
        use strict arg right
        if right~isA(.array) then do
            if \SameDimensions(self, right) then raise syntax 93.900 array("Dimensions are not equal")
            return self~map{::closure expose right ; item + right[index]}
        end
        return self~map{::closure expose right ; item + right}

    ::method "+op:right" -- JLF 15 jan 2014 : fixed the message name
        use strict arg left
        return self~map{::closure expose left ; left + item}


===============================================================================
2014 jan 12

[operator]
Performances are too bad... I give up the approach by routine overriding.
Two problems :
- must not override the optimized implementation of String (and hidden helper
  classes) operators.
- the search strategy of overriding routines was too costly, and not conform to
  the standard visibility rules of routines.
New approach :
- Use only methods to override operators.
- Modify the interpreter to automatically try b~"op:right"(a) when a~"op"(b) raises an exception


===============================================================================
2014 jan 06

[method search order]
Allow to modify the method search order from anywhere.
Before, was possible only from methods of the target object.
    .c1~new~m
    .c1~new~m:.c2 -- Now it's ok, interpreter modified to no longer raise :
                  -- Message search overrides can be used only from methods of the target object

    ::class c1 inherit c2
    ::method m
    say "c1::m"
    self~m:.c2

    ::class c2 mixinclass object
    ::method m
    say "c2::m"


[block]
Implement the functionality described in Q1 of entry 2013 sept 15 :
    Inherit the toplevel source options settings, when creating a method or routine for a block.
    No longer needed for the option OPERATOR_OVERRIDING_BY_ROUTINE (removed), but useful for the rest.
A new optional parameter isBlock can be passed when creating a method or routine :
    .Method~new("do", sourceArray, context, isBlock)
    .Routine~new("", sourceArray, context, isBlock)
This indicator is used to activate specific behaviour, like inheritance of toplevel source options.


[operator]
Remove the option OPERATOR_OVERRIDING_BY_ROUTINE.
Too complicated to manage that per package, will have to find another way to optimize.
For the moment, the search of overriding routines is done systematically when evaluating
a binary or prefix operator.


[operator]
Add more overloading of operators for array.
But not sure it's a good idea for some of them, like "||", " ", "".
I have an error
    Too many arguments in invocation of method; 0 expected
when running:
    d = .dataflow~create(.nil, "source", source, 1)
    say "dataflow="d
where the traceback is
   720 *-*     string = previous~makeString(mask, showPool, pool, values)" | "
       *-* Compiled method REQUEST with scope "Object"
   426 *-*   say "dataflow=".dataflow~create(.nil, "source", source, 1)
A dataflow is a subclass of array, and here the abbutal operator is used.
If I don't declare the operator "", then no error.
RexxInstructionAssignment::execute
    this->expression :
        RexxBinaryOperator
            this->left_term : RexxExpressionMessage "MAKESTRING", count=4
            this->right_term : RexxString " | "
RexxExpressionMessage::Evaluate
    this->target : RexxParseVariable variableName="PREVIOUS"
    the evaluation returns a RexxString "dataflow=The NIL object"
    and then the message MAKESTRING with 4 arguments is sent to this string
    hence the error... because
        in RexxObject::messageSend
            RexxMethod *method_save = this->behaviour->methodLookup(msgname)
            returns a CPPCode with cppEntry = {rexx.dll!RexxObject::makeStringRexx(void)}
                                   argumentCount = 0
        4 > 0 ==> error
In summary :
We have d = [(The NIL object),'source',1,'SOURCE']
This is an array of 4 items.
The 1st item (previous dataflow) is the .NIL object.
The expression "dataflow="d is evaluated ['dataflow=The NIL object', 'dataflow=source', 'dataflow=1', 'dataflow=SOURCE']
The 1st item is the string 'dataflow=The NIL object'.
The message MAKESTRING with 0 arguments is sent by the interpreter to ['dataflow=The NIL object', 'dataflow=source', 'dataflow=1', 'dataflow=SOURCE']
The implementation for .DataFlow is called.
This implementation do that :
    if previous <> .nil then string = previous~makeString(mask, showPool, pool, values)" | "
Since the previous element is not .NIL, the MAKESTRING with 4 arguments is sent to previous.
Boom!


===============================================================================
2013 dec 31

[functional]
Filtering with ~map ~mapR is now supported for collections.
The non-selected elements are removed, using the ~remove method.
Ex :
.environment~map{if item~class <> .class then item}=
    # 1: index=[ENDOFLINE]   -> item=["0D0A"x]
    # 2: index=[ENVIRONMENT] -> item=[The Environment Directory (66 items)]
    # 3: index=[FALSE]       -> item=[0]
    # 4: index=[LOCAL]       -> item=[The Local Directory (36 items)]
    # 5: index=[NIL]         -> item=[The NIL object]
    # 6: index=[SYSTEM]      -> item=[a Directory (3 items)]
    # 7: index=[TRUE]        -> item=[1]

Ex :
a=.array~new(2,3)~of{integerIndex}
a=
    # 1: index=[1,1] -> item=[1]
    # 2: index=[1,2] -> item=[2]
    # 3: index=[1,3] -> item=[3]
    # 4: index=[2,1] -> item=[4]
    # 5: index=[2,2] -> item=[5]
    # 6: index=[2,3] -> item=[6]
a~mapR{if item//2=0 then item} -- in place
a=
    # 1: index=[1,2] -> item=[2]
    # 2: index=[2,1] -> item=[4]
    # 3: index=[2,3] -> item=[6]


[rgf_util2]
No longer override pp2 in rgf_util2_wrappers.rex.
Better to modify this routine pp2 directly in my copy of rgf_util2.rex


===============================================================================
2013 nov 26

[doers]

~functionDoer and actionDoer have been modified to return directly the cached executable,
when already calculated. This is needed to support correctly this test case :
    g={::coactivity loop i=0; if i//2 == 0 then .yield[i]; else .yield[]; end}
    .array~new(2,3)~of(g)=
        # 1: index=[1,1] -> item=[0]
        # 2: index=[1,3] -> item=[2]
        # 3: index=[2,2] -> item=[4]
    .array~new(2,3)~of(g)=
        # 1: index=[1,1] -> item=[6]
        # 2: index=[1,3] -> item=[8]
        # 3: index=[2,2] -> item=[10]
Before that change, the second array had the same content than the first array, because
a new coactivity was created and stored in the cache when calling ~functionDoer from .array~of.
Note :
When called directly, ~sourceDoer is still applying the source transformations and
returns a new executable. There is no impact on the cached executable.


[rgf_util2]

Added the variable .local~rgf.showIdentityHash to control if the identity hash
is displayed or not.
Default value is false (not displayed).


===============================================================================
2013 nov 23

Add support for option guarded|ungarded in the declaration {::method...}
The need has been discovered while exploring this alternative implementation of
the methods ascendingItems and descendingItems in BinaryTree.cls :
    ::method ascendingItems
        -- return .Coactivity~new("visitAscending", , self~rootNode)
        return {::method.coactive self~rootNode~visitAscending}~doer(self)
    ::method descendingItems
        --return .Coactivity~new("visitDescending", , self~rootNode)
        return {::method.coactive self~rootNode~visitDescending}~doer(self)
With this test case :
    btree = .BinaryTree~of(4, 6, 2, 7, 5, 3, 1)
    ascending = btree~visitAscending
    descending = btree~visitDescending
    do btree~items
        say ascending~()
        say descending~()
    end
There is a deadlock when calling descending~() because the instance btree is locked
by the execution of ascending~().
The solution is to declare the coactive methods unguarded :
    return {::method.unguarded.coactive self~rootNode~visitAscending}~doer(self)

.Array alternative operators
Add implementation for * scalar multiplication.
Add implementation for / scalar division.
Add implementation for % scalar integer division.
Add implementation for // scalar remainder.

.Complex alternative operators
Add implementation for - scalar multiplication.
Add implementation for * scalar multiplication.
Add implementation for / scalar division.
Add implementation for % scalar integer division.
Add implementation for // scalar remainder.


===============================================================================
2013 nov 17

Merge revisions 9423-9515 from SourceForge main/trunk


===============================================================================
2013 sep 15

Merge revisions 8678-9423 from SourceForge main/trunk


===============================================================================
2013 sep 15

Creation of the branch block_closure.

Will be used to optimize the implementation of closures.
Currently, the instance of closure is created by user code in doers.cls.
See the method sourceDoer of RexxBlockDoer.
See the method init of Closure.
This is very inefficient implementation, to replace by a native (C++) implementation.

For the needs of operator overloadings, I have to bring an answer to question Q1 below.
I propose to inherit the options settings, when creating a method or routine for a block.
I will need to add an additional parameter isBlock to the constructor of a method/routine.
This code, currently in ::routine "+" in array.cls :
    return array~map{::closure expose scalar ; options "OPERATOR_OVERRIDING_BY_ROUTINE" ; item + scalar}
will become :
    return array~map{::closure expose scalar ; item + scalar}


Standard ooRexx behavior :
When a routine or method is created, a new RexxSource (i.e. a package) is created.
All the settings defined on the package level (i.e. RexxSource) have the default values.
It's possible to pass a context from which a RexxSource is taken (called parentSource) which
allows the created routine/method to inherit class and routine lookup scope from another source.
Nothing else is inherited.

[inherited from context]
    routines
    merged_public_routines
    installed_classes
    merged_public_classes
[currently never inherited from context]
    digits
    fuzz
    form
    trace
    enableCommands (sandbox only)
    enableMacrospace (sandbox only)
    enableOperatorOverridingByRoutine (sandbox only)
In the sandbox, the raw executable created from a RexxBlock is a routine or a method.
Given the rule explained above, this raw executable has its own RexxSource (i.e. package) :
    say .context~package~identityHash ; {say .context~package~identityHash}~() -- the hashes are different


Q1
Should a RexxBlock inherit the settings of the package in which it's defined ?
If yes, all kinds of RexxBlock or just ::closure RexxBlock ?
Currently, the visibility on routines/classes is inherited, but none of the following options are inherited :
    ::options digits
    ::options form
    ::options fuzz
    ::options trace
    ::options commands (sandbox only)
    ::options nocommands (sandbox only)
    ::options macrospace (sandbox only)
    ::options nomacrospace (sandbox only)
    ::options operator_overriding_by_routine (sandbox only)
    ::options nooperator_overriding_by_routine (sandbox only)
Illustration :
    say 1/3
    {say 1/3}~()
    ::options trace i
    ::options digits 20
    ::requires "extension/extensions.cls"
Output :
     1 *-* say 1/3
       >L>   "1"
       >L>   "3"
       >O>   "/" => "0.33333333333333333333"
       >>>   "0.33333333333333333333"
0.33333333333333333333
     2 *-* {say 1/3}~()
       >L>   "a RexxBlock"
0.333333333

[2014 jan 06] Q1 has been adressed:
Inherit the toplevel source options settings, when creating a method or routine for a block.


Q2
Same question for the settings of the RexxActivation in which the RexxBlock is evaluated.
Here, only a closure  is supposed to capture its environment.
Should a closure remember the following settings of its defining RexxActivation ?
The goal being to reuse automatically these settings at each execution (so from a different RexxActivation).
Currently, none of the following settings are captured :
    numeric digits
    numeric form
    numeric fuzz
    trace
    options "commands" (sandbox only)
    options "nocommands" (sandbox only)
    options "macrospace" (sandbox only)
    options "nomacrospace" (sandbox only)
    options "operator_overriding_by_routine" (sandbox only)
    options "nooperator_overriding_by_routine" (sandbox only)
Illustration :
    trace i
    numeric digits 20
    say 1/3
    {::closure say 1/3}~()
    ::requires "extension/extensions.cls"
Output :
     2 *-* numeric digits 20
       >L>   "20"
       >>>   "20"
     3 *-* say 1/3
       >L>   "1"
       >L>   "3"
       >O>   "/" => "0.33333333333333333333"
       >>>   "0.33333333333333333333"
0.33333333333333333333
     4 *-* {::closure say 1/3}~()
       >L>   "a RexxBlock"
0.333333333


===============================================================================
2013 sep 07

Implementation of operator overriding was not working for
    .array~of(1,2) + .complex[1,5]
This is because the search was limited to the requires order, which is :
    extensions.cls --requires--> array.cls
    extensions.cls --requires--> complex.cls
The package array.cls provides an implementation of "+", but does not requires complex.cls.
The package complex.cls provides an implementation of "+", but does not requires array.cls.
It was possible to make it work by adding extra requires :
    array.cls --requires--> complex.cls
    complex.cls --requires--> array.cls
but that's clearly not a good solution.

There is no direct call of a specific implementation of "+", we are in a case similar to
CLOS generic methods, or Clojure multimethods : dependency on a polymporphic "+", where
the polymorphism is not limited to the type of the first argument.

To solve this problem, the search strategy is modified :
From current activation, search for the oldest Rexx activation in the call stack.
Get the package of the oldest Rexx activation : oldest package
From the oldest package, search for a local routine having the operator name.
From the oldest package, search for a public imported routine having the operator name, in the requires order.

The execution strategy is unchanged :
iterate over the routines returned by the search strategy.
call the current routine.
if a result is returned then stop the iteration and return this result
otherwise contine the iteration.

Todo :
a) Modify the inheritance of context when creating an executable for a block.
b) Modify the execution strategy to no execute a given method several times.


===============================================================================
2013 sep 02

Operator overriding supports overriding per package.

Illustration :
array.cls defines operators for array and scalar.
complex.cls defines operators for complex number and not-complex number.
1 + .complex[1,5] =  -- 2+5i
.complex[1,5] + 1 =  -- 2+5i
1 + .array~of(1,2) = -- [2,3]
.array~of(1,2) + 1 = -- [2,3]

Todo :
a) Still not working : .array~of(1,2) + .complex[1,5]
   That's because the overriding in complex.cls is not visible from array.cls.
b) When iterating over imported packages, remember the already visited packages to not revisit a visited package.
c) Optimize the search of overriding routines. A table of operator overridings can be managed per package
   (similar to the table of operators managed on ObjectClass, StringClass, NumberStringClass, IntegerClass).
d) I see a strange behavior in relation with findRoutine and merged_public_routines : d::r called instead of c::r
   [later]
   ok, I understand now, the behavior is correct.
   Each package manages its own list of imported packages.
   See RexxSource::addPackage which updates the RexxList loadedPackages.
   When a package P2 is indirectly required by the package P1, then this package P2 is loaded by the interpreter instance,
   but not added to P1's loadedPackage.
   If later this package P2 is directly required by P1 (my test case below), then the interpreter instance returns
   the already loaded package P1 (so, no new elaboration) and the package P2 updates its list loadedPackage. There is also
   an update of the directory merged_public_routines.
e) I think that the fix of bug "#821 ::Routines cannot be called in mixed/lower case " does not respect the documentation.
   call "r" should not succeed in the test case below, because only "R" routines are registered.

----- a.rex -----
say "elaborate a"
call "r"
::requires b
::requires c
::requires d

----- b.rex -----
say "elaborate b"
::requires d
::routine r public
say "b::r"

----- c.rex -----
say "elaborate c"
::requires d
::routine r public
say "c::r"

----- d.rex -----
say "elaborate d"
::routine r public
say "d::r"

----- tests -----
if "requires d" is not used in a.rex :
elaborate d
elaborate b
elaborate c
elaborate a
c::r

if "requires d" is used in a.rex :
elaborate d
elaborate b
elaborate c
elaborate a
d::r               <-- ??? the elaboration order is unchanged, how is that possible to call a different implementation ?
                       [later]
                       The elaboration of a package is managed by the interpreter instance, which takes care to
                       load a package once, and return this same package if required several times.
                       Each package manages its own list of loadedPackage.
                       When a package P2 is indirectly required by the package P1, the list loadedPackage of P1 is not impacted.
                       But if the package P2 is directly required by P1, then the list loadedPackage of P1 is impacted.
                       This is what happens here :
                       - d is indirectly required by b --> elaboration of d
                       - d is directly required by a --> no elaboration because already loaded by the interpreter instance,
                         d is added to the list loadedPackage of a,
                         and the directory merged_public_routines is updated.


===============================================================================
2013 may 04

The overriding of binary operators by routine has an impact on performances.
The class String (behind the scene : StringClass, NumberStringClass, IntegerClass) has
a fast access to operators implementations (see callOperatorMethod and operatorMethods).
The overriding by routine replaces the fast access by a call to a routine, searched by name.
A new option has been added to control the activation of this overriding :
options "OPERATOR_OVERRIDING_BY_ROUTINE"
options "NOOPERATOR_OVERRIDING_BY_ROUTINE"
::options OPERATOR_OVERRIDING_BY_ROUTINE
::options NOOPERATOR_OVERRIDING_BY_ROUTINE
Unary operators can also be overriden by a routine.


===============================================================================
2013 may 03

Start working on alternative binary operators.
The idea is to let override binary operators using a routine which takes
two arguments (left, right) and decide which behavior to support, depending
on the types of both arguments.
Ex :
    1 + .array~of(10,20,30) --> [11, 21, 31]
If no overriding routine then fallback to the classic behaviour :
send message to left arg.


===============================================================================
2013 apr 13

[GC]
Fix crash due to unprotected object.
In ClassClass.cpp
method RexxClass::enhanced : enhanced_instance_mdict must be GC-protected.
method RexxClass::subclass : enhancing_class_methods must be GC-protected.


[build]
Add support for Visual C++ 2012, include debug info in release build.

The file AgtCtl_i.c is no longer delivered with Visual C++ 2012.
This file is needed to compile extensions\platform\windows\ole.
Workaround : copy this file from an older version of VC++, paste it in the ole directory.

Debug infos in release build :
I keep all the optimizations, my goal is just to have a call stack with symbolic names, in case of crash.


[pipe]
No longer return a result at the end of the execution of the following methods :
~pipe
~coactivePipe
~pipeProfile
~coactivePipeProfile
Previously, the returned result was the first pipestage of the pipe.
That was useless, and not well adapted to coactive pipes.
In the case of coactive pipes, several results can be yielded, and it's better
to have no result when the coactive pipe is ended (same behaviour as generators).


===============================================================================
2013 mar 20

Summary of recent changes :

[GC]
GC verbose message : use proper format to avoid negative values

[pipe]
Added a 'yield' pipe stage, to yield the current item.
Works only from a coactive pipe.
This is a convenience pipeStage, equivalent to .do {.yield[item]}
Ex :
    branchGenerator = "git branch -a"~coactivePipe(.system | .yield)
    branchGenerator~()=    -- '  3.2.0'
    branchGenerator~()=    -- '  4.0.1'
    branchGenerator~()=    -- '  4.0beta'
    branchGenerator~()=    --   4.1
    branchGenerator~()=    -- '  4.1.0'
    branchGenerator~()=    -- '  4.1.2'
    branchGenerator~()=    -- '* master'
    etc..
Note about implementation :
The class "yield" existed already, defined in coactivity.cls.
This class has been extended by inheriting from the class "pipeStage", which brings
the operators "[]", "|", ">", ">>" and " ".
The operator "[]" was already defined to do .Coactivity~yield(value), which hides
the 2nd definition.
Summary of possible usages :
.yield[value] : equivalent to .Coactivity.yield[value] which yields immediatly the value.
.yield        : only from a coactive pipe, creates an instance of pipeStage which will
                yield the current item at each execution of the method "process".


===============================================================================
2013 jan 10

[doers]

The 'expose' was not detected correctly in the following code :
{::cl
    expose v
}~functionDoer
The tag ::cl was removed when calling SourceLiteralParser~kind, but the resulting
clause was empty. Fixed by going to the next non-empty clause.

Change the minimal abbreviation of some doers' tag, to follow the ooRexx abbreviation rules :
::c[oactivity]     --> ::co[activity]
:[:routine]        --> ::r[outine]
option .c[oactive] --> .co[active]

The message INIT sent by RexxBlock passed mistakenly two parameters, instead of none.
Fixed.


[unicode]
Activate STRONG_TYPES only when compiling C++ code (otherwise compilation error).


[ooRexxShell & ooRexxTry]
Use condensed representation for arrays of dimension 0.


===============================================================================
2012 dec 14

merge 7771-8678 from main/trunk


SourceFile.cpp, RexxSource::processInstall
I see a change when processing classes :
Each installed class is stored in an array createdClasses.
When all classes have been installed, iterate over createdClasses and send the
message OREF_ACTIVATE.
Should I do the same for extensions ? No...
But maybe a message ACTIVATE_EXTENSION could be useful.
See previous entry : I send the message INIT from native RexxBlock, but this is
not a standard pattern. Moreover, I have no way to intialize each extension separately.


doers-stress.rex : Stack overflow, despite the fix made in trunk...
The crash also occurs in trunk.
If 'signal on syntax' is not used then no crash.


===============================================================================
2012 dec 09

RexxBlock :
Removed the native method "executable" implemented by RexxBlock::getExecutable,
and "executable=" implemented by RexxBlock::setExecutable.
Can be implemented in RexxBlockDoer using a private variable.
Impacted files :
BlockClass.cpp, BlockClass.hpp, CPPCode.cpp, Setup.cpp,RexxConstants.hpp

After first tests, I see I need to initialize the variable "executable" added by extension.
For that, I send the message INIT from native RexxBlock code. But the pattern is not really
standard... Normally this message should be sent from RexxBlock::newRexx, but this method
which implements .RexxBlock~new is not allowed from Rexx code (my decision).
I send the message INIT from RexxBlock::RexxBlock, but I had to do that :
	RexxBehaviour *behaviour = ((RexxClass *)this)->getInstanceBehaviour();
    if (behaviour != NULL) this->setBehaviour(behaviour);
instead of that in the standard pattern :
    this->setBehaviour(((RexxClass *)this)->getInstanceBehaviour());
because the behaviour returned by getInstanceBehaviour is NULL.


===============================================================================
2012 sept 30

[logical]
Routine if(aLogical, whenTrue, whenFalse)
Method aLogical~ifTrue(whenTrue[, whenFalse])
Method aLogical~ifFalse(whenFalse[, whenTrue])
When passing a doer for whenTrue and/or whenFalse, the evaluation is done only when needed.


===============================================================================
2012 aug 01

Now I have win7 and can build a 64bits version for Windows.
But I don't like how the build is managed :
- no separate destination for 32 and 64 bits
- wrong detection of the compiler when a french localized version is installed

Modified makeorx.bat and orxdb.bat to manage correctly the bitness of the compiler.
The detection of the compiler bitness is done by compiling a small cpp file and
parsing its output. The choice of compiler is done by launching the appropriate shell.
Now I can have at the same time these directories :
Win32Dbg
Win32Rel
Win64Dbg
Win64Rel


===============================================================================
2012 june 30

[doers]

Implemented the Y combinator as a method on Doer.
http://en.wikipedia.org/wiki/Fixed-point_combinator#Y_combinator
No practical interest... Inspired by http://mvanier.livejournal.com/2897.html
Example (to run from ooRexxTry) :
fact = {
           use strict arg f
           return {
                      ::closure expose f
                      use strict arg n
                      if n==0 then
                          return 1
                      else
                          return n * f~(n-1)
                  }
       }~Y          -- ~Y(.true) for verbose mode
fact~(10)=          -- 3628800

ooRexx supports anonymous recursive functions, so no need of the Y combinator...
fact = {
    use strict arg n
    if n==0 then
        return 1
    else
        return n * .context~executable~(n-1)
}
fact~(10)=          -- 3628800


===============================================================================
2012 june 12


Finished the implementation of an APL-like array initializer.
See doc in the file extension/array.cls.


In the various shells, the condensed output for arrays is now used only for array having one dimension.
Exception : In the pipelines, the condensed output is still used for any kind of array.


rgf_util2_wrappers.rex  : Overloaded the pretty-printing made by the routine pp2.
Since I pretty-print arrays using square brackets, I prefer to avoid square brackets
for pretty-printing strings. Now using quotes, when not a number.
Other change : the objects other than strings and collections are surrounded by
round brackets, instead of square brackets.


generator.cls : added "use strict arg -- none" everywhere appropriate to ensure
that no argument is passed when resuming a generator.


coactivity.cls : the automatic termination of gc'ed coactivities was not working
as expected. Some coactivities were never gc'ed and I suppose it's because of
the coactive closures which keep a reference to other coactivities.
By explicitely assigning .nil where appropriate, I increase the chances to have
more GC'ed objects. But that's not normal to have to do that !
Clearly, I see a problem with CoactivityObj : the uninit method is *rarely* called
by the interpreter, whereas the uninit method of Coactivity is called as expected.


Pipe stage .append : new option "iterate"
By default, there is no iteration, except for coactivities.


===============================================================================
2012 may 05

[pipes]
Method pipe.generate renamed coactivePipe.
Method pipeProfile.generate renamed coactivePipeProfile.
The old names were not good, because a generator takes in charge the yields.
This is not the case here, where the yields must be explicitely inserted in the pipe.


[coactivity]
For convenience, ~isEnded returns .true when the coactivity has been killed.


[ooRexxTry.rex & ooRexxTry.rxj]
Added the routine updatePackageEnvironment which creates the same environment as
oorexxshell (list of imported packages).


===============================================================================
2012 apr 22

merge 7736-7771 from main/trunk

Adaptation of ooRexxTry.rex :
- set default code page to UTF-8 when using wide-char oodialog.
- support omitted arguments.
- display elapsed time.
- when using extended ooRexx :
    manage the '=' shortcut at the end of each clause.
    display the number of coactivities.

Prepare files for a new delivery in my dropbox.


===============================================================================
2012 mar 23

merge 7691-7736 from main/trunk


Adaptation of ooRexxTry.rxj :
Preloads all the main components (math, ftp, socket, bsf, hostemu, ...).
The '=' shortcut is managed at the end of each clause.
Now, it's possible to write that :
    dir;rc=;unknown;rc=
The transformed command is :
    dir;
    options "NOCOMMANDS";
    rc ;
    call dumpResult;
    options "COMMANDS";
    unknown;
    options "NOCOMMANDS";
    rc ;
    call dumpResult;
    options "COMMANDS"


[pipes]
Fixed a deadlock.
The methods ~pipe, ~pipe.generate, pipeProfile and pipeProfile.generate must be unguarded.


[coactivity]
Added support for onStart and onTerminate at the class level.
Needed to attach/detach properly to/from the Java thread in ooRexxTry.rxj.
10/06/2015 : removed, no longer needed.


[parser]
Fixed a bug in .Clauser.
When parsing a multi-line source literal, a single line is created by concatenating each line.
A ';' was missing to delimitate the clauses.
Probably to rework : should keep the source literal as-is (multi-line) to have good line numbers
in case of error.


===============================================================================
2012 mar 23

merge 7390-7647 from main/trunk
merge 7647-7688 from main/trunk
merge 7688-7691 from main/trunk

Remember :
GC crash while running functional-test.rex :
The list of protected objects was corrupted, because of that :
In RexxExpressionMessage::evaluate (ExpressionMessage.cpp), I declared _target as a protected object.
The assignment result = _target, which was supposed to store the RexxObject target in the protected
object result, corrupted the list of protected objects because the default operator= stored a copy of
all the attributes of _target onto the protected object result, overwriting the next attribute.
Fixed by declaring these methods private :
    ProtectedObject(const ProtectedObject&);
    ProtectedObject &operator=(const ProtectedObject&);
Now the compiler forces to cast like that :
result = (RexxObject*)_target
[later]
I think I don't need to protect the intermediate objects returned by ->evaluate, because they should
be protected by the stack. I keep the changes made to ProtectedObject.


===============================================================================
2012 mar 06

Another GC crash
 	rexx.dll!RexxMemory::markObjectsMain(RexxObject * rootObject)  Line 373 + 0xc bytes	C++
 	rexx.dll!RexxMemory::markObjects()  Line 653	C++
 	rexx.dll!RexxMemory::collect()  Line 1030	C++
 	rexx.dll!NormalSegmentSet::handleAllocationFailure(unsigned int allocationLength)  Line 1272	C++
 	rexx.dll!RexxMemory::newObject(unsigned int requestLength, unsigned int type)  Line 1110 + 0x12 bytes	C++
 	rexx.dll!new_object(unsigned int s, unsigned int t)  Line 426 + 0x1e bytes	C++
 	rexx.dll!RexxListTable::operator new(unsigned int size, unsigned int initialSize)  Line 94 + 0x16 bytes	C++
 	rexx.dll!RexxList::getFree()  Line 123 + 0x12 bytes	C++
 	rexx.dll!RexxList::insert(RexxObject * _value, RexxObject * _index)  Line 556 + 0x8 bytes	C++
 	rexx.dll!RexxList::append(RexxObject * _value)  Line 542	C++
 	rexx.dll!RexxActivity::generateProgramInformation(RexxDirectory * exobj)  Line 941	C++
 	rexx.dll!RexxActivity::createExceptionObject(long errcode, RexxString * description, RexxArray * additional, RexxObject * result)  Line 894	C++
 	rexx.dll!RexxActivity::raiseException(long errcode, RexxString * description, RexxArray * additional, RexxObject * result)  Line 774 + 0x18 bytes	C++
 	rexx.dll!RexxActivation::raise(RexxString * condition, RexxObject * rc, RexxString * description, RexxObject * additional, RexxObject * resultObj, RexxDirectory * conditionobj)  Line 1639	C++
 	rexx.dll!RexxActivation::raiseExit(RexxString * condition, RexxObject * rc, RexxString * description, RexxObject * additional, RexxObject * resultObj, RexxDirectory * conditionobj)  Line 1544	C++
>	rexx.dll!RexxInstructionRaise::execute(RexxActivation * context, RexxExpressionStack * stack)  Line 280	C++
 	rexx.dll!RexxActivation::run(RexxObject * _receiver, RexxString * msgname, RexxObject * * _arglist, unsigned int _argcount, RexxInstruction * start, ProtectedObject & resultObj)  Line 544	C++
----------
Review of RexxInstructionRaise::execute
    _result to protect (done)
    _description to protect (done)
    _additional to protect (done)
Review of RexxActivation::raise
    _conditionObj to protect if not a propagation, because new directory created (done)


Previous protection are not enough... Crash again.
Now using /DCHECKOREFS
 	rexx.dll!RexxInternalObject::getObjectTypeNumber()  Line 2045 + 0x3 bytes	C++
 	rexx.dll!RexxInternalObject::isObjectType(unsigned int t)  Line 263 + 0xf bytes	C++
 	rexx.dll!RexxMemory::objectReferenceOK(RexxObject * o)  Line 339 + 0xa bytes	C++
 	rexx.dll!RexxMemory::orphanCheckMark(RexxObject * markObject, RexxObject * * pMarkObject)  Line 1565 + 0xc bytes	C++
 	rexx.dll!RexxMemory::markGeneral(void * obj)  Line 1471	C++
 	rexx.dll!StackFrameClass::liveGeneral(int reason)  Line 143	C++
 	rexx.dll!RexxMemory::killOrphans(RexxObject * rootObject)  Line 440	C++
 	rexx.dll!RexxMemory::markObjects()  Line 641	C++
 	rexx.dll!RexxMemory::collect()  Line 1030	C++
 	rexx.dll!NormalSegmentSet::handleAllocationFailure(unsigned int allocationLength)  Line 1272	C++
 	rexx.dll!RexxMemory::newObject(unsigned int requestLength, unsigned int type)  Line 1110 + 0x12 bytes	C++
 	rexx.dll!new_object(unsigned int s, unsigned int t)  Line 426 + 0x1e bytes	C++
 	rexx.dll!RexxListTable::operator new(unsigned int size, unsigned int initialSize)  Line 94 + 0x16 bytes	C++
 	rexx.dll!RexxList::getFree()  Line 123 + 0x12 bytes	C++
 	rexx.dll!RexxList::insert(RexxObject * _value, RexxObject * _index)  Line 556 + 0x8 bytes	C++
 	rexx.dll!RexxList::append(RexxObject * _value)  Line 542	C++
 	rexx.dll!RexxActivity::generateProgramInformation(RexxDirectory * exobj)  Line 941	C++
 	rexx.dll!RexxActivity::createExceptionObject(long errcode, RexxString * description, RexxArray * additional, RexxObject * result)  Line 894	C++
 	rexx.dll!RexxActivity::raiseException(long errcode, RexxString * description, RexxArray * additional, RexxObject * result)  Line 774 + 0x18 bytes	C++
 	rexx.dll!RexxActivation::raise(RexxString * condition, RexxObject * rc, RexxString * description, RexxObject * additional, RexxObject * resultObj, RexxDirectory * conditionobj)  Line 1641	C++
 	rexx.dll!RexxActivation::raiseExit(RexxString * condition, RexxObject * rc, RexxString * description, RexxObject * additional, RexxObject * resultObj, RexxDirectory * conditionobj)  Line 1544	C++
 	rexx.dll!RexxInstructionRaise::execute(RexxActivation * context, RexxExpressionStack * stack)  Line 289	C++
 	rexx.dll!RexxActivation::run(RexxObject * _receiver, RexxString * msgname, RexxObject * * _arglist, unsigned int _argcount, RexxInstruction * start, ProtectedObject & resultObj)  Line 544	C++
 	rexx.dll!RexxCode::run(RexxActivity * activity, RexxMethod * method, RexxObject * receiver, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, ProtectedObject & result)  Line 136	C++
 	rexx.dll!RexxMethod::run(RexxActivity * activity, RexxObject * receiver, RexxString * msgname, RexxObject * * argPtr, unsigned int count, ProtectedObject & result)  Line 325	C++
>	rexx.dll!RexxObject::messageSend(RexxString * msgname, RexxObject * * arguments, unsigned int count, ProtectedObject & result)  Line 793	C++             // JLF : "yield"
----------
objectReferenceOK :
o = 0x7f23f050 {objectVariables=0x00000000 operatorMethods=0x00558920 classInstance=0x7fcc0a50 }
    objectSize = 6
    instanceClass.id = "Object"
    RexxBehaviour *type = o->getObjectType();       // JLF : NULL
StackFrameClass::liveGeneral :
    memory_mark_general(this->name);                // JLF this->name = 0x7f23f050
        this = 0x7de6d440 {type=0x0052ee64 "METHOD" name=0x7f23f050 executable=0x7fcc2e90 ...}
So we have a problem with the argument 'name' passed to the StackFrameClass constructor.
RexxActivation::createStackFrame
    pass getMessageName() : I don't see a problem here, because returns this->settings.msgname which is protected.
    The name stored in settings.msgname comes from the method RexActivation::run, I don't think there is a problem here.
    But I see a potential problem with the local variable 'arguments' : receives a new array returned by getArguments() --> must be protected (done)
RexxNativeActivation::createStackFrame
    pass getMessageName() : I don't see a problem here, because returns this->msgname which is protected.
    The names comes from :
        RexxNativeActivation::run : _msgname
        RexxNativeActivation::callNativeRoutine : functionName
            RexxNativeRoutine::call : functionName
        RexxNativeActivation::callRegisteredRoutine : functionName
            RegisteredRoutine::call : functionName
RexxSource::createStackFrame
    pass programName : I don't see a problem here
    The programName comes from :
        RexxSource::RexxSource
PackageManager::callNativeRoutine
    Maybe a problem here : name = name->upper(); --> to protect (done)
SystemInterpreter::invokeExternalFunction : target
    RexxActivation::externalCall : target
        RexxInstructionCall::execute --> I see a problem here : _name = REQUEST_STRING(result) --> to protect (done)
RexxActivation::callExternalRexx : target


review of risky code :
->upper
    RexxBehaviour::methodObject : no risk ?
    RexxClass::defineMethod : done
    RexxClass::defineClassMethod : done
    RexxClass::deleteMethod : done
    RexxClass::method : done
    RexxClass::methodDictionaryCreate : done
    RexxDirectory::setEntry : done
    RexxDirectory::remove : no risk ?
    RexxDirectory::setMethod : done
    RexxObject::instanceMethod : to protect because of reportException (done)
    RexxObject::setMethod : done
    RexxObject::unsetMethod : done
    RexxObject::requestRexx : two variables to protect (done)
    RexxObject::decodeMessageName : no risk ?
    RexxObject::defMethods : done
    RexxObject::defMethod : done
    RexxStem::request : done
    RexxNativeActivation::stemSort : incomplete protection (fixed)
    RexxVariableDictionary::getVariableRetriever : done
    BUILTIN(VALUE) : to protect (done, the code has been slightly rewritten)
    RexxInstructionForward::execute : done
    PackageManager::createRegisteredRoutine : done
    PackageManager::dropRegisteredRoutine : done
    PackageManager::queryRegisteredRoutine : done
    PackageManager::callNativeRoutine : done
    RexxSource::findClass : done
    RexxSource::classDirective : done
    RexxSource::extensionDirective : done
    RexxSource::methodDirective : done
    RexxSource::attributeDirective : done
    RexxSource::constantDirective : done
    RexxSource::words : done
    Interpreter::findClass : I think it must be protected because a method could be attached to the environment, no ? (done)
    InterpreterInstance::resolveCommandHandler : done
    SystemInterpreter::valueFunction : no risk, I think
    SystemInterpreter::valueFunction : I think it's ok, SystemInterpreter::allocateResultMemory has no relation with GC
REQUEST_STRING (requestString)
    RexxClass::methodDictionaryMerge : done
    RexxClass::methodDictionaryCreate : already done
    RexxInteger::concatBlank : to protect, I think (done)
    RexxInteger::concat : to protect, I think (done)
    RexxObject::copyIntoTail : done
    RexxObject::concatRexx : done
    RexxObject::concatBlank : done
    RexxStem::sort : is there a risk of GC in array->put(nextValue, j + bounds) ? (NOT done)
    StringClass.cpp : I hope it's ok ! did not investigate
    RexxActivity::display : done, but really not sure if I need to do that
    RexxActivity::displayDebug :  done, but really not sure if I need to do that
    RexxActivity::callFunctionExit : nothing done, I don't understand the code with temp
    RexxInstructionDo::execute : done
    RexxInstructionDo::controlSetup : done
    RexxInstructionForward::execute : done
    RexxInstructionInterpret::execute : done
    RexxInstructionOptions::execute : done
    RexxInstructionQueue::execute : done
    RexxInstructionRaise::execute : done
    RexxInstructionSay::execute : done
    RexxInstructionSignal::execute : done
    RexxInstructionTrace::execute : done
requestString
    RexxMethod::newRexx : I think protection is needed (done)
    RexxNativeActivation::processArguments : is ok, according to the comment
    RexxExpressionStack::requiredStringArg : done
    RexxExpressionStack::optionalStringArg : done
makeString
    RexxMethod::newMethodObject : done
    RoutineClass::newRoutineObject : done
    RoutineClass::newRoutineObject : done
    RexxCompoundTable::findEntry : done
arrayArgument (requestArray)
    RexxObject::sendWith : for me, protection is needed, no ? (done)
    RexxObject::startWith : for me, protection is needed, no ? (done)
    RexxObject::decodeMessageName : for me, protection is needed, no ? (done)
    PackageClass::loadPackage : for me, protection is needed, no ? (done)
    PackageClass::newRexx :  for me, protection is needed, no ? (done)
    RoutineClass::callWithRexx : for me, protection is needed, no ? (done)
    RexxNativeActivation::processArguments : is ok, according to the comment
    RexxNativeActivation::objectToValue : is ok, according to the comment
requestArray (makeArray)
    RexxMethod::newMethodObject : already protected
    RoutineClass::newRoutineObject : already protected
makeArray
    RexxArray::toString : already protected
    RexxList::supplier : done
    RexxQueue::supplier : done
    RexxActivity::display : already protected
    RexxInstructionDo::execute : is ok, assigned to this
    RexxSource::getGuard : is ok, assigned to this
->request
    Nothing new to protect (requestString and requestArray already reviewed)
required_string (macro, requiredStringArg)
    requiredStringArg already reviewed
optional_string (macro, optionalStringArg)
    optionalStringArg already reviewed
decodeMessageName : the string returned in messageName is not protected, see what's done by the caller
    RexxObject::sendWith : for me, protection needed, no ? (done)
    RexxObject::send : for me, protection needed, no ? (done)
    RexxObject::startCommon : for me, protection needed, no ? (done)
    RexxMessage::newRexx : for me, protection needed, no ? (done)
->concat
    RexxObject::requestRexx : I think it's ok, methodLookup should not trigger a GC, right ?
    RexxActivity::messageSubstitution : done
    RexxActivity::traceOutput : done
    RexxSource::commonString : no "->concat" inside, but while looking for "->concat", I saw a lot of calls to commonString where the passed parameter is not protected. Now the parameter string is protected.
    RexxSource::callNew : done
    RexxSource::raiseNew : done
    RexxSource::signalNew : done
    RexxSource::extract : done
    RexxSource::methodDirective : done
    RexxSource::attributeDirective : done
->evaluate
    RexxActivation::evaluateLocalCompoundVariable : done --> cancelled
    <to continue...> --> not needed, the objects should be protected by the stack
decodeExternalMethod
    RexxSource::methodDirective : done
    RexxSource::attributeDirective : done


===============================================================================
2012 mar 04

Fixed a GC crash.
RexxActivity::generateProgramInformation calls createStackFrame.
In RexxActivation::createStackFrame, the last line is
    return new StackFrameClass(type, getMessageName(), (BaseExecutable *)getExecutableObject(), target, arguments, getTraceBack(), getContextLineNumber());
The operator 'new' of StackFrameClass is overloaded and returns a new object before the constructor is called.
This object is not protected.
The call to getTraceBack triggered a GC and the new object was put on the list of dead objects.
The object is returned to generateProgramInformation which puts it in the stackFrames list.
Later, crash because the behaviour pointer of the stack frame is NULL.
Fixed by passing a ProtectedObject to the 'new' operator of StackFrameClass.
Applied the same fix to :
RexxSource::createStackFrame
RexxNativeActivation::createStackFrame


Fixed another GC crash, but less sure I identified the real problem...
A crash occured while searching the method ~available on a supplier. The behaviour was NULL.
I have a subclass of Supplier (CoactivitySupplier) whose init method creates an empty array.
That could explain the problem : in case of GC during init, the supplier is put on the list of dead objects.
After modifying RexxSupplierClass::newRexx to protect newObj before sending the message "init",
no more crash (for the moment).


Remember :
Fix done in RexxSupplierClass::newRexx also done in :
(search for OREF_INIT in interpreter source files)
RexxDirectory::newRexx
RexxIdentityTable::newRexx
RexxList::newRexx
RexxMessage::newRexx
PackageClass::newRexx
RexxQueue::newRexx
RexxRelation::newRexx
RexxStem::newRexx
RexxString::newRexx
RexxSupplierClass::newRexx
RexxTable::newRexx
WeakReference::newRexx


ContextClass : mark this->objectVariables.
It's an exported class, so better to do that... (done)


Remember :
To activate the GC diagnostics, add these definitions in RexxCore.h :
    #define CHECKOREFS
    #define MEMPROFILE
    #define VERBOSE_GC
or better : could be added in lib/orxwin32.mak to my_cdebug, when debug mode.
    /DCHECKOREFS /DMEMPROFILE /DVERBOSE_GC


Remember :
A conditional break "newObj == 0x7eeff200" on the last line of RexxMemory::newObject (RexxMemory.cpp)
lets stop the execution when the object is created. If too long, then modify the source :
    if (newObj == (RexxObject*)0x7eeff200)
    {
        int dummy=0;    //  <-- put breakpoint here
    }
    return newObj;
Then put a data breakpoint to detect when the attribute 'behavior' is overwritten.


===============================================================================
2012 feb 18

Implementation of this Coactivity todo :
<<
The arguments passed to the coactivity with resume should be available like traditional
arguments (use arg...). Currently they are returned by yield as an array.
>>
Implemented by adding support for :
    context = .context~parentContext : let retrieve the context of the yield's caller.
    .context~args=<an array of arguments> : let store the arguments passed to resume.
Now, the method ~yield no longer return a value.


A routine-version of yield is available : "call yield value" where value is optional.


Changed the search order in RexxDotVariable::evaluate :
Try first context->rexxVariable : .methods, .routines, .rs, .line, .context
then try context->resolveDotVariable :  getSourceObject()->findClass(name)
    findInstalledClass(internalName)
    findPublicClass(internalName)
    ActivityManager::getLocalEnvironment(internalName) controlled by security manager
    TheEnvironment->at(internalName)                   controlled by security manager
The use of .context becomes prominent with coactivities, the goal of this change is
to find the value of .context as fast as possible.
Tested from ooRexxShell where more than 700 classes are loaded :
do i=1 to 100000; v=.context ; end
    5 runs : 0.032 0.047 0.078 0.063 0.078
.environment~my.var=1
do i=1 to 100000; v=.my.var ; end
    5 runs : 0.703 0.625 0.593 0.594 0.672


Implemented RFE 2868655.
Done by adding support for variable ".threadLocal" in RexxActivation::rexxVariable.
This implementation is faster than the previous implementation with .activity.
Note 1 :
I did not modify RexxDotVariable to search in .threadLocal. Maybe should be done,
but I find that the search made by RexxDotVariable is already slow enough.
Note 2 :
Seems faster to do that :
do i=1 to 100000; v=.threadlocal["MY.VAR"] ; end
    5 runs : 0.078 0.109 0.109 0.046 0.046
rather than that :
do i=1 to 100000; v=.threadlocal~my.var ; end
    5 runs : 0.140 0.141 0.156 0.140 0.141


coactivity.cls is no longer compatible with standard ooRexx, because depends on :
.context~args = <array>
.threadLocal


interpreter\platform\windows\SysActivity.hpp
interpreter\platform\unix\SysActivity.hpp
Moved SysActivity::yield to the .cpp file to reduce the amount of recompilation when
experimenting various settings. For the moment, sleep(0) under Windows works fine for me,
and is quit faster than sleep(1) used in standard ooRexx.
sleep(0) : rexx coactivity-stress.rex 100 --> global duration=1.671, duration per consumer=0.01671
sleep(1) : rexx coactivity-stress.rex 100 --> global duration=24.625, duration per consumer=0.24625

JLF 10/09/2016
https://www.quora.com/What-is-the-difference-between-sleep-0-and-sched_yield
sched_yield()
    The sched_yield() function shall force the running thread to relinquish the
    processor until it again becomes the head of its thread list.
    This function has a standard C++ analog, std::this_thread::yield()
sleep()
    The sleep() function shall cause the calling thread to be suspended from
    execution until either the number of realtime seconds specified by the
    argument seconds has elapsed or a signal is delivered to the calling thread.
sleep(0)
    If you call sleep(0), the implementation is allowed to do exactly nothing
    and return immediately.
    The idea of sleeping for zero seconds probably comes from Windows API, where
    Sleep(0) is specified to "cause the thread to relinquish the remainder of
    its time slice to any other thread of equal priority that is ready to run.".
    Until Windows XP introduced SwitchToThread, this was the only way to yield in WinAPI.


Added counters for monitoring interpreter activities :
.yieldCounter :              how many times SysActivity::yield has been called since the begining
.addWaitingActivityCounter : how many times ActivityManager::addWaitingActivity has been called since the begining
.relinquishCounter :         how many times ActivityManager::relinquish has been called since the begining
.requestAccessCounter :      how many times RexxActivity::requestAccess has been called since the begining
.getAPIManagerCounter :      how many times LocalAPIContext::getAPIManager has been called since the begining
See samples/concurrency/coactivity-stress.rex
See samples/concurrency/factorials_generators.rex


===============================================================================
2012 feb 16

[parser]
Fixed a bug in .Clauser.
When parsing a source literal embedded into another source literal, the ';' were removed.
Ex :
    block = {return {::closure.coactive expose item ; do forever ; .yield[item] ; item += 1 ; end}}
    block~source~each{say item}
Output before fix:
    return {::closure.coactive expose item  do forever  .yield[item]  item += 1  end}
Output after fix :
    return {::closure.coactive expose item ; do forever ; .yield[item] ; item += 1 ; end}


[pipes]

The implicit argument 'value' has been renamed 'item'.

New convenience method ~pipe.generate to let yield the values produced by the pipe, one by one :
    .object~pipe.generate(.subClasses recursive once | .do {.yield[item]})
is equivalent to
    {::coactivity .object~pipe(.subClasses recursive once | .do {.yield[item]})}

New pipeStage :
.importedPackages : equivalent to .inject {item~importedPackages} iterateAfter

.console pipeStage :
The option "showTags" has been removed : the tags are now always included in the string representation.

.inject pipeStage :
The option "unique" has been renamed "once", to follow the same naming convention as coactivities.
New options "iterateBefore", "iterateAfter" : no longer need the helpers index_item and index_item (removed).

Gradually, the pipeIndex class evolved from a simple index to a whole data flow.
So renamed pipeIndex : now dataflow.
The index parameter is now only the index generated by the previous pipeStage.
A third parameter "dataflow" is passed to the process methods.
The option "memorizeIndex" has been renamed "memorize". It's used to indicate which stages
to memorize in the dataflow.

As written in the 2011 nov 16 entry, I find more natural to retrieve the produced item from
the producing stage, rather than from the next stage.
A stage's dataflow contains the produced item and index.
New methods :
    ~index
    ~item

Ex : "hello"~pipe(.console dataflow)
source:1,'hello'
       |    |
       |    +-> this is the produced item.
       |
       +-> this is the index of the produced item.
           Here, only one value is produced.


Ex : .array~of(10,20,30)~pipe(.console dataflow)
source:1,10
source:2,20
source:3,30
       |  |
       |  +-> produced item
       |
       +-> this item is the 3rd produced from the source.


Ex : List of visible packages with their public classes.
Compare with entry 2011 nov 16, the option "mem.package" has been moved to the producing stage).
Other difference : must specify explicitely "iterateAfter".
    packageName = {.file~new(dataflow["package"]~item~name)~name}
    .context~package~pipe(.inject once after {item~importedPackages} iterateAfter recursive mem.package |,
                          .inject {item~publicClasses} iterateAfter |,
                          .sort {item~id} packageName |,
                          .console packageName ":" item,
                         )


[array]
New extension ArrayPrettyPrinter which defines the method ~ppRepresentation.
This method is used by ooRexxShell to display arrays in condensed form.


[file]
Added extension method listFilesIfNotSymbolicLink, which is a convenience method to support the generation of files, even in case of recursive paths :
    g=.file~new("C:\Program Files\ooRexx")~generate("listFilesIfNotSymbolicLink")~iterateAfter~recursive
Reminder :
    - SysFileTree for Unix does not dereference symbolic links, which is good because it's possible to create recursive paths.
    - SysFileTree for Windows dereferences the symbolic links (tested with a junction), but does not crash with recursive paths.
      The recursion is stopped when the path becomes too long.
    - File~listFiles dereferences the symbolic links : if File is a symbolic link to a directory, then ~listFiles returns the list of files of the target directory.
      MUST test SysIsFileLink when recursively walking through the directories, otherwise internal buffer overflow.


===============================================================================
2012 jan 31

[parser]

Parsing problem with
    .environment~select{index~left(1) == "S"}
because == not recognized as equality operator.
Modified SourceFile.cpp, RexxSource::instruction
Now, this example is ok :
    xrange("A", "Z")~eachC{use arg letter ; .environment~select{::closure expose letter ; left(index, 1) == letter}~dump2}


[functional]

The implicit argument 'value' has been renamed 'item'.

Modified the result returned by the methods xxxI (eachI, eachCI, eachWI, etc...)
Was an array of two arrays (array of items and array of indexes).
Now it's an array of pairs (item, index), which is more appropriate for yielding.

New methods available on .String and .MutableBuffer :
Characters :
    ~dropC(count=1)
    ~dropCI(count=1)
    ~dropLastC(count=1)
    ~dropLastCI(count=1)
    ~dropUntilC(predicate)
    ~dropUntilCI(predicate)
    ~dropWhileC(predicate)
    ~dropWhileCI(predicate)
    ~rejectC(predicate)
    ~rejectCI(predicate)
    ~selectC(predicate)
    ~selectCI(predicate)
    ~takeC(count=1)
    ~takeCI(count=1)
    ~takeLastC(count=1)
    ~takeLastCI(count=1)
    ~untilC(predicate)
    ~untilCI(predicate)
    ~whileC(predicate)
    ~whileCI(predicate)
Words :
    ~dropW(count=1)
    ~dropWI(count=1)
    ~dropLastW(count=1)
    ~dropLastWI(count=1)
    ~dropUntilW(predicate)
    ~dropUntilWI(predicate)
    ~dropWhileW(predicate)
    ~dropWhileWI(predicate)
    ~rejectW(predicate)
    ~rejectWI(predicate)
    ~selectW(predicate)
    ~selectWI(predicate)
    ~takeW(count=1)
    ~takeWI(count=1)
    ~takeLastW(count=1)
    ~takeLastWI(count=1)
    ~untilW(predicate)
    ~untilWI(predicate)
    ~whileW(predicate)
    ~whileWI(predicate)

New methods available on .Collection :
    ~reject(predicate)
    ~rejectI(predicate)
    ~select(predicate)
    ~selectI(predicate)

New methods available on .OrderedCollection :
    ~drop(count=1)
    ~dropI(count=1)
    ~dropLast(count=1)
    ~dropLastI(count=1)
    ~dropUntil(predicate)
    ~dropUntilI(predicate)
    ~dropWhile(predicate)
    ~dropWhileI(predicate)
    ~take(count=1)
    ~takeI(count=1)
    ~takeLast(count=1)
    ~takeLastI(count=1)
    ~until(predicate)
    ~untilI(predicate)
    ~while(predicate)
    ~whileI(predicate)

New methods available on .Supplier :
    ~drop(count=1)
    ~dropI(count=1)
    ~dropLast(count=1)
    ~dropLastI(count=1)
    ~dropUntil(predicate)
    ~dropUntilI(predicate)
    ~dropWhile(predicate)
    ~dropWhileI(predicate)
    ~reject(predicate)
    ~rejectI(predicate)
    ~select(predicate)
    ~selectI(predicate)
    ~take(count=1)
    ~takeI(count=1)
    ~takeLast(count=1)
    ~takeLastI(count=1)
    ~until(predicate)
    ~untilI(predicate)
    ~while(predicate)
    ~whileI(predicate)

[coactivity]

~resume must be guarded otherwise the same value can be returned to different consumers
running concurrently (detected when running coactivity-stress.rex).
So, the fix for deadlock4 was not good... It's not ~resume that must be unguarded, it's ~yield.

"LazyCoactivitySupplier" renamed "CoactivitySupplier".

The class CoactivitySupplier was not lazy enough : the first item was calculated
by the ~init method, to know if an item would be available or not. Now, the first item
is calculated when really needed by the following methods : ~available, ~index, ~item.

The behaviour of CoactivitySupplier has been changed :
No longer ends when no result returned. Instead, returns item=.nil and index=.nil

Two subclasses have been added to CoactivitySupplier :
- CoactivitySupplierForGeneration : the services are specialized for generation, where items
  are yielded one by one. This kind of supplier is returned by default for coactivities.
- CoactivitySupplierForIteration : the services are specialized for iteration, where all items
  are consumed in one loop. This kind of supplier is returned by the method ~iterator.
Example :
    {::coactivity do i=1 to 10; .yield[i]; end}~each{say item}= -- return a Coactivity, nothing displayed
    {::coactivity do i=1 to 10; .yield[i]; end}~iterator~each{say item}= -- display 1 2 3 4 5 6 7 8 9 10 and return an empty array

New methods available on .Coactivity and .CoactivitySupplier :
    ~drop(count=1) : drop the 'count' first items
    ~dropI(count=1) : like drop, but yield pairs (item, index)
    ~dropLast(count=1) : drop the 'count' last items
    ~dropLastI(count=1) : like dropLast, but yield pairs (item, index)
    ~dropUntil(predicate) : drop the first items, until the predicate is true
    ~dropUntilI(predicate) : like until, but yield pairs (item, index)
    ~dropWhile(predicate) : drop the first items, while the predicate is true
    ~dropWhileI(predicate) : like while, but yield pairs (item, index)
    ~reject(predicate) : yield all the items but those for which the predicate is true
    ~rejectI(predicate) : like reject, but yield pairs (item, index)
    ~select(predicate) : yield all the items for which the predicate is true
    ~selectI(predicate) : like select, but yield pairs (item, index)
    ~take(count=1) : yield the 'count' first items
    ~takeI(count=1) : like take, but yield pairs (item, index)
    ~takeLast(count=1) : yield the 'count' last items
    ~takeLastI(count=1) : like takeLast, but yield pairs (item, index)
    ~until(predicate) : yield the first items, until the predicate is true
    ~untilI(predicate) : like until, but yield pairs (item, index)
    ~while(predicate) : yield the first items, while the predicate is true
    ~whileI(predicate) : like while, but yield pairs (item, index)

New class .Generator which is somewhat equivalent to the pipeStage .inject.
The .Generator class supports a doer of type message (.inject does not support messages because a string
is always interpreted as an option, not as a doer).
The options are passed by calling methods :
~action(action) :
    The action to execute on each item. The default action is {use arg item ; return item}.
    An action of type message (string) is supported. For convenience, the message is sent only
    if the receiver understands it (i.e. ~hasMethod returns .true). In case of recursive execution,
    the recursion is automatically stopped if the current item does not understand the message.
    Ex : the method .File~listFiles returns .nil if the item is not a directory. Since .nil does
    not understand ~listFiles, the recursion is stopped.
    This method returns the generator (self), to let chaining other methods.
~allowCommands :
    To allow execution of system commands from a RexxBlock.
    By default, the message ~functionDoer is sent to the RexxBlock. The source is transformed to
    support implicit return, which implies the NOCOMMANDS option.
    When this option is specified, the message ~actionDoer is sent to the RexxBlock. There is no
    implicit return, and the NOCOMMANDS option is not injected in the source.
    This method returns the generator (self), to let chaining other methods.
~iterateBefore :
    If the current item has the method "supplier", then apply the doer on each item returned by the supplier.
    This method returns the generator (self), to let chaining other methods.
~iterateAfter :
    If the current result has the method "supplier", then yield each item returned by the supplier.
    In case of recursive execution, each item is used as input value for the next recursive call.
    This method returns the generator (self), to let chaining other methods.
~once :
    To remember all the processed items from the start, and process an item only once.
    This option encompasses the option ~recursive("cycles") which is limited to the call stack.
    This method returns the generator (self), to let chaining other methods.
~recursive(options="") :
    To execute the action recursively on the returned values.
    The default algorithm is depthFirst.
    Options can be ([limit|depthFirst|breadthFirst|cycles][.])*
    Ex :
    ~recursive(0) : limit=0, execute the action on each item, no recursive call
    ~recursive(1) : limit=1, execute the action on each item and reexecute the action on each resulting item (1 level of recursion)
    ~recursive("depthFirst") : http://en.wikipedia.org/wiki/Depth-first_search
    ~recursive("breadthFirst") : http://en.wikipedia.org/wiki/Breadth-first_search
    ~recursive("cycles") : detect cycles, to not reprocess an item already processed in the call stack.
    ~recursive("10.breadthFirst.cycles") : combination of several options.
    This method returns the generator (self), to let chaining other methods.
~returnIndex :
    To yield .array~of(item, index).
    If the generation is recursive then yield .array~of(item, index, depth) where depth is the number of nested calls.
    This method returns the generator (self), to let chaining other methods.
~trace :
    To activate internal trace.
    This method returns the generator (self), to let chaining other methods.

New methods :
    .Object~generate(action) : returns .Generator~new(self)~action(action)
    .Object~generateI(action) : returns .Generator~new(self)~action(action)~returnIndex
    .String~generateC(action) : returns .Generator~new(self~makeArray(""))~action(action)
    .String~generateCI(action) : returns .Generator~new(self~makeArray(""))~action(action)~returnIndex
    .String~generateW(action) : returns .Generator~new(self~subwords)~action(action)
    .String~generateWI(action) : returns .Generator~new(self~subwords)~action(action)~returnIndex
    .MutableBuffer~generateC(action) : returns .Generator~new(self~makeArray(""))~action(action)
    .MutableBuffer~generateCI(action) : returns .Generator~new(self~makeArray(""))~action(action)~returnIndex
    .MutableBuffer~generateW(action) : returns .Generator~new(self~subwords)~action(action)
    .MutableBuffer~generateWI(action) : returns .Generator~new(self~subwords)~action(action)~returnIndex
    .Collection~generate(action) : returns .Generator~new(self)~iterateBefore~action(action)
    .Collection~generateI(action) : returns .Generator~new(self)~iterateBefore~action(action)~returnIndex
    .Supplier~generate(action) : returns .Generator~new(self)~iterateBefore~action(action)
    .Supplier~generateI(action) : returns .Generator~new(self)~iterateBefore~action(action)~returnIndex
    .Coactivity~generate(action) : returns .Generator~new(self)~iterateBefore~action(action)
    .Coactivity~generateI(action) : returns .Generator~new(self)~iterateBefore~action(action)~returnIndex

~times.yield renamed ~times.generate
~yield~upto renamed ~generate~upto
~yield~downto renamed ~generate~downto
Careful :
100000~times~generate{2*item} -- Collect all items in an array and then generate each array's item one by one (you don't get the first item immediatly)
100000~times.generate{2*item} -- Generate directly each item one by one (you get the first item immediatly)
The duration is roughly the same for the two lines.

Examples :
-- All items in .environment
    g=.environment~generate
    g~do= -- [The OLEObject class id#_268012703]
    g~do= -- [The InvertingComparator class id#_268059180]
    ...

-- All pairs of index,item in .environment
    g=.environment~generateI
    g~do= -- [(The OLEObject class),'OLEOBJECT']
    g~do= -- [(The InvertingComparator class),'INVERTINGCOMPARATOR']
    ...

-- Illustration of depthFirst (default) vs breadthFirst
   "one two three"~generateW{if depth == 0 then item; else if item <> "" then item~substr(2)}~recursive~makeArray=
        ['one','ne','e','','two','wo','o','','three','hree','ree','ee','e','']
   "one two three"~generateW{if depth == 0 then item; else if item <> "" then item~substr(2)}~recursive("breadthFirst")~makeArray=
        ['one','two','three','ne','wo','hree','e','o','ree','','','ee','e','']

-- All the files and directories in the ooRexx directory
    g=.file~new("C:\Program Files\ooRexx")~generate("listFiles")~iterateAfter~recursive
    t=g~take(4) -- The 4 first results returned by ~listFiles, one by one
    t~do= -- C:\Program Files\ooRexx\api
    t~do= -- C:\Program Files\ooRexx\api\oorexxapi.h
    t~do= -- The NIL object -- ~listFiles returns .nil when the target is not a directory
    t~do= -- C:\Program Files\ooRexx\api\oorexxerrors.h
    t~do= -- no result -- The take coactivity is ended, but not the listFiles coactivity...
    g~makeArray(4)~dump2 -- The next 4 results returned by ~listFiles, as an array.
        # 1: index=[1] -> item=[The NIL object id#_268001399]
        # 2: index=[2] -> item=[C:\Program Files\ooRexx\api\rexx.h id#_263525300]
        # 3: index=[3] -> item=[The NIL object id#_268001399]
        # 4: index=[4] -> item=[C:\Program Files\ooRexx\api\rexx.lib id#_263525874]
    t=g~reject{item == .nil}~take(5) -- Add a constraint to no longer get the .nil results and take only 5 results.
    t~do= -- C:\Program Files\ooRexx\api\rexxapi.lib
    t~do= -- C:\Program Files\ooRexx\api\rexxapidefs.h
    t~do= -- C:\Program Files\ooRexx\api\rexxapitypes.h
    t~do= -- C:\Program Files\ooRexx\api\rexxplatformapis.h
    t~do= -- C:\Program Files\ooRexx\api\rexxplatformdefs.h
    t~do= -- no result

-- All the imported packages, with an indented view of the dependencies
    g = .context~package~generateI("importedPackages")~iterateAfter~recursive("cycles")
    -- Next line :
    -- item[1] is the package
    -- item[3] is the depth of recursivity, can be used to indent.
    g~iterator~each{say "   "~copies(item[3]) || item[1]~name}
    Output :
        ...
        C:\Program Files\BSF4ooRexx\BSF.CLS
        C:\Program Files\BSF4ooRexx\UNO.CLS
           C:\Program Files\BSF4ooRexx\BSF.CLS
           C:\Program Files\BSF4ooRexx\UNO_XINTERFACES.RXO
           C:\Program Files\BSF4ooRexx\rgf_util2.rex
        d:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\extension\extensions.cls
           d:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\extension\doers.cls
              d:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\concurrency\coactivity.cls
                 d:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\concurrency\activity.cls
        ...

-- Generation of all natural numbers : 1 2 3 ...
    g=0~generate{item+1}~recursive

-- Factorial
    1~times.generate~reduce("*")= -- 1
    2~times.generate~reduce("*")= -- 2
    3~times.generate~reduce("*")= -- 6
    ...
    100~times.generate~reduce("*")= -- 9.33262137E+157
    ...
    1000000~times.generate~reduce("*")= -- 8.26394715E+5565708

-- *NAIVE* generation of factorials from 0! :
    g=(-1)~generate{item+1}~recursive~each{.array~of(item~times.generate~reduce(1, "*"), item)}
    g~take(10)~iterator~each{say item[2]"! =" item[1]}
        0! = 1
        1! = 1
        2! = 2
        3! = 6
        4! = 24
        5! = 120
        6! = 720
        7! = 5040
        8! = 40320
        9! = 362880

-- Less naive generation of factorials from 0! :
    g=0~generateI{if item == 0 then 1; else stack[1] * depth}~recursive
    g~take(10)~iterator~each{say item[3]"! =" item[1]}
        0! = 1
        1! = 1
        2! = 2
        3! = 6
        4! = 24
        5! = 120
        6! = 720
        7! = 5040
        8! = 40320
        9! = 362880

[doers]

Added the method ~arity to Doers, which lets higher-order functions to decide which arguments to pass.
Usage :
myDoer~arity -- returns the arity of myDoer (number of supported arguments). -1 if unknown (default).
myDoer~arity(3) -- set the arity to 3, return myDoer.

Fixed a problem of variable name collision in .Closure~initVariables :
If there was a variable 'supplier' in the outer environment, then when doing
'call value "supplier", supplierValue', the iteration over the variables was impacted,
because the variable 'supplier' was used in ~initVariables.

Added the method ~unknown to RexxBlock : any unknown message is forwarded to the implicit doer.
Ex :
The methods ~take and ~select are not defined on .RexxBlock, but they are defined on .Coactivity.
{::coactivity i=1 ; do forever; .yield[i]; i += 1 ; end}~take(5)~iterator~each{say item}
{::coactivity i=1 ; do forever; .yield[i]; i += 1 ; end}~select{item//2 == 0}~take(5)~iterator~each{say item}


[Summary of extension methods]

                                 -----------------------------------------------------------------------------
                                  |        |           |        generateC    generateW   |       |    generate
                                 -|--------|-----------|-----------|------------|--------|-------|--------|---
                                  |     reduce         |        reduceC      reduceW     |       |        |
                                 -|--------|-----------|-----------|------------|--------|-------|--------|---
                                 map       |           |        mapC         mapW        |       |        |
                                 mapR      |           |           |            |      mapCR   mapWR      |
                                 -|--------|-----------|-----------|------------|--------|-------|--------|---
                                  |     each           |        eachC        eachW       |       |        |
                                  |     eachI          |        eachCI       eachWI      |       |        |
                                 -|--------|-----------|-----------|------------|--------|-------|--------|---
                                  |        |        drop        dropC        dropW       |       |        |
                                  |        |        dropI       dropCI       dropWI      |       |        |
                                  |        |        dropLast    dropLastC    dropLastW   |       |        |
                                  |        |        dropLastI   dropLastCI   dropLastWI  |       |        |
                                  |        |        dropUntil   dropUntilC   dropUntilW  |       |        |
                                  |        |        dropUntilI  dropUntilCI  dropUntilWI |       |        |
                                  |        |        dropWhile   dropWhileC   dropWhileW  |       |        |
                                  |        |        dropWhileI  dropWhileCI  dropWhileWI |       |        |
                                  |     reject         |        rejectC      rejectW     |       |        |
                                  |     rejectI        |        rejectCI     rejectWI    |       |        |
                                  |     select         |        selectC      selectW     |       |        |
                                  |     selectI        |        selectCI     selectWI    |       |        |
                                  |        |        take        takeC        takeW       |       |        |
                                  |        |        takeI       takeCI       takeWI      |       |        |
                                  |        |        takeLast    takeLastC    takeLastW   |       |        |
                                  |        |        takeLastI   takeLastCI   takeLastWI  |       |        |
                                  |        |        until       untilC       untilW      |       |        |
                                  |        |        untilI      untilCI      untilWI     |       |        |
                                  |        |        while       whileC       whileW      |       |        |
                                  |        |        whileI      whileCI      whileWI     |       |        |
--------------------------------------------------------------------------------------------------------------
.Object ..................................................................................................X...
.String ...........................................................X............X.........................X...
.MutableBuffer ....................................................X............X........X.......X........X...
.Collection.......................X........X..............................................................X...
.OrderedCollection................X........X...........X..................................................X...
.Supplier .................................X...........X..................................................X...
.Coactivity ...............................X...........X..................................................X...
.CoactivitySupplierForGeneration ..........X...........X..................................................X...
.CoactivitySupplierForIteration ...........X...........X..................................................X...


===============================================================================
2011 dec 23

Renamed RexxContextualSource to RexxBlock, because it's now more than a simple
source. Since it's close to Smalltack blocks or Ruby blocks, the name RexxBlock
seems more appropriate.


===============================================================================
2011 dec 19

Moved wide-char oodialog (now outdated) to oodialog.wchar and adapted the makefiles
to build both standard oodialog and oodialog.wchar. The wide-char version can be
still useful to test unicode support by the interpreter.

Next step : merge from trunk.
Done.


===============================================================================
2011 dec 18

[parser]

Fixed a bug that I introduced in RexxSource::argList when adding support for the
shortcut syntax f(a1,a2,...){...}.
The end-of-clause was not tested and a token was read beyond the EOC.
Symptom : the following piece of code displayed 1 because an argument was
associated to the CallInstruction. That argument was the token {dummy2} from
the previous clause...
    {}~instancemethods({}~class) ; call dumpresult
    return
    dumpResult: procedure
        say arg()


[doers]

Simplification : Only a RexxContextualSource supports the method ~sourceDoer.
Previously, any doer supported this method, because any doer has potentially an
associated source from which a doer can be created. But to support this feature,
I should add the methods ~package, ~kind and ~rawExecutable to all the doers.
That would add complexity for something not really needed.

Added the method ~trampoline to Doer.
http://en.wikipedia.org/wiki/Tail_call#Through_trampolining
A trampoline is a technique to transform recursive calls into a sequence of calls
to doers. Instead of returning the result, the doer returns a doer which returns
the result. While the result returned by the doer is a doer, the result is called.
The loop is ended when the result is not a doer.
Ex :
    say {say "one" ; return {say "two" ; return "three"}}~trampoline -- one two three
Ex :
    factorial = {
        use strict arg n, accu=1
        if n <= 1 then return accu
        executable = .context~executable
        return {::cl
            expose n accu executable
            return executable~(n-1, n*accu)
        }
    }
    say factorial~trampoline(1000000) -- 8.26394406E+5565708

Added the method ~partial to Doer
http://en.wikipedia.org/wiki/Partial_application
Returns a closure which remembers the arguments passed to ~partial.
When this closure is called with the remaining arguments, a whole argument array is
built from both argument lists (partial and remaining) and passed to the target of
~partial.
Ex :
    add10 = "+"~partial(10)
    say add10~(1) -- 11
Ex :
    sub10 = "-"~partial(, 10)
    say sub10~(1) -- -9
Ex :
    myArguments = .context~package~findRoutine("myArguments")
    p1 = myArguments~partial(1,,3,,5)
    p1~()                               1:1 3:3 5:5
    p1~(2,,6)                           1:1 2:2 3:3 5:5 6:6
    p1~(2,4,6,,8)                       1:1 2:2 3:3 4:4 5:5 6:6 8:8
    p2 = myArguments~partial(,,3,4)
    p2~()                               3:3 4:4
    p2~(2,,6)                           1:2 3:3 4:4 5:6
    p2~(2,4,6,,8)                       1:2 2:4 3:3 4:4 5:6 7:8
    ::routine myArguments
        arg(1, "a")~each{call charout, index":"value" "}
        say
    ::requires "extension/extensions.cls"


===============================================================================
2011 dec 13

[source literal]
No more deferred parsing, the parser delegates the parsing of the source literals
to .SourceLiteralParser~rawExecutable, which creates routines or methods.
Easy because the parser supports reentrancy (or I did not yet detect problems in
relation with reentrancy...).
This class SourceLiteralParser must be preloaded (part of rexx.img).
Consequence :
- all the source literals are parsed at load-time, syntax errors are detected immediately.
- performances are good, even if the source literal is inside a loop.
  see benchmark/doers-benchmark.output.txt


[doers]

Simplification of ~sourceDoer : no longer need to create a pure expression, so
parameter expression and related code removed.
That was done in the early days to bypass a parse error when using arg() as
first expression. But since then, the parser has been modified to no longer raise
an error when arg() appears as first expression.


===============================================================================
2011 dec 10

[source literal]

RexxContextualSource : added the native method "executable=" to let the ooRexx code
in doers.cls store the executable on the instance of RexxContextualSource.
That will be used both for convenience (no longer needed for the user to call ~doer)
and performance (reuse cached executable).
JLF 2012 dec 09 : native implementation of "executable=" not needed.
Better to expose an internal variable "executable".


[doers]

(Updated 2011 dec 13)
At the first call of ~RexxContextualSource~doer, if an executable is not already stored
on the RexxContextualSource, then an executable is created and cached on the RexxContextualSource.
The next calls of ~doer return directly the cached executable.
Unlike ~doer, the methods ~functionDoer and ~actionDoer will create and cache a new
executable at each call (replacing the previous cached executable). This is because these
methods let transform the source before creating the executable.

RexxContextualSourceDoer : implemented the 3 abstract methods declared by .doer :
    ~needsObject
    ~do
    ~doWith
An implicit call to ~doer is done when calling these methods.
Ex :
    range = { use arg min, max ; return { ::closure expose min max ; use arg num ; return min <= num & num <= max }}
    from5to8 = range~do(5, 8) --     each execution of range returns a different RexxContextualSource.
    from20to30 = range~do(20, 30) -- since the RexxContextualSource is a closure's source, it holds a snapshot of the context's variables.
    say from5to8~do(6) -- 1          first execution : the RexxContextualSource is parsed, the closure executable is created and cached.
    say from5to8~do(9) -- 0          reuse the RexxContextualSource's cached closure executable.
    say from20to30~do(6) -- 0        from20to30 contains a RexxContextualSource different from from5to8. first execution : the closure is parsed.
    say from20to30~do(25) -- 1       reuse the cached executable.

Big picture (updated 2011 dec 13) :
    a RexxSourceLiteral is an internal rexx object, created by the parser, not accessible from ooRexx scripts.
    a RexxSourceLiteral holds these properties, shared among all the RexxContextualSource instances created from it.
      |  source : the text between the curly brackets {...} as an array of lines, including the tag :xxx if any.
      |  package : the package which contain the source literal.
      |  kind : kind of source, derived from the source's tag.
      |  rawExecutable : routine or method created at load-time (immediate parsing).
      |
      +--> a RexxContextualSource is created each time the RexxSourceLiteral is evaluated, and is accessible from ooRexx scripts.
      |    Why not return directly the RexxSourceLiteral ? (after all, this is what is done for other literals :
      |    A RexxInteger, a RexxNumberString, a RexxString  evaluate to itself)...
      |    Because, as indicated by its name, a RexxContextualSource contains informations that depends on the evaluation context.
      |    In particular, when a RexxContextualSource is a closure's source, it will hold a snapshot of the context's variables.
      |        ~source : source of the RexxSourceLiteral, never changed even if ~functionDoer or ~actionDoer called.
      |        ~variables : snapshot of the context's variables (a directory), created only if the source starts with "::cl".
      |        ~rawExecutable : the raw executable of the RexxSourceLiteral, created at load-time (routine or method).
      |        ~executable : cached executable, managed by doers.cls.
      |                      routine or method or coactivity or closure. ~executable~source can be different from ~source.
      |
      +--> a RexxContextualSource
      |
      +--> etc... (a new instance is created at each evaluation of the RexxSourceLiteral)

Example, from ooRexxShell (the final '=' is used to display the result) :

    cs = {"hello"} -- immediate parsing (if syntax error, will be raised when the package is loaded)
    cs~source= -- the RexxSourceLiteral's source
        # 1: index=[1] -> item=["hello"]
    cs~rawExecutable= -- [a Routine id#_264298413]
    cs~rawExecutable~source=
        # 1: index=[1] -> item=["hello"]
    cs~executable= -- [The NIL object id#_268001399]
    cs~do -- execute the system command "hello" --> display "Bonjour, le monde!"
    cs~executable= -- cached executable [a Routine id#_264001464]

    cs~functionDoer= -- [a Routine id#_267150234] created from a transformed source derived from cs~source
    cs~executable= -- [a Routine id#_267150234] this new routine has been memorized
    cs~executable~source= -- transformed source
        # 1: index=[1] -> item=[options "NOCOMMANDS" ; "hello"]
        # 2: index=[2] -> item=[ ; if var("result") then return result]
    cs~source= -- the original source is unchanged and still available
        # 1: index=[1] -> item=["hello"]
    cs~do= -- [hello]

    cs~actionDoer= -- [a Routine id#_266463660] created from a source derived from cs~source (no transformation)
    cs~executable= -- [a Routine id#_266463660] memorized
    cs~executable~source=
        # 1: index=[1] -> item=["hello"]
    cs~do -- execute the system command "hello" --> display  "Bonjour, le monde!"

    cs~executable = .nil -- reset the cache
    cs~executable= -- [The NIL object id#_268001399]


[parser]

Added support for tilde-call message "~()".
The message name can be omitted, but the list of parameters is mandatory (can be empty).
    target~()
    target~(arg1, arg2, ...)
    target~~()
    target~~(arg1, arg2, ...)
When the expression is evaluated, the target receives the message "~()".
Why not just "()" ? because I keep the possibility to have a distinct message in case of
pure function-call (not activated, but the code is implemented and it works.
See functionCallMessage in SourceFile.cpp).
So now, an additional form of message term is supported :
>>-receiver-+- ~ --+----+---------+----(--+----------------+--)--><
            +- ~~ -+    +-:symbol-+       | +-,----------+ |
                                          | V            | |
                                          +---expression-+-+
Implementation in doers.cls :
    ::class "Doer" mixinclass Object public inherit DoerFactory
    -- Tilde call
    ::method "~()" unguarded
        forward message "do" to (self~doer)
So any doer which receives the message "~()" will execute its ~do method.
Ex :
    {say hello}~() -- HELLO
    run={arg(1)~()} ; run~{say hello} -- HELLO
    {say arg(1)}~~("hello")~~("bye") -- hello bye
    say 1 + {return 2 * arg(1)}~(2) + 3 -- 1 + 2*2 + 3 = 8
Ex :
    myFunc = {return 2 * arg(1)}
    do i=1 to 10 ; say 1 + myFunc~(i) ; end
Ex : (already seen above, but here only tilde-calls are used, no more ~do)
    range = { use arg min, max ; return { ::closure expose min max ; use arg num ; return min <= num & num <= max }}
    from5to8 = range~(5, 8)
    from20to30 = range~(20, 30)
    say from5to8~(6) -- 1       first execution : the closure is parsed
    say from5to8~(9) -- 0
    say from20to30~(6) -- 0     first execution : the closure is parsed
    say from20to30~(25) -- 1


[functional]

Modified the following methods to always return an array, even if no result collected
(in this case, the returned array is empty) :
    ~times
    ~upto
    ~downto
This is more consistent for the caller, no need to test if a result was returned or not.


===============================================================================
2011 nov 16


[pipes]

The option 'memorizeIndex' lets specify an optional tag : memorizeIndex[.tag]
By default, the tag is the pipeStage class id.
Still thinking to improve this memorization, because when needing the produced value,
the tag must be specified on the next pipeStage (which consumes the value).
In the example below, the tag "package" is associated to the 2nd inject, whereas
I find it would be more natural to associate it to the 1st inject.
todo : add ~valueIn, ~valueOut.
Ex : List of visible packages with their public classes
.context~package~pipe(.inject {value~importedPackages} recursive unique after |,
                      .inject {value~publicClasses} mem.package |,
                      .sort {value~id} {index["package"]~value~name} |,
                      .console {.file~new(index["package"]~value~name)~name} ":" value,
                     )
activity.cls : The Activity class
coactivity.cls : The Coactivity class
coactivity.cls : The WeakProxy class
coactivity.cls : The yield class
array.cls : The ArrayInitializer class
doers.cls : The Clauser class
doers.cls : The CoactivityDoer class
...


[source literal]

Removed RexxContextualSource::getContext (~context)
Added RexxContextualSource::getVariables (~variables)
The method ~variables returns a snapshot of .context~variables at the time of creation
of the RexxContextualSource.


[doers]

Added support for closures by value.
When a RexxSourceLiteral is evaluated, a RexxContexualSource is created, which holds
a snapshot of the current context (directory of variables).
The RexxContexualSource can be passed back to the caller, the directory of variables
will remain accessible (unlike a RexxContext instance which becomes invalid once the
RexxActivation has been popped).

Closure by value means : Updating a variable from the closure will have no impact on the
original context.
Note : If the variable contains a mutable value then updating the mutable value from the
closure will have an impact on the original context (if still active).

A closure is an object whose exposed variables are created from a directory of variables.
This directory of variables can be passed explicitely, or taken from a RexxContextualSource.
The behavior of the closure is a user-defined method which expose the needed variables.
This method is added to the closure, with the name "do". Ex :
    v = 1 ; closure = .Closure~new(.context~variables){::m expose v ; say v} ; closure~do -- display 1

New tags :
    ::cl[osure]
    ::cl[osure].c[oactive]

The example above can be rewritten :
    v = 1 ; {::closure expose v ; say v}~doer~do -- display 1
The ~doer method returns a closure, because the tag indicates it's a closure.

Can be also a coactive closure :
    v = 1
    w = 2
    closure = {::cl.c expose v w ; .yield[v] ; .yield[w]}~doer
    say closure~do -- 1
    say closure~do -- 2

The context of a closure can be a method :
    myInstance = .myClass~new("myAttributeValue")
    myContextualSource = myInstance~myMethod
    say myContextualSource~class
    say myContextualSource~source~toString
    do v over myContextualSource~variables
        say v
    end
    doer = myContextualSource~doer
    say doer~class
    doer~do
    ::class myClass
    ::method init
        expose a1
        use strict arg a1
    ::method myMethod
        expose a1
        local = "myLocal"
        return {::cl expose self a1 local ; say self~class ; say a1 ; say local}
    ::requires "extension/extensions.cls"
Output :
    The RexxContextualSource class
    ::cl expose self a1 local ; say self~class ; say a1 ; say local
    SELF
    LOCAL
    A1
    SUPER
    The Closure class
    The MYCLASS class
    myAttributeValue
    myLocal


===============================================================================
2011 nov 14

[extensions]

Added a ~help method on the class .Object.
When working from ooRexxShell, I often need to get a quick reminder of some
functionalities, especially for pipeStages. The ~help method searches for the
self~_description_ method. If found, the help text is extracted from the source,
as an array of strings. The first 2 lines and last 2 lines are removed, according
the convention described below. The array is displayed with : say array~toString
and returned as result.
Must follow this convention :
    ::method _description_
    nop
    /*
    <text here>
    */
    nop
I use nop before and after because otherwise the comment is not stored in the method's
source (any instruction would do the trick). Don't know if it's a bug or a feature...
Usage :
    .pipeStage~help
    .pipeIndex~help
    .fanin~help
    .merge~help
    ...


[pipes]

Implemented some ~help methods.

Refactoring of .secondaryConnector : did not connect the wrapped pipeStage
to its follower. Now, .secondaryConnector is a normal pipeStage, the method
~secondaryConnector is no longer needed.
Ex :
    fanin = .fanin mem | .console showTags
    fanout1 = .left[3]  mem | .lower mem | fanin  -- not bufferized
    fanout2 = .right[3] mem | .upper mem | .inject {"my_"value} after | .secondaryConnector | fanin -- bufferized until fanout1 is eof
    .array~of("aaaBBB", "CCCddd", "eEeFfF")~pipe(.fanout mem >> fanout2 > fanout1)
source[Array#1(an Array),1]|fanout[i1='aaaBBB']|left[i1]|lower[i2='aaa']|fanin[i2] : aaa
source[Array#1(an Array),2]|fanout[i1='CCCddd']|left[i1]|lower['CCC']|fanin['ccc'] : ccc
source[Array#1(an Array),3]|fanout[i1='eEeFfF']|left[i1]|lower['eEe']|fanin['eee'] : eee
source[Array#1(an Array),1]|fanout[i1='aaaBBB']|right[i1]|upper[i2='BBB']|fanin[i2] : BBB
source[Array#1(an Array),1]|fanout[i1='aaaBBB']|right[i1]|upper['BBB']|fanin['my_BBB'] : my_BBB
source[Array#1(an Array),2]|fanout[i1='CCCddd']|right[i1]|upper['ddd']|fanin['DDD'] : DDD
source[Array#1(an Array),2]|fanout[i1='CCCddd']|right[i1]|upper['ddd']|fanin['my_DDD'] : my_DDD
source[Array#1(an Array),3]|fanout[i1='eEeFfF']|right[i1]|upper['FfF']|fanin['FFF'] : FFF
source[Array#1(an Array),3]|fanout[i1='eEeFfF']|right[i1]|upper['FfF']|fanin['my_FFF'] : my_FFF


===============================================================================
2011 nov 12

[coactivity]

No longer use the directive ::OPTIONS NOMACROSPACE in coactivity.cls and activity.cls.
That breaks oorexxShell when run with standard ooRexx.
For me, ::OPTIONS should not raise an error in case of unknown option.
This is the case for the instruction options : Unrecognized words in the result are
ignored, since they are assumed to be instructions for a different language processor.

Fixed a deadlock which is due to the split of .Coactivty in two distinct classes.
The following methods must be declared unguarded because they can start the wrapped .CoactivityObj :
.Coactivity~start
.Coactivity~resume
See samples/concurrency/deadlock4.rex for the details


===============================================================================
2011 nov 07

[coactivity]
The LazyCoactivitySupplier no longer needs an uninit method.


[GC]
Added testcase2.rex for uninit which covers both cases :
step 1 : call only predefined functions/methods --> no uninit called during the loop
step 2 : call only user-defined procedures/routines/methods --> uninit called during the loop


===============================================================================
2011 nov 06

[coactivity]

By default, a coactivity is no longer started when created.
Now automatically started by the first resume, if not yet started.

Spent several hours for nothing, trying to use WeakReferences for the global cache
of coactivities. I was hopping to get an automatic end of coactivity when this
coactivity is no longer referenced by a client. But the tests demonstrated that a
started coactivity can't be GC'ed, even if no longer referenced by a client. I suppose
it's because of the method ~start which is running on its own thread, and the self
variable references the coactivity, thus keeping it alive...

There is a way to auto-end a coactivity : just use a wrapper object whose sole
responsibility is to end the coactivity when itself is GC'ed. This is what is already
doing LazyCoactivitySupplier, and that works as expected.
Now using two distinct classes :
- .Coactivity for the wrapper instance.
- .CoactivityObj for the wrapped instance.
Maybe I could use only one class (.Coactivity) to create both the wrapper and the
wrapped instances. Will see, but for the moment, I think the code is more clear
with two classes (despite the forwarding methods on .Coactivity).
Examples of auto-ending coactivies (to test from ooRexxShell) :
    .coactivity~new{i=0; do forever; i+=1; .yield[i]; end}~makeArray(5)=
        # 1: index=[1] -> item=[1]
        # 2: index=[2] -> item=[2]
        # 3: index=[3] -> item=[3]
        # 4: index=[4] -> item=[4]
        # 5: index=[5] -> item=[5]
    #Coactivities: 1                -- still active but no longer reachable, not yet GC'ed
    .coactivity~new{i=0; do forever; i+=1; .yield[i]; end}~pipe(.take 5 | .console)
        (a Coactivity),1 : 1
        (a Coactivity),2 : 2
        (a Coactivity),3 : 3
        (a Coactivity),4 : 4
        (a Coactivity),5 : 5
    #Coactivities: 2                -- still active but no longer reachable, not yet GC'ed
    do 10000 ; .object~new ; end    -- force a GC
    #Coactivities: 0                -- both coactivities have been ended by uninit


[GC]
The work on WeakReferences showed that the calls to uninit methods are impacted by
the use of a security manager (was detected from ooRexxShell which has a security
manager) : more "reactive", i.e. the uninit methods are called during the execution
and not just when the interpreter is halting.
Added samples/gc/testcase1 and several outputs.
Added internals/notes/uninit.txt (code review and various notes)
Added some verbose messages in the interpreter to trace the calls to uninit.
(remember : in trunk/lib/orxwin32.mak, add /DVERBOSE_GC at the end of cflags_common)


[functional]
Modified the ~each methods to always return an array, even if no result collected
(in this case, the returned array is empty). This is more consistent for the caller,
no need to test if a result was returned or not.


===============================================================================
2011 nov 04

[coactivity]

Fixed a deadlock.
(see concurrency/deadlock3.rex for the description of the test case)
The minimal fix was to declare .RoutineDoer~do and ~doWith unguarded.
But I declared unguarded all the methods in doers.cls and functional.cls that don't
modify the state of the self object. I hope this is the right strategy to follow...

According to my tests, a predefined method which is declared guarded is never locked.
But a user-defined method which is declared guarded is locked, as expected.
See :
concurrency/guarded_predefined_method_are_not_locked.rex
concurrency/guarded_user-defined_method_are_locked.rex


Changed the behaviour of ~makeArray, now working like the pipestage .take :
c = 1000~times.yield
c~makeArray(5)
    # 1: index=[1] -> item=[1]
    # 2: index=[2] -> item=[2]
    # 3: index=[3] -> item=[3]
    # 4: index=[4] -> item=[4]
    # 5: index=[5] -> item=[5]
c~makeArray(5)
    # 1: index=[1] -> item=[6]
    # 2: index=[2] -> item=[7]
    # 3: index=[3] -> item=[8]
    # 4: index=[4] -> item=[9]
    # 5: index=[5] -> item=[10]
etc...


[pipes]
I see a loss of performance (twice longer) in the profiled pipeline at the end of
pipe_extension_test.output.txt, and I can't find why...
    7048    20.485   dbg (ok, dbg config is slower due to semaphores tracing)
    7078     8.281   rel
    7086     8.781   rel
    7112     8.531   rel
    7139     8.265   rel
    7154     8.828   rel
    7172     8.953   rel
    7246     8.953   rel
    current 17.936   rel
Made a rebuild of the binaries at revision 7123 : same loss of performance.
Made a test with samples at revision 7048 : no longer adapted to current binaries
(RexxContextualSource source is no longer a string, but an array).
Made a test with samples at revision 7080 : same loss of performance (using current
binaries or rev 7123).
Added a non-profiled version of the same pipeline, with duration, to detect if a similar
loss of performance happens in the future with non-profiled code.


===============================================================================
2011 oct 30

Each call to an external function (like SysXxx functions) triggers a communication
with the rxapi server through a socket (QUERY_MACRO, to test is the function is
defined in the macrospace).
This has a major impact on performance !
Example with .yield[] which calls SysGetTid() or SysQueryProcess("TID") at each call :
    10000 calls to .yield[] with macrospace enabled  : 2.1312
    10000 calls to .yield[] with macrospace disabled : 0.4531
(samples/benchmark/doers-benchmark-output.txt)
So I decided to add an option to control the use of macrospace :
    ::options MACROSPACE
    ::options NOMACROSPACE
    options "MACROSPACE"
    options "NOMACROSPACE"
By default, the macrospace is queried, according to the rules described in rexxref
section "7.2.1 Search order".
When using the option NOMACROSPACE, the macrospace is not queried.


Yet something to investigate (no relation with rxapi) : Under WinXP, a call to a routine
is much slower than a run of a method (sandbox or main - same results) :
    10000 calls of an empty routine by name : 0.2422
    10000 calls of an empty routine object  : 0.2437
    10000 runs of an empty method           : 0.0141
Under MacOsX, no such difference :
    10000 calls of an empty routine by name : 0.0103
    10000 calls of an empty routine object  : 0.0104
    10000 runs of an empty method           : 0.0087
(samples/benchmark/call-benchmark.rexx)


===============================================================================
2011 oct 26

Fixed a crash in relation with RexxContextualSource and GC :
Must mark objectVariables.

Fixed a crash in hostemu for Windows platform :
Must add RexxEntry in the declaration of GrxHost.


===============================================================================
2011 oct 23

[doers]

Currently {::coactivity ...} always create a routine from the source literal.
But a method can be also a coactivty.
Assuming 'coactive' is like an option for the directives ::method and ::routine,
I added the following tags :
::routine myRoutine coactive  --> tag = ::r[outine][.c[oactive]]
::method myMethod coactive    --> tag = ::m[ethod][.c[oactive]]

The following declarations are equivalent :
{::c[oactivity] ...}
{::r[outine].c[oactive] ...}

Example of coactive method :
c={::m.c self~each{.yield[arg(1)]}}~doer(.array~of(1,2,3))
c~do -- returns 1
c~do -- returns 2
c~do -- returns 3
The object is the array.
The method is {::m self~each{.yield[arg(1)]}} where self is the array.

Something to think about :
When the doer is a method, the object on which the method is applied is passed as
first argument of ~do. And the rest of the arguments are passed to the method in
arg(1), arg(2), ...
    {::m say self~class ":" arg(1)}~doer~do(.array~new, "2nd arg") -- The Array class : 2nd arg
is implemented by
    .array~new~run(doer, "i", "2nd arg")
When the doer is a coactive method, the object on which the method is applied is
passed using ~doer and memorized by the coactivity. That makes sense since the method
can yield several result, and it's the same object which is used at each resume.
But then, the ~do method has less arguments.
    {::m.c say self~class ":" arg(1)}~doer(.array~new)~do("1st arg") -- The Array class : 1st arg
Internally, the call to the method is the same as a normal method, but with this test that I have
only in coactivity (for the moment) :
    if doer~needsObject then doer~doWith(object, arguments) -- object needed (message, method)
    else doer~doWith(arguments) -- no object needed (routine)
I could modify .MethodDoer~doer to pass the object with ~doer. But that breaks a lot of code.
And I would need to do the same for StringDoer~doer (a .Message is sent to an object,
the object is passed as first argument of ~do).
    say "+"~doer~do(1,2) -- here, 1 is the object : 1~send("+", 2)
Will see on usage if this difference of parameters between a method and a coactive method
is effectively a problem or not...


[functional]

Simplification :
I follow the same approach than for pipes, by transforming the source literals
to add the parameters value and index.
For reduce, three parameters are passed : accu, value, index.
A difference with pipes, when calling the doer~do method, I pass the index only if
~functionDoer exists on the doer. That lets use messages like "+" with reduce.
The current pipe implementation does not support doers of type message (and will
never do), because strings are recognized as options, not as doers.

Consequence :
reduceI, reduceCI, reduceWI, mapI, mapCI, mapWI, mapRI, mapCRI, mapWRI, eachI, eachCI, eachWI : removed
eachII, eachCII, eachWII : renamed respectively eachI, eachCI, eachWI


===============================================================================
2011 oct 18

I just discovered that I have a conflict on the ~doer method for .Coactivity :
In coactivity.cls, "doer" is a private attribute
In doers.cls, "doer" is a public method on CoactivityDoer.

After thoughts, I find that using ::attribute for a private object variable is probably
a wrong decision. With expose, no risk of such conflict.
-->
Now using expose.


Added the method 'executable' to give access to the routine or method controlled by the
coactivity.


===============================================================================
2011 oct 16


[functional]

Refactoring of ~reduce, ~map and ~each :
- Since a parameter "options" is supported by ~reduce and ~map, I could remove
  ~reduceChar ~reduceWord ~mapChar ~mapWord, and pass an option "char" or "word"
  to the methods ~reduce and ~map.
  After experimentation, I think it's not a good idea. More verbose to write, and
  sometimes must omit parameters.
  The reading of http://en.wikipedia.org/wiki/Fold_(higher-order_function) convinced
  me to have different methods names, using one letter for each option, including the
  "indexed" and "inplace" options, "inplace" being renamed "replace".
  Consequence : the parameter "options" is removed.
- ~map allowed to update in-place, but the design decisions were not good... I limited
  this option to collections which understand ~append, because I wanted to support
  deletion (filtering) of items. But that's a bad idea, better to not allow deletion
  and use []= for assignment. That will work with any collection, including multi-
  dimensional arrays.
- String and MutableBuffer are a special case, where ~append is more appropriate for
  implementing ~map. Filtering is supported.
- ~map and ~each had overlapping features. Now, these methods have distinct usage :
  The result returned by ~map has the same type as the self object.
  The result returned by ~each is either an array or no result (if procedural action).
  ~map can be in-place, ~each is never in-place.
  ~map can't filter collections, ~each can filter collections.
- ~each must be available on String and MutableBuffer. The result is an array or no result.

In summary :
(update JLF 23 oct 2011 : the xxxI methods have been removed, the xxxII methods have been renamed xxxI)
                reduce   reduceC   reduceW   map   mapC   mapW   mapR   mapCR   mapWR   each    eachC    eachW
                reduceI  reduceCI  reduceWI  mapI  mapCI  mapWI  mapRI  mapCRI  mapWRI  eachI   eachCI   eachWI
                                                                                        eachII  eachCII  eachWII
.String         ............X.........X..............X......X......................................X........X...
.MutableBuffer  ............X.........X..............X......X.............X.......X................X........X...
.Array          ...X..........................X....................X......................X.....................
.Bag            ...X..........................X....................X......................X.....................
.CircularQueue  ...X..........................X....................X......................X.....................
.Directory      ...X..........................X....................X......................X.....................
.List           ...X..........................X....................X......................X.....................
.Properties     ...X..........................X....................X......................X.....................
.Queue          ...X..........................X....................X......................X.....................
.Relation       ...X..........................X....................X......................X.....................
.Set            ...X..........................X....................X......................X.....................
.Stem           ...X..........................X....................X......................X.....................
.Table          ...X..........................X....................X......................X.....................
.IdentityTable  ...X..........................X....................X......................X.....................
.Supplier       ...X......................................................................X.....................
.Coactivity     ...X......................................................................X.....................

Reduce on non-ordered collections will give good results only with commutative operations.
Ex : any collection can be reduced with "+", but only ordered collections should be reduced with "-".

Experimental : I search my way to implement lazy iterators using coactivities.
I created additional methods like
    ~times.yield
    ~yield.upto
    ~yield.downto
They work as expected, but having to create a new method to manage the coactivity sounds not good.
Especially if I want to do the same for the ~each methods (21 methods to add...).
So far, I see these possibilities :
    1~yield.upto(10){arg(1)}   -- Current implementation, with a distinct method which creates the coactivity and delegates to ~upto which yields each value.
    1~upto(10, .true){arg(1)}  -- Pass a boolean to ask for a coactivity. The coactivity and the yield are managed by ~upto.
    1~upto(10){.yield[arg(1)]} -- The yield is done by the doer. Problem : ~upto has no way to know that a coactivity must be created...
                               -- ...unless the doer "knows" it contains a yield, and ~upto can test that...
According to what I see in Python, the interpreter automatically creates a generator when a yield is in the code of a function.
At the first call of the function, the generator object is returned.
    def countdown(n):
        print "Counting down from", n
        while n > 0:
            yield n
            n -= 1
    >>> x = countdown(10)
    >>> x
    <generator object at 0x58490>
    >>>
So it looks similar to the third solution. Except that in the Python example, the loop and the yield are in the same function.
In the case of ~upto, the loop and the yield are not in the same routine.


===============================================================================
2011 oct 02

[parser]

For good or bad reason, arg(1) at the begining of a clause is recognized as an
instruction, because arg is a keyword instruction.
I often use source literals like {arg(1)...} where I want arg(1) to be interpreted
as a function call. So I decided to change the behavior of the parser to interpret
as a function call any symbol followed immediatly by a left paren, even if the
symbol is a keyword instruction.

With implicit return, such an expression is quite common when filtering : value==1
    .array~of(1,2,1)~pipe(.select {value==1} | .console)
but the parser raises an error to protect the user against a potential typo error,
assuming the user wanted to enter : value=1.
I deactivated this control, now the expression above is ok.
Yes, it remains a problem (no syntax error, but it's an assignment, not a test) :
    .array~of(1,2,1)~pipe(.select {value=1} | .console)
good point, the lack of returned value is detected, must surround by parentheses
to make it a real expression.
    .array~of(1,2,1)~pipe(.select {(value=1)} | .console)
(an Array),1 : 1
(an Array),3 : 1


[functional]

reduce : added optional initial value
123~reduceChar("+")                    -- initial value is the first char (default), returns 6
123~reduceChar(100, "+")               -- initial value is 100, returns 106
"10 20 30"~reduceWord("+")             -- initial value is the first word (default), returns 60
"10 20 30"~reduceWord(100, "+")        -- initial value is 100, returns 160
.array~of(10, 20, 30)~reduce("+")      -- initial value is the first item (default), returns 60
.array~of(10, 20, 30)~reduce(100, "+") -- initial value is 100, returns 160

(update JLF 16 oct 2011 : 'option' parameter removed)
reduce : added option "ind[exed]"
    arg(1) : accumulated result
    arg(2) : current item of collection
    arg(3) : current index of collection, passed only if option "ind[exed]" is specified
"10 20 30"~reduceWord(, "ind"){arg(1) + arg(2) + arg(3)}         -- initial value is the first word (default), index passed as 3rd argument, returns 10 + 20+2 + 30+3 = 65
"10 20 30"~reduceWord(0, "ind"){arg(1) + arg(2) + arg(3)}        -- initial value is 0, index passed as 3rd argument, returns 0 + 10+1 + 20+2 + 30+3 = 66
.array~of(10, 20, 30)~reduce(, "ind"){arg(1) + arg(2) + arg(3)}  -- initial value is the first item (default), index passed as 3rd argument, returns 10 + 20+2 + 30+3 = 65
.array~of(10, 20, 30)~reduce(0, "ind"){arg(1) + arg(2) + arg(3)} -- initial value is 0, index passed as 3rd argument, returns 0 + 10+1 + 20+2 + 30+3 = 66

map : can act as a filter.
"one two three"~mapWord{if arg(1)~length == 3 then arg(1)} -- returns "one two"

(update JLF 16 oct 2011 : 'option' parameter removed)
map : added option "ind[exed]".
    arg(1) : current item of collection
    arg(2) : current index of collection, passed only if option "ind[exed]" is specified
"one two three"~mapWord("ind"){arg(2)":"arg(1)} -- returns "1:one 2:two 3:three"

(update JLF 16 oct 2011 : no result instead of .nil when nothing returned)
(update JLF 16 oct 2011 : no longer raise an error if no action : default is {arg(1)})
times : now can act as an array generator.
3~times{0}          -- returns .array~of(0,0,0)
3~times{arg(1)}     -- returns .array~of(1,2,3)
3~times{say arg(1)} -- returns .nil : no resulting array because no result returned during the iteration
3~times             -- raise an error because the parameter action is mandatory

(update JLF 16 oct 2011 : no result instead of .nil when nothing returned)
upto and downto : now can act as an array generator.
11~upto(13)             -- returns .array~of(11,12,13) because the default action is {arg(1)}
(-1)~upto(3)            -- returns .array~of(-1,0,1,2,3) -- Note that -1 MUST be surrounded by paren or quotes
11~upto(13){2*arg(1)}   -- returns .array~of(22,24,26)
11~upto(13){say arg(1)} -- returns .nil : no resulting array because no result returned during the iteration

(update JLF 16 oct 2011 : now, ~each always return an array)
each : can act as a collection generator and a filter.
The type of generated collection depends on the type of itererated source :
    collection --> same type of collection
    supplier --> array
    coactivity --> array
.array~of(1,2,3)~each{2*arg(1)}                       -- returns .array~of(2,4,6)
.set~of(1,2,3)~each{2*arg(1)}                         -- returns .set~of(2,4,6)
.set~of(1,2,3)~supplier~each{2*arg(1)}                -- returns .array~of(2,4,6)
{::c do i=1 to 3; .yield[i]; end}~doer~each{2*arg(1)} -- returns .array~of(2,4,6)
1~upto(20){if arg(1) // 3 == 0 then arg(1)}           -- returns .array~of(3,6,9,12,15,18) -- filter

[pipes]

pipeIndex representation : When using the option 'showTags', a tag class#id is
inserted before the representation of objects. The id is a short id (starts from 1,
incremented for each new instance of the same class in the index).
before : tag1['a',1,2,3,4]|tag2['a',1,2]|tag3[(22222),(my file)]
now    : tag1['a',1,2,3,4]|tag2['a',1,2]|tag3[MutableBuffer#1(22222),File#1(my file)]

pipeIndex representation : ~makeString takes two additional parameters :
localMask : which local indexes to include ("" means all). Ex : "2 3".
showNested : if .false then the nested index is not included.

Added two scripts to illustrate how a pipeline can be used for real scripts :
grep_sources.rex
trailing_whitespaces.rex


[profiling]

Added support for class methods.
But that won't work with standard ooRexx, because depends on ~setMethod which is private.


[array programming]

Currently investigating this area from several languages : APL, J, F-Script.
A first consequence was the modification of ~times ~upto ~downto and ~each to make them
generators of array.

Work in progress in extension/array.cls


===============================================================================
2011 sep 18

[pipes]

.startsWith now accepts a variable number of arguments (like .all and .notAll).
The value is selected if it starts with one of the strings passed as argument.

New pipeStage .endsWith, useful to test the suffix of files.
"c:\"~pipe(.fileTree | .endsWith["sys", "bat"] caseless | .console)

Added partition support to pipeStages that delay their output :
.drop, .take, .buffer, .lineCount, .charCount, .wordCount
(.take had already partition support for 'first' but not for 'last').

New management of indexes.
A pipeIndex is an array of variable length :
array[1] : tag (generally the id of the pipeStage class, or "source" for the initial index)
array[2] : nested pipeIndex (received from previous pipeStage)
array[3] : optional local index1
array[4] : optional local index2
etc...
When a pipeStage receives an index and a value, it applies transformations or
filters on the value. When a value is forwarded to a following pipeStage, it can
be accompanied by a new index that encapsulates the received index and add a tag
and local indexes. See option 'memorizeIndex' below.
Conventions followed in this pipeline implementation :
- The received value becomes the first local index (you have a call stack with arguments).
- If the pipeStage generates several values from the received value, then a second
  local index is added, which gives the position of the current generated value.
- If the pipeStage lets create a user-defined index (ex : .inject), then this index
  becomes the third (and following) local index.

The creation of the pipe indexes is controlled by the option 'memorizeIndex' (abbrev 'mem').
This option is available from any pipeStage.
By default, the pipe indexes are not created, except for the source of the pipeline.

.inject : adaptation of the behaviour to the new management of indexes.
Two options are available : 'memorizeIndex' and 'recursive.memorizeIndex'.
By default, no index is memorized by .inject.
In the example below, the first column is the source index (always memorized)
1~pipe(.inject {value+1} recursive.2 | .console)
1,1 : 2
1,1 : 3
1,1 : 4
Here, the last index calculated by .inject during recursive calls is memorized.
1~pipe(.inject {value+1} recursive.2 mem | .console)
1,1|1,1 : 2
1,1|2,1 : 3
1,1|3,1 : 4
Here, the intermediate indexes calculated by .inject during recursive calls are memorized.
No need to specify the stand-alone 'memorizeIndex' option, because 'recursive.memorizeIndex'
includes its functionality (but you can if you wish, it's just redundant).
1~pipe(.inject {value+1} recursive.2.mem | .console)
1,1|1,1 : 2
1,1|1,1|2,1 : 3
1,1|1,1|2,1|3,1 : 4

A memorized index can be retrieved by tag.
Example :
This pipeline iterates over all the files in the ooRexx install directory.
For each file, iterates over its contents, line by line.
Selects the lines which contain '::class'.
The .take pipeStage takes only one line per file.
'C:\Program Files\ooRexx\'~pipe(.fileTree recursive | .getFiles memorize | .all['::class'] | .take 1 {index~get('getFiles')~value} | .console)
Example of output :
'C:\Program Files\ooRexx\',1|(C:\Program Files\ooRexx\csvStream.cls),55 : ::class CsvStream subclass Stream Public
'C:\Program Files\ooRexx\',1|(C:\Program Files\ooRexx\mime.cls),49 : ::class mimepart public
'C:\Program Files\ooRexx\',1|(C:\Program Files\ooRexx\OODIALOG.CLS),54 : ::class 'DialogExtensions' public MIXINCLASS object
...

The class pipeIndex has a specific 'makeString' method which accepts two arguments :
- showTags (default .false) : when .true, the tags are inserted in the representation string.
- showPool (default .false) : when .true, a value which appears several times is replaced by
  a reference to the first occurence of the value.
Strings are surrounded by quotes, except string numbers.
To make a distinction between a real string and other objects, the representation
of instances of objects other than strings are surrounded by round brackets.
Example :
i1 = .pipeIndex~create("tag1", .nil, 1)                   -- 1
i2 = .pipeIndex~create("tag2", i1, "a")                   -- 1|'a'
i3 = .pipeIndex~create("tag3", i2, .mutableBuffer~new(2)) -- 1|'a'|(2)
i4 = .pipeIndex~create("tag4", i3, .file~new("c:\"))      -- 1|'a'|(2)|(c:)
i5 = .pipeIndex~create("tag5", i4, .file~new("c:\"))      -- 1|'a'|(2)|(c:)|(c:)
say i5~makeString(.true)                                  -- tag1[1]|tag2['a']|tag3[(2)]|tag4[(c:)]|tag5[(c:)]
say i5~makeString(.false, .true)                          -- 1|'a'|(2)|i1=(c:)|i1

.console :
- By default, the tags of the pipe indexes are not displayed by .console.
  Use the option 'showTags' to see them.
- .console always use showPool=.true.
- By default, .console writes a newline at the end of the text.
  If the last expression is an empty string "" then no newline is written.


===============================================================================
2011 sep 04

[pipes]

Standardization of doers usage :
    try first ~functionDoer,
    then ~actionDoer (if candidate),
    then ~doer.
The goal is to accept traditional routines or methods everywhere a functionDoer is
accepted. Currently, only RexxContextualSourceDoer has the methods ~functionDoer
and ~actionDoer.
Ex :
.sort myRoutine
where myRoutine is a routine which returns a result that is used as key for sorting.
Before, only .sort {my source literal} was accepted.

The .system pipeStage now manages a private queue for each execution of command.

The .inject pipeStage now accepts the options 'before' and 'after'.
When using 'before', the new values generated from the current value by .inject
are written to the pipe before writing the current value :
    new_values value.
When using 'after', the new values generated from the current value by .inject
are written to the pipe after writing the current value :
    value new_values.
You can specify both 'before' and 'after'. In this case, you will have the sequence
    value new_values value
The option 'append' has been removed, since equivalent to 'after'.
The option 'replace' has been removed, because useless (just don't use 'before'
and 'after' to get the same effect).


[source literal]
Fixed a crash in relation with line adjustment.


===============================================================================
2011 aug 21

Refinement of tokens 'subclass' attribute (for analysis) :
The scanner splits a source file in clauses, and decompose each clause in tokens.
Then the parser creates an AST from the tokens.
The tokens were not annotated by the parser to attach semantic information found
during parsing. After a discussion with Rony about syntax coloring, I decided to
see which informations could be added to the tokens. I found that the attribute
'subclass' of the tokens could hold informations like that :
IS_KEYWORD
IS_SUBKEY
IS_DIRECTIVE
IS_SUBDIRECTIVE
IS_CONDITION
IS_BUILTIN
There is no impact on the interpreter, as far as I can tell... Except maybe the
tokenized files ? did not check.

For the moment, there is no access to the clauses/tokens from an ooRexx script.
If the environment variable RXTRACE_PARSING=ON then the clauses and tokens are
dumped to the debug output (Windows) or the log (Unix) using dbgprintf.
See samples/parsing for an example of dump.

Interesting to watch :
http://ibm-netrexx.215625.n3.nabble.com/NetRexx-Eclipse-status-video-td3271843.html


===============================================================================
2011 aug 16

Fixed a crash in relation with source literals and GC.
Two problems :
1) Forgot to replace RexxDirectory by RexxList when disabling the optimization
for source literals (was a copy-paste of optimization done for string literals).
2) The constructor RexxSourceLiteral::RexxSourceLiteral can trigger a GC. Must protect
'this'.


Remember1:
----------
When the crash occurs during GC (ex : in ObjectHeader::isObjectMarked), it's possible
to see which ooRexx object is corrupted. Here the object is 0x7eeff200
 	rexx.dll!ObjectHeader::isObjectMarked(unsigned int mark)  Line 106 + 0xa bytes	C++
 	rexx.dll!RexxInternalObject::isObjectMarked(unsigned int markword)  Line 247 + 0x16 bytes	C++
 	rexx.dll!RexxListTable::live(unsigned int liveMark)  Line 55 + 0x26 bytes	C++
>	rexx.dll!RexxMemory::markObjectsMain(RexxObject * rootObject)  Line 374	C++                 <-- markObject = 0x7eeff200 {size=2129676696 elements=0x7eeff214 }  RexxListTable with OVERWRITTEN size !!!
 	rexx.dll!RexxMemory::markObjects()  Line 645	C++
 	rexx.dll!RexxMemory::collect()  Line 1022	C++

A conditional break "newObj == 0x7eeff200" on the last line of RexxMemory::newObject (RexxMemory.cpp)
lets stop the execution when the object is created. If too long, then modify the source :
    if (newObj == (RexxObject*)0x7eeff200)
    {
        int dummy=0;    //  <-- put breakpoint here
    }
    return newObj;
Once the interpreter is stopped here, it's relatively easy to do a code review of the methods
in the call stack, to check if an intermediate object must be protected.

If needed, a data breakpoint can be set on the part of memory which is overwritten
(here the 'size' attribute). In my case, was triggered when the object was inserted
in the list of dead objects.


Remember2:
----------
Occurences of new_directory, not protected (no crash so far, except for createConditionObject) :
DirectoryClass.cpp, RexxDirectory::newRexx (05/03/2012 : done when fixing OREF_INIT)
ExceptionClass.cpp, ExceptionClass::getCondition (05/03/2012 : done)
RexxActivation.cpp, RexxActivation::raise  : here, the conditionObj is passed by argument.
                                             BUT there is one case where conditionObj is created. To protect !
    called by RexxActivation::raiseExit --> the directory conditionobj is passed by argument, no need of protect here.
        called by RexxInstructionRaise::execute --> the directory conditionobj is created here, seems ok because comes from context->getConditionObj()
                                                    [06/03/2012] Got a GC crash where RexxInstructionRaise::execute is in the call stack...
                                                                 After a new review, I think that following variables must be protected : _result, _additional
    called by RexxInstructionRaise::execute --> the directory is created here, seems ok because comes from context->getConditionObj().
RexxActivity.cpp, RexxActivity::createConditionObject (fixed in sandbox)

Other potential problems. A fresh created object is not protected, and some calls are made that could trigger GC.
RexxBehaviour.cpp, RexxBehaviour::copy : newBehaviour is not protected. (05/03/2012 : done)
RexxBehaviour.cpp, RexxBehaviour::addScope : this->scopes->allAt(TheNilObject) creates an object which is not protected. (05/03/2012 : added to this->scopes, so seems protected)
RexxCollection.cpp, RexxHashTableCollection::copy : newObj is not protected.
    Should be protected only if ActivityManager::currentActivity != NULL, otherwise crash in implementation of ProtectedObject's methods
    (RexxHashTableCollection::copy is called during interpreter initialization, and at this time, ActivityManager::currentActivity == NULL).
ArrayClass.cpp, RexxArray::copy : newArray is not protected.
ClassClass.cpp, RexxClass::defineMethod : method_name and method_object are not protected.
ClassClass.cpp, RexxClass::methodDictionaryCreate : method_name is not protected.
DirectoryClass.cpp, RexxDirectory::copy : newObj is not protected.
ListClass.cpp, RexxList::copy : newList is not protected.
ObjectClass.cpp, RexxObject::copy : newObj is not protected.
ObjectClass.cpp, RexxObject::defMethod : msgname and methcopy are not protected.
InstructionParser.cpp, RexxSource::signalNew : newObject is not protected.
SourceFile.cpp, RexxSource::translateBlock : _instruction is not protected.


===============================================================================
2011 aug 14

[doers]

Modified functionDoer : Try first the source as-is, and in case of error try
the 'clause transformed to expression'.
Before this change :
    say {if .true then 2}~functionDoer~do
    -- display : "IF 1 THEN 2"
    -- because the clause has been transformed to an expression.
    say {if .true then 2}~functionDoer~source~tostring
    -- display :
    -- options "NOCOMMANDS" ; ( if .true then 2 )
    --  ; if var("result") then return result
Now :
    say {if .true then 2}~functionDoer~do
    -- display : "2"
    -- because the clause remains as-is :
    -- options "NOCOMMANDS" ; if .true then 2
    --  ; if var("result") then return result


[pipes]

New pipeStages :
.superClasses    : equivalent to .inject {value~superClasses}
.subClasses      : equivalent to .inject {value~subClasses}
.methods         : equivalent to .inject {value~methods}
.instanceMethods : equivalent to .inject {value~instanceMethods}
.system          : to execute a system command and get the contents of its stdout line by line

The index created by .inject is now a pair (value, resultIndex) where
- value is the processed value.
- resultIndex is the index of the current result calculated with value.
When doing recursive calculations and using the pushIndex option, the index
is like a call stack with intermediate results : you get one pair
(value, resultIndex) for each level of recursion.
Ex :
.stream~pipe(.superclasses recursive pushIndex | .console)
1|The Stream class|1 : The InputOutputStream class
1|The Stream class|1|The InputOutputStream class|1 : The Object class
1|The Stream class|1|The InputOutputStream class|2 : The InputStream class
1|The Stream class|1|The InputOutputStream class|2|The InputStream class|1 : The Object class
1|The Stream class|1|The InputOutputStream class|3 : The OutputStream class
1|The Stream class|1|The InputOutputStream class|3|The OutputStream class|1 : The Object class

New option 'unique' added to .inject.
When used, a value that has been already processed will not be processed again.
No need of having sorted values, a list of all previously processed values is kept.
This option is different from 'cycles' which lets stop infinite recursion (use
also a list, but the list is limited to the call stack).
Ex :
.stream~pipe(.superclasses recursive pushIndex unique | .console)
1|The Stream class|1 : The InputOutputStream class
1|The Stream class|1|The InputOutputStream class|1 : The Object class
1|The Stream class|1|The InputOutputStream class|2 : The InputStream class
1|The Stream class|1|The InputOutputStream class|3 : The OutputStream class


===============================================================================
2011 aug 14

Fixed a crash that occured after GC : in RexxActivity::createConditionObject),
the value returned by new_directory() must be protected.


[source literal]

Fixed a crash which occurred when running
    interpret "{"
where interpret is on line 2 or above.

I need a line adjustment (similar to what's done for interpret) for error reporting.
- The line adjustment is made only in case of immediate parsing.
- The current name 'interpret_adjust' is not adapted to source literals...
  Renamed 'line_adjust'.
- Same remark for RexxSource::interpretLine, renamed RexxSource::adjustLine.
- To support this line adjustment for source literals, I had to deactivate this
  optimization :
      case TOKEN_SOURCE_LITERAL:
          retriever = this->sourceLiterals->fastAt(name);
  Was a copy-paste of the optimization done for the string literals.
  Using this optimization, when the same source literal was used at different places
  in the package's source, only one instance of RexxSourceLiteral was created, and so
  only one routine object was created.
  Not sure it was a useful optimization for source literals.


===============================================================================
2011 july 31

[doers]

ClauseSupplier renamed Clauser because it does not follow the semantics of a supplier.
New implementation which is derived from the ooRexx scanner : the comments and
continuations are correctly supported.
The multiline clauses are flattened to get only monoline clauses (more easy to transform).

New kind of doers : coactivity

The tag can be abbreviated like that :
    ::m[ethod]
    ::c[oactivity]
    :[:routine]
    : (defaults to routine)

Exemple :
    doer = {::coactivity
            say "hello" arg(1)
            arg = .yield[]
            say "good bye" arg[1]
           }~doer
    say doer~class -- The Coactivity class
    doer~do("John") -- hello John
    doer~do("Kathie") -- good bye Kathie
    doer~do("Keith") -- <nothing done, the coactivity is ended>

    doer = {::c
            do i=1 to 10000000
                call charout ,"yield["i"] "
                .yield[i]
            end}~doer
    doer~pipe(.take 3 | .console)
    doer~pipe(.take 4 | .console)
    .coactivity~endAll
    ----------
    Output :
    yield[1] 1 : 1
    yield[2] 2 : 2
    yield[3] 3 : 3
    yield[4] 1 : 4
    yield[5] 2 : 5
    yield[6] 3 : 6
    yield[7] 4 : 7


[functional]

Make use of functionDoer to emulate pure expressions, but the current emulation shows its limits.
    arg(1) * 2 --> Incorrect PARSE template detected at "*"
If I change the expression to :
    2 * arg(1)
then it's ok.
That gave me the idea to modify functionDoer to surround the first clause other than "expose" and
"use [strict] arg" by round brackets. An error is raised if a clause other than "return" is found
after the surrounded clause. So the pattern is :
    [expose some variables]
    * point of insertion of clauseBefore
    [use [strict] arg some arguments]
    [a clause candidate to expression] --> if present then will be surrounded by round brackets
    [return something]
    * point of insertion of clauseAfter
In case of syntax error, the so-called 'clause candidate to expression' is used as-is.
Will see on usage if that works effectively...


===============================================================================
2011 july 31

The parsing of a source literal is now immediate when the first character is not ':'.
A routine is created and attached to the source literal.
This routine is accessible using the method RexxContextualSource~executable.
    routine = {say arg(1)+1}~executable
    routine~call(99) -- 100
[Updated 2011 dec 08] Next method has been removed, because now it's possible to
use directly ~do.
For convenience, this routine is callable using the method RexxContextualSource~call.
    {say arg(1)+1}~call(99) -- 100
    say {return arg(1)+1}~call(99) -- 100

A source literal starting with ':' is not parsed immediately (deferred parsing).
In this case, no routine is attached to the source literal.
    {:say arg(1)+1}~executable -- .nil
    [Updated 2011 dec 08] ~call has been removed
    {:say arg(1)+1}~call(99) -- Error : Incorrect call to routine
Such a source literal can be handled by the package extensions.cls :
    {:say arg(1)+1}~doer~do(99) -- 100
    [Updated 2011 dec 08] it's possible to use directly ~do
    {:say arg(1)+1}~do(99) -- 100
    ::requires "extension/extensions.cls"


===============================================================================
2011 july 25

[pipe]
.displayer renamed .console, to be closer to CMS pipeline.


[pipe extensions]
Refactoring of makeFunctionDoer and makeActionDoer : now implemented in doers.cls
as methods functionDoer and actionDoer on RexxContextualSource.


[doers]
New class ClauseSupplier which lets iterate over the clauses of a source and replace
a clause by a new clause.

New method sourceDoer which lets transform the source before creating a doer from it.
This method is used by functionDoer and actionDoer .
Ex :
    {if value==0 then "infinity" ; else 1/value}~functionDoer("use arg value")
returns a routine built using this transformed source
    {use arg value                            -- optional source fragment passed as parameter to functionDoer
     option "NOCOMMANDS"                      -- added by functionDoer : expressions are not commands in functions
     if value==0 then "infinity" else 1/value -- original source literal, unchanged
     if var("result") then return result}     -- added by functionDoer : returns the result of the last evaluated expression


===============================================================================
2011 july 21

[expression evaluation]
Added an option to control execution of commands :
    ::options COMMANDS
    ::options NOCOMMANDS
    options "COMMANDS"
    options "NOCOMMANDS"
By default, a clause consisting of an expression only is interpreted as a command string.
When using the option NOCOMMANDS, the value of the expression is stored in the
variable RESULT, and not interpreted as a command string.


[source literal]
Removed method RexxSourceLiteral::setSource
Removed method RexxContextualSource::setSource
Removed method RexxContextualSource~"source="
This assignment of source is not needed, and moreover was buggy (overwriting directly
the literal source in the directory of literals).


[source literal]
Now RexxSourceLiteral::getSource returns an array of strings, no longer a monoline string.
The monoline string was buggy, because continuation characters were not supported correctly.
And that's how the sources are managed everywhere else.


[source literal]
To investigate...
When a routine or method is created, a new RexxSource is created. So all the settings
defined on the package level (i.e. RexxSource) have the default values.
It's possible to pass a context from which a RexxSource is taken (called parentSource)
which allows the created routine/method to inherit class and routine lookup scope from
another source. Nothing else is inherited.
    [inherited from context]
        routines
        merged_public_routines
        installed_classes
        merged_public_classes
    [currently never inherited from context]
        digits
        fuzz
        form
        trace
        enableCommands
See RoutineClass::newRoutineObject and RexxMethod::newMethodObject, there is a call to
getSourceObject()->inheritSourceContext(parentSource).
This chained context is managed in the following methods :
    RexxSource::findLocalRoutine   (search in routines)
    RexxSource::findPublicRoutine  (search in merged_public_routines)
    RexxSource::findInstalledClass (search in installed_classes)
    RexxSource::findPublicClass    (search in merged_public_classes)
A source literal is somewhat special, because it's supposed to have all the settings of
the package in which it's defined (well, I suppose...). So, should find a way to
initialize the RexxSource of the source literal with the settings of the package.
Then, I have the same need for the settings of the RexxActivation in which the executable
created from the RexxContextualSource will run. I think that the closure will be the right
place to manage that, since the closure is a snapshot of the RexxActivation in which the
RexxContextualSource is created.


===============================================================================
2011 july 11

More work on pipe.

.inject : the detection of cycles has a runtime cost. This detection is no longer
active by default, must pass the option "cycles" to activate it.


.inject : it's now possible to replace completely the current index by a new index,
using .index_value or .value_index.
.array~of(10,20,30)~pipe(.displayer)
1 : 10
2 : 20
3 : 30
.array~of(10,20,30)~pipe(.inject {.index_value[value, 2*value]} | .displayer)
10 : 20
20 : 40
30 : 60


.inject : with option 'pushIndex', it's now possible to pass an array of indexes.
.array~of(10,20,30)~pipe(.inject {
    .index_value[ .array~of(value-1, value+1), 2*value ]
    } push | .displayer)
1|9|11 : 20
2|19|21 : 40
3|29|31 : 60


Made .do a subclass of .inject, because I realized that .do is really like .inject,
except for the execution of commands : with .do, you can execute address commands,
with .inject, it's not allowed.


.take : added support for partition expression, to take the specified number of
elements in the partition. When the partition key changes, the counter is reset.
.array~of(1,1,1,2,2,2,2,3,3,3,3,3,1,1,1)~pipe(.take 2 {value} | .displayer)
1 : 1
2 : 1
4 : 2
5 : 2
8 : 3
9 : 3
13 : 1
14 : 1


Added profiling of pipeline :
.array~of(b, a, c)~pipeProfile(.sort byValue | .displayer)
2 : A
1 : B
3 : C
----------------------------------------
.SORT~go
  .SORT~EOF count=1 duration=0
    .DISPLAYER~EOF count=1 duration=0
    .DISPLAYER~ISEOP count=6 duration=0
    .DISPLAYER~PROCESS count=3 duration=0
  .SORT~ISEOP count=3 duration=0
  .SORT~PROCESS count=3 duration=0
  .SORT~START count=1 duration=0
    .DISPLAYER~START count=1 duration=0
duration=0
----------------------------------------
The pipeline's methods to profile must be instrumented.
    ::method myMethod
    my code here...

    is instrumented to become :

    ::method myMethod protected        <-- will be intercepted
    forward message("myMethod_unprotected")

    ::method myMethod_unprotected      <-- the security manager will forward this message
    my code here...
The profiling has an impact on the performances, but the durations should keep their
proportions.


===============================================================================
2011 july 06

Adapted the package doers.cls to source literals.
The class String is no longer used to hold routine's source or method's source.
Now RexxContextualSource is used for that.
    doer = {use arg name; say "hello" name}~doer
    say doer~class -- The Routine class
    doer~do("John") -- hello John

    doer = {::method say "hello" self}~doer
    say doer~class -- The Method class
    doer~do("John") -- hello John
Strings are still used for doers of type Message.
    doer = "length"~doer
    say doer~class -- The String class
    say doer~do("John") -- 4


Adapted the samples in extension, concurrency, pipeline :
- No longer need to call Doers.AddVisibilityFrom(.context).
- Source fragments are no longer strings, but source literals.
- Use abbreviated syntax when passing source literals


===============================================================================
2011 july 06

When a source literal was evaluated by an interpret instruction, the package associated
to the RexxContextualSource (at parse time) was not holding the right informations
for class & routine lookup scope.
Symptom (assuming .myclass is visible from the current package, thanks to a ::requires) :
    {say .myclass}~doer~do             --> display The MYCLASS class (good)
    interpret "{say .myclass}~doer~do" --> display .MYCLASS          (not good)
Fixed by using the package associated to the RexxActivation in which the interpret is parsed.


I get "Error 49:  Interpretation error" when running
    rexx -e "v={}"
This is because SourceLiteral is currently a transient class, and I reach this code
in RexxEnvelope.cpp :
        // transient classes should never be flattened.  This is a problem if we encounter one
        if (newObj->behaviour->isTransientClass())
        {
            reportException(Error_Interpretation);
        }
Fixed by making the class SourceLiteral an internal class.


Added support for trailing blocks (similar to Groovy & Swift syntax for closures) :
    f{...} is equivalent to f({...})
    f(a1,a2,...){...} is equivalent to f(a1,a2,...,{...})
Example :
    10~times{call charout , arg(1)}  -- 12345678910
    4~upto(7){call charout , arg(1)} -- 4567

New method on class RexxContextualSource :
::method "source=" -- lets assign an updated source, while keeping all the contextual infos.
I need that for the pipe stages which accept source literals used as expression.
.select {value~isPrivate} --> the source of the RexxContextualSource is transformed to :
"use arg value, index; return value~isPrivate"
See makeFunctionDoer in pipeline/pipe_extension.cls.


===============================================================================
2011 june 27

Added support for source literals.
Currently, a source literal is surrounded by curly braces, which is probably heretical,
but my main focus is not on the syntax.
My needs :
- I need to make a distinction between a "real" string and a source literal.
  (will be useful for the pipeStage .Displayer)
- I need the context of the source literal's definer. Thay way, I no longer need to call
  Doers.AddVisibilityFrom.
- I need sometimes to transform the source (see pipelines : add arguments, add return),
  so must not be parsed too early because the initial source is not always valid ooRexx.
  I prefer to have the source as a single string, instead of an array of lines.
  (this transformation of source must be reworked, because current implementation is not
  very robust, especially for the insertion of return).
- I want to keep the current functionalities of doers. The source literal is passed
  as argument to .Method~new or .Routine~new, or used as a message when containing
  only one word.
In the current implementation, a source literal is a multiline string whose scanning is
aware of the ooRexx tokens. Curly braces in comments or in string are properly supported.
For the parser, a source literal is a token, which is translated to a RexxSourceLiteral
(transient class). When evaluated, a RexxSourceLiteral returns a RexxContextualSource
(exported class).

New class available from an ooRexx script :
::class RexxContextualSource
::method package -- the package where the source literal is defined.
::method context -- the context of the execution environment from which the source literal was evaluated.
::method source -- the text inside the curly braces, where '\n' has been replaced by ';'

Example of use :
The source literal can be assigned to a variable and passed as argument to a routine.

-- package1.rex
function = {use arg n
            return doubler(n)}
do v over map(.array~of(1,2,3,4), function)
    say v
end
::routine doubler
return 2*arg(1)
::requires package2.rex

-- package2.rex
::routine map public
use strict arg array, contextualSource
say contextualSource~source
-- parse only once, before iteration
routine = .routine~new("", contextualSource~source, contextualSource~package)
value = .array~new(array~items)
do v over array
    value~append(routine~call(v)) -- 'doubler', which is defined in package1, is visible
end
return value

Output :
use arg n;            return doubler(n)
2
4
6
8


===============================================================================
2011 june 25

More work on pipe.

.inject : added options 'append', 'pushIndex'.
The option 'recursive' has two new sub-options : 'depthFirst', 'breadthFirst'.

.fileTree : new pipeStage
Get the childrens (files or directories) of a file instance.

.fileText : new pipeStage
Get the contents of a text file line by line.

.words : new pipeStage
Get the words of the current value.

.characters : new pipeStage
Get the characters of the current value.


===============================================================================
2011 june 20

More work on pipe.

.sort : the doers are parsed as soon as possible (during initOptions)

.all, .startsWith, .notall, .between, .after, .before : added option 'caseLess'

.displayer : added options 'index', 'value', 'space', newline', expression

Added support for end of process (EOP). The idea comes from
CMS Pipeline Telecourse (http://www.vm.ibm.com/download/packages/descript.cgi?TCVM2)
<<
pipe < big file a | take 5 | console
The TAKE stage take the first 5 records passing through the pipe (in this case
coming from the disk-read stage). After having seen 5 records go by, the TAKE stage
tells the PIPE dispatcher "I've done my job, I don't need anything more...", and the
dispatcher in turn informs the previous stage that there isn't anybody listening
anymore to its output, so it can stop also.
So, a pipeline can suddenly collapse when one stage decides to stop
>>
There is no dispatcher in current implementation, but the idea of end of process is
very interesting. In particular with infinite coactivities :
.coactivity~new("i=0; do forever; i+=1; .yield[i]; end")~pipe(.take 5 | .displayer)
Also interesting with big files, when only the n first lines must be processed...

.drop : replace both .dropFirst and .dropLast

.take : replace both .takeFirst and .takeLast

.append : new pipeStage
Copy items from its primary input to its primary output, and then invoke the supplier
passed as argument and write the items produced by that supplier to its primary output.


===============================================================================
2011 june 13

More work on pipe.

.sort : refactoring of the internal helpers.
Now a single indexedValueComparator handles all the kinds of comparisons
(by value, by index, by expression).

.sort : added option 'strict'

.sort : can sort on several criteria.
The order in which the options are passed is the order in which they are executed.
A 'value' or 'index' or expression option is impacted only by the preceding options.

.inject : a limit can be specified with option recursive : recursive.10


===============================================================================
2011 june 09

More work on pipe.rex.

Added support to pass options to a pipeStage (use the blank operator) :
    .myStage[arg1, arg2, ...] option1 option2 ...

.sort : added options byValue, byIndex, ascending, descending, caseless, quickSort.

.sortWith : added option quickSort.

.inject : added option recursive.
In case of infinite recursion, the recursion is stopped. This is detected
by keeping a stack of items already processed.


===============================================================================
2011 june 09

The alternate syntax [] for pipeStage gave me the idea to do the same for the yield
method of the coactivity class.
    .yield[value]
    is equivalent to (and more compact than)
    .Coactivity~yield(value)
Remember : the blank operator would be still more compact,
    .yield value
but unfortunately a result is mandatory (an operator is not a message instruction),
and that triggers a command if the result is not used... So forget this syntax.


Side note : I start to find this triggering of commands seriously annoying !
Too easy to trigger a command accidentaly. Yes, I could use a security manager, but
would be tedious to put it *everywhere*.
To investigate : a message instruction can trigger a command only if surrounded by ().
Not possible to apply this rule all the time, including expressions ?
rm "*".lst --> the string "rm *.lst" would be assigned to the variable RESULT.
(rm "*".lst) --> the string "rm *.lst" would be submitted as a command to the external environment.
That way, the programmer controls explicitely where a command can be triggered.
Code review :
    SourceFile.cpp
        RexxSource::instruction
            this->messageNew
                RexxSource::messageNew
                    new RexxInstructionMessage
            this->commandNew
                RexxSource::commandNew
                    _expression = this->expression(TERM_EOC)
                        RexxSource::expression
                            this->subExpression(terminators)
                    new RexxInstructionCommand
    InstructionParser.cpp
        RexxInstructionCommand
        RexxSource::commandNew
            expression = this->expression(TERM_EOC)
    MessageInstruction.cpp
        RexxInstructionMessage::execute (assign the RESULT variable)
    CommandInstruction.cpp
        RexxInstructionCommand::execute
            RexxObject *result = this->expression->evaluate(context, stack);
                ***HERE*** could decide to assign result to RESULT instead of triggering command
            RexxString *command = REQUEST_STRING(result);    /* force to string form              */
            context->command(context->getAddress(), command);


Side note :
A message term can have one of the following forms :
    receiver~messagename:symbol(expression, ...)
    receiver~~messagename:symbol(expression, ...)
    receiver[expression, ...]
The receiver is a term.
Would it make sense to add that ?
    receiver(expression, ...)
Probably not, according to my tests :
    .c~"()"    -- the method "()" is called
    .c()       -- could not find routine ".C"
    ::class c
    ::method "()" class
A function call is a term in an expression calling a routine.
    function_name(expression, ...)
The function_name is a string literal or a single symbol, which is taken to be a constant.
So no way to have something similar to the C++ operator().


===============================================================================
2011 may 29

Modified pipe.rex to keep the index information of the collection passed as argument to ~go.
Useful when working with a collection of methods, where the name of the methods is available
only through the indexes.

Added the extension ~pipe to all objects.
myObject~pipe(myPipeline)

Added extensions to pipe.rex, to benefit from doers :
inject
do
select

Added the extension ~each to all the collections.

Added the extensions ~each and ~reduce to the suppliers.

Fixed a bug in rgf_util2 :
dump2 was not working with suppliers, because ~items was called.

Concurrency trace : report information about ovd, even if not yet assigned to the RexxActivation.
See getReserveCount and getVariableDictionary in RexxActivation.hpp.

Debug of semaphores : the variable name was overwritten, fixed.


===============================================================================
2011 may 29

Adaptation of concurrency trace to support 64 bits pointers.

Now, concurrency trace is displayed only when env variable RXTRACE_CONCURRENCY=ON

The debug messages for semaphores and mutexes are very costly : about 400 times
slower than main/trunk... Now, those messages are controlled by conditional
compilation, and activated only in debug configuration.

Slow learning curve of xcode4 under MacOsX, experimentation of several configurations :
gcc/debug
    $oorexx_src_dir/configure --prefix=$oorexx_delivery CFLAGS="-g -O0 -D_DEBUG" CXXFLAGS="-g -O0 -D_DEBUG"
gcc/default :
    $oorexx_src_dir/configure --prefix=$oorexx_delivery
gcc/release
    $oorexx_src_dir/configure --prefix=$oorexx_delivery CFLAGS="-g -O3" CXXFLAGS="-g -O3"
Currently using gcc only, but plan to test llvmgcc.
Each configuration is initialized by running a shell script located in the appropriate delivery folder.
If debug from xcode4 is needed, then must launch xcode4 from the config's shell : open -a xcode4
The directory layout is like that :
oorexx
    build
        main
            releases
                4.1.0
                    trunk
                        gcc
                            default : run configure here
            trunk
                gcc
                    default : run configure here
        sandbox
            jlf
                trunk
                    gcc
                        debug : run configure here
                        default : run configure here
                        release : run configure here
    delivery
        main
            releases
                4.1.0
                    trunk
                        gcc
                            default : setenv.sh to declare config variables
            trunk
                gcc
                    default : setenv.sh to declare config variables
        sandbox
            jlf
                trunk
                    gcc
                        debug : setenv.sh to declare config variables
                        default : setenv.sh to declare config variables
                        release : setenv.sh to declare config variables
    svn
        main
            trunk
        sandbox
            jlf
                trunk

===============================================================================
2011 mar 18

Added an early traceEntry for proper diagnostic in case of deadlock of guarded method.
See test cases in samples/concurrency :
deadlock1.rex
deadlock2.rex

Fixed in RexxActivation::run


===============================================================================
2011 mar 17

I have a small problem with doers :
Any routine/method created by StringDoer will have a lookup scope limited to the
doers package, because the routines/methods are created from the doers package,
not from the caller's package.
StringDoer~doer accepts a context parameter to let the caller pass its own lookup scope,
but this is tedious to pass it explicitely at each call.
Example from oorexxshell :
say .color                     -- The COLOR class
"say .color"~doer~do           -- .COLOR because the COLOR class is not visible from doers
"say .color"~doer(.context)~do -- The COLOR class

I provide the convenience routine "Doers.AddVisibilityFrom" which lets see from doers
the same packages/methods/routines as the caller.
Usage from caller's package :
call Doers.AddVisibilityFrom(.context)
::requires "extension/doers.cls"
With this sequence, no need to pass explicitely the .Context when creating a doer :
"say .color"~doer~do           -- The COLOR class

This problem would not exist if we had support for first-class expressions/instructions
that are parsed in place, instead of being parsed by StringDoer.
https://sourceforge.net/mailarchive/message.php?msg_id=19911593
https://sourceforge.net/mailarchive/message.php?msg_id=19912031
The proposed syntax [expr] lets defer the evaluation of expr, but is not supposed to
support instructions (why not ?).
Maybe
    c = .Coactivity~new("do i = 1 to 10 ; .Coactivity~yield(i) ; end")
could become
    c = .Coactivity~new([do i = 1 to 10 ; .Coactivity~yield(i) ; end])
In this case, the context is the "good" context, i.e. the context of the place from where
the block is parsed. The distinction expression/instructions is similar to the distinction
eval/apply in Lisp : You evaluate an expression, you apply a method/routine to a list of
arguments.


===============================================================================
2011 mar 17

m17n :
Don't use strong types by default, because gcc can't compile as-is.
Fixed compilation errors under Linux.


===============================================================================
2011 mar 16

I learned recently that ooRexx manages nested guard conditions...
So, I added new informations in the trace output :
- variable dictionary id (3rd column)
- nesting counter (4th column)

Raw trace, generated by rexx :
00004fec 7efc0fb0 7efc10f0 00001*     79 *-* if start
00004fec 7efc0fb0 7efc10f0 00001*        >V>   START => "1"
00004fec 7efc0fb0 7efc10f0 00001*        >>>   "1"
00004fec 7efc0fb0 7efc10f0 00001*     79 *-*   then
00004fec 7efc0fb0 7efc10f0 00001*     79 *-*     self~start
00004fec 7efc0fb0 7efc10f0 00001*        >V>       SELF => "a Coactivity"
00004fec 7efc9918 7efc10f0 00002*        >I> Method START with scope "The Coactivity class" in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\concurrency\coactivity.cls
...
00004fec 7efc9918 7efc10f0 00002*     93 *-* reply self
00004fec 7efc9918 7efc10f0 00002*        >V>   SELF => "a Coactivity"
00004fec 7efc9918 7efc10f0 00002*        >>>   "a Coactivity"
00004fec 7efc0fb0 7efc10f0 00001*        >>>       "a Coactivity"
00004fec 7eee9be8 00000000 00000         >M>   "NEW" => "a Coactivity"
0000478c 7efc9918 7efc10f0 00001*        >I> Method START with scope "The Coactivity class" in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\concurrency\coactivity.cls
00004fec 7eee9be8 00000000 00000         >>>   "a Coactivity"
0000478c 7efc9918 7efc10f0 00001*     94 *-* .Activity~local~empty


Human readable trace, generated by rexx trace/tracer using raw trace as input :
T1   A4     V2      1*     79 *-* if start
T1   A4     V2      1*        >V>   START => "1"
T1   A4     V2      1*        >>>   "1"
T1   A4     V2      1*     79 *-*   then
T1   A4     V2      1*     79 *-*     self~start
T1   A4     V2      1*        >V>       SELF => "a Coactivity"
T1   A5     V2      2*        >I> Method START with scope "The Coactivity class" in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\concurrency\coactivity.cls
...
T1   A5     V2      2*     93 *-* reply self
T1   A5     V2      2*        >V>   SELF => "a Coactivity"
T1   A5     V2      2*        >>>   "a Coactivity"
T1   A4     V2      1*        >>>       "a Coactivity"
T1   A3                       >M>   "NEW" => "a Coactivity"
T2   A5     V2      1*        >I> Method START with scope "The Coactivity class" in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\concurrency\coactivity.cls
T1   A3                       >>>   "a Coactivity"
T2   A5     V2      1*     94 *-* .Activity~local~empty


===============================================================================
2011 mar 10

Implemented an emulation of coroutine, named "coactivity" to follow the ooRexx
vocabulary. This is not a "real" coroutine implementation, because it's based on
ooRexx threads and synchronization. But at least you have all the functionalities
of a stackful asymmetric coroutine (resume + yield). All is in place to support
symmetric coroutines (yield only), but the scheduler remains to implement.

For a better support of coactivity, I'm thinking to modify the interpreter :
Arguments can be passed by the consumer when he resumes a coactivity.
For the first resume, the traditional arguments declaration can be used on the producer side.
But for the following resumes, it's less declarative : you get only an array returned by yield.
I'd like to use the traditional arguments declaration everywhere...
    consumer : res = coactivity~resume(arg1, arg2)
               res = coactivity~resume(arg1, arg2)
               ...
    producer : use strict arg arg1, arg2
               res = f(arg1, arg2)...
               args = coactivity~yield(res) --> returns an array of arguments
               use strict arg arg1, arg2   --> but this array of arguments can't be read that way
               ...

For an example of coroutine implementation for the HotSpot JVM, see :
http://ssw.jku.at/Research/Papers/Stadler11Master
I found the reading interesting because :
- Java, like ooRexx, has synchronized threads.
- Java, like ooRexx, doesn't support real coroutines.
- With the proposed implementation for JVM, operations on coroutines implicitly always
  operate on the current thread. This allows the system to assume that only a minimal amount
  of synchronization is necessary.


===============================================================================
2011 mar 10

For all scripts under jlf/sandbox/samples, use path relative to samples in requires,
assuming the path to samples will be in the PATH.


Refactoring of extension :
- Separation between code for standard ooRexx (in subdirectory std), and sandbox.
- Removed factory.rex : can be replaced by ~enhanced
- When ~enhanced can't be used then use delegation

Current pattern for standard ooRexx, to extend a predefined class, assuming that
the name of the predefined class is "ClassName", and the name of the extension
is "Extension" (no need of that with ::extension) :

::class ClassNameExtension mixinclass Object public

::method init
    expose className -- optional : an encapsulated instance of the predefined class
    use arg className=.nil

::method myMethod
    expose className
    if var("className"), className <> .nil then self = className -- delegates to the encapsulated instance
    -- here your extension code which depends on self

::class ExtendedClassName subclass ClassName public inherit ClassNameExtension1 ClassNameExtension2 ...

The level of integration brougth by extension/std is poor compared to the integration with ::extension !
Most of the time, you will create instances of your extended class.
Ex : .ExtendedString~new("say 2*arg(1)")~doer~do(10) -- display 20
But sometimes, you must work with instances returned by the interpreter, and you can't create an instance
of your extended class. In this case, you create an instance of your extension mixin which encapsulates the
instance returned by the interpreter.
Ex : routine = .context~package~findRoutine("multiply_by_2")
     doer = .RoutineDoer~new(routine)
     doer~do(10) -- display 20

     ::routine multiply_by_2
     say 2*arg(1)


===============================================================================
2011 mar 09

Send the trace output to the debug output.
Made the debug output of SysSemaphore and SysMutex compatible with trace output.
Now I get the trace lines and the interpreter locks in the same stream, and I can
parse them with tracer.rex (could be faster, but...).

0001eab4 7eff0af8 *     89 *-* reply self
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.release : before ReleaseMutex(0x1fb4) from ActivityManager::unlockKernel (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.release : after ReleaseMutex(0x1fb4) from ActivityManager::unlockKernel (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.requestImmediate : before WaitForSingleObject(0x1fb4) from ActivityManager::lockKernelImmediate (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.requestImmediate : after WaitForSingleObject(0x1fb4) from ActivityManager::lockKernelImmediate (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.release : before ReleaseMutex(0x1fb4) from ActivityManager::unlockKernel (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.release : after ReleaseMutex(0x1fb4) from ActivityManager::unlockKernel (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.requestImmediate : before WaitForSingleObject(0x1fb4) from ActivityManager::lockKernelImmediate (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.requestImmediate : after WaitForSingleObject(0x1fb4) from ActivityManager::lockKernelImmediate (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.release : before ReleaseMutex(0x1fb4) from ActivityManager::unlockKernel (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.release : after ReleaseMutex(0x1fb4) from ActivityManager::unlockKernel (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.requestImmediate : before WaitForSingleObject(0x1fb4) from ActivityManager::lockKernelImmediate (0x55dec0)
0001eab4 00000000   ...... ... (SysMutex)ActivityManager::kernelSemaphore.requestImmediate : after WaitForSingleObject(0x1fb4) from ActivityManager::lockKernelImmediate (0x55dec0)
0001eab4 7eff0af8 *        >V>   SELF => "a COACTIVITY"


===============================================================================
2011 feb 27

Implemented the script samples\trace\tracer.rex.
This script lets :
- replace hexadecimal values by more human-readable values like T1, A1.
- generate a CSV file, for further analysis with your favorite tool.

Can be used as a pipe filter (reads from stdin) :
rexx my_traced_script.rex 2>&1 | rexx tracer

or can read from a file :
rexx tracer -csv my_trace_file.txt


===============================================================================
2011 feb 24

Added thread id, activation id and lock flag in the lines printed by trace.
Should help to analyze the traces of a multithreaded script.

Not sure yet to have covered all the cases, since I modified only this method :
RexxActivity::traceOutput
But looks good on my first tests.

The extract below illustrates quite well the problem of interleaved traces.
See after the reply, two threads are running concurrently.

coroutine~start -- guarded
coroutine~resume -- unguarded

0000ccac 7efcae78 *        >I> Method START with scope "The COROUTINE class" in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\generator\coroutine.cls
...<snip>...
0000ccac 7efcae78 *     92 *-* status = .Coroutine~suspended
0000ccac 7efcae78 *        >E>   .COROUTINE => "The COROUTINE class"
0000ccac 7efcae78 *        >M>   "SUSPENDED" => "1"
0000ccac 7efcae78 *        >>>   "1"
0000ccac 7efcae78 *        >=>   STATUS <= "1"
0000ccac 7efcae78 *     93 *-* guard off
0000ccac 7efcae78       94 *-* reply self
0000ccac 7efcae78          >V>   SELF => "a COROUTINE"
0000ccac 7efcae78          >>>   "a COROUTINE"
0000c8dc 7efcae78          >I> Method START with scope "The COROUTINE class" in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\generator\coroutine.cls
0000ccac 7efd0968          >I> Method RESUME with scope "The COROUTINE class" in package D:\local\Rexx\ooRexx\svn\sandbox\jlf\samples\generator\coroutine.cls
0000c8dc 7efcae78       95 *-* signal on any
0000ccac 7efd0968      162 *-* expose status yieldValue
0000c8dc 7efcae78       96 *-* guard on when status <> .Coroutine~suspended
0000ccac 7efd0968      163 *-* if status == .Coroutine~notStarted
0000c8dc 7efcae78 *        >V>   STATUS => "1"
0000ccac 7efd0968          >V>   STATUS => "1"

If you redirect the stderr to a file, and open it with Excel, then you can filter by thread and/or by activation.


===============================================================================
2010 nov 14

I have reached a state where the interpreter is no longer broken by m17n.
The most difficult bugs were because of the default constructor of rxStringSize.
By assigning 0 (a good practice for me), I had nasty bugs in the parser.
Solved by leaving the attribute uninitialized...
Remember :

RexxSource::sayNew
    RexxObject *_expression = this->expression(TERM_EOC);
    RexxInstruction *newObject = new_instruction(SAY, Say);     <-- location is copied from this->clause by RexxSource::sourceNewObject
    new ((void *)newObject) RexxInstructionSay(_expression);    <-- boom ! location is overwritten by default constructor of rxStringSize

inline RexxBuffer *new_buffer(sizeB_t s) { return new (size_v(s)) RexxBuffer; }     <-- bufferSize and dataLength were always 0 !
void *RexxBuffer::operator new(size_t size, size_t _length)
    newBuffer->bufferSize = _length;    <-- initialized here, *before* the execution of default constructor
    newBuffer->dataLength = _length;    <-- same problem


Now, the next step is probably to change the signature of the methods in StringUtil,
to pass a IRexxString parameter, instead of a couple (char*, size_t) which are the
internal attributes stringData and length.


===============================================================================
2010 oct 10

rexx.h
Defined strong types to detect misuse between 'size in bytes' and 'size in chars'.
When changing the sources for m17n, I activate the strong types.
Otherwise I use the weak types.
See rxStringSize.


===============================================================================
2010 sept 24

Started a review of the NetRexx specification, in unicode/_readme.odt.
The goal is to see how the issues reported by Rick are covered by NetRexx.


===============================================================================
2010 sept 20

Fixed the build of m17n under Linux.
Had to rename all the *.c files to *.cpp, because .c source files are not correctly
built by Makefile.am.


Note about Parrot :
The charset/encoding merge has been moved in Parrot's trunk.
I will probably apply this merge.


===============================================================================
2010 sep 05

Found a bug, fixed in sandbox, to fix in trunk.
.mutablebuffer~new('abcdef')~replaceat('XXX', 1, 16)
makes the interpreter crash.


Parrot charset/encoding merge :
http://lists.parrot.org/pipermail/parrot-dev/2010-September/004678.html
I will wait for the move in Parrot's trunk before analysing that.


===============================================================================
2010 aug 28

Added encoding to RexxString (m17n) : I borrowed the Parrot's implementation
(the overall design is kept, but a lot of things has been adapted to ooRexx).

For the moment, I have three sources of inspiration : Parrot, Ruby, Falcon
I choosed Parrot to start, because it uses ICU if available at compile-time.
It's a minimal use, but at least I can put my hands on ICU through a concrete work.
One pointer for charset and one pointer for encoding is probably too much, but this is
how Parrot is implemented... And a third pointer is coming, for NFG.
[2010 aug 25] New, there is an RFC to merge charsets and encodings :
http://lists.parrot.org/pipermail/parrot-dev/2010-August/004633.html

Ruby's m17n is more complete than Parrot's, but seems more difficult to apprehend.
The encoding is stored as a 16 bits index.

Falcon is not like Parrot or Ruby, its internal charset is Unicode only.
I'm interested by its "string polymorphism".
The string manager (ako encoding) is stored as a pointer.

See unicode/_readme.odt for more details.


To build with ICU under Windows :
    set HAVE_ICU=1      <-- assign 0 or put this line in comment if you don't want to build with ICU
    set icu_dir=D:\local\Unicode\ICU\icu4c-4_4_1-Win32-msvc9
    set PATH=%icu_dir%\bin;%PATH%
    set INCLUDE=%icu_dir%\include;%INCLUDE%
    set LIB=%icu_dir%\lib;%LIB%

The environment variable HAVE_ICU is tested in buildorx.bat :
    set ICU_OPTION=
    if defined HAVE_ICU set ICU_OPTION="HAVE_ICU=%HAVE_ICU%"
    NMAKE /F INTERPRETER.MAK %ICU_OPTION%

interpreter.mak :
    !IFNDEF HAVE_ICU
    HAVE_ICU=0
    !ENDIF

    !IF "$(HAVE_ICU)" == "0"
    ICU_OPTIONS=
    !ELSE
    ICU_OPTIONS=/DHAVE_ICU
    !ENDIF


Careful if building from Visual Studio (no problem when building from Cmd shell) :
The INCLUDE environment variable is redefined by Visual Studio, and because of that,
the ICU headers are not found. You must launch Visual Studio like that :
    vcexpress /useenv
See makeorx_verbose.bat for more details to build from Visual Studio.


===============================================================================
2010 july 3

Continue Unicode review : added notes about Falcon.

Adapted ooRexxTry to use UTF-8 encoding and Arial Unicode MS.
Preloads all the main components (math, ftp, socket, bsf, hostemu, ...).


===============================================================================
2010 july 3

Debug crash in gc
RexxMemory::markObjectsMain
    markObject->live(liveMark);

0x003d2b8c                                          --> this is 0x7eee1ac0->behaviour
Access violation reading location 0x44414550        --> this is the vfptr of the behaviour of a string

((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*markObject))))).__vfptr


RexxMemory::mark(RexxObject *markObject)
    pushLiveStack((RexxObject *)markObject->behaviour);
markObject = 0x7eee1ac0                             --> see below, this is the 30th element of string array
    [RexxString]
               if tmp<2 then         -- start at first char

called by RexxArray::live(size_t liveMark)      ArrayClass.cpp
where this = 0x7f30ed70
this->objects = 7f30ed98
arrayPtr=7f30ee0c
0x7f30ee0c - 0x7f30ed98 = 116 = 29 * 4 --> this is the 30th element

element 1 to 13 : not a string... but doesn't be a problem
+		(*(RexxString*)this->get(14)).stringData	0x7eee36a4 "  len1=length(arg1string)        -- get length of string"	char [4]
+		(*(RexxString*)this->get(15)).stringData	0x7eee3704 "  newArr=.array~new        -- create new array for the arguments"	char [4]
+		(*(RexxString*)this->get(16)).stringData	0x7eee376c "  newArr[1]=new1string     -- "new"-string"	char [4]
+		(*(RexxString*)this->get(18)).stringData	0x7eee37e4 "  prepend=""               -- optional prepend string (if positioning before start!)"	char [4]
+		(*(RexxString*)this->get(20)).stringData	0x7eee388c "  arg2startori=arg2start         -- save passed-in value, if any"	char [4]
+		(*(RexxString*)this->get(21)).stringData	0x7eee38f4 "  if arg4pad=="" then arg4pad=" "-- define blank as the default pad char"	char [4]
+		(*(RexxString*)this->get(23)).stringData	0x7eee398c "  if arg(3,"Exists") then  -- start in "target"-string"	char [4]
+		(*(RexxString*)this->get(24)).stringData	0x7eee2dfc "  do"	char [4]
+		(*(RexxString*)this->get(25)).stringData	0x7eee2e2c "     if datatype(arg2start,"W") then"	char [4]
+		(*(RexxString*)this->get(26)).stringData	0x7eee2e7c "     do"	char [4]
+		(*(RexxString*)this->get(27)).stringData	0x7eee2eac "        if arg2start<0 then      -- negative, start from right"	char [4]
+		(*(RexxString*)this->get(28)).stringData	0x7eee2f14 "        do"	char [4]
+		(*(RexxString*)this->get(29)).stringData	0x7eee2f44 "           tmp=len1+arg2start+1  -- get starting position"	char [4]
+		(*(RexxString*)this->get(30)).stringData	0x7eee1ae4 "           if tmp<2 then         -- start at first char"	char [4]
+		(*(RexxString*)this->get(31)).stringData	0x7eee1b44 "           do"	char [4]
+		(*(RexxString*)this->get(32)).stringData	0x7eee1b7c "              if tmp<0 then"	char [4]

The behaviour of the 30th element is broken :
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(28))))).behaviour)))))).__vfptr	0x003aa62c const RexxBehaviour::`vftable'	*
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(29))))).behaviour)))))).__vfptr	0x003aa62c const RexxBehaviour::`vftable'	*
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(30))))).behaviour)))))).__vfptr	0x44414548	*
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(31))))).behaviour)))))).__vfptr	0x003aa62c const RexxBehaviour::`vftable'	*
+		((*(RexxVirtualBase*)(&(*(RexxInternalObject*)(&*(((*(RexxInternalObject*)(&*(this->get(32))))).behaviour)))))).__vfptr	0x003aa62c const RexxBehaviour::`vftable'	*

the behaviour of 30th element is stored at 0x7eee1acc


called by RexxMemory::markObjectsMain(RexxObject *rootObject)
where rootObject =
+		rootObject	0x003d2a90 class RexxMemory memoryObject {markWord=1 markReason=1 variableCache=0x7f5b55a8 ...}	RexxObject *

called by RexxMemory::markObjects()

called by RexxMemory::collect()

objectclass.hpp
inline void   setBehaviour(RexxBehaviour *b) { behaviour = b; }         <-- this method is called to assign the behavior of type 22 (T_String)
>	rexx.dll!RexxInternalObject::setBehaviour(RexxBehaviour * b)  Line 265 + 0x10 bytes	C++
 	rexx.dll!RexxObject::initializeNewObject(unsigned int mark, void * vft, RexxBehaviour * b)  Line 362	C++
 	rexx.dll!RexxMemory::newObject(unsigned int requestLength, unsigned int type)  Line 1134	C++
 	rexx.dll!new_object(unsigned int s, unsigned int t)  Line 422 + 0x1e bytes	C++
 	rexx.dll!RexxString::newString(const char * string, unsigned int length)  Line 1894 + 0xd bytes	C++
 	rexx.dll!new_string(const char * s, unsigned int l)  Line 521	C++
 	rexx.dll!RexxSource::get(unsigned int _position)  Line 838 + 0x1d bytes	C++
 	rexx.dll!RexxSource::extractSource(SourceLocation & location)  Line 1119 + 0x10 bytes	C++                 <-- counter = 735
 	rexx.dll!RexxCode::getSource()  Line 199	C++
 	rexx.dll!BaseExecutable::source()  Line 149	C++
 	rexx.dll!CPPCode::run(RexxActivity * activity, RexxMethod * method, RexxObject * receiver, RexxString * messageName, RexxObject * * argPtr, unsigned int count, ProtectedObject & result)  Line 144 + 0x6 bytes	C++
 	rexx.dll!RexxMethod::run(RexxActivity * activity, RexxObject * receiver, RexxString * msgname, RexxObject * * argPtr, unsigned int count, ProtectedObject & result)  Line 325	C++
 	rexx.dll!RexxObject::messageSend(RexxString * msgname, RexxObject * * arguments, unsigned int count, ProtectedObject & result)  Line 793	C++
 	rexx.dll!RexxExpressionStack::send(RexxString * message, unsigned int count, ProtectedObject & result)  Line 74 + 0x33 bytes	C++
 	rexx.dll!RexxExpressionMessage::evaluate(RexxActivation * context, RexxExpressionStack * stack)  Line 139	C++
 	rexx.dll!RexxExpressionMessage::evaluate(RexxActivation * context, RexxExpressionStack * stack)  Line 123 + 0x23 bytes	C++
 	rexx.dll!RexxInstructionAssignment::execute(RexxActivation * context, RexxExpressionStack * stack)  Line 122 + 0x1d bytes	C++
 	rexx.dll!RexxActivation::run(RexxObject * _receiver, RexxString * msgname, RexxObject * * _arglist, unsigned int _argcount, RexxInstruction * start, ProtectedObject & resultObj)  Line 522	C++
 	rexx.dll!RexxCode::call(RexxActivity * activity, RoutineClass * routine, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, RexxString * calltype, RexxString * environment, int context, ProtectedObject & result)  Line 116	C++
 	rexx.dll!RexxCode::call(RexxActivity * activity, RoutineClass * routine, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, ProtectedObject & result)  Line 92	C++
 	rexx.dll!RoutineClass::call(RexxActivity * activity, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, ProtectedObject & result)  Line 234	C++
 	rexx.dll!InterpreterInstance::runRequires(RexxActivity * activity, RexxString * name, RoutineClass * code)  Line 877	C++
 	rexx.dll!InterpreterInstance::loadRequires(RexxActivity * activity, RexxString * shortName, RexxString * fullName)  Line 932	C++
 	rexx.dll!RexxSource::loadRequires(RexxActivity * activity, RexxString * target)  Line 6082 + 0x14 bytes	C++
 	rexx.dll!PackageClass::loadPackage(RexxString * name, RexxArray * s)  Line 366 + 0x16 bytes	C++             <-- rgf_util2.rex


The previous behaviour is overwritten by
inline void insertAfter(DeadObject *newDead)            DeadObject.hpp
where newDead = 7eee1ac0
 	rexx.dll!DeadObject::insertAfter(DeadObject * newDead)  Line 89	C++
 	rexx.dll!DeadObjectPool::add(DeadObject * obj)  Line 165	C++
>	rexx.dll!NormalSegmentSet::addDeadObject(char * object, unsigned int length)  Line 461	C++
 	rexx.dll!MemorySegmentSet::sweep()  Line 1170	C++
 	rexx.dll!RexxMemory::collect()  Line 1038	C++
 	rexx.dll!NormalSegmentSet::handleAllocationFailure(unsigned int allocationLength)  Line 1272	C++
 	rexx.dll!RexxMemory::newObject(unsigned int requestLength, unsigned int type)  Line 1117 + 0x12 bytes	C++ <-- length = 48, we are in "small object" part (lesser than LargeBlockThreshold 4096)
 	rexx.dll!new_object(unsigned int s, unsigned int t)  Line 422 + 0x1e bytes	C++
 	rexx.dll!RexxString::newString(const char * string, unsigned int length)  Line 1894 + 0xd bytes	C++
 	rexx.dll!new_string(const char * s, unsigned int l)  Line 521	C++
 	rexx.dll!new_string(const char * s, unsigned int l)  Line 521	C++
 	rexx.dll!RexxSource::get(unsigned int _position)  Line 838 + 0x1d bytes	C++
 	rexx.dll!RexxSource::extractSource(SourceLocation & location)  Line 1119 + 0x10 bytes	C++                 <-- counter = 754
 	rexx.dll!RexxCode::getSource()  Line 199	C++
 	rexx.dll!BaseExecutable::source()  Line 149	C++
 	rexx.dll!CPPCode::run(RexxActivity * activity, RexxMethod * method, RexxObject * receiver, RexxString * messageName, RexxObject * * argPtr, unsigned int count, ProtectedObject & result)  Line 144 + 0x6 bytes	C++
 	rexx.dll!RexxMethod::run(RexxActivity * activity, RexxObject * receiver, RexxString * msgname, RexxObject * * argPtr, unsigned int count, ProtectedObject & result)  Line 325	C++
 	rexx.dll!RexxObject::messageSend(RexxString * msgname, RexxObject * * arguments, unsigned int count, ProtectedObject & result)  Line 793	C++
 	rexx.dll!RexxExpressionStack::send(RexxString * message, unsigned int count, ProtectedObject & result)  Line 74 + 0x33 bytes	C++
 	rexx.dll!RexxExpressionMessage::evaluate(RexxActivation * context, RexxExpressionStack * stack)  Line 139	C++
 	rexx.dll!RexxExpressionMessage::evaluate(RexxActivation * context, RexxExpressionStack * stack)  Line 123 + 0x23 bytes	C++
 	rexx.dll!RexxInstructionAssignment::execute(RexxActivation * context, RexxExpressionStack * stack)  Line 122 + 0x1d bytes	C++
 	rexx.dll!RexxActivation::run(RexxObject * _receiver, RexxString * msgname, RexxObject * * _arglist, unsigned int _argcount, RexxInstruction * start, ProtectedObject & resultObj)  Line 522	C++
 	rexx.dll!RexxCode::call(RexxActivity * activity, RoutineClass * routine, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, RexxString * calltype, RexxString * environment, int context, ProtectedObject & result)  Line 116	C++
 	rexx.dll!RexxCode::call(RexxActivity * activity, RoutineClass * routine, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, ProtectedObject & result)  Line 92	C++
 	rexx.dll!RoutineClass::call(RexxActivity * activity, RexxString * msgname, RexxObject * * argPtr, unsigned int argcount, ProtectedObject & result)  Line 234	C++
 	rexx.dll!InterpreterInstance::runRequires(RexxActivity * activity, RexxString * name, RoutineClass * code)  Line 877	C++
 	rexx.dll!InterpreterInstance::loadRequires(RexxActivity * activity, RexxString * shortName, RexxString * fullName)  Line 932	C++
 	rexx.dll!RexxSource::loadRequires(RexxActivity * activity, RexxString * target)  Line 6082 + 0x14 bytes	C++
 	rexx.dll!PackageClass::loadPackage(RexxString * name, RexxArray * s)  Line 366 + 0x16 bytes	C++             <-- rgf_util2.rex
    while loading rgf_util2.rex

Why is 0x7eee1ac0 a dead object ?
In RexxSource::extractSource, the array "source" is created, but is not a ProtectedObject.


===============================================================================
2010 may 15

Fix build under Windows for dbgprintf (link error).

Changed the build for "oodialog" target :
Builds both oodialogA and oodialogW (and not just oodialogA as before)
Ex :
makeorx BOTH oodialog clean --> cleans the debug & release files of oodialogA and oodialogW
makeorx BOTH oodialog       --> builds the debug & release files of oodialogA and oodialogW

Made a review of the conversions and removed those unneeded.
opts can remain byte-char.
strdupupr and strdupupr_nospace can remain byte-char.
setControlData can remain byte-char. The conversion is done internally.
putUnicodeText converts to wide-char, so no need to convert byte-char to wide-char before calling it (but keep the wide-char signature)


===============================================================================
2010 may 15

Added the function dbgprintf to write debug strings.
Under Windows, it calls OutputDebugString.
Under Linux, it calls syslog.

Remember, typical debug session under PuppyLinux (with busybox) :
Open a console :
    syslogd -S -C   # -S Smaller loggin output. -C Log to share mem buffer (read it using logred).
    logread -f
    The output of syslog is displayed by logread in this console (lock management, on client and server side).
Open a console, launch rxapi.
    Has been compiled to stay as a foreground process.
    It sends debug strings to stderr, more easy to follow in this console (messages between client and server).
Open a console, run the rexx command. The two other consoles are updated with debug infos.


[2011 apr 25 update]
Under MacOsX, I see this message in console : process exceeded 500 log messages per second limit.
To bypass this limit :
Edit /System/Library/LaunchDaemons/com.apple.syslogd.plist with xcode (binary format)
Search for : <string>/usr/sbin/syslogd</string>
Add these lines to the program arguments section :
<string>-mps_limit</string>
<string>0</string>
A value of 0 disables the limit. The default is 500 messages per second.
Restart the syslog daemon with:
sudo launchctl unload /System/Library/LaunchDaemons/com.apple.syslogd.plist
sudo launchctl load /System/Library/LaunchDaemons/com.apple.syslogd.plist
-----
LOG_DEBUG messages still not visible in console...
Probably because of /etc/asl.conf :
    # save everything from emergency to notice
    ? [<= Level notice] store
Remember :
    Emergency     (level 0)
    Alert         (level 1)
    Critical      (level 2)
    Error         (level 3)
    Warning       (level 4)
    Notice        (level 5)
    Info          (level 6)
    Debug         (level 7)
-----
Create the file /var/log/debug.log :
sudo touch /var/log/debug.log
Add this line to /etc/syslog.conf to get the debug messages in /var/log/debug.log :
*.debug   /var/log/debug.log
then restart the syslogd daemon as explained above.


===============================================================================
2010 may 14

More work on wide-chars in oodialog.

Fixed a crash in the conversion A2W and W2A : The length must be asked to the Windows service,
and not calculated with bad assumptions as I did.


Something not clear to me :
In oodMessaging.cpp, there is a message queue implemented as a string.
Each element is separated by a special character 0xFF.
This message queue is declared rxcharT, so it's a wide-char string when building the wide-char configuration.
Several methods have a rexxMethod parameter, and I declared it rxcharT.
But normally, a method name is always a byte-char string, there is no need to convert it to wide-char...
Problem : if I declare it as rxcharA, then what should I do with the pMessageQueue ?
Can I declare it rxcharA ? in this case, I must encode wide-char to byte-char each time a message is added
Or is it better to keep it rxcharW ? Currently addDialogMessage takes two wide-char arguments...
It's a matter of conversion boundary...


The japanese characters are not properly displayed by MessageBox (i.e. InfoDialog).
It seems that under XP, one must install files for complex scripts.
Not needed under Vista.
--> go to the "Regional and Language Options" control panel, go to the "Languages" tab,
and select "Install filesfor complex script...".
You need to reboot :-(
--> good, after reboot it works...


===============================================================================
2010 may 13

More work on wide-chars in oodialog.

New configuration names : oodialogA and oodialogW.
No longer needed to pass "WCHAR=1" to build the wide-char configuration.
makeorx DEBUG                   builds both configurations
makeorx DEBUG oodialogA         builds the byte-char configuration
makeorx DEBUG oodialogA clean   cleans the byte-char configuration
makeorx DEBUG oodialogW         builds the wide-char configuration
makeorx DEBUG oodialogW clean   cleans the wide-char configuration
makeorx DEBUG oodialog          like oodialogA

byte-char and wide-char configurations of oodialog are working, tested with oodialog examples.
There are some problems, but I have the same problems in trunk, so I assume there are some work in progress there...

Test of wide-char configuration :
It's not enough to put win32dbg/wchar in fromt of %PATH%, you must also rename
or remove win32dbg/oodialog.dll because it's this DLL which is loaded by default.
See unicode/ooRexx/oodtree.png for a screenshot with french, german, hebrew, russian, greek, etc...

Summary of the changes made to the oodtree example :
oodtree.rex, added : call setCodePage 65001 -- UTF-8
oodtree.rc, changed : FONT 8, "Arial Unicode MS"
oodtree.inp, added UTF-8 strings for demo


===============================================================================
2010 may 9

Added support for wide-chars in oodialog.
Currently, the "A" Windows API is called, and the conversion occurs there, inside Windows, based on the current locale.
When compiling ooDialog with wide chars UTF-16, the "W" API is called directly, making the dialogs Unicode-enabled.
GTK+ uses UTF-8 internally. Most of  the Unix-style operating systems use UTF-8 internally.
So it's natural to use multi-byte chars in ooRexx instead of wide chars, and to provide string services which supports UTF-8.
But the case of ooDialog is different :
This is a Windows-only sub-system, and for better integration with Windows, it must use UTF-16 chars internally.
The conversion to UTF-16 is under the responsability of ooDialog, which lets support code pages that are different
from the system's default code page. Typically, we can pass UTF-8 string to ooDialog which convert them to UTF-16 strings
before calling the Windows "W" API.

By default, the byte-char configuration is built when buildling the whole interpreter :
makeorx DEBUG

To build the byte-char configuration only, enter :
makeorx DEBUG oodialog
or
makeorx DEBUG oodialog "WCHAR=0"


To clean the byte-char configuration, enter :
makeorx DEBUG oodialog clean
or
makeorx DEBUG oodialog clean "WCHAR=0"

To build the wide-char configuration, enter :
makeorx DEBUG oodialog "WCHAR=1"
The output files are generated in the subdirectory win32dbg\wchar

To clean the wide-char configuration, enter :
makeorx DEBUG oodialog clean "WCHAR=1"


===============================================================================
2010 april 28

rgf_util2 wrappers to make the services of Rony available as methods on predefined classes.
For proof of concept... For a real library of methods, rgf_util2 should be rewritten to use
the variable "self" where appropriate, instead of passing the object as first parameter.



===============================================================================
2010 april 25

Add ::extension directive
todo : Limit the extension to new methods, raise an error if redefining a predefined method
(but keep ~define unlocked for investigation).

todo : I don't manage dependencies on ExtensionDirective
See RexxSource::resolveDependencies, there is maybe something to do there.
Currently, if the same method is extended several times, then it's the "last" extension who wins...
The definition of "last" depends on the order of resolution of ::requires
See samples\extension\test_extension_order.rex

Remember :
Unlike ::class, you can have several ::extension in the same source for the same class.
So the current check for duplicate method in an ExtensionDirective is not very useful.
The interpreter will complain for that :
::extension object
::method m
::method m
but not for that :
::extension object
::method m
::extension object
::method m


===============================================================================
2010 april 24

Unlock ~define


Creation of sandbox :
cd D:\local\Rexx\ooRexx\svn\sandbox
mkdir jlf
svn add jlf
svn commit jlf
svn copy https://oorexx.svn.sourceforge.net/svnroot/oorexx/main/trunk https://oorexx.svn.sourceforge.net/svnroot/oorexx/sandbox/jlf
svn update jlf

rev 5812
merge 5812-5835 from main/trunk
merge 5835-5957 from main/trunk
merge 5957-5988 from main/trunk
merge 5988-6048 from main/trunk
merge 6048-6142 from main/trunk
merge 6142-6189 from main/trunk
merge 6189-6500 from main/trunk

merge 6500-6784 from
    main/trunk/api
    main/trunk/extension/hostemu
    main/trunk/interpreter
    main/trunk/platform
    main/trunk/rexxapi

merge 6784-6976 from
    main/trunk/configure.ac (except oodialog)
    main/trunk/Makefile.am
    main/trunk/makeorx.bat
    main/trunk/extensions/platform/unix
    main/trunk/extensions/rexxutil
    main/trunk/extensions/rxsock
    main/trunk/interpreter
    main/trunk/platform/unix
    main/trunk/rexxapi

move oodialog to oodialog.wchar
commit
copy oodialog from trunk
commit
merge 6500-7390 from main/trunk/samples
merge 6784-7390 from main/trunk/platform/windows
merge 6976-7390 from main/trunk
revert oodialog (to stay with the last copied version)
revert oodialog.wchar (to not take into account the new oodialog)
resolve remaining conflicts
commit

merge 7390-7647 from main/trunk
revert oodialog.wchar (to not take into account the new oodialog)
Strange, when comparing after merge oodialog in my sandbox with trunk, I get a lot of differences
after the merge, whereas I should have zero difference. Not sure it's a good decision, but to fix that,
I made a copy-paste of the whole oodialog from trunk to my sandbox...
Same problem with samples/windows/oodialog (first level) : fixed by copy
Same problem with samples/windows/oodialog/examples (first level) : fixed by copy
Same problem with samples/windows/oodialog/examples/resources (first level) : fixed by copy

merge 7647-7688 from main/trunk

merge 7688-7691 from main/trunk

merge 7691-7736 from main/trunk

merge 7736-7771 from main/trunk

merge 7771-8678 from main/trunk

merge 8678-9423 from main/trunk

merge 9423-9515 from main/trunk

merge 9515-9978 from main/trunk
remove oodialog :
main/trunk/extensions/platform/windows/oodialog
main/trunk/samples/windows/oodialog

9980..10164     cmake support

10083   Clean up some build-time messages that don't really provide any useful information any more

10167..10170    modernize samples

to merge:
10171   [bugs:#1266] qualify() BIF Crashes Interpreter
10195   [#596] Add a package method to the Class class
10196   [#598] Allow .File object on .Properties load and save methods
10203   Fix use of uinitialized variable in the rxmath extension.
10205   [feature-requests:#451] add contains method to String Class...non-word versions for string and mutablebuffer
10207   [feature-requests:#451] add contains method to String Class...the word versions for both string and mutablebuffer

The hostile fork starts at 10208, ends at 10464.
From now, it's impossible to merge trunk in Executor repository.


Remember Cornerstone :
Merge by cherry-pick, option ignore line endings
To solve conflict, select file, then Working Copy/Resolve conflict using File Merge
In FileMerge, if you don't see the merged file, then drag the splitter bar at the bottom of the window
In FileMerge, there is a default merge applied, even on conflicted area.
If the default merge is ok, then just File/Save merge.
Back in Cornerstone, click the button Resolve.
