Sandbox for experimental work, unsorted notes.


Try to understand the internal locks.
--> added some dbgprintf (Windows and Linux), now must analyze...


Allow extension of the predefined ooRexx classes to get something similar to C# extension methods (but more powerful).
done.
--> unlock the define method : see samples/functional for an example of use.
    unlock the inherit method
    added ::extension directive
    >>-::EXTENSION--classname----+-------------------+-----------------><
                                 +-INHERIT--iclasses-+


Add the "in" keyword to the DO repetitor : Similar to "over" but calls the method "supplier" instead of "makearray".
[2015 Jul 12] : no longer needed to work on that, ooRexx5 supports DO WITH index ITEM item OVER supplier.
todo: retrofit in executor.


See if a thread could return more than one result and become a generator when synchronized with : do i in generator ...
--> done with .Coactivity


Export the classes instantiated by the parser and make expression instances available from an ooRexx script.
Inspired by C# LINQ and the expression tree API.
See if that can be used to write macros (i.e. transform expression tree), user directives, DSL...
todo...


Named parameters (by opposition to positional parameters).
--> done.


Deferred evaluation of parameters.
Let the routine/method decide which parameters must be evaluated, ex : iif(cond, iftrue, iffalse)
todo


Investigate the Activation stack (reify ? closure ? continuation ?)
--> closure by value : done


Unicode ?
--> added support for wide-chars in oodialog. [now deprecated]
--> frozen : m17n (this is not the way proposed by Rick)
--> investigate a new approach: Encoded strings (RexxText layer above String)


Extension of the message term : keyword and multiple dispatch.
http://atomo-lang.org/
http://slatelanguage.org/
https://julialang.org/
todo...


Pipes todo :
.inject in breadthFirst mode is not limited by the ooRexx callstack size.
Do the same for depthFirst mode.
1~pipe(.inject {2*item} rec.506 | .take last | .console) is ok, but if you do one more recursion,
you get the error "Insufficient control stack space; cannot continue execution"
No such problem in breadthFirst mode :
1~pipe(.inject {2*item} rec.b.100000 | .take last | .console) --> last result is 1.99800307E+30103


Pipes todo :
Add partition support to .stemCollector, .arrayCollector
For .arrayCollector, the collected values will be arrays.
For .stemCollector, I don't know.
Is .stemCollector really needed ? I don't see the added value, compared to .arrayCollector


Extension todo :
Forbids to replace a predefined method. The goal is to extend, not to alter the behavior.
Maybe not so easy to do for 'inherit'.
2022 Oct 15: no, must be able to replace a predefined method. Example:
    -- Compatibility with ooRexx5
    .MutableBuffer~define("appendLegacy", .MutableBuffer~method("append"))
    .MutableBuffer~define("append", "do i=1 to arg(); self~appendLegacy(arg(i)); end; return self")



Extension todo :
Add the parameters "unlock=.false, propagate=.false" to the methods .class~define and .class~inherit.


Extension todo:
The instance methods added on Object by extension are not available from Class.
For the moment, must duplicate the instance method at class level.
It's a problem of propagation.


Profiler todo :
Error "does not understand message XXX_UNPROTECTED" when the method XXX is private.


Clauser todo :
Keep the multi-line source literals as-is (multi-line), for better error report.
That makes the transformation of clauses more difficult, since a clause can be
multi-line.
Remember : a multi-line source literal is flattened only if a transformation is
made on the clause which contains it.


Error reporting todo :
A block line number is relative to the block, should be relative to its package,
except when interpreted (in ooRexxShell, I want the line number relative to the block).


Tail recursion todo:
See if it's possible to modify the implementation of FORWARD to reduce the
comsumption of stack frames.


Stems to investigate:
This functionality is not working with stems:
    "When a variable has no value, the interpreter sends the message "NOVALUE" to the
    object .local["NOVALUE"]."
constants.infinity = "very big"
constants.=
    a Stem (1 items)
    'INFINITY' : 'very big'     -- should be 'The positive infinity'
x = infinity
constants.x = "very big"
constants.=
    a Stem (2 items)
    'INFINITY'              : 'very big'
    'The positive infinity' : 'very big'


================================================================================
cmake, makefile
================================================================================

# Under Windows, to see the full command line
set MAKEFLAGS=U
nmake install VERBOSE=1

https://stackoverflow.com/questions/57358039/how-to-see-the-underlying-compiler-linker-command-line-with-cmake-nmake
nmake has an option to display inline files / response files:
    /U Dump inline files
For recursive make you might want to set this in an environment variable like this:
    set MAKEFLAGS=U
This way, the content of all response files will appear on the console.


================================================================================
Align CMakeLists.txt with official
================================================================================

-DORX_CATDIR="${catdir}"

to remove ?
set (build_extensions_rexxutil_dir ${build_extensions_dir}/rexxutil)
set (build_extensions_rexxutil_platform_dir ${build_extensions_rexxutil_dir}/${ORX_PLATFORM_DIR})



CMakeLists
diff official vs executor
---
975-977


Rechercher occurences BUILD_DEB OR BUILD_RPM
devrait être supprimé


================================================================================
Tail recursion (todo)
================================================================================

See if it's possible to modify the implementation of FORWARD to reduce the
comsumption of stack frames.
Should be possible when the option CONTINUE is not used.
Could be used to emulate tail recursion.
Under MacOs, last value before stack overflow when calculating the factorial:
x86_64  Executor: 1056      ooRexx5: 17441 (yes! and then segmentation fault)
arm64   Executor: 4282      ooRexx5: 20079 and then seg fault
    use arg n
    say factorial(n)
    return
    factorial:
    use arg n
    if n==0 then return 1
    else return n * factorial(n-1)
x86_64  Executor:  736      ooRexx5: 793
arm64   Executor: 3778      ooRexx5: 886        bizarre!
    use arg n
    say factorial(n)
    return
    ::routine factorial
    use arg n
    if n==0 then return 1
    else return n * factorial(n-1)
x86_64  Executor:  487      ooRexx5: 511
arm64   Executor: 2293      ooRexx5: 591        bizarre!
    use arg n
    say factorial(n)
    return
    ::routine factorial
    use arg n
    if n==0 then return 1
    else return n * .context~executable~call(n-1)
x86_64   484
arm64   2290
    {use arg n; if n==0 then return 1; else return n * .context~executable~call(n-1) }~call(484)=
x86_64  197
arm64   890
    {use arg n; if n==0 then return 1; else return n * .context~executable~(n-1) }~(197)=
I would like to support the same limit 484 when using the doer method ~().
    ::class "Doer" mixinclass Object public inherit DoerFactory
    ::method "~()" unguarded
        forward message "do"
    ::class "RoutineDoer" mixinclass Object public inherit Doer
    ::method do unguarded
        forward message "call"


================================================================================
Deferred evaluation of parameters (todo)
================================================================================

Let the routine/method decide which parameters must be evaluated, ex : iif(cond, iftrue, iffalse)
todo

--> See routine if(aLogical, whenTrue, whenFalse).
    It's up to the caller to freeze the evaluation, by passing explicitely a doer.
    So the goal is not reached... I want the callee to have full control of the evaluation.

According to
http://www.nhplace.com/kent/Papers/Special-Forms.html
fexpr must be avoided. Macros are better.

[2021, July 4]
Thoughts about lazy evaluation of arguments:
        Some articles:
            https://dlang.org/articles/lazy-evaluation.html
            https://colinfay.me/lazyeval/
        Goal:
            x=5; say (x<>0)~?(1/x, "infinity")      -- 0.2
            x=0; say (x<>0)~?(1/x, "infinity")      -- "infinity", instead of the error "divisor must not be zero"
            a=1; b=2; call swap a, b; say a b       -- 2 1

        When calling a routine, the target is evaluated and found.
        The target indicates if the arguments must be evaluated or not. This is independant from any instruction 'use arg' on the target side.
        If the arguments must be evaluated then it's the current implementation: pass an array of evaluated expressions
        otherwise pass an array of not-evaluated expressions. Probably an array of LazyRexxExpression which is a wrapper holding the expression and the context for the evaluation (a RexxActivation).

        Signature for evaluation:
            virtual RexxObject  *evaluate(RexxActivation *, RexxExpressionStack *)
        Concrete implementations (Executor):
            RexxNumberString::evaluate          stack->push(this); return this;
            RexxInteger::evaluate               stack->push(this); return this;
            RexxUnaryOperator::evaluate         stack->prefixResult(result); return result;
            RexxBinaryOperator::evaluate        stack->operatorResult(result); return result;
            RexxExpressionMessage::evaluate     loop { this->arguments[i+1]->evaluate(context, stack); } stack->send(this->messageName, argcount, namedArgcount, result); return result;
            RexxStemVariable::evaluate          value = context->getLocalStem(this->stem, this->index); stack->push(value); return value;
            RexxCompoundVariable::evaluate      value = context->evaluateLocalCompoundVariable(stemName, index, &tails[0], tailCount);stack->push(value); return value;
            RexxParseVariable::evaluate         variable = context->getLocalVariable(variableName, index); value = variable->getVariableValue(); stack->push(value); return value;
            RexxString::evaluate                stack->push(this); return this;
            RexxInternalObject::evaluate        return OREF_NULL
            RexxSourceLiteral::evaluate         value = new RexxBlock(this, rexxContext); stack->push(value); return value;
            RexxExpressionList::evaluate        result = new_array(expressionCount); loop { expr = expressions[i]; value = expr->evaluate(context, stack); result->put(value, i + 1); } stack->push(result); return result;
            RexxExpressionFunction::evaluate    loop { this->arguments[i]->evaluate(context, stack); call internal or builtin or external...; stack->push(result); return result;
            RexxDotVariable::evaluate           result = context->rexxVariable(this->variableName); stack->push(result); return result;
            RexxExpressionLogical::evaluate     loop { value = expressions[i]->evaluate(context, stack); return true or false }

        Example of lazy evaluation:
            -- context = theRexxActivation1
            a=1                 -- theRexxParseVariable1(variableName="A", index=6)
                                --     when evaluated in the context theRexxActivation1, it's theRexxVariable1(variable_name="A", variableValue=1, creator=theRexxActivation1)
            b=2                 -- theRexxParseVariable2(variableName="B", index=7)
                                --     when evaluated in the context theRexxActivation1, it's theRexxVariable2(variable_name="B", variableValue=2, creator=theRexxActivation1)
            call swap a, -      -- pass LazyRexxExpression~new(theRexxActivation1, theRexxParseVariable1)
                      b         -- pass LazyRexxExpression~new(theRexxActivation1, theRexxParseVariable2)
            say a               -- 2
            say b               -- 1
            ::routine swap lazyargs             -- The LAZYARGS option indicates that the arguments must not be evaluated on call
                -- context = RexxActivation2    -- The callee's context is different from the caller's context
                use strict arg x, y             -- x = theLazyRexxExpression1(theRexxActivation1, theRexxParseVariable1)
                                                -- y = theLazyRexxExpression2(theRexxActivation1, theRexxParseVariable2)
                                                -- If an argument is a LazyRexxExpression whose expression is a subclass of RexxVariableBase supporting assignment
                                                -- (RexxStemVariable, RexxCompoundVariable, RexxParseVariable, but not RexxDotVariable)
                                                -- then create an alias variable.
                                                -- [2021 Jul 7] Better to declare explictly that a special retriever must be used.
                                                --              The syntax would be the same as variable reference, but on callee side only.
                                                --              use strict arg >x, >y
                tmp = x                         -- First evaluation of x, the value 1 is cached on theLazyRexxExpression1
                x = y                           -- First evaluation of y, the value 2 is cached on theLazyRexxExpression2
                                                -- The assignment 'x =' is delegated to theRexxParseVariable1
                y = x                           -- Retrieve the cached value 2 stored on theLazyRexxExpression1
                                                -- The assignment 'y =' is delegated to theRexxParseVariable1
        To investigate:
            1) expose var
               use arg >var -- Will it work with LazyRexxExpression ? ooRexx5 raises Error 98.995:  Unable to reference variable "VAR"; it must be an uninitialized local variable.
            2) use arg >var
               drop var     -- Will it work with LazyRexxExpression ? ooRexx5 drops the value of the referenced variable.
            3) The reference operator supports stems but doesn't support compound symbols.
               Will compound symbols be supported with LazyRexxExpression ?


================================================================================
Named arguments
================================================================================

Remainging todo for implementation of named arguments
-----------------------------------------------------

Message~new
add support for named arguments: option "Directory"

Message~namedArguments
to implement

Changes in ooRexx5 that I don't need to support until retrofitting:
Message~send allows to pass arguments
Message~sendWith: new method
Message~start allows to pass arguments
Message~startWith: new method

StackFrame~namedArguments
to implement

Security manager CALL
Add NAMEDARGUMENTS: a directory of the function named arguments
to the information directory.

Security manager METHOD
Add NAMEDARGUMENTS: a directory of the method named arguments
to the information directory.

RexxNativeActivation::callNativeRoutine(RoutineClass *_routine, RexxNativeRoutine *_code, RexxString *functionName,
The named arguments are not passed to the native routine.
void RexxNativeActivation::callNativeRoutine(RoutineClass *_routine, RexxNativeRoutine *_code, RexxString *functionName,
    RexxObject **list, size_t count, size_t named_count, ProtectedObject &resultObj)


Maybe to rework
---------------

forward : use a single array for positional & named
instead of 2 as currently
  RexxArray  * array;                  /* argument array specification      */
  RexxArray  * namedArgumentsArray;    /* name, value, name, value, etc...  */
Reason :
1) there is only one keyword ARRAY(...), so both positional & named must be managed as a whole
2) Message~new and Object~run supports the option "I" which is followed by a list of positional & named arguments
   managed as a whole, not as 2 distincts subsets


Option "Directory" for Message~new and Object~run :
should I specify a named argument Directory:argument
instead of 2 positional arguments "Directory", argument ?
Probably yes, I should not impact the positional arguments.
[later]
Probably no. There is no impact for the ooRexx user, and the option "Directory"
is a natural extension.


To investigate
--------------

RexxDirectory::unknown
see if named arguments must be supported


RexxNativeActivation::run
see if named arguments must be supported here:
    // retrieve the argument signatures and process them
    uint16_t *types = (*methp)((RexxMethodContext *)&context, NULL);
    processArguments(argcount, arglist, types, arguments, MAX_NATIVE_ARGUMENTS);


RexxClass::enhanced
RexxObject::newRexx
RexxClass::newRexx
RexxDirectory::newRexx
RexxList::newRexx
RexxMethod::newRexx
RexxMutableBufferClass::newRexx
PackageClass::newRexx
RexxQueue::newRexx
RexxRelation::newRexx


RexxObject  *RexxArray::of(RexxObject **args, size_t argCount, size_t named_argCount)
TODO
The named arguments could be added to the returned array (splitting the key:value).
    .array~of(1,2,n3:3,n4:4) --> [1,2,n3,3,n4,4]
That would be the opposite of what I do with .Directory~of (grouping in key:value)
    .directory~of(1,2,n3:3,n4:4) --> [1:2,n3:3,n4:4]


.List~of(v1,v2,...,vn)
RexxList *RexxList::classOf(
     RexxObject **args,                /* array of list items               */
     size_t       argCount,            /* size of the argument array        */
     size_t       named_argCount)
TODO
The named arguments could be added to the returned array (splitting the key:value).


Remember
--------

(moved from UseStrictInstruction.cpp)

    // Special check when parse_time.
    //
    // Background:
    // Before this special check, the following code was accepted at parse_time
    //     block = {use named arg normalization(1), nfl(2)}
    //     block~(n:1, nf:2, normalization:3)
    // I wanted to support such minimum lengths because there was no ambiguity:
    //     'n'  matches with normalization(1), but not with nfl(2) because at least 2 characters needed
    //     'no' matches with normalization(1), but not with nfl(2) because the second characters differ
    //     'nf' matches with nfl(2), but not with normalization(1) because the second characters differ
    //     etc...
    // but this misleading error was raised at run_time:
    //     named argument NORMALIZATION is not an expected argument name.
    //
    // That happened because the third argument normalization:3 was not matched with NORMALIZATION,
    // which had been already matched (assigned==true) with the first argument n:1,
    // and thus was not matched at all and reported as not expected.
    // This is due to the optimization at the begining of the current method to reduce the number of matching
    // (skip a named argument if already assigned). I want to keep this optimization...
    //
    // The parser has been modified to check this rule when parsing the argument names passed by the caller:
    //     No named parameter name must start with the name of another named parameter.
    // For the implementation of this rule, see RexxSource::argList which calls checkNamedArguments.
    // Now this error is raised at parse_time:
    //    Named argument: 'N:' and 'NORMALIZATION:' denote the same argument.
    //
    // Ok, then remove the redundant named parameter:
    //     block~(n:1, nf:2)
    // An error is still raised at parse_time:
    //     Named argument: 'N:' and 'NF:' denote the same argument.
    //
    // This time, we have a problem because the instruction "use named arg normalization(1), nfl(2)" allows this call.
    // At parse_time, it's impossible to know the minimum lengths when parsing a list of named arguments passed by the caller.
    // So, to be consistent, the same rule must be enforced on callee side:
    //     No named parameter name must start with the name of another named parameter.
    // Consequence, the declaration on called side must be modified by the programmer to force at least 2 characters:
    //     block = {use named arg normalization(2), nfl(2)}
    // This is the purpose of the following lines to put in place the conditions to raise an error if the rule is not met.
    // Now the code with minimum length (1) is no longer accepted at parse_time:
    //     Use named arg: The name 'NORMALIZATION(1)' collides with 'NFL(2)'.

    if (parse_time)
    {
        if (expectedNameMinimumLength > nameMinimumLength) expectedNameMinimumLength = nameMinimumLength;
    }


===============================================================================
Positional & Named arguments
===============================================================================

Thinking to a new shorthand syntax
    name:       with no value, pass .true                                       (done)
    :var        with no name, where var is a variable name, pass var:var        (done)

    (next is very questionable)
    ...         forward the positional arguments
    -n          after ... to remove the nth positional argument from ...
    : ...       forward the named arguments
    : - name    after : ... to remove name from : ...

where notation ... is inspired by Ruby:
https://blog.saeloun.com/2020/09/16/ruby-3.0-to-add-support-for-forwarding-arguments-along-with-lead-arguments.html

Update 2023 Nov 25:
https://zverok.space/blog/2023-11-24-syntax-sugar4-argument-forwarding.html
“Useless Ruby sugar”: Argument forwarding
jlf: read it quickly, to read again with better motivation

In Ruby, ... represents the remaining arguments after those explictely declared in the signature (called leading arguments).
Rexx has no unique signature, so the semantic must be different.
At first sight, I think ... should be equal to context~args, and : ... should be equal to .context~namedArgs.

With only this syntax, you can:
- prepend positional arguments to ...   r1(2,3);       ::routine r1; r2(0,1, ...)           -- r2 receives 0,1,2,3
- add named arguments to : ...          r1(n2:2,n3:3); ::routine r1; r2(n0:0, n1:1, ...)    -- r2 receives n0:0,n1:1,n2:2,n3:3
- replace named arguments in : ...      r1(n2:2,n3:3); ::routine r1; r2(n0:0, n2:5, ...)    -- r2 receives n0:0,n2:5,n3:3


Application to real code from Executor:

        ::class "RexxTextStringInterface"
        ::method caselessCompareTo
            use strict arg text, n=1, length=.nil
            use strict named arg casefold=.true, lump= .false, stripIgnorable= .false, stripmark = .false
actual      selfNormalized = self~substr(n, selfLength)~NFC(casefold: casefold, lump: lump, stripIgnorable: stripIgnorable, stripmark: stripmark)
            ----------
new         selfNormalized = self~substr(n, selfLength)~NFC(:casefold, :lump, :stripIgnorable, :stripmark)
new         selfNormalized = self~substr(n, selfLength)~NFC(: ...)


        ::class "XTF8_CommonServices"
        ::method transform
            use strict arg -- none
            use strict named arg normalization(4) = 1, casefold(4) = .false, lump= .false, stripMark = .false, stripIgnorable= .false, stripCC = .false, stripNA = .false, returnString = .false, memorize(3) = (.Unicode~memorizeTransformations)
actual      string = .Unicode~utf8proc_transform(self~string, normalization: normalization, casefold: casefold, lump: lump, stripMark: stripMark, stripIgnorable: stripIgnorable, stripCC: stripCC, stripNA: stripNA)
            ----------
new         string = .Unicode~utf8proc_transform(self~string, :normalization, :casefold, :lump, :stripMark, :stripIgnorable, :stripCC, :stripNA)
new         string = .Unicode~utf8proc_transform(self~string, : ..., : -returnString, : -memorize)


        ::class "IndexerStringInterface"
        ::method caselessMatch
            use strict arg startC, other, nC=1, lengthC=.nil
            use strict named arg lump= .false, stripIgnorable= .false, stripMark=.false
actual      return self~matchText(startC, other, nC, lengthC, casefold:.true, lump: lump, stripIgnorable: stripIgnorable, stripMark: stripMark)
            ----------
new         return self~matchText(startC, other, nC, lengthC, casefold:, :lump, :stripIgnorable, :stripMark)
new         return self~matchText(startC, other, nC, lengthC, casefold:, : ...)


        ::class "XTF8_CommonServices"
        ::method casefold
actual      forward message "transform" namedArguments (.context~namedArgs~~setEntry("normalization", 0)~~setEntry("casefold", .true))
            ----------
new         forward message "transform" array (normalization: 0, casefold:, : ...)
new         self~transform(normalization: 0, casefold:, : ...)


        ::class "Doer"
        ::method go unguarded
actual      forward message "startWith" array("do", .context~args, n:.context~namedArgs)
            ----------
new         self~start("do", ..., : ...)


        ::class "MethodDoer"
        ::method do unguarded
            use strict arg object, ...
actual      forward to (object) message "run" array (self, "a", arg(2,"a"), n:.context~namedArgs)
            ----------
new         object~run(self, "i", ..., -1, : ...)


        ::class "StringDoer"
        ::method do unguarded
            use strict arg object, ...
actual      forward to (object) message "sendWith" array (self, arg(2,"a"), n:.context~namedArgs)
            ----------
new         object~send(..., -1, : ...)


        "helllo"~changeStr2("l", "L", -2) --> changeStr2("l", "helllo", "L", -2) --> "helLLo"
        ::extension String
actual  ::method changeStr2 ; return changeStr2~call(self, .context~args, 2) -- prepend self to arg(1, "a") then swap [1] and [2]
        ----------
new     ::method changeStr2 ; changeStr2(arg(1), self, ..., -1)


================================================================================
pad character todo: if length > 1 then forward to RexxText (done)
================================================================================

jlf 20/04/2024
A more general solution has been implemented:
The string BIFs become polymorphic on RexxString/RexxText.
If at least one positional argument is a RexxText then the string BIFs forward
to RexxText, otherwise the string BIFs forward to RexxString.


Several classic Rexx scripts in RosettaCode contain UTF-8 characters. Ex: in
Aliquot-sequence-classifications, there is
say center('numbers from ' low " to " high, 79, "═")
where "═" is the Unicode character BOX DRAWINGS DOUBLE HORIZONTAL, encoded E2 95 90 in UTF-8.
ooRexx and Regina complains:
Error 40.23: CENTER argument 3 must be a single character; found "═"
I would like an intelligent support of UTF-8 here, without modifying the Rexx script. The length in
grapheme is 1, the interpreter should not complain, even if the length in bytes is <> 1.

// out of scope
bitAnd                  ""      func
bitOr                   ""      func
bitXor                  ""      func

// in scope
caselessCompare         " "
center                  " "     func
compare                 " "     func
insert                  " "     func    MutableBuffer
left                    " "     func
overlay                 " "     func    MutableBuffer
replaceAt               " "             MutableBuffer
right                   " "     func
space                   " "     func    MutableBuffer
substr                  " "     func    MutableBuffer
translate               " "     func    MutableBuffer


================================================================================
Encoded stream
================================================================================

TODO:
.stream~linein is not working correctly with UTF-16, UTF-32
The detection of EOL is not good, should test the bytes listed below, in function of the encoding.
("U+0A", "U+0D")~pipe(.inject { .unicode[item] } | .inject { ("utf8", "utf16be", "utf16le", "utf32be", "utf32le")~each{ expose item; arg(1)":"arg(1)~(item)~c2x } } | .console)
    1 : ['utf8:0A','utf16be:000A','utf16le:0A00','utf32be:0000000A','utf32le:0A000000']
    2 : ['utf8:0D','utf16be:000D','utf16le:0D00','utf32be:0000000D','utf32le:0D000000']
Additional constraint: respect the character boundaries.

Dump files generated in the folder unicode/bbedit-save_as for the following cases supported by the editor BBEdit under MacOs:
    UTF-8
    UTF-8 with BOM
    UTF-16
    UTF-16 no BOM
    UTF-16LE
    UTF-16LE no BOM

Files showing the problem with .stream~linein:
    utf16_crlf-dump.txt:         end of string is 000D 00 (remaining of 000D 000A where only 0A was recognized)
    utf16_lf-dump.txt:           end of string is 00 (remaining of 000A where only 0A was recognized)
    utf16_nobom_crlf-dump.txt:   same as utf16_crlf-dump.txt
    utf16_nobom_lf-dump.txt:     same as utf16_lf-dump.txt
    utf16le_crlf-dump.txt:       end of first string is 0D00. Then all the following strings are wrongly extracted (not aligned on 16-bit boundary)
    utf16le_lf-dump.txt:         end of first string is correct. But then all the following strings are wrongly extracted (not aligned on 16-bit boundary)
    utf16le_nobom_crlf-dump.txt: same as utf16le_crlf-dump.txt
    utf16le_nobom_lf-dump.txt:   same as utf16le_lf-dump.txt

Occurences of \r
----------------

common/platform/unix/SysFile.cpp
common/platform/windows/SysFile.cpp
SysFile::gets
This is here that the EOL is managed. To modify to support encoded files
The current implementation is testing "\n".
If found then if previous character is "\r" then replace "\r\n" by "\n".

common/platform/unix/SysFile.hpp
#define LINE_TERMINATOR "\n"
Must be adapted

common/platform/windows/SysFile.hpp
#define LINE_TERMINATOR "\r\n"
Must be adapted

common/platform/unix/SysFile.cpp
common/platform/windows/SysFile.cpp
SysFile::putLine
Write a line to the stream, adding the platform specific line terminator.
Must be adapted

interpreter/classes/support/StringUtil.cpp
StringUtil::makearray
A specific separator can be passed, but this deactivate the management of \r.
If no specific separator, then search for \n and checks if \r\n

interpreter/platform/windows/PlatformDefinitions.h
#define line_end "\r\n"
Used in RexxArray::toString (interpreter/classes/ArrayClass.cpp)

interpreter/streamLibrary/StreamNative.hpp
#define cr     '\r'


Occurences of \n
----------------

interpreter/classes/RoutineClass.cpp
RoutineClass::restore
Related to image, no need to support encoded files

interpreter/platform/unix/PlatformDefinitions.h
#define line_end "\n"
Used in RexxArray::toString (interpreter/classes/ArrayClass.cpp)

interpreter/streamLibrary/StreamNative.cpp
StreamInfo::readVariableLine
This is here that the EOL is managed. To modify to support encoded files

interpreter/streamLibrary/StreamNative.hpp
#define nl     '\n'


================================================================================
Indexation of UTF-8 strings (applicable other UTF encodings)
================================================================================

Executor
thinking about grapheme indexes (draft)

    Grapheme indexes : see if it's possible to replace .Array by a class being really a sparse array.
    This class should be ultra specialized for the management of string indexes.
    For example, could manage a flexible storage in function of the size of the index.
    Maybe a multi-stage table ? For example https://www.strchr.com/multi-stage_tables
    Maybe a direct indexation of the 255 first and last bytes ?
        Where each index has an associated byte position.
        Not like a pseudo sparse ooRexx array where an index can be associated to a NULL value, meaning pos == index.
    For the rest of the bytes, maybe several (many) chunks of indexes
    Each chunk of indexes would have a base index, the stored indexes would be relative to this base index.
        1-byte encoding: index = base_index + relative_index
        2-byte encoding: index = 2*base_index + 2*relative_index
        4-byte encoding: index = 4*base_index + 4*relative_index

    Example:
        first256
            startC = 0 (always)

        last256
            startC = 45632135789 (for example)

        middle: array of 2, 4 or 8 bytes
            2 bytes: 0..FF chunks of 1 byte
            3 bytes: 0..FF chunks of 2 bytes
            4 bytes: 0..FFFF chunks of 2 bytes
            5 bytes: 0..FF chuncks of 4 bytes
            6 bytes: 0..FFFF chunks of 4 bytes
            7 bytes: 0..FF chunks of 6 bytes
            8 bytes: 0..FFFF chunks of 6 bytes

        size of indexes:
            1 byte:  string length <= FF: 0..FF bytes (direct mapping. 0 byte if all the indexes = pos)
            2 bytes: string length <= FFFF:
                0..FF bytes for first (direct mapping)
                0..FD * (2 bytes for start + FF bytes)
                (2 bytes for start + FF bytes) for last (direct mapping)
            3 bytes: string length <= FFFFFF: 65536 * 256

    Interface:
        indexTable~new(stringSizeInBytes)   -- determine the number of stages
        indexTable~size                     -- redundant with indexer~string~length
        indexTable~items                    -- redundant with indexer~graphemeCount
        indexTable[integer]
        indexTable[integer] = bytePosition
        indexTable~first                    --  index of the first item in the table

    The character length is not stored in the indexes. It's given by the utf8 encoding.
    Only the indexes starting a new sequence of character length are stored.
    I don't remember what is 'next'... Is it the first index in the current table ?

    One table per size of index & offset
    1 byte      FF                  0..255                              #items next = 1 + 1 = 2 bytes
    2 bytes     FFFF                0..65,535                           #items next = 2 + 2 = 4 bytes
    3 bytes     FFFFFF              0..16,777,215                       #items next = 3 + 3 = 6 bytes
    4 bytes     FFFFFFFF            0..4,294,967,295                    #items next = 4 + 4 = 8 bytes
    5 bytes     FFFFFFFFFF          0..1,099,511,627,775                #items next = 5 + 5 = 10 bytes
    6 bytes     FFFFFFFFFFFF        0..281,474,976,710,655              #items next = 6 + 6 = 12 bytes
    7 bytes     FFFFFFFFFFFFFF      0..72,057,594,037,927,900           #items next = 7 + 7 = 14 bytes
    8 bytes     FFFFFFFFFFFFFFFF    0..18,446,744,073,709,600,000       #items next = 8 + 8 = 16 bytes
                                                                        total       = 72 bytes
    Better to not systematically allocate all the sizes of indexes...


    Examples of indexes
    --------------------------

    129 char, 256 bytes
    char length 1 1 2 2 2 2 ... 2   2   1   1
    char offset 0 1 2 4 6 8 ... 250 252 254 255
    char index  0 1 2 3 4 5 ... 126 127 128 129
    indexes:
        last:  129
        3 : +1

    7 char, 17 bytes
    char length 2 3 2 3 2  3  2
    char offset 0 2 5 7 10 12 15
    char index  0 1 2 3 4  5  6
    indexes 1 byte :
        #items: 3
        next: 0
        2 --> 5
        4 --> 10
        6 --> 15
    size indexes = 1 + 1 + 3*(1+1) = 8 bytes (47%)


    8 char, 16 bytes
    char length 1 3 1 3 1 3 1  3
    char offset 0 1 4 5 8 9 12 13
    char index  0 1 2 3 4 5 6  7
    indexes 1 byte :
        #items: 3
        next: 0
        2 --> 4
        4 --> 8
        6 --> 12
    size indexes = 1 + 1 + 3*(1+1) = 8 bytes (50%)


    9 char, 18 bytes
    char length 1 2 3 1 2 3 1  2  3
    char offset 0 1 3 6 7 9 12 13 15
    char index  0 1 2 3 4 5 6  7  8
    indexes 1 byte :
        #items: 4
        next: 0
        2 --> 3
        4 --> 7
        6 --> 12
        8 --> 15
    size indexes = 1 + 1 + 4*(1+1) = 10 bytes (56%)


    11 char, 16 bytes
    char length 1 2 1 2 1 2 1 2  1  2  1
    char offset 0 1 3 4 6 7 9 10 12 13 15
    char index  0 1 2 3 4 5 6 7  8  9  10
    indexes 1 byte :
        #items: 5
        next: 0
        2 --> 3
        4 --> 6
        6 --> 9
        8 --> 12
        10 --> 15
    size indexes = 1 + 1 + 5*(1+1) = 12 bytes (75%)


    16 char, 18 bytes
    char length 1 1 1 1 1 1 1 1 1 1 1  1  1  1  1  3
    char offset 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
    char index  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
    indexes 1 byte :
        #items: 0
        next: 0
    size indexes = 1 + 1 = 2 bytes (11%)


    72 char, 88 bytes
    char           V  o  i  c  i     l  a     l  i  s  t  e     d  e  s     a  c  c  e  n  t  s     e  n     f  r  a  n  ç     a  i  s     :     à        ä        â        é        è        ë        ê        ï        î        ö        ô        ù        ü        û        ÿ     .
    char code   20 56 6F 69 63 69 20 6C 61 20 6C 69 73 74 65 20 64 65 73 20 61 63 63 65 6E 74 73 20 65 6E 20 66 72 61 6E C3 A7 61 69 73 20 3A 20 C3 A0 20 C3 A4 20 C3 A2 20 C3 A9 20 C3 A8 20 C3 AB 20 C3 AA 20 C3 AF 20 C3 AE 20 C3 B6 20 C3 B4 20 C3 B9 20 C3 BC 20 C3 BB 20 C3 BF 2E
    char length 1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  2     1  1  1  1  1  1  2     1  2     1  2     1  2     1  2     1  2     1  2     1  2     1  2     1  2     1  2     1  2     1  2     1  2     1  2     1
    char offset 0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43    45 46    48 49    51 52    54 55    57 58    60 61    63 64    66 67    69 70    72 73    75 76    78 79    81 82    84 85    87
    char index  0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35    36 37 38 39 40 41 42    43 44    45 46    47 48    49 50    51 52    53 54    55 56    57 58    59 60    61 62    63 64    65 66    67 68    69 70    71
    indexes 1 byte :
        #items: 15
        next: 0
        36 --> 37
        44 --> 46
        46 --> 49
        48 --> 52
        50 --> 55
        52 --> 58
        54 --> 61
        56 --> 64
        58 --> 67
        60 --> 70
        62 --> 73
        64 --> 76
        66 --> 79
        68 --> 82
        70 --> 85
        72 --> 88
    size indexes = 1 + 1 + 15*(1+1) = 32 bytes (36%)

        0  : 0 + 1n
        35 : 35 + 2n
        36 : 37 + 1n
        42 : 43 + 2n
        43 : 45 + 1n
        44 : 46 + 2n
        45 : 48 + 1n


        36 : +1
        43 : +2
        45 : +3
        47 : +4
        49 : +5
        51 : +6
        53 : +7
        55 : +8
        57 : +9
        59: + 10
        61 : +11
        63 : +12
        65 : +13
        67 : +14
        69 : +15
        71 : +16


https://code.google.com/archive/p/judyarray/


https://juliapackages.com/p/judydicts           deprecated

https://judy.sourceforge.net/
https://sourceforge.net/projects/judy/

https://nanxiao.me/en/a-judy-array-example/


================================================================================
Encoded strings - TODO
================================================================================

TODO: segmentation
Add indexes for words (tr29) and sentences.

TODO: substr should copy the flags for normalization
but not the cached strings

TODO: test if a string is NFC when indexing
https://www.unicode.org/reports/tr15/#Implementation_Notes
In fact it's possible to test if the string is in any normalization form, on the fly,
using quick check, character by character (no, yes, maybe).

TODO: align .UnicodeCharacters~properties with UCD PropertyAliases.txt

TODO: stream-safe text format
The Unicode standard provides for a stream-safe format where no more than 30
characters need to be examined, and combining grapheme joiner is U+034F used to
mark boundaries.
utf8proc works only with strings, not with streams, so this format is not needed.
But is there an impact on the strings?

TODO: If possible, retrofit the ooRexx5 implementation.
::constant is not evaluating the constant value, thus breaking the solution with
an extended String::Evaluate.
ConstantGetterCode


================================================================================
Encoded strings - Miscellaneous notes
================================================================================

A string reverse works correctly only at grapheme level.
A string reverse at codepoint level can corrupt the string.
So if ARB decides to support Unicode at codepoint level only, then the method
'reverse' should not be declared  Unicode compliant.

Example 1
"René"~text~nfd~unicodeCharacters==
    an Array (shape [5], 5 items)
     1 : ( "R"   U+0052 Lu 1 "LATIN CAPITAL LETTER R" )
     2 : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )
     3 : ( "n"   U+006E Ll 1 "LATIN SMALL LETTER N" )
     4 : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )
     5 : ( "́"    U+0301 Mn 0 "COMBINING ACUTE ACCENT" )
"René"~text~nfd~c2g==
    '52 65 6E 65CC81'
"René"~text~nfd~graphemes~each("c2x")==
    an Array (shape [4], 4 items)
     1 :  52
     2 :  65
     3 : '6E'
     4 : '65 CC81'
"René"~text~nfd~reverse~unicodeCharacters==
    an Array (shape [5], 5 items)
     1 : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )
     2 : ( "́"    U+0301 Mn 0 "COMBINING ACUTE ACCENT" )
     3 : ( "n"   U+006E Ll 1 "LATIN SMALL LETTER N" )
     4 : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )
     5 : ( "R"   U+0052 Lu 1 "LATIN CAPITAL LETTER R" )
"René"~text~nfd~reverse~c2g==
    '65CC81 6E 65 52'
"René"~text~nfd~reverse~graphemes~each("c2x")==
    an Array (shape [4], 4 items)
     1 : '65 CC81'
     2 : '6E'
     3 :  65
     4 :  52

Example 2
https://www.w3.org/TR/charmod-norm/#composition_decomposition
NFC: The resulting character sequence can still contain combining marks, since
not all character sequences have a precomposed equivalent.
Many scripts offer no alternative to the use of combining marks, such as the
Devanagari vowels in this example:
"यूनिकोड"~text~unicodeCharacters==
    an Array (shape [7], 7 items)
     1 : ( "य"   U+092F Lo 1 "DEVANAGARI LETTER YA" )
     2 : ( "ू"    U+0942 Mn 0 "DEVANAGARI VOWEL SIGN UU" )
     3 : ( "न"   U+0928 Lo 1 "DEVANAGARI LETTER NA" )
     4 : ( "ि"    U+093F Mc 0 "DEVANAGARI VOWEL SIGN I" )
     5 : ( "क"   U+0915 Lo 1 "DEVANAGARI LETTER KA" )
     6 : ( "ो"    U+094B Mc 0 "DEVANAGARI VOWEL SIGN O" )
     7 : ( "ड"   U+0921 Lo 1 "DEVANAGARI LETTER DDA" )
"यूनिकोड"~text~c2g=
    'E0A4AFE0A582 E0A4A8E0A4BF E0A495E0A58B E0A4A1'
"यूनिकोड"~text~graphemes~each("c2x")==
    an Array (shape [4], 4 items)
     1 : 'E0A4AF E0A582'
     2 : 'E0A4A8 E0A4BF'
     3 : 'E0A495 E0A58B'
     4 : 'E0A4A1'
"यूनिकोड"~text~reverse~unicodeCharacters==
    an Array (shape [7], 7 items)
     1 : ( "ड"   U+0921 Lo 1 "DEVANAGARI LETTER DDA" )
     2 : ( "क"   U+0915 Lo 1 "DEVANAGARI LETTER KA" )
     3 : ( "ो"    U+094B Mc 0 "DEVANAGARI VOWEL SIGN O" )
     4 : ( "न"   U+0928 Lo 1 "DEVANAGARI LETTER NA" )
     5 : ( "ि"    U+093F Mc 0 "DEVANAGARI VOWEL SIGN I" )
     6 : ( "य"   U+092F Lo 1 "DEVANAGARI LETTER YA" )
     7 : ( "ू"    U+0942 Mn 0 "DEVANAGARI VOWEL SIGN UU" )
"यूनिकोड"~text~reverse~c2g==
    'E0A4A1 E0A495E0A58B E0A4A8E0A4BF E0A4AFE0A582'
"यूनिकोड"~text~reverse~graphemes~each("c2x")==
    an Array (shape [4], 4 items)
     1 : 'E0A4A1'
     2 : 'E0A495 E0A58B'
     3 : 'E0A4A8 E0A4BF'
     4 : 'E0A4AF E0A582'


https://hexdocs.pm/elixir/String.html#reverse/1
Keep in mind reversing the same string twice does not necessarily yield the original string:
"̀e"~text~c2x=                  -- 'CC80 65'  -- 2 graphemes
"̀e"~text~reverse~c2x=          -- '65 CC80'  -- 1 grapheme
"̀e"~text~reverse~reverse~c2x=  -- '65 CC80'  -- reversing 1 grapheme gives this same grapheme


Negator '¬'
In some code pages Not is 'AA'X, in others 'AC'X. In Unicode it's U+00AC ('C2AC'X in UTF-8).
Z/OS port of Regina REXX
    533 $ locale
    LC_COLLATE="en_US.UTF-8"

        trace R; parse version .
        1 *-* parse version .
    .>   "REXX-Regina_3.9.5(MT) 5.00 25 Jun 2022"

    I have no displayable '¬' that works with that Regina, but:
       "trace R; parse source .; interpret 'say' 'ac'x 0
        1 *-* parse source .
    .>   "UNIX SUBROUTINE /tmp/Linux-4.19.0-24-amd64-paulgilm/Rx_4088"
          *-* interpret 'say' 'ac'x 0
          *-* interpret 'say' 'ac'x 0
    1


================================================================================
Encoded strings - queries
================================================================================

-- List all the git commits such as their message contains "encod" or "unicode"
git log -i --grep=encod --grep=unicode --pretty=medium > log-encod.txt


-- List the classes implemented by the package text.cls.
-- All these classes are mixin classes.
?c = (text.cls)
    .M         'EncodedMutableBuffer'                           : (text.cls)
    .M         'EncodedPackage'                                 : (text.cls)
    .M         'EncodedString'                                  : (text.cls)
    .M         'RexxTextContents'                               : (text.cls)
    .M         'RexxTextInitializer'                            : (text.cls)
    .M         'RexxTextOperators'                              : (text.cls)
    .M         'RexxTextStringInterface'                        : (text.cls)
    .M         'StringRexxTextInterface'                        : (text.cls)


-- List the methods of the classes implemented by the package text.cls
-- We retrieve the mixin classes listed by the previous query, plus the Object class for which a direct extension is applied.
-- Not listed here (319 lines)
?cm = (text.cls)


-- List the Object's method added by text.cls
-- No need of ?cmi because Object can"t be extended by inheritance
?cm Object = (text.cls)
    P. PCG.    'ISBUFFERORSTRING'            : 'Object' (text.cls)
    P. P.G.    'ISBUFFERORSTRING'            : 'Object' (text.cls)
    P. P.G.    'ISCOMPATIBLEWITHBYTESTRING'  : 'Object' (text.cls)
    P. PCG.    'ISCOMPATIBLEWITHBYTESTRING'  : 'Object' (text.cls)
    P. PCG.    'ISTEXTORBUFFERORSTRING'      : 'Object' (text.cls)
    P. P.G.    'ISTEXTORBUFFERORSTRING'      : 'Object' (text.cls)
    P. PCG.    'REQUESTBUFFERORSTRING'       : 'Object' (text.cls)
    P. P.G.    'REQUESTBUFFERORSTRING'       : 'Object' (text.cls)
    P. PCG.    'REQUESTTEXTORBUFFERORSTRING' : 'Object' (text.cls)
    P. P.G.    'REQUESTTEXTORBUFFERORSTRING' : 'Object' (text.cls)


-- List the String's method added by text.cls
?cmi String = (text.cls)
    P. P.G.    'BYTE'                               : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'BYTES'                              : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'C2G'                                : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'C2U'                                : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'CASEFOLD'                           : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'CHARACTER'                          : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'CHARACTERS'                         : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'CHECKHEXADECIMALVALUECOMPATIBILITY' : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'CHECKLOGICALVALUECOMPATIBILITY'     : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'CHECKNUMERICVALUECOMPATIBILITY'     : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'CODEPOINTS'                         : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'COPY'                               : 'String' 'EncodedString' (text.cls)
    P. P.G.    'DESCRIPTION'                        : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'DESCRIPTIONFORERROR'                : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'DETACH'                             : 'String' 'EncodedString' (text.cls)
    P. P.G.    'ENCODING'                           : 'String' 'EncodedString' (text.cls)
    P. P.G.    'ENCODING='                          : 'String' 'EncodedString' (text.cls)
    P. P.G.    'ERRORS'                             : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'GRAPHEME'                           : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'GRAPHEMES'                          : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'HASENCODING'                        : 'String' 'EncodedString' (text.cls)
    P. P.G.    'HASTEXT'                            : 'String' 'EncodedString' (text.cls)
    P. PCG.    'ISBUFFERORSTRING'                   : 'String' 'Object' (text.cls)
    P. P.G.    'ISBUFFERORSTRING'                   : 'String' 'EncodedString' (text.cls)
    P. P.G.    'ISBUFFERORSTRING'                   : 'String' 'Object' (text.cls)
    P. P.G.    'ISCASEFOLD'                         : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'ISCCSTRIPPED'                       : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'ISCOMPATIBLEWITHASCII'              : 'String' 'StringRexxTextInterface' (text.cls)
    P. PCG.    'ISCOMPATIBLEWITHBYTESTRING'         : 'String' 'Object' (text.cls)
    P. P.G.    'ISCOMPATIBLEWITHBYTESTRING'         : 'String' 'Object' (text.cls)
    P. P.G.    'ISCOMPATIBLEWITHBYTESTRING'         : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'ISIGNORABLESTRIPPED'                : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'ISLOWER'                            : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'ISMARKSTRIPPED'                     : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'ISNASTRIPPED'                       : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'ISNFC'                              : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'ISNFD'                              : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'ISNFKC'                             : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'ISNFKD'                             : 'String' 'StringRexxTextInterface' (text.cls)
    P. PCG.    'ISTEXTORBUFFERORSTRING'             : 'String' 'Object' (text.cls)
    P. P.G.    'ISTEXTORBUFFERORSTRING'             : 'String' 'EncodedString' (text.cls)
    P. P.G.    'ISTEXTORBUFFERORSTRING'             : 'String' 'Object' (text.cls)
    P. P.G.    'ISUPPER'                            : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'MAKEREXXTEXT'                       : 'String' 'EncodedString' (text.cls)
    P. P.G.    'MAKEREXXTEXTORSTRING'               : 'String' 'EncodedString' (text.cls)
    P. P.G.    'MAXIMUMCODEPOINT'                   : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'MAXIMUMUNICODECODEPOINT'            : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'NFC'                                : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'NFD'                                : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'NFKC'                               : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'NFKD'                               : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'REQUESTBUFFERORSTRING'              : 'String' 'EncodedString' (text.cls)
    P. P.G.    'REQUESTBUFFERORSTRING'              : 'String' 'Object' (text.cls)
    P. PCG.    'REQUESTBUFFERORSTRING'              : 'String' 'Object' (text.cls)
    P. PCG.    'REQUESTTEXTORBUFFERORSTRING'        : 'String' 'Object' (text.cls)
    P. P.G.    'REQUESTTEXTORBUFFERORSTRING'        : 'String' 'EncodedString' (text.cls)
    P. P.G.    'REQUESTTEXTORBUFFERORSTRING'        : 'String' 'Object' (text.cls)
    P. P.G.    'SETENCODING'                        : 'String' 'EncodedString' (text.cls)
    P. P.G.    'TEXT'                               : 'String' 'EncodedString' (text.cls)
    P. P.G.    'TEXT='                              : 'String' 'EncodedString' (text.cls)
    P. P.G.    'TITLE'                              : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'TRANSCODETO'                        : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'TRANSFORM'                          : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'TRANSFORMER'                        : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'U2C'                                : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'UNESCAPE'                           : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'UNICODE'                            : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'UNICODE16'                          : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'UNICODE32'                          : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'UNICODE8'                           : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'UNICODECHARACTERS'                  : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'UNICODEN'                           : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'UTF16'                              : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'UTF16BE'                            : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'UTF16LE'                            : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'UTF32'                              : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'UTF32BE'                            : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'UTF32LE'                            : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'UTF8'                               : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'WTF16'                              : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'WTF16BE'                            : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'WTF16LE'                            : 'String' 'StringRexxTextInterface' (text.cls)
    P. P.G.    'WTF8'                               : 'String' 'StringRexxTextInterface' (text.cls)


-- List the MutableBuffer's method added by text.cls
?cmi MutableBuffer = (text.cls)
    P. P.G.    'APPENDENCODED'               : 'MutableBuffer' 'EncodedMutableBuffer' (text.cls)
    P. P.G.    'DESCRIPTION'                 : 'MutableBuffer' 'EncodedMutableBuffer' (text.cls)
    P. P.G.    'DESCRIPTIONFORERROR'         : 'MutableBuffer' 'EncodedMutableBuffer' (text.cls)
    P. P.G.    'ENCODEDSTRING'               : 'MutableBuffer' 'EncodedMutableBuffer' (text.cls)
    P. P.G.    'ENCODING'                    : 'MutableBuffer' 'EncodedMutableBuffer' (text.cls)
    P. P.G.    'ENCODING='                   : 'MutableBuffer' 'EncodedMutableBuffer' (text.cls)
    P. P.G.    'HASENCODING'                 : 'MutableBuffer' 'EncodedMutableBuffer' (text.cls)
    P. P.G.    'INIT_EXTENDED'               : 'MutableBuffer' 'EncodedMutableBuffer' (text.cls)
    P. P.G.    'ISBUFFERORSTRING'            : 'MutableBuffer' 'EncodedMutableBuffer' (text.cls)
    P. P.G.    'ISBUFFERORSTRING'            : 'MutableBuffer' 'Object' (text.cls)
    P. PCG.    'ISBUFFERORSTRING'            : 'MutableBuffer' 'Object' (text.cls)
    P. P.G.    'ISCOMPATIBLEWITHASCII'       : 'MutableBuffer' 'EncodedMutableBuffer' (text.cls)
    P. P.G.    'ISCOMPATIBLEWITHBYTESTRING'  : 'MutableBuffer' 'Object' (text.cls)
    P. PCG.    'ISCOMPATIBLEWITHBYTESTRING'  : 'MutableBuffer' 'Object' (text.cls)
    P. PCG.    'ISTEXTORBUFFERORSTRING'      : 'MutableBuffer' 'Object' (text.cls)
    P. P.G.    'ISTEXTORBUFFERORSTRING'      : 'MutableBuffer' 'EncodedMutableBuffer' (text.cls)
    P. P.G.    'ISTEXTORBUFFERORSTRING'      : 'MutableBuffer' 'Object' (text.cls)
    P. PCG.    'REQUESTBUFFERORSTRING'       : 'MutableBuffer' 'Object' (text.cls)
    P. P.G.    'REQUESTBUFFERORSTRING'       : 'MutableBuffer' 'EncodedMutableBuffer' (text.cls)
    P. P.G.    'REQUESTBUFFERORSTRING'       : 'MutableBuffer' 'Object' (text.cls)
    P. PCG.    'REQUESTTEXTORBUFFERORSTRING' : 'MutableBuffer' 'Object' (text.cls)
    P. P.G.    'REQUESTTEXTORBUFFERORSTRING' : 'MutableBuffer' 'EncodedMutableBuffer' (text.cls)
    P. P.G.    'REQUESTTEXTORBUFFERORSTRING' : 'MutableBuffer' 'Object' (text.cls)
    P. P.G.    'SETENCODING'                 : 'MutableBuffer' 'EncodedMutableBuffer' (text.cls)


-- StringIndexer is a mixin class.
-- List the classes that inherit from it: the supported encodings.
.StringIndexer~pipe(.subclasses "recursive" | .sort | .console "item")
    (The Byte_Encoding class)
    (The IBM1252_Encoding class)
    (The IBM437_Encoding class)
    (The ISO88591_Encoding class)
    (The UTF16BE_Encoding class)
    (The UTF16LE_Encoding class)
    (The UTF32BE_Encoding class)
    (The UTF32LE_Encoding class)
    (The UTF8_Encoding class)
    (The Unicode16_Encoding class)
    (The Unicode32_Encoding class)
    (The Unicode8_Encoding class)
    (The WINDOWS1252_Encoding class)
    (The WTF16BE_Encoding class)
    (The WTF16LE_Encoding class)
    (The WTF8_Encoding class)


-- A supported encoding can have several aliases.
.encoding~list~table==
    a Table (45 items)
     437               : (The IBM437_Encoding class)
     819               : (The ISO88591_Encoding class)
     8859              : (The ISO88591_Encoding class)
     28591             : (The ISO88591_Encoding class)
     88591             : (The ISO88591_Encoding class)
    'ASCII8BIT'        : (The Byte_Encoding class)
    'BINARY'           : (The Byte_Encoding class)
    'BYTE'             : (The Byte_Encoding class)
    'BYTES'            : (The Byte_Encoding class)
    'CP1252'           : (The WINDOWS1252_Encoding class)
    'CP437'            : (The IBM437_Encoding class)
    'CP5348'           : (The WINDOWS1252_Encoding class)
    'CP65001'          : (The UTF8_Encoding class)
    'CP819'            : (The ISO88591_Encoding class)
    'CSISOLATIN1'      : (The ISO88591_Encoding class)
    'CSPC8CODEPAGE437' : (The IBM437_Encoding class)
    'CSWINDOWS1252'    : (The WINDOWS1252_Encoding class)
    'IBM1252'          : (The IBM1252_Encoding class)
    'IBM437'           : (The IBM437_Encoding class)
    'IBM5348'          : (The WINDOWS1252_Encoding class)
    'IBM819'           : (The ISO88591_Encoding class)
    'ISO88591'         : (The ISO88591_Encoding class)
    'ISO885911987'     : (The ISO88591_Encoding class)
    'ISOIR100'         : (The ISO88591_Encoding class)
    'L1'               : (The ISO88591_Encoding class)
    'LATIN'            : (The ISO88591_Encoding class)
    'LATIN1'           : (The ISO88591_Encoding class)
    'UNICODE16'        : (The Unicode16_Encoding class)
    'UNICODE32'        : (The Unicode32_Encoding class)
    'UNICODE8'         : (The Unicode8_Encoding class)
    'UTF16'            : (The UTF16BE_Encoding class)
    'UTF16BE'          : (The UTF16BE_Encoding class)
    'UTF16LE'          : (The UTF16LE_Encoding class)
    'UTF32'            : (The UTF32BE_Encoding class)
    'UTF32BE'          : (The UTF32BE_Encoding class)
    'UTF32LE'          : (The UTF32LE_Encoding class)
    'UTF8'             : (The UTF8_Encoding class)
    'WE8ISO8859P1'     : (The ISO88591_Encoding class)
    'WINDOWS1252'      : (The WINDOWS1252_Encoding class)
    'WINDOWS28591'     : (The ISO88591_Encoding class)
    'WINDOWS437'       : (The IBM437_Encoding class)
    'WTF16'            : (The WTF16BE_Encoding class)
    'WTF16BE'          : (The WTF16BE_Encoding class)
    'WTF16LE'          : (The WTF16LE_Encoding class)
    'WTF8'             : (The WTF8_Encoding class)


-- List the StringIndexer's methods (common interface for all the supported encodings)
?cm StringIndexer
    PM PCG.    'ANALYZE'                 : 'StringIndexer' (stringIndexer.cls)
    PM PCG.    'APPENDTOBUFFER'          : 'StringIndexer' (stringIndexer.cls)
    PM PCG.    'ASENCODINGFOR'           : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'BYTES'                   : 'StringIndexer' (stringIndexer.cls)
    PM PCG.    'BYTESEQUENCESIZE'        : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'C2G'                     : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'C2U'                     : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'C2X'                     : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'CASE'                    : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'CHARACTER'               : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'CHARACTERCOUNT'          : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'CHARACTERINDEXB'         : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'CHARACTERINDEXC'         : 'StringIndexer' (stringIndexer.cls)
    PM ..G.    'CHARACTERINDEXES'        : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'CHARACTERS'              : 'StringIndexer' (stringIndexer.cls)
    PM PCG.    'CHECKCODEPOINT'          : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'CODEPOINT'               : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'CODEPOINTCOUNT'          : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'CODEPOINTINDEXB'         : 'StringIndexer' (stringIndexer.cls)
    PM ..G.    'CODEPOINTINDEXES'        : 'StringIndexer' (stringIndexer.cls)
    PM PCG.    'CODEPOINTMAXBYTES'       : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'CODEPOINTS'              : 'StringIndexer' (stringIndexer.cls)
    PM PCG.    'CODEPOINTSIZEINBYTES'    : 'StringIndexer' (stringIndexer.cls)
    PM PCG.    'CODEPOINTTOLOWERFULL'    : 'StringIndexer' (stringIndexer.cls)
    PM PCG.    'CODEPOINTTOLOWERSIMPLE'  : 'StringIndexer' (stringIndexer.cls)
    PM PCG.    'CODEPOINTTOTITLEFULL'    : 'StringIndexer' (stringIndexer.cls)
    PM PCG.    'CODEPOINTTOTITLESIMPLE'  : 'StringIndexer' (stringIndexer.cls)
    PM PCG.    'CODEPOINTTOUPPERFULL'    : 'StringIndexer' (stringIndexer.cls)
    PM PCG.    'CODEPOINTTOUPPERSIMPLE'  : 'StringIndexer' (stringIndexer.cls)
    PM PCG.    'CODEUNITSIZEINBYTES'     : 'StringIndexer' (stringIndexer.cls)
    PM PCG.    'CONCATENATE'             : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'COPY'                    : 'StringIndexer' (stringIndexer.cls)
    PM PCG.    'DECODE'                  : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'DESCRIPTION'             : 'StringIndexer' (stringIndexer.cls)
    PM PCG.    'DESCRIPTION'             : 'StringIndexer' (stringIndexer.cls)
    PM PCG.    'DESCRIPTIONFORERROR'     : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'DESCRIPTIONFORERROR'     : 'StringIndexer' (stringIndexer.cls)
    PM PCG.    'EMPTYSTRING'             : 'StringIndexer' (stringIndexer.cls)
    PM PCG.    'ENCODE'                  : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'ENCODING'                : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'ERRORS'                  : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'FLAGS'                   : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'FLAG_CASEFOLD'           : 'StringIndexer' (stringIndexer.cls)
    PM P...    'FLAG_CASEFOLD'           : 'StringIndexer' (stringIndexer.cls)
    PM P...    'FLAG_LUMP'               : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'FLAG_LUMP'               : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'FLAG_NFC'                : 'StringIndexer' (stringIndexer.cls)
    PM P...    'FLAG_NFC'                : 'StringIndexer' (stringIndexer.cls)
    PM P...    'FLAG_NFD'                : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'FLAG_NFD'                : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'FLAG_NFKC'               : 'StringIndexer' (stringIndexer.cls)
    PM P...    'FLAG_NFKC'               : 'StringIndexer' (stringIndexer.cls)
    PM P...    'FLAG_NFKD'               : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'FLAG_NFKD'               : 'StringIndexer' (stringIndexer.cls)
    PM P...    'FLAG_STRIP_CC'           : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'FLAG_STRIP_CC'           : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'FLAG_STRIP_IGNORABLE'    : 'StringIndexer' (stringIndexer.cls)
    PM P...    'FLAG_STRIP_IGNORABLE'    : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'FLAG_STRIP_MARK'         : 'StringIndexer' (stringIndexer.cls)
    PM P...    'FLAG_STRIP_MARK'         : 'StringIndexer' (stringIndexer.cls)
    PM P...    'FLAG_STRIP_NA'           : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'FLAG_STRIP_NA'           : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'INIT'                    : 'StringIndexer' (stringIndexer.cls)
    PM P...    'ISBYTE'                  : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'ISBYTE'                  : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'ISCASEFOLD'              : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'ISCCSTRIPPED'            : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'ISCOMPATIBLEWITHASCII'   : 'StringIndexer' (stringIndexer.cls)
    PM P...    'ISCOMPATIBLEWITHASCII'   : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'ISIGNORABLESTRIPPED'     : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'ISLOWER'                 : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'ISLUMPED'                : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'ISMARKSTRIPPED'          : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'ISNASTRIPPED'            : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'ISNFC'                   : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'ISNFD'                   : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'ISNFKC'                  : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'ISNFKD'                  : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'ISUNICODE'               : 'StringIndexer' (stringIndexer.cls)
    PM P...    'ISUNICODE'               : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'ISUNICODE16'             : 'StringIndexer' (stringIndexer.cls)
    PM P...    'ISUNICODE16'             : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'ISUNICODE32'             : 'StringIndexer' (stringIndexer.cls)
    PM P...    'ISUNICODE32'             : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'ISUNICODE8'              : 'StringIndexer' (stringIndexer.cls)
    PM P...    'ISUNICODE8'              : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'ISUNICODEN'              : 'StringIndexer' (stringIndexer.cls)
    PM P...    'ISUNICODEN'              : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'ISUPPER'                 : 'StringIndexer' (stringIndexer.cls)
    PM P...    'ISUTF16'                 : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'ISUTF16'                 : 'StringIndexer' (stringIndexer.cls)
    PM P...    'ISUTF16BE'               : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'ISUTF16BE'               : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'ISUTF16LE'               : 'StringIndexer' (stringIndexer.cls)
    PM P...    'ISUTF16LE'               : 'StringIndexer' (stringIndexer.cls)
    PM P...    'ISUTF32'                 : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'ISUTF32'                 : 'StringIndexer' (stringIndexer.cls)
    PM P...    'ISUTF32BE'               : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'ISUTF32BE'               : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'ISUTF32LE'               : 'StringIndexer' (stringIndexer.cls)
    PM P...    'ISUTF32LE'               : 'StringIndexer' (stringIndexer.cls)
    PM P...    'ISUTF8'                  : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'ISUTF8'                  : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'ISWTF16'                 : 'StringIndexer' (stringIndexer.cls)
    PM P...    'ISWTF16'                 : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'ISWTF16BE'               : 'StringIndexer' (stringIndexer.cls)
    PM P...    'ISWTF16BE'               : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'ISWTF16LE'               : 'StringIndexer' (stringIndexer.cls)
    PM P...    'ISWTF16LE'               : 'StringIndexer' (stringIndexer.cls)
    PM P...    'ISWTF32'                 : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'ISWTF32'                 : 'StringIndexer' (stringIndexer.cls)
    PM P...    'ISWTF32BE'               : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'ISWTF32BE'               : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'ISWTF32LE'               : 'StringIndexer' (stringIndexer.cls)
    PM P...    'ISWTF32LE'               : 'StringIndexer' (stringIndexer.cls)
    PM PC..    'ISWTF8'                  : 'StringIndexer' (stringIndexer.cls)
    PM P...    'ISWTF8'                  : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'MAXIMUMCODEPOINT'        : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'MAXIMUMUNICODECODEPOINT' : 'StringIndexer' (stringIndexer.cls)
    PM PCG.    'NAME'                    : 'StringIndexer' (stringIndexer.cls)
    PM PCG.    'NEXTCODEPOINTINDEXB'     : 'StringIndexer' (stringIndexer.cls)
    PM PCG.    'PREVIOUSCODEPOINTINDEXB' : 'StringIndexer' (stringIndexer.cls)
    PM PCG.    'SPACECHARACTER'          : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'STRING'                  : 'StringIndexer' (stringIndexer.cls)
    PM ..G.    'STRING='                 : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'TRANSCODETO'             : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'TRANSFORM'               : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'UNESCAPE'                : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'UNICODE'                 : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'UNICODE16'               : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'UNICODE32'               : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'UNICODE8'                : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'UNICODECHARACTERS'       : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'UTF16'                   : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'UTF16BE'                 : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'UTF16LE'                 : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'UTF32'                   : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'UTF32BE'                 : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'UTF32LE'                 : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'UTF8'                    : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'WTF16'                   : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'WTF16BE'                 : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'WTF16LE'                 : 'StringIndexer' (stringIndexer.cls)
    PM P.G.    'WTF8'                    : 'StringIndexer' (stringIndexer.cls)
    [Info] [1] Class 'StringIndexer' has 144 methods


-- List all the methods c2x
?ms c2x
    -- RexxText delegates to the indexer
    .M P.G.    'C2X' : 'RexxTextStringInterface' (text.cls)
     > 0001 forward to (self~indexer)

    -- String's native implementation
    P. P.G.    'C2X' : 'String' (REXX)

    -- Same implementation for all the encodings.
    -- The part specific to each encoding is managed by self~codepoints
    PM P.G.    'C2X' : 'StringIndexer' (stringIndexer.cls)
     > 0001 use strict arg -- none
     > 0002     use strict named arg buffer=.nil
     > 0003     codepoints = self~codepoints
     > 0004     returnBuffer = .nil <> buffer
     > 0005     if .nil == buffer then buffer = .MutableBuffer~new
     > 0006     targetEncoding = self~encoding
     > 0007     buffer~encoding = targetEncoding~asEncodingFor(buffer) -- raise an error if not compatible
     > 0008     bufferStart = buffer~length + 1
     > 0009     first = .true
     > 0010     do while codepoints~available
     > 0011         if \first then buffer~append(" ")
     > 0012         first = .false
     > 0013         codepoint = codepoints~item(.false) -- false: don't decode
     > 0014         buffer~append(codepoint~c2x)
     > 0015         codepoints~next
     > 0016     end
     > 0017     if returnBuffer then return buffer
     > 0018     xstring = buffer~substr(bufferStart)
     > 0019     -- It's a new string, without any encoding stored on it
     > 0020     xstring~encoding = targetEncoding
     > 0021     return xstring


================================================================================
Why a pure attribute is 4 to 5 times faster than a method ?
================================================================================

::attribute
no response yet...

Executor
-------

void RexxSource::attributeDirective()
    RexxString *name = token->value; /* get the string name               */
    RexxString *internalname = this->commonString(name->upper());
    RexxVariableBase *retriever = this->getRetriever(name);
                    createAttributeGetterMethod(internalname, retriever, Class, Private == PRIVATE_SCOPE,
                        Protected == PROTECTED_METHOD, guard != UNGUARDED_METHOD);


void RexxSource::createAttributeGetterMethod(RexxString *name, RexxVariableBase *retriever,
    bool classMethod, bool privateMethod, bool protectedMethod, bool guardedMethod)
{
    // create the kernel method for the accessor
    BaseCode *code = new AttributeGetterCode(retriever);
    RexxMethod *_method = new RexxMethod(name, code);
    _method->setAttributes(privateMethod, protectedMethod, guardedMethod);
    // add this to the target
    addMethod(name, _method, classMethod);
}


ooRexx5
-------

void LanguageParser::attributeDirective()
    RexxString *name = token->value();
    RexxString *internalname = commonString(name->upper());
    RexxVariableBase *retriever = getRetriever(name);
                createAttributeGetterMethod(internalname, retriever, isClass, accessFlag, protectedFlag, guardFlag);


void LanguageParser::createAttributeGetterMethod(RexxString *name, RexxVariableBase *retriever,
    bool classMethod, AccessFlag privateMethod, ProtectedFlag protectedMethod, GuardFlag guardedMethod)
{
    // create the kernel method for the accessor
    Protected<BaseCode> code = new AttributeGetterCode(retriever);
    Protected<MethodClass> _method = new MethodClass(name, code);
    _method->setAttributes(privateMethod, protectedMethod, guardedMethod);
    // mark as an attribute method
    _method->setAttribute();
    // add this to the target
    addMethod(name, _method, classMethod);
}


================================================================================
ooRexx5 optimizations
================================================================================

ooRexx5 optimization retrofit todo:
When an external routine has been resolved, cache the executable in the field
externalTarget of the CallInstruction or ExpressionFunction. The next call will
be a fast call, by avoiding to search again the executable.
This optimization is not applicable to dynamic calls.


ooRexx5 optimization retrofit todo:
RexxDotVariable cachedValue


ooRexx5 optimization retrofit todo:
SpecialDotVariable for .nil, .true, .false


ooRexx5 optimization retrofit todo:
optimized implementation of .array~items (the value is stored)


ooRexx optimization to investigate:
[later] It's probably related to the optimization of .true .false.
        When replacing .false by 0, I get almost the same durations as ooRexx5.
c = .array~new(3); do 1000000; c[1]=.false; c[2]=1; c[3]="error description"; end
    Executor = 0.93s
    ooRexx5  = 0.62s
c = .array~new(3); do 1000000; c~append(.false); c~append(1); c~append("error description"); end
    Executor = 1.87ss
    ooRexx5  = 1.70s
::class "DecodeContext" public
    ::attribute isError
    ::attribute indexB
    ::attribute errorMessage
c = .DecodeContext~new; do 1000000; c~iserror=.false; c~indexB=1; c~errorMessage="error description"; end
    Executor = 1.05s
    ooRexx5  = 0.75s


ooRexx5 optimization for unknown processing to review:
See comment of
    StringHashCollection::processUnknown
    RexxInteger::processUnknown
    NumberString::processUnknown
    StemClass::processUnknown
    VariableReference::processUnknown


ooRexx5 optimization for NativeActivation to review
    RexxInternalObject *firstSavedObject;// first saved object...an optimization


================================================================================
ooRexx5 to retrofit, maybe
================================================================================

Needed retrofits for trunk/extensions/dateparser:
    1)  ::CONSTANT DefaultDayNames ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")
    2)  use local
    3)  select  case (type)
            when 'd', 'D' then do
    4)  ::OPTIONS novalue error


Needed retrofits for trunk/extensions/json.cls (Rony's version)
    1) .Package~local (including the search of dot variables)
    2) Extended xrange implementation: done


Needed retrofits for trunk/extensions/json.testGroup (Rony's version)
    1) .Class~package
    2) ::options novalue error


checkuninit
review again
ooRexx4 has few places (only RexxActivation::run)
ooRexx5 has many places where checkuninit is called.
    Activity.cpp		memoryObject.checkUninitQueue()
    Activity::runThread
    Activity::exitCurrentThread
    Activity::run

    ClassClass.cpp		checkUninit()
    RexxClass::defineMethods
    RexxClass::defineMethodsRexx
    RexxClass::inheritInstanceMethods
    RexxClass::buildFinalClassBehaviour
    RexxClass::updateSubClasses
    RexxClass::updateInstanceSubClasses
    RexxClass::enhanced
    RexxClass::subclass

    NativeActivation.cpp		memoryObject.checkUninitQueue()
    NativeActivation::run

    ObjectClass.cpp		checkUninit()
    RexxObject::defineInstanceMethod
    RexxObject::deleteInstanceMethod

    RexxActivation.cpp		memoryObject.checkUninitQueue()
    RexxActivation::run

    Implementation:
    RexxMemory.hpp
    RexxMemory.cpp


================================================================================
Things I don't like in ooRexx4
================================================================================

The lack of consistency to pass arguments:

    Instruction forward
    -------------------

    Inconsistency with Message~new and Object~run.
    Here, ARRAY is followed by a list of arguments.
    There, "Array" is followed by a mandatory array. "Individual" is followed by a list of arguments.

    exprn is a directory of named arguments.

    >>-FORWARD--+------------+--+---+--------------------+--+-------------------------+---+--+------------------+--+----------------+--+-------------+----><
                +--CONTINUE--+  |   +--ARGUMENTS--expra--+  +--NAMEDARGUMENTS--exprd--+   |  +--MESSAGE--exprm--+  +--CLASS--exprs--+  +--TO--exprt--+
                                +--------------ARRAY----(--| Arguments |--)---------------+

    .Message~new
    ------------

    Inconsistency with the instruction FORWARD.
    Here, "Array" is followed by a mandatory array.
    There, ARRAY is followed by a list of arguments. ARGUMENTS is followed by a mandatory array.

    >>-new(-target-,-messagename-+-------------------------------------------------------+-)--><
                                 +-,-"Individual"--| Arguments |-------------------------+
                                 +--+-------------------+--+--------------------------+--+
                                    +-,-"Array"-,-expra-+  +-,-NAMEDARGUMENTS-:-exprd-+

    .Object~run
    -----------

    Inconsistency with the instruction FORWARD.
    Here, "Array" is followed by a mandatory array.
    There, ARRAY is followed by a list of arguments. ARGUMENTS is followed by a mandatory array.

    >>-run(-method-+-------------------------------------------------------+-)--><
                   +-,-"Individual"---| Arguments |------------------------+
                   +--+-------------------+--+--------------------------+--+
                      +-,-"Array"-,-expra-+  +-,-NAMEDARGUMENTS-:-exprd-+


================================================================================
Things I don't like in ooRexx5
================================================================================

The lack of consistency in ::OPTIONS:
    The numeric options should start with "NUMERIC" (too late...).
        ::OPTIONS NUMERIC DIGITS <digits>
        ::OPTIONS NUMERIC FORM <form>
        ::OPTIONS NUMERIC FUZZ <fuzz>

    The error options should start with TRAP, to not have so many orphan keywords.
    ("ALL" how do you know it's about trap errors ???).
    The keywords SYNTAX and CONDITION in ::options should be respectively ON and OFF,
    to be consistent with the instruction SIGNAL.
        ::OPTIONS TRAP ERROR ON|OFF
        ::OPTIONS TRAP ON|OFF ERROR

    Why no option for NOMETHOD ? Maybe because it makes no sense to deactivate this trap ?


The syntax of the namespaces:
    namespace:name collides with the usual syntax for named arguments.
    This is not blocking, you can surround by parentheses when passing a qualified symbol as positional argument.
        call myRoutine myNamedArgument:object
        call myRoutine (myNamespace:object)
        call myRoutine myNamedArgument:myNamespace:object


The syntax of the variable reference terms:
    Why 2 reference operators '>' and '<' ?
    Why impacting both the caller and the callee ?

    The rest of this section is a code review and tests, not a list of things I don't like...
    In fact, I learned to like these features during the review...
    {
        My understanding of why impacting both the caller and the callee:
            - The reference operator on caller side is needed because the expression must be evaluated as a VariableReference instance.
              A VariableReference holds one attribute:  RexxVariable *variable; // the referenced variable object.
              A VariableReference can be used independently of use arg.
            - The reference operator on callee side is needed to indicate that a special retriever must be used.
              UseVariable::handleArgument tests if this is a retriever for reference argument (>x on callee side):
                  isOfClass(UseArgVariableRef, variable)
              and then UseVariable::handleReferenceArgument ensures that the argument passed by the caller is a VariableReference (>x on caller side):
                  isVariableReference(argument)

        Error management:
        - There is an error raised when passing a normal variable to a routine which takes a variable reference.
        - There is no error raised when passing a variable reference to a routine which takes a normal variable.
              A VariableReference can be used independently of use arg.
              A VariableReference can be passed to the routine R1 not expecting a variable reference, which pass it to the routine R2 expecting a variable reference.

        It's possible to create an infinite loop:
            x = >y; y = >z; z = >x; say x   -- The interpreter hangs
        but ~value= is ok with such circularity:
            x = >y; y = >z; z = >x; y~value = 20; say x~class"=" x; say y~class"=" y; say z~class"=" z
                The VariableReference class= 20
                The VariableReference class= 20
                The String class= 20
         Note the difference when assigning directly to y:
            x = >y; y = >z; z = >x; y = 20; say x~class"=" x; say y~class"=" y; say z~class"=" z
                The VariableReference class= 20
                The String class= 20
                The VariableReference class= 20

        It's possible to get a reference to a variable no longer existing, by returning this reference from a routine.
        That's ok because the variable stay alive thanks to the reference.
            ::routine danglingReference
                v = "no longer existing"
                return >v

        It's possible to return a reference to an object variable.
            ::method secretObjectVariableAlias
                expose secretObjectVariable
                return >secretObjectVariable
    }


The instruction USE LOCAL:
    sounds like not related to EXPOSE.

    is followed by a list of names without comma separators,
    whereas USE ARG is followed by a list of names WITH comma separators.

    If 'USE LOCAL' with no name makes all the variables exposed (except RC, RESULT, SIGL, SELF, and SUPER)
    then 'EXPOSE' with no name should make all the variables local.
    But this is not supported: Error 20.902:  Symbol expected after EXPOSE keyword
    Anyway, this is not needed because all the variables are local when no EXPOSE and no USE LOCAL...

    Doesn't support a name enclosed by parentheses.
    I can't find a use case where that would be useful, so probably ok to not support that.


The method .string~"[]"
    This methods takes a position and a length.
    This method is not consistent with the indexation of an array where [n1,n2] is applicable only to a 2-dimensional array.
    "my string"[2,3] is equivalent to .array~section(2,3)
    .string~"[]" should behave like .string~subchar which takes only one argument: the character's position.


================================================================================
Error messages to fix
================================================================================

   939 *-* ::extension "Byte_Encoding" public inherit Byte_CommonServices StringIndexer
    11 *-* ::requires "encoding/stringEncoding.cls"
    15 *-* ::requires "extension/text.cls"
    97 *-* ::requires "extension/extensions.cls"
REX0025E: Error 25 running /local/rexx/oorexx/executor/sandbox/jlf/packages/encoding/stringEncoding.cls line 939:  Invalid subkeyword found.
REX0289E: Error 25.901:  Unknown keyword on ::CLASS directive; found "PUBLIC".
--> should be            Unknown keyword on ::EXTENSION directive; found "PUBLIC"


  1260 *-* ::extension "CP1252_Encoding" subclass Byte_Encoding /*public*/
    11 *-* ::requires "encoding/stringEncoding.cls"
    15 *-* ::requires "extension/text.cls"
    97 *-* ::requires "extension/extensions.cls"
REX0025E: Error 25 running /local/rexx/oorexx/executor/sandbox/jlf/packages/encoding/stringEncoding.cls line 1260:  Invalid subkeyword found.
REX0289E: Error 25.901:  Unknown keyword on ::CLASS directive; found "SUBCLASS".
--> should be            Unknown keyword on ::EXTENSION directive; found "SUBCLASS".


================================================================================
rexx.img
================================================================================

Tried to put all the extensions in rexx.img, by adding this line in CoreClasses.orx
call "extension/extensions.cls"
error because transient class SecurityManager included.

This error is due to the use of ::requires
Code review to see where SecurityManager could be referenced and retrieved when generating rexx.img

    interpreter
    method
    package
    RexxSource
    RoutineClass (code)
    RexxActivation
    RexxActivity (InterpreterInstance *instance)
    RexxCode (RexxSource      * source)
    RexxNativeActivation (SecurityManager *securityManager)
    RexxNativeCode (RexxSource *source)
    RoutineClass (code)
    RexxSource (SecurityManager *securityManager)

Did not investigate further, even not sure that if will be possible to support ::requires
Maybe I should review what was done in official oorexx to clean the rexx.img
    12158	[#1712] rexx.img varies from ASLR	bigrixx	02/11/2021 09:27 PM
    12157	[#1712] rexx.img varies from ASLR	bigrixx	02/10/2021 09:55 PM
    12155	[#1712] rexx.img varies from ASLR	bigrixx	02/10/2021 12:36 AM
    12153	[#1712] rexx.img varies from ASLR	bigrixx	02/09/2021 10:07 PM
https://sourceforge.net/p/oorexx/bugs/1712/

================================================================================
oorexxshell
================================================================================

23/03/2023
J Leslie Turriff <jlturriff@mail.com>
in netrexx@groups.io
Re: [netrexx] NetRexx Workspace
The current XDG standard is to place configuration files in ~/.config,
thus .config/nrws.properties.

Maybe I should do that for oorexxshell
Currently it's
    self~settingsFile = HOME || "/.oorexxshell.ini"
    self~historyFile = HOME || "/.oorexxshell_history"

================================================================================
ICU4X
================================================================================

Don't know how to avoid this warning:
...icu4x/target/aarch64-apple-darwin/release/libicu_capi_cdylib.dylib) was built for newer macOS version (12.0) than being linked (11.0)
https://stackoverflow.com/questions/43216273/object-file-was-built-for-newer-osx-version-than-being-linked


================================================================================
regex.cls
================================================================================

p = .Pattern~compile("(.)*foo")
p~matches("xfooxxxxxxfooXXXX")=
Invalid position argument specified; found "0".

