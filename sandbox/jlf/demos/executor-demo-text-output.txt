
----------------
-- Text encoding
----------------

Start working on a prototype for encoded strings.

Main ideas explored with this prototype :
- The existing String class is kept unchanged, but its semantic becomes : "byte-oriented".
- The prototype adds a layer of services working at grapheme level, provided by the RexxText class.
- The RexxText class works on the bytes managed by the String class.
- String instances are immutable, the same for RexxText instances.
- No automatic conversion to Unicode by the interpreter.
- The strings crossing the I/O barriers are kept unchanged.
- Supported encodings : byte, UTF-8, UTF-16BE.

On my Mac, where locale returns :

ooRexx[bash]> "locale"
LANG=
LC_COLLATE="en_US.UTF-8"
LC_CTYPE="en_US.UTF-8"
LC_MESSAGES="en_US.UTF-8"
LC_MONETARY="en_US.UTF-8"
LC_NUMERIC="en_US.UTF-8"
LC_TIME="en_US.UTF-8"
LC_ALL="en_US.UTF-8"

I get that under ooRexxShell :

ooRexx[bash]> s1 = "é"

ooRexx[bash]> s1=                                 -- 'é'
'é'

ooRexx[bash]> s1~length=                          -- 2
 2

ooRexx[bash]> s1~c2x=                             -- C3 A9
'C3A9'

ooRexx[bash]> combining_acute_accent = "cc81"x

ooRexx[bash]> s2 = "e" || combining_acute_accent

ooRexx[bash]> s2=                                 -- 'é'
'é'

ooRexx[bash]> s2~length=                          -- 3
 3

ooRexx[bash]> s2~c2x=                             -- 65 CC 81
'65CC81'

My goal :
s1~text~length=                     -- 1 grapheme
s1~text~codepoints~count=           -- 1 codepoint
s1~text~string~length=              -- 2 bytes

s2~text~length=                     -- 1 grapheme
s2~text~codepoints~count=           -- 2 codepoints
s2~text~string~length=              -- 3 bytes

ooRexx[bash]> 

ooRexx[bash]> .encoding~defaultEncoding = "utf8"

ooRexx[bash]> s1~text~length=                     -- 1 grapheme
 1

ooRexx[bash]> s1~text~codepoints~count=           -- 1 codepoint
 1

ooRexx[bash]> s1~text~string~length=              -- 2 bytes
 2


ooRexx[bash]> s2~text~length=                     -- 1 grapheme
 1

ooRexx[bash]> s2~text~codepoints~count=           -- 2 codepoints
 2

ooRexx[bash]> s2~text~string~length=              -- 3 bytes
 3

A String is linked to a RexxText, which itself is linked to this String:

    a String
     ▲  text --------⮸ a RexxText
     │                     indexer (anEncoding)
     │                          codepoints (sequential access)
     │                          graphemes  (direct access)
     +-----------------------⮷- string

The ooRexx programmer has the choice :
- working with String at byte level
- working with RexxText at grapheme level.
- the same instance of String is used in both cases.

ooRexx[bash]> myText = "où as tu e" || .Unicode~character("combining acute accent")~utf8 || "té ?"

ooRexx[bash]> myText=                         -- T'où as tu été ?'
T'où as tu été ?'

ooRexx[bash]> myString = myText~string

ooRexx[bash]> myString=                       -- 'où as tu été ?'
'où as tu été ?'

ooRexx[bash]> myString~length=                -- 18
 18

ooRexx[bash]> myText~length=                  -- 14
 14

                                -- 1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18
myString                        -- 6F C3 B9 20 61 73 20 74 75 20 65 CC 81 74 C3 A9 20 3F
                                -- o. ù....  . a. s.  . t. u.  . e. acute t. é....  . ?.

ooRexx[bash]> myString~eachC("c2x")=
['6F','C3','B9', 20, 61, 73, 20, 74, 75, 20, 65,'CC', 81, 74,'C3','A9', 20,'3F']

                                -- 1  2     3  4  5  6  7  8  9  10       11 12    13 14
myText                          -- 6F C3B9  20 61 73 20 74 75 20 65 CC81  74 C3A9  20 3F
                                -- o. ù...   . a. s.  . t. u.  . e. acut  t. é...   . ?.

ooRexx[bash]> myText~graphemes~each("c2x")=
['6F','C3B9', 20, 61, 73, 20, 74, 75, 20,'65CC81', 74,'C3A9', 20,'3F']

CR+LF is a grapheme made of 2 codepoints.
LF+CR are 2 graphemes.

ooRexx[bash]> "0D0A"x~text~description=
'UTF-8 ASCII (1 grapheme, 2 codepoints, 2 bytes, 0 error)'

ooRexx[bash]> "0A0D"x~text~description=
'UTF-8 ASCII (2 graphemes, 2 codepoints, 2 bytes, 0 error)'

More examples of encoded string

ooRexx[bash]> "( ͡° ͜ʖ﻿ ͡°)"~text~description=
'UTF-8 not-ASCII (9 graphemes, 12 codepoints, 20 bytes, 0 error)'

ooRexx[bash]> "( ͡° ͜ʖ﻿ ͡°)"~text~graphemes~each("c2x")=
[ 28,'20CDA1','C2B0','20CD9C','CA96','EFBBBF','20CDA1','C2B0', 29]

ooRexx[bash]> "( ͡° ͜ʖ﻿ ͡°)"~text~codepoints~each{"U+"item~d2x}=
['U+28','U+20','U+361','U+B0','U+20','U+35C','U+296','U+FEFF','U+20','U+361','U+B0','U+29']

ooRexx[bash]> "(ノಠ益ಠ)ノ彡"~text~description=
'UTF-8 not-ASCII (8 graphemes, 8 codepoints, 20 bytes, 0 error)'

ooRexx[bash]> "(ノಠ益ಠ)ノ彡"~text~graphemes~each("c2x")=
[ 28,'E3838E','E0B2A0','E79B8A','E0B2A0', 29,'E3838E','E5BDA1']

ooRexx[bash]> "(ノಠ益ಠ)ノ彡"~text~codepoints~each{"U+"item~d2x}=
['U+28','U+30CE','U+CA0','U+76CA','U+CA0','U+29','U+30CE','U+5F61']

U+FE0E VARIATION SELECTOR-15 (UTF-8: EF B8 8E)
https://codepoints.net/U+fe0e
This codepoint may change the appearance of the preceding character.
If that is a symbol, dingbat or emoji, U+FE0E forces it to be rendered in a
textual fashion as compared to a colorful image.

U+FE0F VARIATION SELECTOR-16 (UTF-8: EF B8 8F)
https://codepoints.net/U+fe0f
This codepoint may change the appearance of the preceding character.
If that is a symbol, dingbat or emoji, U+FE0F forces it to be rendered as a
colorful image as compared to a monochrome text variant.
In theory ❤ and ❄ (and many other emoji) should display as text style by default
without VS16, but many applications ignore that.

ooRexx[bash]> emoji_bag = .bag~of('❤', '❤️', '❄', '❄︎', '❄️', '⚪', '⚪️', '⚫', '⚫️')

ooRexx[bash]> emoji_table = emoji_bag~table~map("text")

ooRexx[bash]> emoji_table~map("c2x")==
a Table (9 items)
'⚪'    : 'E29AAA'
'⚪️' : 'E29AAAEFB88F'
'⚫'    : 'E29AAB'
'⚫️' : 'E29AABEFB88F'
'❄'    : 'E29D84'
'❄︎' : 'E29D84EFB88E'
'❄️' : 'E29D84EFB88F'
'❤'    : 'E29DA4'
'❤️' : 'E29DA4EFB88F'

ooRexx[bash]> emoji_table~map("c2u")==
a Table (9 items)
'⚪'    : 'U+26AA'
'⚪️' : 'U+26AA U+FE0F'
'⚫'    : 'U+26AB'
'⚫️' : 'U+26AB U+FE0F'
'❄'    : 'U+2744'
'❄︎' : 'U+2744 U+FE0E'
'❄️' : 'U+2744 U+FE0F'
'❤'    : 'U+2764'
'❤️' : 'U+2764 U+FE0F'
The tables above are not well aligned
because the alignement is based on the length of the indexes,
which is (for the moment) a count of bytes, not a count of graphemes...

https://www.reddit.com/r/cpp/comments/aqzu7i
👩‍👨‍👩‍👧‍👦‍👧‍👧‍👦
is one grapheme, made up of 15 codepoints

ooRexx[bash]> family = "👩‍👨‍👩‍👧‍👦‍👧‍👧‍👦"

ooRexx[bash]> family=
'👩‍👨‍👩‍👧‍👦‍👧‍👧‍👦'

ooRexx[bash]> family~text~description=                              -- 1 grapheme, 15 codepoints, 53 bytes
'UTF-8 not-ASCII (1 grapheme, 15 codepoints, 53 bytes, 0 error)'

ooRexx[bash]> family~text~c2x=
'F09F91A9E2808DF09F91A8E2808DF09F91A9E2808DF09F91A7E2808DF09F91A6E2808DF09F91A7E2808DF09F91A7E2808DF09F91A6'

ooRexx[bash]> family~text~c2u=
'U+0001F469 U+200D U+0001F468 U+200D U+0001F469 U+200D U+0001F467 U+200D U+0001F466 U+200D U+0001F467 U+200D U+0001F467 U+200D U+0001F466'

https://onlineunicodetools.com/generate-zalgo-unicode
Uses Unicode combining characters to create symbol noise.
"hello" zalgoified:
h̵᷊̟͉͔̟̲͆e̷͇̼͉̲̾l̸̨͓̭̗᷿︣︠ͦl̶̯̻̑̈ͮ͌︡̕o̵̝̬̯᷊̭̯̦᷃ͪ̆́᷈́͜͢͞

ooRexx[bash]> helloZalgo = "h̵᷊̟͉͔̟̲͆e̷͇̼͉̲̾l̸̨͓̭̗᷿︣︠ͦl̶̯̻̑̈ͮ͌︡̕o̵̝̬̯᷊̭̯̦᷃ͪ̆́᷈́͜͢͞"

ooRexx[bash]> helloZalgo =
'h̵᷊̟͉͔̟̲͆e̷͇̼͉̲̾l̸̨͓̭̗᷿︣︠ͦl̶̯̻̑̈ͮ͌︡̕o̵̝̬̯᷊̭̯̦᷃ͪ̆́᷈́͜͢͞'

ooRexx[bash]> helloZalgo~text~description=                          -- 5 graphemes, 54 codepoints, 111 bytes
'UTF-8 not-ASCII (5 graphemes, 54 codepoints, 111 bytes, 0 error)'

ooRexx[bash]> helloZalgo~text~c2x=
'68CD86CCB5E1B78ACC9FCD89CD94CC9FCCB2 65CCBECCB7CD87CCBCCD89CCB2 6CEFB8A3EFB8A0CDA6CCB8CD93CCADCC97E1B7BFCCA8 6CCC91CC88CDAECD8CEFB8A1CC95CCB6CCAFCCBB 6FE1B783CDAACC86CC81E1B788CD81CD9ECCB5CC9DCD9CCCACCCAFE1B78ACDA2CCADCCAFCCA6'

ooRexx[bash]> helloZalgo~text~c2u=
'U+0068 U+0346 U+0335 U+1DCA U+031F U+0349 U+0354 U+031F U+0332 U+0065 U+033E U+0337 U+0347 U+033C U+0349 U+0332 U+006C U+FE23 U+FE20 U+0366 U+0338 U+0353 U+032D U+0317 U+1DFF U+0328 U+006C U+0311 U+0308 U+036E U+034C U+FE21 U+0315 U+0336 U+032F U+033B U+006F U+1DC3 U+036A U+0306 U+0301 U+1DC8 U+0341 U+035E U+0335 U+031D U+035C U+032C U+032F U+1DCA U+0362 U+032D U+032F U+0326'

Supported encoding conversions:
Byte to UTF-8
Byte to UTF-16
UTF-8 to UTF-16
UTF-16 to UTF-8

The Byte_Encoding can be specialized to add support for specific encoding conversions.

ooRexx[bash]> .Encoding~supported~table==
a Table (10 items)
'BYTE'        : (The Byte_Encoding class)
'BYTES'       : (The Byte_Encoding class)
'CP1252'      : (The CP1252_Encoding class)
'UTF16'       : (The UTF16BE_Encoding class)
'UTF16BE'     : (The UTF16BE_Encoding class)
'UTF8'        : (The UTF8_Encoding class)
'WINDOWS1252' : (The CP1252_Encoding class)
'WTF16'       : (The WTF16BE_Encoding class)
'WTF16BE'     : (The WTF16BE_Encoding class)
'WTF8'        : (The WTF8_Encoding class)

Example: CP1252 to UTF-8
"Un œuf de chez MaPoule™ coûte ±0.40€"

ooRexx[bash]> str_cp1252 = "Un " || "9C"x || "uf de chez MaPoule" || "99"x || " co" || "FB"x || "te " || "B1"x || "0.40" || "80"x

ooRexx[bash]> txt_cp1252 = str_cp1252~text("cp1252")

ooRexx[bash]> txt_cp1252~description=
'CP1252 not-ASCII (36 graphemes, 36 codepoints, 36 bytes, 0 error)'

ooRexx[bash]> txt_cp1252~c2x=
'55 6E 20 9C 75 66 20 64 65 20 63 68 65 7A 20 4D 61 50 6F 75 6C 65 99 20 63 6F FB 74 65 20 B1 30 2E 34 30 80'

ooRexx[bash]> txt_utf8 = txt_cp1252~utf8

ooRexx[bash]> txt_utf8=
T'Un œuf de chez MaPoule™ coûte ±0.40€'

ooRexx[bash]> txt_utf8~description=
'UTF-8 not-ASCII (36 graphemes, 36 codepoints, 43 bytes, 0 error)'

ooRexx[bash]> txt_utf8~c2x=
'55 6E 20 C593 75 66 20 64 65 20 63 68 65 7A 20 4D 61 50 6F 75 6C 65 E284A2 20 63 6F C3BB 74 65 20 C2B1 30 2E 34 30 E282AC'

Comparing the size of UTF-8 encoding vs UTF-16 encoding for various strings.
These strings are UTF-8 encoded.
The first step is to get a wrapper RexxText (default encoding is UTF-8).
The second step is to convert to UTF-16.

ooRexx[bash]> howMuchOfStorage = "how much of storage?"

ooRexx[bash]> howMuchOfStorage~text~description=              -- 'UTF-8 ASCII (20 graphemes, 20 codepoints, 20 bytes)'
'UTF-8 ASCII (20 graphemes, 20 codepoints, 20 bytes, 0 error)'

ooRexx[bash]> howMuchOfStorage~text~utf16~description=        -- 'UTF-16BE ASCII (20 graphemes, 20 codepoints, 40 bytes)
'UTF-16BE ASCII (20 graphemes, 20 codepoints, 40 bytes, 0 error)'

ooRexx[bash]> rexCharacters = "'rex' in their name: ꎅ ꎜ ꏑ 🦖"

ooRexx[bash]> rexCharacters~text~description=                 -- 'UTF-8 not-ASCII (28 graphemes, 28 codepoints, 37 bytes)'
'UTF-8 not-ASCII (28 graphemes, 28 codepoints, 37 bytes, 0 error)'

ooRexx[bash]> rexCharacters~text~utf16~description=           -- 'UTF-16BE not-ASCII (28 graphemes, 28 codepoints, 58 bytes)'
'UTF-16BE not-ASCII (28 graphemes, 28 codepoints, 58 bytes, 0 error)'

ooRexx[bash]> family = "👩‍👨‍👩‍👧‍👦‍👧‍👧‍👦"

ooRexx[bash]> family~text~description=                        -- 'UTF-8 not-ASCII (1 grapheme, 15 codepoints, 53 bytes)'
'UTF-8 not-ASCII (1 grapheme, 15 codepoints, 53 bytes, 0 error)'

ooRexx[bash]> family~text~utf16~description=                  -- 'UTF-16BE not-ASCII (1 grapheme, 15 codepoints, 46 bytes)
'UTF-16BE not-ASCII (1 grapheme, 15 codepoints, 46 bytes, 0 error)'

ooRexx[bash]> helloZalgo = "h̵᷊̟͉͔̟̲͆e̷͇̼͉̲̾l̸̨͓̭̗᷿︣︠ͦl̶̯̻̑̈ͮ͌︡̕o̵̝̬̯᷊̭̯̦᷃ͪ̆́᷈́͜͢͞"

ooRexx[bash]> helloZalgo~text~description=                    -- 'UTF-8 not-ASCII (5 graphemes, 54 codepoints, 111 bytes)
'UTF-8 not-ASCII (5 graphemes, 54 codepoints, 111 bytes, 0 error)'

ooRexx[bash]> helloZalgo~text~utf16~description=              -- 'UTF-16BE not-ASCII (5 graphemes, 54 codepoints, 108 bytes)
'UTF-16BE not-ASCII (5 graphemes, 54 codepoints, 108 bytes, 0 error)'

End of demonstration.
