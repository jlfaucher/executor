
----------------------------------
-- Text encoding - Internal checks
----------------------------------

Creation of a RexxText

ooRexx[bash]> 

ooRexx[bash]> s = "hello"

ooRexx[bash]> s~text = .RexxText~new("hello")          -- The counterpart must be a RexxText linked to this String
EncodedString: the counterpart must be a RexxText linked to this String.
Error code= 93.900

ooRexx[bash]> s~text = .RexxText~new(s)                -- ok, the RexxText is linked to s, now can be assigned to s~text

ooRexx[bash]> "Ã©"~text("byte") || "Ã¨"~text("utf8")=    -- Cannot concatenate Byte with UTF-8
Encoding: cannot concatenate Byte not-ASCII text with UTF-8 not-ASCII text.
Error code= 93.900

ooRexx[bash]> "Ã©"~text("byte") || "Ã©"~text("utf8")=    -- T'Ã©Ã©' encoded UTF-8
T'Ã©Ã©'
No error because the 2 occurences of the string "Ã©" are the same interned string.
So both texts are in fact the same instance of RexxText.
The last encoding selection wins, the result is UTF-8.

Byte encoding

ooRexx[bash]> s = "63 C3 B4 74 65 CC 81 F0 9F 91 8D"x  -- An UTF-8 string. The Byte encoding works at byte level, as the String class

ooRexx[bash]> s=                                       -- 'cÃ´teÌðŸ‘'
'cÃ´teÌðŸ‘'

ooRexx[bash]> .byte_encoding~decode(s, 1)=             -- 99 (63)
 99

ooRexx[bash]> .byte_encoding~decode(s, 2)=             -- 195 (C3)
 195

ooRexx[bash]> .byte_encoding~decode(s, 12)=            -- -1 (end of string)
-1

ooRexx[bash]> .byte_encoding~decode(s, 1, 2)=          -- 2 is an invalid codepoint size
Byte encoding: 2 is an invalid codepoint size.
Error code= 93.900

ooRexx[bash]> .byte_encoding~encode(65)=               -- T'A'
T'A'

ooRexx[bash]> .byte_encoding~encode(256)=              -- 256 is an invalid codepoint (range 0..255)
Byte encoding: invalid codepoint 256 (0100x). Allowed range is 0..255.
Error code= 93.900

UTF-8 encoding

-- If you don't pass a size to ~decode then the method calculates it, while checking the validity of the encoding

ooRexx[bash]> s = "63 C3 B4 74 65 CC 81 F0 9F 91 8D"x  -- An UTF-8 string: 'cÃ´teÌðŸ‘'

ooRexx[bash]> .utf8_encoding~decode(s, 1)=             -- 99
 99

ooRexx[bash]> .utf8_encoding~nextCodepointIndex(s, 1)= -- 2
 2

ooRexx[bash]> .utf8_encoding~decode(s, 2)=             -- 244
 244

ooRexx[bash]> .utf8_encoding~nextCodepointIndex(s, 2)= -- 4
 4

ooRexx[bash]> .utf8_encoding~decode(s, 4)=             -- 116
 116

ooRexx[bash]> .utf8_encoding~nextCodepointIndex(s, 4)= -- 5
 5

ooRexx[bash]> .utf8_encoding~decode(s, 5)=             -- 101
 101

ooRexx[bash]> .utf8_encoding~nextCodepointIndex(s, 5)= -- 6
 6

ooRexx[bash]> .utf8_encoding~decode(s, 6)=             -- 769
 769

ooRexx[bash]> .utf8_encoding~nextCodepointIndex(s, 6)= -- 8
 8

ooRexx[bash]> .utf8_encoding~decode(s, 8)=             -- 128077
 128077

ooRexx[bash]> .utf8_encoding~nextCodepointIndex(s, 8)= -- 12
 12

ooRexx[bash]> .utf8_encoding~decode(s, 12)=            -- -1 (end of string)
-1

-- Example of check

ooRexx[bash]> "63 C3 B4 74 65 CC 81 F0 9F 91 8D"x~text("utf8")=           -- T'cÃ´teÌðŸ‘'
T'cÃ´teÌðŸ‘'

ooRexx[bash]>       "B4 74 65 CC 81 F0 9F 91 8D"x~text("utf8")~errors=    -- Invalid start byte
['UTF-8 sequence at byte-position 1 has an invalid start byte 180 (B4x).']

ooRexx[bash]> "63 C3    74 65 CC 81 F0 9F 91 8D"x~text("utf8")~errors=    -- Invalid continuation byte
['UTF-8 sequence at byte-position 2 has an invalid continuation byte 116 (74x) at byte-position 3.']

ooRexx[bash]> "63 C3 B4 74 65 CC 81 F0 9F 91"x~text("utf8")~errors=       -- UTF-8 character is truncated
['UTF-8 sequence at byte-position 8 is truncated, expected 4 bytes.']

-- If you pass a size to ~decode, the method assumes you know what you do, there is no check

ooRexx[bash]> .utf8_encoding~decode(s, 2, 1)=          -- 67      invalid size, the result is wrong
 67

ooRexx[bash]> .utf8_encoding~decode(s, 2, 2)=          -- 244     correct
 244

ooRexx[bash]> .utf8_encoding~decode(s, 2, 3)=          -- 15668   invalid size, the result is wrong
 15668

ooRexx[bash]> .utf8_encoding~decode(s, 2, 4)=          -- 864789  invalid size, the result is wrong
 864789

ooRexx[bash]> .utf8_encoding~decode(s, 2, 5)=          -- UTF-8 encoding: 5 is an invalid codepoint size
UTF-8 encoding: 5 is an invalid codepoint size.
Error code= 93.900

-- Encoding

ooRexx[bash]> .utf8_encoding~encode(65)=               -- T'A'
T'A'

ooRexx[bash]> .utf8_encoding~encode(650)=              -- T'ÊŠ'
T'ÊŠ'

ooRexx[bash]> .utf8_encoding~encode(6500)=             -- T'á¥¤'
T'á¥¤'

ooRexx[bash]> .utf8_encoding~encode(65000)=            -- T'ï·¨'
T'ï·¨'

ooRexx[bash]> .utf8_encoding~encode(650000)=           -- T'òž¬'
T'òž¬'

ooRexx[bash]> .utf8_encoding~encode(6500000)=          -- 6500000 is an invalid codepoint (range 0..1114111)
UTF-8 encoding: invalid codepoint 6500000 (00632EA0x). Allowed range is 0..1114111.
Error code= 93.900

ooRexx[bash]> .utf8_encoding~encode(55296)~errors=     -- 55296 is an invalid codepoint (high surrogate)
['UTF-8 encoding: invalid codepoint 55296 (D800x). High surrogate is not allowed.']

ooRexx[bash]> .utf8_encoding~encode(56320)~errors=     -- 56320 is an invalid codepoint (low surrogate)
['UTF-8 encoding: invalid codepoint 56320 (DC00x). Low surrogate is not allowed.']

UTF-16 encoding


ooRexx[bash]> s = "63 C3 B4 74 65 CC 81 F0 9F 91 8D"x         -- An UTF-8 string: 'cÃ´teÌðŸ‘'

ooRexx[bash]> t16 = s~text("utf8")~utf16                      -- interpret the bytes as UTF-8 and convert them to UTF-16

ooRexx[bash]> t16=                                            -- Each codepoint is 2 bytes
T'[00]c[00]ô[00]t[00]e[0301]Ø=ÜM'

ooRexx[bash]> s16 = t16~string                                -- internal bytes

ooRexx[bash]> s16=
'[00]c[00]ô[00]t[00]e[0301]Ø=ÜM'

ooRexx[bash]> t16~c2u=                                        -- [ 99, 244, 116, 101, 769, 128077]
'U+0063 U+00F4 U+0074 U+0065 U+0301 U+0001F44D'

ooRexx[bash]> t16~c2x=                                        -- [ 0063,'00F4', 0074, 00650301,'D83DDC4D']
'0063 00F4 0074 00650301 D83DDC4D'

-- If you don't pass a size to ~decode then the method calculates it, while checking the validity of the encoding

ooRexx[bash]> .utf16be_encoding~decode(s16, 1)=               -- 99
 99

ooRexx[bash]> .utf16be_encoding~nextCodepointIndex(s16, 1)=   -- 3
 3

ooRexx[bash]> .utf16be_encoding~decode(s16, 3)=               -- 244
 244

ooRexx[bash]> .utf16be_encoding~nextCodepointIndex(s16, 3)=   -- 5
 5

ooRexx[bash]> .utf16be_encoding~decode(s16, 5)=               -- 116
 116

ooRexx[bash]> .utf16be_encoding~nextCodepointIndex(s16, 5)=   -- 7
 7

ooRexx[bash]> .utf16be_encoding~decode(s16, 7)=               -- 101
 101

ooRexx[bash]> .utf16be_encoding~nextCodepointIndex(s16, 7)=   -- 9
 9

ooRexx[bash]> .utf16be_encoding~decode(s16, 9)=               -- 769
 769

ooRexx[bash]> .utf16be_encoding~nextCodepointIndex(s16, 9)=   -- 11
 11

ooRexx[bash]> .utf16be_encoding~decode(s16, 11)=              -- 128077
 128077

ooRexx[bash]> .utf16be_encoding~nextCodepointIndex(s16, 11)=  -- 15
 15

ooRexx[bash]> .utf16be_encoding~decode(s16, 15)=              -- -1 (end of string)
-1

-- Example of checks

ooRexx[bash]> "D800 DC00 D801 DC01"x~text("utf16")~utf8=          -- T'ð€€ð'
T'ð€€ð'

ooRexx[bash]>      "DC00 D801 DC01"x~text("utf16")~errors=        -- Unpaired low surrogate
['UTF-16BE encoding: unpaired low surrogate 56320 (DC00x) at byte-position 1.']

ooRexx[bash]>      "DC00 D801 DC01"x~text("wtf16")~errors=        -- acceptable when WTF
(The NIL object)

ooRexx[bash]>      "DC00 D801 DC01"x~text("wtf16")~utf8~errors=   -- but cannot be converted to UTF-8: invalid codepoint DC00x
['UTF-8 encoding: invalid codepoint 56320 (DC00x). Low surrogate is not allowed.']

ooRexx[bash]> "D800 1000 D801 DC01"x~text("utf16")~errors=        -- Invalid low surrogate
['UTF-16BE encoding: invalid low surrogate 4096 (1000x) at byte-position 3.']

ooRexx[bash]> "D800 1000 D801 DC01"x~text("wtf16")~errors=        -- acceptable when WTF
(The NIL object)

ooRexx[bash]> "D800 DC00 D801 DC"x~text("utf16")~errors=          -- character is truncated
['UTF-16BE encoding: character is truncated at byte-position 7, expected 2 bytes.','UTF-16BE encoding: character is truncated at byte-position 7, expected 2 bytes.']

ooRexx[bash]> "D800 DC00 D801 DC"x~text("wtf16")~errors=          -- not acceptable, even when WTF-16
['WTF-16BE encoding: character is truncated at byte-position 7, expected 2 bytes.','WTF-16BE encoding: character is truncated at byte-position 7, expected 2 bytes.']

-- If you pass a size to ~decode, the method assumes you know what you do, there is no check

ooRexx[bash]> .utf16be_encoding~decode(s16, 3, 1)=            -- 1 is an invalid codepoint size
UTF-16BE encoding: 1 is an invalid codepoint size.
Error code= 93.900

ooRexx[bash]> .utf16be_encoding~decode(s16, 3, 2)=            -- 244         correct
 244

ooRexx[bash]> .utf16be_encoding~decode(s16, 3, 3)=            -- 3 is an invalid codepoint size
UTF-16BE encoding: 3 is an invalid codepoint size.
Error code= 93.900

ooRexx[bash]> .utf16be_encoding~decode(s16, 3, 4)=            -- invalid size, the result is wrong
-56363916

ooRexx[bash]> .utf16be_encoding~decode(s16, 3, 5)=            -- 5 is an invalid codepoint size
UTF-16BE encoding: 5 is an invalid codepoint size.
Error code= 93.900

-- Encoding

ooRexx[bash]> .utf16be_encoding~encode(65)=                   -- T'[00]A'
T'[00]A'

ooRexx[bash]>  .utf16be_encoding~encode(650)=                 -- T'[02]?'
T'[02]Š'

ooRexx[bash]> .utf16be_encoding~encode(6500)=                 -- T'[19]d'
T'[19]d'

ooRexx[bash]>  .utf16be_encoding~encode(65000)=               -- T'??'
T'ýè'

ooRexx[bash]> .utf16be_encoding~encode(650000)=               -- T'?:?[10]'
T'Ú:ß[10]'

ooRexx[bash]> .utf16be_encoding~encode(6500000)=              -- 6500000 is an invalid codepoint
UTF-16BE encoding: invalid codepoint 6500000 (00632EA0x). Allowed range is 0..1114111.
Error code= 93.900

ooRexx[bash]> .utf16be_encoding~encode(55296)~errors=         -- 55296 is an invalid codepoint (high surrogate)
['UTF-16BE encoding: unpaired high surrogate 55296 (D800x) at byte-position 1.']

ooRexx[bash]> .wtf16be_encoding~encode(55296)~errors=         -- acceptable when WTF
(The NIL object)

ooRexx[bash]> .utf16be_encoding~encode(56320)~errors=         -- 56320 is an invalid codepoint (low surrogate)
['UTF-16BE encoding: unpaired low surrogate 56320 (DC00x) at byte-position 1.']

ooRexx[bash]> .wtf16be_encoding~encode(56320)~errors=         -- acceptable when WTF
(The NIL object)

To concatenate two WTF-8 strings: if the earlier one ends with a lead surrogate
and the latter one starts with a trail surrogate, both surrogate need to be
removed and replaced with a 4-byte sequence

ooRexx[bash]> "D800 DC01"x~text("utf16")~utf8~string~c2x=     -- UTF-8 encoding of character U+10001 from its UTF-16 encoding
'F0908081'

ooRexx[bash]> t1 = "D800"x~text("wtf16")                      -- An invalid UTF16 encoding, but a valid WTF8 encoding (high surrogate)

ooRexx[bash]> t2 = "DC01"x~text("wtf16")                      -- An invalid UTF16 encoding, but a valid WTF8 encoding (low surrogate)

ooRexx[bash]> (t1 || t2)~utf16~string~c2x=                    -- The concatenation is valid UTF16
'D800DC01'

ooRexx[bash]> t1~wtf8~string~c2x=                             -- WTF-8 encoding of U+D800 (high surrogate)
'EDA080'

ooRexx[bash]> t2~wtf8~string~c2x=                             -- WTF-8 encoding of U+DC01 (low surrogate)
'EDB081'

ooRexx[bash]> (t1~wtf8~string || t2~wtf8~string)~c2x=         -- The concatenation of both WTF8 can't be this (2 codepoints)
'EDA080EDB081'

ooRexx[bash]> (t1~wtf8 || t2~wtf8)~c2x=                       -- The correct concatenation is this (1 codepoint)
'F0908081'

Noncharaters are supported without error.
http://www.unicode.org/faq/private_use.html#noncharacters
A "noncharacter" is a code point that is permanently reserved in the Unicode Standard for internal use.
They are considered unassigned to any abstract character, and they share the General_Category value Cn (Unassigned) with unassigned reserved code points in the standard.
Unicode has exactly 66 noncharacters.
(In this table, "#" stands for either the hex digit "E" or "F".)
    UTF-32      UTF-16      UTF-8
    0000FDD0    FDD0        EF B7 90
    ...
    0000FDEF    FDEF        EF B7 AF
    0000FFF#    FFF#        EF BF B#
    0001FFF#    D83F DFF#   F0 9F BF B#
    0002FFF#    D87F DFF#   F0 AF BF B#
    0003FFF#    D8BF DFF#   F0 BF BF B#
    0004FFF#    D8FF DFF#   F1 8F BF B#
    ...
    000FFFF#    DBBF DFF#   F3 BF BF B#
    0010FFF#    DBFF DFF#   F4 8F BF B#

ooRexx[bash]> .utf16be_encoding~encode("FDD0"~x2d)~c2x=       -- FDD0
'FDD0'

ooRexx[bash]> .utf8_encoding~encode("FDD0"~x2d)~c2x=          -- EF B7 90
'EFB790'



End of demonstration.
