<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- This file was created with the aha Ansi HTML Adapter. https://github.com/theZiz/aha -->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="application/xml+xhtml; charset=UTF-8"/>
<title>executor-demo-array-output.html</title>
</head>
<body>
<pre>
<span style="font-weight:bold;color:green;">loadPackage OK for extension/stringChunk.cls
</span><span style="font-weight:bold;color:green;">loadPackage OK for utilities/indentedStream.cls
</span><span style="font-weight:bold;color:green;">loadPackage OK for extension/extensions.cls
</span><span style="font-weight:bold;color:green;">loadLibrary OK for rxunixsys
</span><span style="font-weight:bold;color:green;">loadPackage OK for ncurses.cls
</span><span style="font-weight:bold;color:green;">loadPackage OK for csvStream.cls
</span><span style="font-weight:bold;color:green;">loadLibrary OK for hostemu
</span><span style="font-weight:bold;color:green;">loadPackage OK for json.cls
</span><span style="font-weight:bold;color:green;">loadPackage OK for mime.cls
</span><span style="font-weight:bold;color:green;">loadPackage OK for rxftp.cls
</span><span style="font-weight:bold;color:green;">loadLibrary OK for rxmath
</span><span style="font-weight:bold;color:green;">loadPackage OK for rxregexp.cls
</span><span style="font-weight:bold;color:green;">loadPackage OK for regex/regex.cls
</span><span style="font-weight:bold;color:green;">loadPackage OK for smtp.cls
</span><span style="font-weight:bold;color:green;">loadPackage OK for socket.cls
</span><span style="font-weight:bold;color:green;">loadPackage OK for streamsocket.cls
</span><span style="font-weight:bold;color:green;">loadPackage OK for pipeline/pipe.cls
</span><span style="font-weight:bold;color:green;">loadPackage OK for rgf_util2/rgf_util2.rex
</span><span style="font-weight:bold;color:green;">loadPackage OK for BSF.CLS
</span><span style="font-weight:bold;color:green;">loadPackage OK for oorexxshell_queries.cls
</span><span style="font-weight:bold;color:green;">loadPackage OK for pipeline/pipe_extension.cls
</span><span style="font-weight:bold;color:green;">loadPackage OK for rgf_util2/rgf_util2_wrappers.rex
</span><span style="font-weight:bold;color:green;">
</span><span style="font-weight:bold;color:green;">REXX-ooRexx_4.3.0(MT)_64-bit 6.04 22 Jun 2024
</span><span style="font-weight:bold;color:green;">Input queue name: Sade9Q600001c5ebe0
</span>
<span style="font-weight:bold;color:blue;">--------------------
</span><span style="font-weight:bold;color:blue;">-- Array programming
</span><span style="font-weight:bold;color:blue;">--------------------
</span>
<span style="font-weight:bold;color:blue;">/*
</span><span style="font-weight:bold;color:blue;">rank
</span><span style="font-weight:bold;color:blue;">
</span><span style="font-weight:bold;color:blue;">APL R←⍴⍴Y
</span><span style="font-weight:bold;color:blue;">An array may have 0 or more axes or dimensions.
</span><span style="font-weight:bold;color:blue;">The number of axes of an array is known as its rank.
</span><span style="font-weight:bold;color:blue;">An array with 0 axes (rank 0) is called a scalar
</span><span style="font-weight:bold;color:blue;">An array with 1 axis (rank 1) is called a vector.
</span><span style="font-weight:bold;color:blue;">An array with 2 axes (rank 2) is called a matrix or table.
</span><span style="font-weight:bold;color:blue;">An array with 3 axes (rank 3) is called a cube.
</span><span style="font-weight:bold;color:blue;">An array with more than 2 axes is called a multi-dimensional array
</span><span style="font-weight:bold;color:blue;">*/
</span>
<span style="font-weight:bold;color:blue;">/*
</span><span style="font-weight:bold;color:blue;">shape
</span><span style="font-weight:bold;color:blue;">
</span><span style="font-weight:bold;color:blue;">APL R←⍴Y (Rho)
</span><span style="font-weight:bold;color:blue;">The shape of a scalar is an empty vector []
</span><span style="font-weight:bold;color:blue;">The shape of an array is an array which gives the size of each dimension.
</span><span style="font-weight:bold;color:blue;">*/
</span>
<span style="font-weight:bold;color:blue;">/*
</span><span style="font-weight:bold;color:blue;">ooRexx:
</span><span style="font-weight:bold;color:blue;">Any object other than an array is a scalar.
</span><span style="font-weight:bold;color:blue;">In particular, a string is a scalar, not an array as in APL.
</span><span style="font-weight:bold;color:blue;">Special case which does not exist in APL : The rank of an array with no dimension yet assigned is -1.
</span><span style="font-weight:bold;color:blue;">*/
</span>
<span style="font-weight:bold;color:blue;">-- scalar
</span>ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">&quot;string&quot;~shape=</span>
[]
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">&quot;string&quot;~rank=</span>
 0

<span style="font-weight:bold;color:blue;">-- array with no dimension
</span>ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">.array~new~shape=</span>
an Array (shape [], 0 items)
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">.array~new~rank=</span>
-1

<span style="font-weight:bold;color:blue;">/*
</span><span style="font-weight:bold;color:blue;">The helper v(...) creates a vector.
</span><span style="font-weight:bold;color:blue;">*/
</span>
<span style="font-weight:bold;color:blue;">-- empty vector
</span>ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">v()=</span>
[]
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">v()~rank=</span>
 1

<span style="font-weight:bold;color:blue;">-- vector of 3 items
</span>ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">v(0,1,2)~shape=</span>
[ 3]
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">v(0,1,2)~rank=</span>
 1

<span style="font-weight:bold;color:blue;">/*
</span><span style="font-weight:bold;color:blue;">The helper a(...) creates an empty array of specified dimensions.
</span><span style="font-weight:bold;color:blue;">It's almost similar to .array~new(...), except for a() which returns an array with 0 dimension (a scalar).
</span><span style="font-weight:bold;color:blue;">Once the number of dimension(s) is fixed, it's no longer possible to change it.
</span><span style="font-weight:bold;color:blue;">This is different from .array~new which returns an array without dimension.
</span><span style="font-weight:bold;color:blue;">The number of dimension(s) will be determined by the first access to the array:
</span><span style="font-weight:bold;color:blue;">a = .array~new; say a[]        -- Not enough positional arguments for method; 1 expected
</span><span style="font-weight:bold;color:blue;">a = .array~new; say a[1]       -- 1 dimension
</span><span style="font-weight:bold;color:blue;">a = .array~new; say a[1,1]     -- 2 dimensions
</span><span style="font-weight:bold;color:blue;">*/
</span>
<span style="font-weight:bold;color:blue;">-- array with 0 dimension (scalar)
</span>ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">nodim = a()</span>
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">nodim=</span>
an Array (shape [], 0 items)
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">nodim~rank=</span>
 0

<span style="font-weight:bold;color:blue;">-- you can't use any index with such array
</span>ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">nodim[1]=</span>
<span style="font-weight:bold;color:red;">Too many subscripts for array; 0 expected.
</span><span style="font-weight:bold;color:red;">Error code= 93.926
</span>
<span style="font-weight:bold;color:blue;">-- but no index is ok
</span>ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">nodim[]=</span>
(The NIL object)
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">nodim[] = &quot;hello!&quot;</span>
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">nodim[]=</span>
'hello!'

<span style="font-weight:bold;color:blue;">-- empty vector of shape 5
</span>ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">a(5)~shape=</span>
[ 5]
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">a(5)~rank=</span>
 1

<span style="font-weight:bold;color:blue;">-- empty matrix of shape 2,2
</span>ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">a(2,2)~shape=</span>
[ 2, 2]
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">a(2,2)~rank=</span>
 2

<span style="font-weight:bold;color:blue;">-- empty cube of shape 3,3,3
</span>ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">a(3,3,3)~shape=</span>
[ 3, 3, 3]
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">a(3,3,3)~rank=</span>
 3

<span style="font-weight:bold;color:blue;">/*
</span><span style="font-weight:bold;color:blue;">The instance method array~of is an initializer which takes into account the dimensions (shape) of the array.
</span><span style="font-weight:bold;color:blue;">
</span><span style="font-weight:bold;color:blue;">Rules inspired by APL :
</span><span style="font-weight:bold;color:blue;">If there are too many items, the extra items are ignored.
</span><span style="font-weight:bold;color:blue;">If there are fewer items than implied by the dimensions, the list of items is reused as many times as necessary to fill the array.
</span><span style="font-weight:bold;color:blue;">*/
</span>ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">a(6)~of(1,2,3)=</span>
[ 1, 2, 3, 1, 2, 3]
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">a(2,3)~of(1,2,3)=</span>
an Array (shape [2,3], 6 items)
[ 1, 1] :  1
[ 1, 2] :  2
[ 1, 3] :  3
[ 2, 1] :  1
[ 2, 2] :  2
[ 2, 3] :  3
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">a(6)~of(1,2,3,4,5,6,7,8,9)=</span>
[ 1, 2, 3, 4, 5, 6]
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">a(2,3)~of(1,2,3,4,5,6,7,8,9)=</span>
an Array (shape [2,3], 6 items)
[ 1, 1] :  1
[ 1, 2] :  2
[ 1, 3] :  3
[ 2, 1] :  4
[ 2, 2] :  5
[ 2, 3] :  6

<span style="font-weight:bold;color:blue;">/*
</span><span style="font-weight:bold;color:blue;">If there is only one argument, and this argument has the method ~supplier then each item returned by the argument's supplier is an item.
</span><span style="font-weight:bold;color:blue;">*/
</span>ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">a(2,3)~of(.object~methods~allIndexes~sort)=</span>
an Array (shape [2,3], 6 items)
[ 1, 1] : ''
[ 1, 2] : ' '
[ 1, 3] : '&lt;&gt;'
[ 2, 1] : '='
[ 2, 2] : '=='
[ 2, 3] : '&gt;&lt;'

<span style="font-weight:bold;color:blue;">/*
</span><span style="font-weight:bold;color:blue;">If there is only one argument, and this argument is a doer, then the doer is called for each cell to initialize.
</span><span style="font-weight:bold;color:blue;">The value returned by the doer is the item for the current cell.
</span><span style="font-weight:bold;color:blue;">If no value returned then the cell remains unassigned.
</span><span style="font-weight:bold;color:blue;">*/
</span>ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">a(2,3)~of{ if item//4 &lt;&gt; 0 then 10*item }=</span>
an Array (shape [2,3], 5 items)
[ 1, 1] :  10
[ 1, 2] :  20
[ 1, 3] :  30
[ 2, 2] :  50
[ 2, 3] :  60

<span style="font-weight:bold;color:blue;">/*
</span><span style="font-weight:bold;color:blue;">If there is more than one argument then each argument is an item as-is.
</span><span style="font-weight:bold;color:blue;">If some arguments are omitted, then the corresponding item in the initialized array remains non-assigned.
</span><span style="font-weight:bold;color:blue;">*/
</span>ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">a(2,3)~of(1,,3,,5,)=</span>
an Array (shape [2,3], 3 items)
[ 1, 1] :  1
[ 1, 3] :  3
[ 2, 2] :  5

<span style="font-weight:bold;color:blue;">/*
</span><span style="font-weight:bold;color:blue;">reshape
</span><span style="font-weight:bold;color:blue;">
</span><span style="font-weight:bold;color:blue;">APL R←X⍴Y (Rho)
</span><span style="font-weight:bold;color:blue;">args : new dimension(s)
</span><span style="font-weight:bold;color:blue;">*/
</span>ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">a(5)~of{ 2*item }=</span>
[ 2, 4, 6, 8, 10]
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">a(5)~of{ 2*item }~reshape(3,3)=</span>
an Array (shape [3,3], 9 items)
[ 1, 1] :  2
[ 1, 2] :  4
[ 1, 3] :  6
[ 2, 1] :  8
[ 2, 2] :  10
[ 2, 3] :  2
[ 3, 1] :  4
[ 3, 2] :  6
[ 3, 3] :  8

<span style="font-weight:bold;color:blue;">/*
</span><span style="font-weight:bold;color:blue;">each
</span><span style="font-weight:bold;color:blue;">
</span><span style="font-weight:bold;color:blue;">APL R←,Y (Ravel)
</span><span style="font-weight:bold;color:blue;">Y may be any array. R is a vector of the elements of Y taken in row-major order.
</span><span style="font-weight:bold;color:blue;">inverse of reshape, which turns any data into a vector whose length is the product
</span><span style="font-weight:bold;color:blue;">of the shape vector (the dimensions) of the operand array
</span><span style="font-weight:bold;color:blue;">*/
</span>ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">a(1,2,3)~of{index}=</span>
an Array (shape [1,2,3], 6 items)
[ 1, 1, 1] : [ 1, 1, 1]
[ 1, 1, 2] : [ 1, 1, 2]
[ 1, 1, 3] : [ 1, 1, 3]
[ 1, 2, 1] : [ 1, 2, 1]
[ 1, 2, 2] : [ 1, 2, 2]
[ 1, 2, 3] : [ 1, 2, 3]
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">a(1,2,3)~of{index}~each=</span>
[[ 1, 1, 1],[ 1, 1, 2],[ 1, 1, 3],[ 1, 2, 1],[ 1, 2, 2],[ 1, 2, 3]]

<span style="font-weight:bold;color:blue;">/*
</span><span style="font-weight:bold;color:blue;">depth
</span><span style="font-weight:bold;color:blue;">
</span><span style="font-weight:bold;color:blue;">APL R←≡Y (Equal Underbar)
</span><span style="font-weight:bold;color:blue;">Depth (≡) indicates the degree of nesting within an array.
</span><span style="font-weight:bold;color:blue;">It returns a non-negative integer which defines the maximum number of levels
</span><span style="font-weight:bold;color:blue;">of structure to be penetrated in order to get to a simple scalar where simple means non-nested.
</span><span style="font-weight:bold;color:blue;">The depth of an array is 1 greater than that of its most deeply nested item.
</span><span style="font-weight:bold;color:blue;">
</span><span style="font-weight:bold;color:blue;">ooRexx:
</span><span style="font-weight:bold;color:blue;">Returns &quot;infinity&quot; when the array is self-referencing.
</span><span style="font-weight:bold;color:blue;">*/
</span>ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">1~depth=</span>
 0
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">v(1)~depth=</span>
 1
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">v(v(1))~depth=</span>
 2
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">v=v(1); v~append(v); v~depth=;</span>
(The positive infinity)

<span style="font-weight:bold;color:blue;">/*
</span><span style="font-weight:bold;color:blue;">enclose
</span><span style="font-weight:bold;color:blue;">
</span><span style="font-weight:bold;color:blue;">APL R←⊂Y (Left Shoe)
</span><span style="font-weight:bold;color:blue;">If Y is a simple scalar, R is the simple scalar unchanged.
</span><span style="font-weight:bold;color:blue;">Otherwise, R has a depth whose magnitude is one greater than the magnitude of the depth of Y.
</span><span style="font-weight:bold;color:blue;">*/
</span>ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">e=1~enclose</span>
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">e=</span>
 1
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">e~depth=</span>
 0
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">e=v(1)~enclose~enclose</span>
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">e=</span>
&lt;&lt;[ 1]&gt;&gt;
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">e~depth=</span>
 3

<span style="font-weight:bold;color:blue;">/*
</span><span style="font-weight:bold;color:blue;">disclose
</span><span style="font-weight:bold;color:blue;">
</span><span style="font-weight:bold;color:blue;">APL R←⊃Y (Right Shoe)
</span><span style="font-weight:bold;color:blue;">Disclose is the inverse of Enclose.
</span><span style="font-weight:bold;color:blue;">*/
</span>ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">e=v(1)~enclose~enclose</span>
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">e=</span>
&lt;&lt;[ 1]&gt;&gt;
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">e=e~disclose</span>
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">e=</span>
&lt;[ 1]&gt;
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">e~depth=</span>
 2
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">e=e~disclose</span>
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">e=</span>
[ 1]
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">e~depth=</span>
 1

<span style="font-weight:bold;color:blue;">/*
</span><span style="font-weight:bold;color:blue;">Indexing a vector
</span><span style="font-weight:bold;color:blue;">It is possible to extract several items in a single operation, and in any order.
</span><span style="font-weight:bold;color:blue;">An item can be selected more than once.
</span><span style="font-weight:bold;color:blue;">*/
</span>ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">vector = (10,20,30,40,50)</span>
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">vector~indexer(3)=</span>
[ 30]
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">vector~indexer(3,3)=</span>
[ 30, 30]
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">'LE CHAT'~eachc~indexer(7,5,2,3,4,6,7)~tostring(&quot;c&quot;)=</span>
'THE CAT'

<span style="font-weight:bold;color:blue;">/*
</span><span style="font-weight:bold;color:blue;">The index may be an array of any shape: scalar, vector, matrix, or an array of higher rank.
</span><span style="font-weight:bold;color:blue;">When a vector is indexed by an array, the result has exactly the same shape as the index
</span><span style="font-weight:bold;color:blue;">array, as if each item of the index had been replaced by the item it designates:
</span><span style="font-weight:bold;color:blue;">*/
</span>ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">index = a(3,5)~of(5,5,4,4,3,3,2,2,1,1)</span>
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">index=</span>
an Array (shape [3,5], 15 items)
[ 1, 1] :  5
[ 1, 2] :  5
[ 1, 3] :  4
[ 1, 4] :  4
[ 1, 5] :  3
[ 2, 1] :  3
[ 2, 2] :  2
[ 2, 3] :  2
[ 2, 4] :  1
[ 2, 5] :  1
[ 3, 1] :  5
[ 3, 2] :  5
[ 3, 3] :  4
[ 3, 4] :  4
[ 3, 5] :  3
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">vector = (10,20,30,40,50)</span>
ooRexx[bash]&gt; <span style="font-weight:bold;color:purple;">vector~indexer(index)=</span>
an Array (shape [3,5], 15 items)
[ 1, 1] :  50
[ 1, 2] :  50
[ 1, 3] :  40
[ 1, 4] :  40
[ 1, 5] :  30
[ 2, 1] :  30
[ 2, 2] :  20
[ 2, 3] :  20
[ 2, 4] :  10
[ 2, 5] :  10
[ 3, 1] :  50
[ 3, 2] :  50
[ 3, 3] :  40
[ 3, 4] :  40
[ 3, 5] :  30

<span style="font-weight:bold;color:blue;">/*
</span><span style="font-weight:bold;color:blue;">End of demonstration.
</span><span style="font-weight:bold;color:blue;">*/
</span></pre>
</body>
</html>
