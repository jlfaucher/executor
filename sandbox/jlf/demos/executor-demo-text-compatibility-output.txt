loadPackage OK for extension/stringChunk.cls
loadPackage OK for utilities/indentedStream.cls
loadPackage OK for extension/extensions.cls
loadLibrary OK for rxunixsys
loadPackage OK for ncurses.cls
loadPackage OK for csvStream.cls
loadLibrary OK for hostemu
loadPackage OK for json.cls
loadPackage OK for mime.cls
loadPackage OK for rxftp.cls
loadLibrary OK for rxmath
loadPackage OK for rxregexp.cls
loadPackage OK for regex/regex.cls
loadPackage OK for smtp.cls
loadPackage OK for socket.cls
loadPackage OK for streamsocket.cls
loadPackage OK for pipeline/pipe.cls
loadPackage OK for rgf_util2/rgf_util2.rex
loadPackage OK for BSF.CLS
loadPackage OK for oorexxshell_queries.cls
loadPackage OK for pipeline/pipe_extension.cls
loadPackage OK for rgf_util2/rgf_util2_wrappers.rex

REXX-ooRexx_4.3.0(MT)_64-bit 6.04 21 Sep 2023
Input queue name: S37e7Q600001cc89c0

ooRexx[sh]> call loadUnicodeCharacterNames
Load the Unicode character names 15.0.0 
.............................................
Total loaded character names: 149186
Total character name aliases: 473
Unicode character intervals not expanded, execute: call expandUnicodeCharacterIntervals


--------------------------------------------
-- Text encoding - Compatibility with String
--------------------------------------------

/*
Compatibility with the class String.
This is a work in progress, many methods not yet supported,
Unicode implementation still missing for many methods.
*/

/*
This string is used in several places:
"noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"
Depending on your editor/browser, you may see 5 emojis, or 3 emojis.
With Unicode 13, the display is 3 emojis (woman + family + father christmas).
ðŸ‘©	U+1F469	WOMAN
â€	U+200D	ZERO WIDTH JOINER
ðŸ‘¨	U+1F468	MAN
â€	U+200D	ZERO WIDTH JOINER
ðŸ‘©	U+1F469	WOMAN
â€	U+200D	ZERO WIDTH JOINER
ðŸ‘§	U+1F467	GIRL
ðŸŽ…	U+1F385	FATHER CHRISTMAS

Notice that ðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ constitute only 1 grapheme thanks to the ZERO WIDTH JOINER.
*/


ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~description=
'UTF-8 not-ASCII (6 characters, 12 codepoints, 34 bytes, 0 error)'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~c2u=
'U+006E U+006F U+00EB U+006C U+1F469 U+200D U+1F468 U+200D U+1F469 U+200D U+1F467 U+1F385'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~c2x=
'6E 6F C3AB 6C F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7 F09F8E85'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~c2g=
'6E 6F C3AB 6C F09F91A9E2808DF09F91A8E2808DF09F91A9E2808DF09F91A7 F09F8E85'


/*
Two RexxText values are considered equal if their extended grapheme clusters
are canonically equivalent.This is used by the Swift language.
Q&A: https://lists.isocpp.org/sg16/2018/08/0121.php

TODO: confirm that it's NFC, and only that.
The definition of canonical equivalence by the Unicode standard seems not
limited to NFC. https://unicode.org/notes/tn5/
*/

/*
The strict comparison operators use the NFC normalization.
After normalization, they delegate to the String's strict comparison operators.

The non-strict comparison operators use the NFKD normalization plus
    stripIgnorable:.true
    lump:.true
After normalization + transformations, they delegate to the String's non-strict
comparison operators. Thanks to the lump transformation, all the Unicode spaces
are supported.
*/

ooRexx[sh]> textNFC = "NoÃ«l"~text~NFC
ooRexx[sh]> textNFC~UnicodeCharacters==
an Array (shape [4], 4 items)
 1 : ( "N"   U+004E Lu 1 "LATIN CAPITAL LETTER N" )
 2 : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
 3 : ( "Ã«"   U+00EB Ll 1 "LATIN SMALL LETTER E WITH DIAERESIS" )
 4 : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
ooRexx[sh]> textNFD="NoÃ«l"~text~NFD
ooRexx[sh]> textNFD~UnicodeCharacters==
an Array (shape [5], 5 items)
 1 : ( "N"   U+004E Lu 1 "LATIN CAPITAL LETTER N" )
 2 : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
 3 : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )
 4 : ( "Ìˆ"    U+0308 Mn 0 "COMBINING DIAERESIS" )
 5 : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
ooRexx[sh]> (textNFC == textNFD)=                                               -- 1
 1
ooRexx[sh]> (textNFC = textNFD)=                                                -- 1
 1
ooRexx[sh]> (" "textNFC == textNFD" ")=                                         -- 0 because strict
 0
ooRexx[sh]> (" "textNFC = textNFD" ")=                                          -- 1
 1
ooRexx[sh]> (" "textNFC = (textNFD"\u{NBSP}")~unescape)=                        -- 1
 1
ooRexx[sh]> (" "textNFC = (textNFD"\u{ZWSP}")~unescape)=                        -- 1
 1
ooRexx[sh]> ("-"textNFC = ("\u{OBLIQUE HYPHEN}"textNFD"\u{ZWSP}")~unescape)=    -- 1
 1


-- []
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text[3]=; result~description=
T'Ã«'
'UTF-8 not-ASCII (1 character, 1 codepoint, 2 bytes, 0 error)'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text[3,3]=; result~description=
T'Ã«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§'
'UTF-8 not-ASCII (3 characters, 9 codepoints, 28 bytes, 0 error)'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text[3,6]=; result~description=
T'Ã«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
'UTF-8 not-ASCII (4 characters, 10 codepoints, 32 bytes, 0 error)'


-- ?
ooRexx[sh]> "0"~text~?("true"~text, "false"~text)=
T'false'
ooRexx[sh]> "1"~text~?("true"~text, "false"~text)=
T'true'
ooRexx[sh]> "not a boolean value"~text~?("true"~text, "false"~text)=
Logical value must be exactly "0" or "1"; found "not a boolean value".
Error code= 34.901
ooRexx[sh]> "not a boolean value ðŸ¤”"~text~?("true"~text, "false"~text)=
UTF-8 not-ASCII 'not a b...' is not compatible with a Rexx logical value.
Error code= 23.900
ooRexx[sh]> "0"~text~?("true ðŸ¤”"~text, "false ðŸ¤”"~text)=
T'false ðŸ¤”'
ooRexx[sh]> "1"~text~?("true ðŸ¤”"~text, "false ðŸ¤”"~text)=
T'true ðŸ¤”'


-- append
ooRexx[sh]> "hello"~text~append(" ")~append("john"~text)=
T'hello john'
ooRexx[sh]> "\uD83D"~text("wtf8")~append("\uDE3F")~unescape=    -- High surrogate followed by low surrogate is valid WTF-8
T'ðŸ˜¿'
ooRexx[sh]> "\uD83D"~text("utf8")~append("\uDE3F")~unescape=    -- High surrogate followed by low surrogate is INVALID UTF-8
T'ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½'


-- c2d
ooRexx[sh]> "e"~text~c2d=
 101
ooRexx[sh]> "Ã©"~text~c2d=
 50089


-- c2x
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~c2x=
'6E 6F C3AB 6C F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7 F09F8E85'


/*
A caseless method is transforming its arguments using CaseFold.
The default normalization is NFC, it's possible to change it with the argument
normalization
    .unicode~NFC    (default)
    .unicode~NFD
    .unicode~NFKC
    .unicode~NFKD
There is no value NFKC_CF because it can be done using the caseless methods by
passing NFKC + stripIgnorable.
*/


-- caselessCompare
-- casefold 2 characters: "ÃŸ" becomes "ss"
ooRexx[sh]> "BundesstraÃŸe im Freiland"~text~caselessCompare("BundesstraÃŸe")=        -- 14
 14
ooRexx[sh]> "BundesstraÃŸe im Freiland"~text~caselessCompare("BundesstraÃŸe", "_")=   -- 13
 13
ooRexx[sh]> "BundesstraÃŸe im Freiland"~text~caselessCompare("bundesstrasse")=       -- 14
 14
ooRexx[sh]> "Bundesstrasse im Freiland"~text~caselessCompare("bundesstraÃŸe")=       -- 15
 15
ooRexx[sh]> "straÃŸssÃŸÃŸssse"~text~compare("stra", "ÃŸ")=                              --  6
 6
ooRexx[sh]> "straÃŸssÃŸÃŸssse"~text~caselessCompare("stra", "ÃŸ")=                      -- 13 (questionable? the last 's' match half of the pad 'ss')
 13


-- caselessCompareTo
ooRexx[sh]> "pere noel"~text~caselessCompareTo("PÃ¨re NoÃ«l")=                    -- -1 (lesser)
-1
ooRexx[sh]> "pere noel"~text~caselessCompareTo("PÃ¨re NoÃ«l", stripMark:.true)=   --  0 (equal because the accents are ignored)
 0


-- caselessEndsWith
ooRexx[sh]> "hello"~text~caselessEndsWith("")=                  -- false
 0
ooRexx[sh]> "hello"~text~caselessEndsWith("O")=                 -- true
 1
ooRexx[sh]> "hello"~text~caselessEndsWith("Ã”")=                 -- false
 0
ooRexx[sh]> "hello"~text~caselessEndsWith("Ã”", stripMark:)=     -- true
 1
"noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~caselessEndsWith("ðŸŽ…")=                -- true
 1
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~caselessEndsWith("ðŸ‘§ðŸŽ…")=              -- false (not aligned with a grapheme)
 0
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~caselessEndsWith("â€ðŸ‘§ðŸŽ…")=             -- false (not aligned with a grapheme)
 0
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~caselessEndsWith("ðŸ‘©â€ðŸ‘§ðŸŽ…")=           -- false (not aligned with a grapheme)
 0
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~caselessEndsWith("Ã«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…")=   -- true
 1
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~caselessEndsWith("Ã‹LðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…")=   -- true
 1


-- caselessEquals
ooRexx[sh]> "Å’UF"~text~caselessEquals("Å“uf")=           -- 1
 1
ooRexx[sh]> "Å“uf"~text~caselessEquals("Å’UF")=           -- 1
 1
ooRexx[sh]> "StraÃŸe"~text~caselessEquals("strasse")=    -- 1
 1
ooRexx[sh]> "strasse"~text~caselessEquals("StraÃŸe")=    -- 1
 1

-- caselessEquals (cont.) strict versus non-strict
ooRexx[sh]> string1 = "LE\u{IDEOGRAPHIC SPACE}PÃˆ\u{ZERO-WIDTH-SPACE}RE\u{HYPHEN}NOÃ‹L"~text~unescape
ooRexx[sh]> string2 = "Le\u{OGHAM SPACE MARK}PÃ¨re\u{EN DASH}No\u{ZERO-WIDTH-SPACE}Ã«l"~text~unescape
ooRexx[sh]> string1=                                                -- T'LEã€€PÃˆâ€‹REâ€NOÃ‹L
T'LEã€€PÃˆâ€‹REâ€NOÃ‹L'
ooRexx[sh]> string2=                                                -- T'Leáš€PÃ¨reâ€“Noâ€‹Ã«l'
T'Leáš€PÃ¨reâ€“Noâ€‹Ã«l'
ooRexx[sh]> string1~c2x=                                            -- '4C 45 E38080 50 C388 E2808B 52 45 E28090 4E 4F C38B 4C'
'4C 45 E38080 50 C388 E2808B 52 45 E28090 4E 4F C38B 4C'
ooRexx[sh]> string2~c2x=                                            -- '4C 65 E19A80 50 C3A8 72 65 E28093 4E 6F E2808B C3AB 6C'
'4C 65 E19A80 50 C3A8 72 65 E28093 4E 6F E2808B C3AB 6C'
ooRexx[sh]> string1~caselessEquals(string2)=                        -- false (strict mode by default)
 0

-- The non-strict mode applies these transformations:
ooRexx[sh]> string1~nfkd(casefold:, lump:, stripIgnorable:)~c2x=    -- '6C 65 20 70 65 CC80 72 65 2D 6E 6F 65 CC88 6C'
'6C 65 20 70 65 CC80 72 65 2D 6E 6F 65 CC88 6C'
ooRexx[sh]> string2~nfkd(casefold:, lump:, stripIgnorable:)~c2x=    -- '6C 65 20 70 65 CC80 72 65 2D 6E 6F 65 CC88 6C'
'6C 65 20 70 65 CC80 72 65 2D 6E 6F 65 CC88 6C'
ooRexx[sh]> string1~caselessEquals(string2, strict:.false)=         -- true (non-strict mode)
 1


-- caselessMatch
-- "BundesschnellstraÃŸe"                                    -- at 14: "s", at 18:"ÃŸ"
--  1234567890123456789
ooRexx[sh]> "BundesstraÃŸe im Freiland"~text~caselessMatch(14, "im")=    -- .true
 1


-- caselessMatchChar
-- "BundesschnellstraÃŸe"                                    -- at 14: "s", at 18:"ÃŸ"
--  1234567890123456789
ooRexx[sh]> "BundesschnellstraÃŸe"~text~caselessMatchChar(18, "s")=      -- 1    "ÃŸ" becomes "ss" which is 2 characters. The first character at 18 matches "s"
 1
ooRexx[sh]> "BundesschnellstraÃŸe"~text~caselessMatchChar(19, "s")=      -- 0    "ÃŸ" becomes "ss" which is 2 characters. The character at 19 is "e", not the second "s"
 0
ooRexx[sh]> "BundesschnellstraÃŸe"~text~caselessMatchChar(19, "e")=      -- 1    "ÃŸ" becomes "ss" which is 2 characters. The character at 19 is "e", not the second "s"
 1

-- caselessMatchChar (cont.)
-- The ligature disappears when casefolded
ooRexx[sh]> "baï¬„e"~text~casefold=                                        -- T'baffle'
T'baffle'
ooRexx[sh]> "BAFFLE"~text~caselessMatchChar(3, "ï¬„")=                     -- 1      "ï¬„" becomes "ffl" (3 characters), there is a match on "f" at 3
 1
ooRexx[sh]> "BAFFLE"~text~caselessMatchChar(5, "ï¬„")=                     -- 1      "ï¬„" becomes "ffl" (3 characters), there is a match on "l" at 5
 1
ooRexx[sh]> "BAFFLE"~text~caselessMatchChar(5, "L")=                      -- 1      there is a match on "l" at 5
 1

-- caselessMatchChar (cont.)
-- Some ligatures are not decomposed by NFKC.
ooRexx[sh]> "Å’UF"~text~caselessEquals("oeuf")=                                  -- 0
 0
ooRexx[sh]> "Å’UF"~text~caselessEquals("oeuf", normalization:.Unicode~NFKC)=     -- 0
 0


-- caselessPos
ooRexx[sh]> "PÃ¨re NoÃ«l PÃ¨re NoÃ«l"~text~caselessPos("OÃ‹")=                   -- 7
 7
ooRexx[sh]> "PÃ¨re NoÃ«l PÃ¨re NoÃ«l"~text~caselessPos("OÃ‹", 8)=                -- 17
 17
ooRexx[sh]> "PÃ¨re NoÃ«l PÃ¨re NoÃ«l"~text~caselessPos("OÃ‹", 8, 10)=            -- 0
 0
ooRexx[sh]> "PÃ¨re NoÃ«l PÃ¨re NoÃ«l"~text~caselessPos("OE")=                   -- 0
 0
ooRexx[sh]> "PÃ¨re NoÃ«l PÃ¨re NoÃ«l"~text~caselessPos("OE", stripMark:)=       -- 7
 7
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~caselessPos("ðŸŽ…")=                     -- 6
 6
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~caselessPos("ðŸ‘§ðŸŽ…")=                   -- 0
 0

-- caselessPos in not-aligned mode
/*
aligned=.false is intended for analysis of matchings and [non-]regression tests.
Otherwise, I don't see any use.

If aligned=.false then return a couple (array) of numbers +/-posC.posB where
posB is the position of the matched byte in the transformed haystack, and posC
is the corresponding grapheme position in the untransformed haystack.
A number is negative if the byte position is not aligned with the corresponding
character position.
The first number is the start of the matching.
The second number is the end of the matching + 1.
*/
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~caselessPos("ðŸ‘§ðŸŽ…", aligned:.false)=   -- [-5.27,+7.35]
[-5.27,+7.35]
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~caselessPos("ðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…", aligned:.false)=   -- [+5.6,+7.35]
[+5.6,+7.35]


-- center
ooRexx[sh]> "noelFC"~text~center(10)=; result~description=              -- forward to String
T'  noelFC  '
'UTF-8 ASCII (10 characters, 10 codepoints, 10 bytes, 0 error)'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~center(10)=; result~description=
T'  noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…  '
'UTF-8 not-ASCII (10 characters, 16 codepoints, 38 bytes, 0 error)'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~center(9)=; result~description=
T' noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…  '
'UTF-8 not-ASCII (9 characters, 15 codepoints, 37 bytes, 0 error)'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~center(8)=; result~description=
T' noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ… '
'UTF-8 not-ASCII (8 characters, 14 codepoints, 36 bytes, 0 error)'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~center(7)=; result~description=
T'noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ… '
'UTF-8 not-ASCII (7 characters, 13 codepoints, 35 bytes, 0 error)'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~center(6)=; result~description=
T'noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
'UTF-8 not-ASCII (6 characters, 12 codepoints, 34 bytes, 0 error)'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~center(5)=; result~description=
T'noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§'
'UTF-8 not-ASCII (5 characters, 11 codepoints, 30 bytes, 0 error)'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~center(4)=; result~description=
T'oÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§'
'UTF-8 not-ASCII (4 characters, 10 codepoints, 29 bytes, 0 error)'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~center(3)=; result~description=
T'oÃ«l'
'UTF-8 not-ASCII (3 characters, 3 codepoints, 4 bytes, 0 error)'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~center(2)=; result~description=
T'Ã«l'
'UTF-8 not-ASCII (2 characters, 2 codepoints, 3 bytes, 0 error)'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~center(1)=; result~description=
T'Ã«'
'UTF-8 not-ASCII (1 character, 1 codepoint, 2 bytes, 0 error)'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~center(0)=; result~description=
T''
'UTF-8 ASCII (0 character, 0 codepoint, 0 byte, 0 error)'

-- center with pad
ooRexx[sh]> "="~description=                                            -- 'UTF-8 ASCII (1 byte)'
'UTF-8 ASCII by default (1 byte)'
ooRexx[sh]> "="~c2x=                                                    -- '3D'
'3D'
ooRexx[sh]> "noelFC"~text~center(10, "=")=; result~description=         -- forward to String
T'==noelFC=='
'UTF-8 ASCII (10 characters, 10 codepoints, 10 bytes, 0 error)'
ooRexx[sh]> "â•"~description=                                            -- 'UTF-8 not-ASCII (3 bytes)'
'UTF-8 not-ASCII by default (3 bytes)'
ooRexx[sh]> "â•"~text~description=                                       -- 'UTF-8 not-ASCII (1 character, 1 codepoint, 3 bytes, 0 error)'
'UTF-8 not-ASCII (1 character, 1 codepoint, 3 bytes, 0 error)'
ooRexx[sh]> "â•"~c2x=                                                    -- 'E29590'
'E29590'
ooRexx[sh]> "noelFC"~text~center(10, "â•")=; result~description=         -- don't forward to String because the pad is more than 1 byte
T'â•â•noelFCâ•â•'
'UTF-8 not-ASCII (10 characters, 10 codepoints, 18 bytes, 0 error)'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~center(10, "â•")=; result~description=
T'â•â•noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…â•â•'
'UTF-8 not-ASCII (10 characters, 16 codepoints, 46 bytes, 0 error)'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~center(9, "â•")=; result~description=
T'â•noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…â•â•'
'UTF-8 not-ASCII (9 characters, 15 codepoints, 43 bytes, 0 error)'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~center(8, "â•")=; result~description=
T'â•noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…â•'
'UTF-8 not-ASCII (8 characters, 14 codepoints, 40 bytes, 0 error)'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~center(7, "â•")=; result~description=
T'noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…â•'
'UTF-8 not-ASCII (7 characters, 13 codepoints, 37 bytes, 0 error)'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~center(6, "â•")=; result~description=
T'noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
'UTF-8 not-ASCII (6 characters, 12 codepoints, 34 bytes, 0 error)'


-- compare
ooRexx[sh]> "BundesstraÃŸe im Freiland"~text~compare("BundesstraÃŸe")=        -- 14
 14
ooRexx[sh]> "BundesstraÃŸe im Freiland"~text~compare("BundesstraÃŸe", "_")=   -- 13
 13
ooRexx[sh]> "BundesstraÃŸe im Freiland"~text~compare("Bundesstrasse")=       -- 11
 11
ooRexx[sh]> "Bundesstrasse im Freiland"~text~compare("BundesstraÃŸe")=       -- 11
 11
ooRexx[sh]> "straÃŸssÃŸÃŸssse"~text~compare("stra", "ÃŸ")=                      --  6
 6


-- compareTo
ooRexx[sh]> "pere noel"~text~compareTo("pÃ¨re noÃ«l")=                    -- -1 (lesser)
-1
ooRexx[sh]> "pere noel"~text~compareTo("pÃ¨re noÃ«l", stripMark:.true)=   --  0 (equal because the accents are ignored)
 0


-- contains
ooRexx[sh]> "noel"~text~contains("oe")=                 -- forward to String
 1
ooRexx[sh]> "noel"~text~contains("oe"~text)=            -- forward to String
 1
ooRexx[sh]> "noel"~text~contains("oÃ«")=
 0
ooRexx[sh]> "noel"~text~contains("oÃ«"~text)=
 0
ooRexx[sh]> "noÃ«l"~text~contains("oe")=
 0
ooRexx[sh]> "noÃ«l"~text~contains("oe"~text)=
 0
ooRexx[sh]> "noÃ«l"~text~contains("oÃ«")=
 1
ooRexx[sh]> "noÃ«l"~text~contains("oÃ«"~text)=
 1


-- copies
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~copies(4)=; result~description=
T'noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
'UTF-8 not-ASCII (24 characters, 48 codepoints, 136 bytes, 0 error)'


-- endsWith
ooRexx[sh]> "hello"~text~endsWith("")=                  -- false
 0
ooRexx[sh]> "hello"~text~endsWith("o")=                 -- true
 1
ooRexx[sh]> "hello"~text~endsWith("Ã´")=                 -- false
 0
ooRexx[sh]> "hello"~text~endsWith("Ã´", stripMark:)=     -- true
 1
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~endsWith("ðŸŽ…")=                -- true
 1
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~endsWith("ðŸ‘§ðŸŽ…")=              -- false (not aligned with a grapheme)
 0
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~endsWith("â€ðŸ‘§ðŸŽ…")=             -- false (not aligned with a grapheme)
 0
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~endsWith("ðŸ‘©â€ðŸ‘§ðŸŽ…")=           -- false (not aligned with a grapheme)
 0
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~endsWith("Ã«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…")=   -- true
 1
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~endsWith("Ã‹LðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…")=   -- false
 0


-- equals
ooRexx[sh]> "Å’UF"~text~lower~equals("Å“uf")=             -- true
 1
ooRexx[sh]> "Å’UF"~text~equals("Å“uf")=                   -- false (would be true if caseless)
 0
ooRexx[sh]> "Å“uf"~text~equals("Å’UF")=                   -- false (would be true if caseless)
 0
ooRexx[sh]> "StraÃŸe"~text~lower~equals("straÃŸe")=       -- true (U+00DF "LATIN SMALL LETTER SHARP S" remains unchanged since it's already a lower letter)
 1
ooRexx[sh]> "StraÃŸe"~text~casefold~equals("strasse")=   -- true (U+00DF "LATIN SMALL LETTER SHARP S" becomes "ss" when casefolded)
 1
ooRexx[sh]> "StraÃŸe"~text~equals("strasse")=            -- false (would be true if caseless)
 0
ooRexx[sh]> "strasse"~text~equals("StraÃŸe")=            -- false (would be true if caseless)
 0

-- equals (cont.) strict versus non-strict
ooRexx[sh]> string1 = "Le\u{IDEOGRAPHIC SPACE}PÃ¨\u{ZERO-WIDTH-SPACE}re\u{HYPHEN}NoÃ«l"~text~unescape
ooRexx[sh]> string2 = "Le\u{OGHAM SPACE MARK}PÃ¨re\u{EN DASH}No\u{ZERO-WIDTH-SPACE}Ã«l"~text~unescape
ooRexx[sh]> string1=                                    -- T'Leã€€PÃ¨â€‹reâ€NoÃ«l'
T'Leã€€PÃ¨â€‹reâ€NoÃ«l'
ooRexx[sh]> string2=                                    -- T'Leáš€PÃ¨reâ€“Noâ€‹Ã«l'
T'Leáš€PÃ¨reâ€“Noâ€‹Ã«l'
ooRexx[sh]> string1~c2x=                                -- '4C 65 E38080 50 C3A8 E2808B 72 65 E28090 4E 6F C3AB 6C'
'4C 65 E38080 50 C3A8 E2808B 72 65 E28090 4E 6F C3AB 6C'
ooRexx[sh]> string2~c2x=                                -- '4C 65 E19A80 50 C3A8 72 65 E28093 4E 6F E2808B C3AB 6C'
'4C 65 E19A80 50 C3A8 72 65 E28093 4E 6F E2808B C3AB 6C'
ooRexx[sh]> string1~equals(string2)=                    -- false (strict mode by default)
 0
ooRexx[sh]> -- The non-strict mode applies these transformations:
ooRexx[sh]> string1~nfkd(lump:, stripIgnorable:)~c2x=   -- '4C 65 20 50 65 CC80 72 65 2D 4E 6F 65 CC88 6C'
'4C 65 20 50 65 CC80 72 65 2D 4E 6F 65 CC88 6C'
ooRexx[sh]> string2~nfkd(lump:, stripIgnorable:)~c2x=   -- '4C 65 20 50 65 CC80 72 65 2D 4E 6F 65 CC88 6C'
'4C 65 20 50 65 CC80 72 65 2D 4E 6F 65 CC88 6C'
ooRexx[sh]> string1~equals(string2, strict:.false)=     -- true (non-strict mode)
 1


-- hashCode
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~hashCode~class=
(The String class)
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~hashCode~c2x=
'8FA5DCDA35AE1A58'


-- left
ooRexx[sh]> do i=0 to 9; "left("i") = " || "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~left(i)=; end
T'left(0) = '
T'left(1) = n'
T'left(2) = no'
T'left(3) = noÃ«'
T'left(4) = noÃ«l'
T'left(5) = noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§'
T'left(6) = noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
T'left(7) = noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ… '
T'left(8) = noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…  '
T'left(9) = noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…   '
ooRexx[sh]> do i=0 to 9; "left("i", â–·) = " || "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~left(i, "â–·")=; end
T'left(0, â–·) = '
T'left(1, â–·) = n'
T'left(2, â–·) = no'
T'left(3, â–·) = noÃ«'
T'left(4, â–·) = noÃ«l'
T'left(5, â–·) = noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§'
T'left(6, â–·) = noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
T'left(7, â–·) = noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…â–·'
T'left(8, â–·) = noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…â–·â–·'
T'left(9, â–·) = noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…â–·â–·â–·'


-- length
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~length=
 6


-- lower
ooRexx[sh]> "LE PÃˆRE NOÃ‹L EST FATIGUÃ‰..."~text~lower=       -- T'le pÃ¨re noÃ«l est fatiguÃ©...'
T'le pÃ¨re noÃ«l est fatiguÃ©...'


-- match
ooRexx[sh]> "noel"~text~match(2, "oe")=                 -- forward to String
 1
ooRexx[sh]> "noel"~text~match(2, "oe"~text)=            -- forward to String
 1
ooRexx[sh]> "noel"~text~match(2, "oÃ«")=
 0
ooRexx[sh]> "noel"~text~match(2, "oÃ«"~text)=
 0
ooRexx[sh]> "noÃ«l"~text~match(2, "oe")=
 0
ooRexx[sh]> "noÃ«l"~text~match(2, "oe"~text)=
 0
ooRexx[sh]> "noÃ«l"~text~match(2, "oÃ«")=
 1
ooRexx[sh]> "noÃ«l"~text~match(2, "oÃ«"~text)=
 1
ooRexx[sh]> "noÃ«l"~text~match(2, "oÃ«l")=
 1
ooRexx[sh]> "noÃ«l"~text~match(2, "oÃ«l"~text)=
 1
ooRexx[sh]> "noÃ«l"~text~match(3, "Ã«")=
 1
ooRexx[sh]> "noÃ«l"~text~match(3, "Ã«"~text)=
 1
ooRexx[sh]> "noÃ«l"~text~match(3, "Ã«l")=
 1
ooRexx[sh]> "noÃ«l"~text~match(3, "Ã«l"~text)=
 1
ooRexx[sh]> "noÃ«l"~text~match(4, "l")=
 1
ooRexx[sh]> "noÃ«l"~text~match(4, "l"~text)=
 1


-- matchChar
ooRexx[sh]> "noel"~text~matchChar(3, "Ee")=             -- forward to String
 1
ooRexx[sh]> "noel"~text~matchChar(3, "Ee"~text)=        -- forward to String
 1
ooRexx[sh]> "noel"~text~matchChar(3, "EÃ‹eÃ«")=
 1
ooRexx[sh]> "noel"~text~matchChar(3, "EÃ‹eÃ«"~text)=
 1
ooRexx[sh]> "noÃ«l"~text~matchChar(3, "EÃ‹eÃ«")=
 1
ooRexx[sh]> "noÃ«l"~text~matchChar(3, "EÃ‹eÃ«"~text)=
 1
ooRexx[sh]> "noÃ«l"~text~matchChar(3, "EÃ‹eÃ«")=
 1
ooRexx[sh]> "noÃ«l"~text~matchChar(3, "Ee", stripMark:)= -- remove the accents from the tested string
 1
ooRexx[sh]> "noÃ«l"~text~matchChar(4, "Ll"~text)=
 1
ooRexx[sh]> "noÃ«l"~text~matchChar(4, "Ll"~text)=
 1

-- matchChar (cont.)
-- "BundesschnellstraÃŸe"                                    -- at 14: "s", at 18:"ÃŸ"
--  1234567890123456789
ooRexx[sh]> "BundesschnellstraÃŸe"~text~matchChar(14, "s")=              -- 1
 1
ooRexx[sh]> "BundesschnellstraÃŸe"~text~matchChar(18, "s")=              -- 0
 0
ooRexx[sh]> "BundesschnellstraÃŸe"~text~matchChar(18, "ÃŸ")=              -- 1
 1

-- matchChar (cont.)
-- The ligature disappears in NFK[CD] but not in NF[CD]
ooRexx[sh]> "baï¬„e"~text~matchChar(3, "f")=                               -- 0     "ï¬„" is ONE character because NFC
 0
ooRexx[sh]> "baï¬„e"~text~matchChar(3, "ï¬„")=                              -- 1     "ï¬„" is ONE character because NFC
 1
ooRexx[sh]> "baï¬„e"~text~matchChar(3, "ï¬„", normalization:.Unicode~NFKD)= -- 1     "ï¬„" becomes "ffl" (3 characters). There is a match because the first character is "f"
 1
ooRexx[sh]> "baï¬„e"~text~matchChar(3, "f", normalization:.Unicode~NFKD)=  -- 1     "ï¬„" becomes "ffl" (3 characters). There is a match because the first character is "f"
 1
ooRexx[sh]> "baï¬„e"~text~matchChar(4, "f", normalization:.Unicode~NFKD)=  -- 0     "ï¬„" becomes "ffl" (3 characters). The character at 4 is "e", not the second "f"
 0
ooRexx[sh]> "baï¬„e"~text~matchChar(4, "e", normalization:.Unicode~NFKD)=  -- 1     "ï¬„" becomes "ffl" (3 characters). The character at 4 is "e", not the second "f"
 1


-- pos
ooRexx[sh]> "noel"~text~pos("oe")=                      -- forward to String
 2
ooRexx[sh]> "noel"~text~pos("oe"~text)=                 -- forward to String
 2
ooRexx[sh]> "noel"~text~pos("oÃ«")=
 0
ooRexx[sh]> "noel"~text~pos("oÃ«"~text)=
 0
ooRexx[sh]> "noÃ«l"~text~pos("oe")=
 0
ooRexx[sh]> "noÃ«l"~text~pos("oe"~text)=
 0
ooRexx[sh]> "noÃ«l"~text~pos("oÃ«")=
 2
ooRexx[sh]> "noÃ«l"~text~pos("oÃ«"~text)=
 2
ooRexx[sh]> "noÃ«l"~text~pos("l")=
 4
ooRexx[sh]> "noÃ«l"~text~pos("l"~text)=
 4
ooRexx[sh]> "PÃ¨re NoÃ«l PÃ¨re NoÃ«l"~text~pos("oÃ«")=                   -- 7
 7
ooRexx[sh]> "PÃ¨re NoÃ«l PÃ¨re NoÃ«l"~text~pos("oÃ«", 8)=                -- 17
 17
ooRexx[sh]> "PÃ¨re NoÃ«l PÃ¨re NoÃ«l"~text~pos("oÃ«", 8, 10)=            -- 0
 0
ooRexx[sh]> "PÃ¨re NoÃ«l PÃ¨re NoÃ«l"~text~pos("oe")=                   -- 0
 0
ooRexx[sh]> "PÃ¨re NoÃ«l PÃ¨re NoÃ«l"~text~pos("oe", stripMark:)=       -- 7
 7
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~pos("ðŸŽ…")=                     -- 6
 6
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~pos("ðŸ‘§ðŸŽ…")=                   -- 0
 0
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~pos("ðŸ‘§ðŸŽ…", aligned:.false)=   -- [-5.27,+7.35]
[-5.27,+7.35]
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~pos("ðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…", aligned:.false)=   -- [+5.6,+7.35]
[+5.6,+7.35]


-- reverse (correct)
ooRexx[sh]> "noÃ«l"~text~c2x=            -- '6E 6F C3AB 6C'
'6E 6F C3AB 6C'
ooRexx[sh]> "noÃ«l"~text~reverse~c2x=    -- '6C C3AB 6F 6E'
'6C C3AB 6F 6E'
ooRexx[sh]> "noÃ«l"~text~reverse=        -- T'lÃ«on'
T'lÃ«on'

-- reverse (wrong)
ooRexx[sh]> "noÃ«l"~c2x=             -- '6E6FC3AB6C'
'6E6FC3AB6C'
ooRexx[sh]> "noÃ«l"~reverse~c2x=     -- '6CABC36F6E'
'6CABC36F6E'
ooRexx[sh]> "noÃ«l"~reverse=         -- 'l??on'
'lï¿½ï¿½on'


-- right
ooRexx[sh]> do i=0 to 9; "right("i") = " || "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~right(i)=; end
T'right(0) = '
T'right(1) = ðŸŽ…'
T'right(2) = ðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
T'right(3) = lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
T'right(4) = Ã«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
T'right(5) = oÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
T'right(6) = noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
T'right(7) =  noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
T'right(8) =   noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
T'right(9) =    noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
ooRexx[sh]> do i=0 to 9; "right("i", â–·) = " || "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~right(i, "â–·")=; end
T'right(0, â–·) = '
T'right(1, â–·) = ðŸŽ…'
T'right(2, â–·) = ðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
T'right(3, â–·) = lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
T'right(4, â–·) = Ã«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
T'right(5, â–·) = oÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
T'right(6, â–·) = noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
T'right(7, â–·) = â–·noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
T'right(8, â–·) = â–·â–·noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'
T'right(9, â–·) = â–·â–·â–·noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…'


-- subchar
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~subchar(3)=; result~description=
T'Ã«'
'UTF-8 not-ASCII (1 character, 1 codepoint, 2 bytes, 0 error)'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~subchar(4)=; result~description=
T'l'
'UTF-8 ASCII (1 character, 1 codepoint, 1 byte, 0 error)'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~subchar(5)=; result~description=
T'ðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§'
'UTF-8 not-ASCII (1 character, 7 codepoints, 25 bytes, 0 error)'


-- substr
ooRexx[sh]> "noel"~text~substr(3, 3, "x")=; result~description=   -- forward to String
T'elx'
'UTF-8 ASCII (3 characters, 3 codepoints, 3 bytes, 0 error)'
ooRexx[sh]> "noel"~substr(3, 3, "â–·")=; result~description=        -- self is a String: error because the pad character is 3 bytes
Incorrect pad or character argument specified; found "â–·"
Error code= 93.922
ooRexx[sh]> "noel"~substr(3, 3, "â–·"~text)=; result~description=   -- self is a String: error because the pad character is not compatible with String
UTF-8 not-ASCII 'â–·' cannot be converted to a String instance.
Error code= 23.900
ooRexx[sh]> "noel"~text~substr(3, 3, "â–·")=; result~description=   -- no error because self is a RexxText and the pad character is one character when converted to the default encoding
T'elâ–·'
'UTF-8 not-ASCII (3 characters, 3 codepoints, 5 bytes, 0 error)'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~substr(3, 3, "â–·")=; result~description=
T'Ã«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§'
'UTF-8 not-ASCII (3 characters, 9 codepoints, 28 bytes, 0 error)'
ooRexx[sh]> "noÃ«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…"~text~substr(3, 6, "â–·")=; result~description=
T'Ã«lðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸŽ…â–·â–·'
'UTF-8 not-ASCII (6 characters, 12 codepoints, 38 bytes, 0 error)'


-- upper
ooRexx[sh]> "Le pÃ¨re NoÃ«l est fatiguÃ©..."~text~upper=       -- T'LE PÃˆRE NOÃ‹L EST FATIGUÃ‰...'
T'LE PÃˆRE NOÃ‹L EST FATIGUÃ‰...'




-- x2c
ooRexx[sh]> "F09F9180"~text~x2c=
T'ðŸ‘€'
ooRexx[sh]> "not an hexadecimal value"~text~x2c
Only 0-9, a-f, A-F, and whitespace characters are valid in a hexadecimal string; character found "n".
Error code= 93.933
ooRexx[sh]> "not an hexadecimal value ðŸ¤”"~text~x2c
UTF-8 not-ASCII 'not an ...' is not compatible with a Rexx hexadecimal value.
Error code= 23.900


---------------------------------------------------------
-- Text encoding - Functional
---------------------------------------------------------

/*
The only needed methods on RexxText are
    ~characters
    ~subwords   (still to implement)
    ~chunks     (still to implement)
*/

/*
Example inspired by https://elixir-lang.org/
Frequency of each character, ignoring the accents:
"Elixir" |> String.graphemes() |> Enum.frequencies()
%{"E" => 1, "i" => 2, "l" => 1, "r" => 1, "x" => 1}
*/

ooRexx[sh]> "Notre pÃ¨re NoÃ«l ðŸŽ…"~text~transform(stripMark:)~reduce(by: "characters", initial: .stem~new~~put(0)){accu[item~string] += 1}=
a Stem (9 items)
'ðŸŽ…' :  1
' '    :  3
'e'    :  4
'l'    :  1
'N'    :  2
'o'    :  2
'p'    :  1
'r'    :  2
't'    :  1


---------------------------------------------------------
-- Text encoding - Generator
---------------------------------------------------------

/*
The only needed methods on RexxText are
    ~characters
    ~subwords   (still to implement)
*/

ooRexx[sh]> g="NoÃ«l ðŸŽ…"~text~generateC
ooRexx[sh]> g~()=       -- T'N'
T'N'
ooRexx[sh]> g~()=       -- T'o'
T'o'
ooRexx[sh]> g~()=       -- T'Ã«'
T'Ã«'
ooRexx[sh]> g~()=       -- T'l'
T'l'
ooRexx[sh]> g~()=       -- T' '
T' '
ooRexx[sh]> g~()=       -- T'ðŸŽ…'
T'ðŸŽ…'
ooRexx[sh]> g~()=       -- [no result]
[no result]


---------------------------------------------------------
-- Text encoding - Compatibility with regular expressions
---------------------------------------------------------

/*
A way to test the compatibility of RexxText with String is to pass instances of
RexxText to the regular expression engine regex.cls, and see what happens...
*/

/*
Relax the constraint "self~isCompatibleWithByteString" when converting a RexxText
to a String. That allows to go further in the tests of regular expression.
*/
ooRexx[sh]> unckeckedConversionToString = .Unicode~unckeckedConversionToString -- backup
ooRexx[sh]> .Unicode~unckeckedConversionToString = .true

ooRexx[sh]> pB = .Pattern~compile("a.c")
ooRexx[sh]> pT = .Pattern~compile("a.c"~text)
ooRexx[sh]> pB~matches("abc")=                          -- 1
 1
ooRexx[sh]> pT~matches("abc"~text)=                     -- 1
 1
ooRexx[sh]> pB~matches("aÃ´c")=                          -- 0 (KO)
 0
ooRexx[sh]> pT~matches("aÃ´c"~text)=                     -- 1
 1
ooRexx[sh]> pB~matches("aðŸŽ…c")=                         -- 0 (KO)
 0
ooRexx[sh]> pT~matches("aðŸŽ…c"~text)=                    -- 1
 1

ooRexx[sh]> pB = .Pattern~compile("ðŸ¤¶...ðŸŽ…")
ooRexx[sh]> pT = .Pattern~compile("ðŸ¤¶...ðŸŽ…"~text)
ooRexx[sh]> pB~matches("ðŸ¤¶123ðŸŽ…")=                      -- 1
 1
ooRexx[sh]> pT~matches("ðŸ¤¶123ðŸŽ…"~text)=                 -- 1
 1
ooRexx[sh]> pB~matches("ðŸ¤¶ðŸ•2ðŸˆðŸŽ…")=                    -- 0 (KO)
 0
ooRexx[sh]> pT~matches("ðŸ¤¶ðŸ•2ðŸˆðŸŽ…"~text)=               -- 1
 1
ooRexx[sh]> pB~matches("ðŸ¤¶ðŸ•ðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸˆðŸŽ…")=          -- 0 (KO)
 0
ooRexx[sh]> pT~matches("ðŸ¤¶ðŸ•ðŸ‘©â€ðŸ‘¨â€ðŸ‘©â€ðŸ‘§ðŸˆðŸŽ…"~text)=     -- 1
 1

-- "ðŸ¤¶" or "ðŸŽ…"
ooRexx[sh]> pB = .Pattern~compile("ðŸ¤¶|ðŸŽ…")
ooRexx[sh]> pT = .Pattern~compile("ðŸ¤¶|ðŸŽ…"~text)
ooRexx[sh]> pB~startsWith("ðŸ¤¶ðŸŽ…c")=                             -- 1
 1
ooRexx[sh]> pT~startsWith("ðŸ¤¶ðŸŽ…c"~text)=                        -- 1
 1
ooRexx[sh]> pB~startsWith("ðŸŽ…ðŸ¤¶c")=                             -- 1
 1
ooRexx[sh]> pT~startsWith("ðŸŽ…ðŸ¤¶c"~text)=                        -- 1
 1
ooRexx[sh]> r = pB~find("xxxðŸ¤¶ðŸŽ…cxxx")
ooRexx[sh]> r~matched=; r~start=; r~end=; r~text=; r~length=
 1
 4
 8
'ðŸ¤¶'
 4
ooRexx[sh]> r = pT~find("xxxðŸ¤¶ðŸŽ…cxxx"~text)
ooRexx[sh]> r~matched=; r~start=; r~end=; r~text=; r~length=
 1
 4
 5
T'ðŸ¤¶'
 1
ooRexx[sh]> r = pB~find("xxxðŸŽ…ðŸ¤¶cxxx")
ooRexx[sh]> r~matched=; r~start=; r~end=; r~text=; r~length=
 1
 4
 8
'ðŸŽ…'
 4
ooRexx[sh]> r = pT~find("xxxðŸŽ…ðŸ¤¶cxxx"~text)
ooRexx[sh]> r~matched=; r~start=; r~end=; r~text=; r~length=
 1
 4
 5
T'ðŸŽ…'
 1

ooRexx[sh]> .Unicode~unckeckedConversionToString = unckeckedConversionToString -- restore


-----------------------------------------
-- Text encoding - Compatibility with BIF
-----------------------------------------

/*
[Intermediate solution]

Several solutions in RosettaCode are in error because the pad character used
with the function 'center' is a UTF-8 string made of several bytes.
The function center now supports utf-8 pad made of 1 multi-bytes character.
When the pad is not a 1 byte character then the interpreter converts the string
to a RexxText and sends it the message "center".
The returned value is the String associated to the RexxText.

The invariants of the method 'center' are true for the RexxText, but not true for
the String (which is normal).
*/

ooRexx[sh]> "â•"~description=                                -- 'UTF-8 not-ASCII (3 bytes)'
'UTF-8 not-ASCII by default (3 bytes)'
ooRexx[sh]> "â•"~text~description=                           -- 'UTF-8 not-ASCII (1 character, 1 codepoint, 3 bytes, 0 error)'
'UTF-8 not-ASCII (1 character, 1 codepoint, 3 bytes, 0 error)'
ooRexx[sh]> "â•"~c2x=                                        -- 'E29590'
'E29590'
ooRexx[sh]> center("hello", 20, "â•")=                       -- 'â•â•â•â•â•â•â•helloâ•â•â•â•â•â•â•â•'
'â•â•â•â•â•â•â•helloâ•â•â•â•â•â•â•â•'
ooRexx[sh]> center("hello", 20, "â•")~text~description=      -- 'UTF-8 not-ASCII (20 characters, 20 codepoints, 50 bytes, 0 error)'
'UTF-8 not-ASCII (20 characters, 20 codepoints, 50 bytes, 0 error)'

-- Idem for the function 'left'
ooRexx[sh]> left("hello", 20, "â•")=                         -- 'helloâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
'helloâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'
ooRexx[sh]> left("hello", 20, "â•")~text~description=        -- 'UTF-8 not-ASCII (20 characters, 20 codepoints, 50 bytes, 0 error)'
'UTF-8 not-ASCII (20 characters, 20 codepoints, 50 bytes, 0 error)'


/*
[General solution]

The new path I would like to explore is the support of graphemes by ALL the BIF...
I have already a tiny support for center() and left(), only triggered in case of
pad character made of several bytes.

The generalization would be to route the BIF either towards String or towards RexxText,
in function of the compatibility of the arguments with String:
BIF(str1, str2, ..., strN)
    --> forward to String (byte-oriented) if str's encoding is Byte or UTF-8 (with ASCII characters only)
    --> forward to RexxText otherwise
*/

-- UTF-8 encoding

ooRexx[sh]> "Noel"~isCompatibleWithByteString=              -- 1
 1
ooRexx[sh]> length("Noel")=                                 -- 4 because "Noel"~length = 4
 4
ooRexx[sh]> "NoÃ«l"~isCompatibleWithByteString=              -- 0
 0
ooRexx[sh]> length("NoÃ«l")=                                 -- TODO: 4 because "NoÃ«l"~text~length = 4
 5
ooRexx[sh]> "NoÃ«l"~length=                                  -- 5 because String remains byte-oriented, not impacted by the default encoding
 5

-- UTF-16BE encoding
ooRexx[sh]> s = "0041004200430044"x
ooRexx[sh]> s=                                              -- '[00]A[00]B[00]C[00]D'
'[00]A[00]B[00]C[00]D'
ooRexx[sh]> s~isCompatibleWithByteString=                   -- 1
 1
ooRexx[sh]> s~description=                                  -- 'UTF-8 ASCII (8 bytes)'
'UTF-8 ASCII by default (8 bytes)'
ooRexx[sh]> length(s)=                                      -- 8 because encoding UTF-8 ASCII is compatible with String
 8
ooRexx[sh]> s~encoding = "UTF16"
ooRexx[sh]> s~isCompatibleWithByteString=                   -- 0
 0
ooRexx[sh]> s~description=                                  -- 'UTF-16BE (8 bytes)'
'UTF-16BE (8 bytes)'
ooRexx[sh]> s~length=                                       -- 8 because String is always byte-oriented (ignores the encoding)
 8
ooRexx[sh]> length(s)=                                      -- TODO: 4 because forwards to Text (encoding UTF-16BE is not compatible with String)
 8
ooRexx[sh]> s~text~utf8=                                    -- ABCD
T'ABCD'

-- UTF-32 encoding
ooRexx[sh]> s = "0000004100000042"x
ooRexx[sh]> s=                                              -- '[000000]A[000000]B'
'[000000]A[000000]B'
ooRexx[sh]> s~isCompatibleWithByteString=                   -- 1
 1
ooRexx[sh]> s~description=                                  -- 'UTF-8 ASCII (8 bytes)'
'UTF-8 ASCII by default (8 bytes)'
ooRexx[sh]> length(s)=                                      -- 8 because encoding UTF-8 ASCII is compatible with String
 8
ooRexx[sh]> s~encoding = "UTF32"
ooRexx[sh]> s~isCompatibleWithByteString=                   -- 0
 0
ooRexx[sh]> s~description=                                  -- 'UTF-32BE (8 bytes)'
'UTF-32BE (8 bytes)'
ooRexx[sh]> s~length=                                       -- 8 because String is always byte-oriented (ignores the encoding)
 8
ooRexx[sh]> length(s)=                                      -- TODO: 2 because forwards to Text (encoding UTF-32 is not compatible with String)
 8
ooRexx[sh]> s~text~utf8=                                    -- AB
T'AB'


/*
End of demonstration.
*/
