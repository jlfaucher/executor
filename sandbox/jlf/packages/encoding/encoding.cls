::requires "encoding/stringIndexer.cls"

/*
Remember: don't requires the packages "xxx_encoding.cls" because that would create
a circular dependency. Each encoding requires "encoding.cls" to register itself.
*/

/******************************************************************************/
::class "Encoding" public

/*
big-endian, little-endian
    0x44332211
         0  1  2  3
    BE  44 33 22 11
    LE  11 22 33 44

    ~c2x is neutral regarding big-endian vs little-endian:
    "44332211"x~c2x -- 44332211
    "11223344"x~c2x -- 11223344

    ~c2d is always big-endian, whatever the endianness of the CPU:
    "00000001"x~c2d -- 1
    "10000000"x~c2d -- 268435456


The character at code point U+FEFF is defined as the byte order mark
Its byte-reversed counterpart, U+FFFE is a noncharacter (U+FFFE) in UTF-16 ,
or outside the code space (0xFFFE0000) for UTF-32

    UTF-8 BOM: 0xEF 0xBB 0xBF

    UTF-16 BOM: 0xFEFF
    BE: FE FF
    LE: FF FE

    UTF-32 BOM: 0x0000FEFF
    BE: 0x00 0x00 0xFE 0xFF
    LE: 0xFF 0xFE 0x00 0x00


http://www.herongyang.com/Unicode//UTF-32-UTF-32BE-UTF-32LE-Encoding.html
    - Output byte streams of UTF-32 encoding may have 3 valid formats:
      Big-Endian without BOM, Big-Endian with BOM, and Little-Endian with BOM.
    - UTF-32BE encoding is identical to the Big-Endian without BOM format of UTF-32 encoding.
    - UTF-32LE encoding is identical to the Little-Endian with BOM format of UTF-32 encoding without using BOM.

https://www.unicode.org/reports/tr17/
    UNICODE CHARACTER ENCODING MODEL

https://www.ietf.org/rfc/rfc2781.txt
    UTF-16, an encoding of ISO 10646
    This document contains the registration for three MIME charset parameter values:
    UTF-16BE (big-endian), UTF-16LE (little-endian), and UTF-16.

    UTF-16BE
        Text labelled "UTF-16BE" can always be interpreted as being big-endian.
        The detection of an initial BOM does not affect de-serialization of text labelled as UTF-16BE.
        Finding 0xFF followed by 0xFE is an error since there is no Unicode character 0xFFFE. (jlf: an error ? no: 0xFFFE is a noncharacter, Unicode says it's not an error)

    UTF-16LE
        Text labelled "UTF-16LE" can always be interpreted as being little-endian.
        The detection of an initial BOM does not affect de-serialization of text labelled as UTF-16LE.
        Finding 0xFE followed by 0xFF is an error since there is no Unicode character 0xFFFE, which would be the interpretation of those octets under little-endian order. (jlf: an error ? no: 0xFFFE is a noncharacter, Unicode says it's not an error)

    UTF-16
        If the first two octets of the text is 0xFE followed by 0xFF, then the text can be interpreted as being big-endian.
        If the first two octets of the text is 0xFF followed by 0xFE, then the text can be interpreted as being little-endian.
        If the first two octets of the text is not 0xFE followed by 0xFF, and is not 0xFF followed by 0xFE, then the text SHOULD be interpreted as being big-endian.

http://www.unicode.org/reports/tr19/tr19-9.html
    UTF-32
    The code units for UTF-32 correspond exactly to Unicode code points.
    3 encoding schemes: UTF-32 (possibly using BOM), UTF-32BE, and UTF-32LE.

    UTF-32BE
        (a) UTF-32BE is the Unicode Transformation Format that serializes a Unicode code point as a sequence of four bytes, in big-endian format.
            An initial sequence corresponding to U+FEFF is interpreted as a zero width no-break space.
        (b) An illegal UTF-32BE code unit sequence is any byte sequence that would correspond to a numeric value outside of the range 0 to 10FFFF.
        (c) An irregular UTF-32BE code unit sequence is an eight-byte sequence where the first four bytes correspond to a high surrogate, and the next four bytes correspond to a low surrogate.
            As a consequence of C12, these irregular UTF-32BE sequences shall not be generated by a conformant process.
        In UTF-32BE, <U+004D, U+0061, U+10000> is serialized as <00 00 00 4D 00 00 00 61 00 01 00 00>

    UTF-32LE
        (a) UTF-32LE is the Unicode Transformation Format that serializes a Unicode code point as a sequence of four bytes, in little-endian format.
            An initial sequence corresponding to U+FEFF is interpreted as a zero width no-break space.
        (b) An illegal UTF-32LE code unit sequence is any byte sequence that would correspond to a numeric value outside of the range 0 to 10FFFF.
        (c) An irregular UTF-32LE code unit sequence is an eight-byte sequence where the first four bytes correspond to a high surrogate, and the next four bytes correspond to a low surrogate.
            As a consequence of C12, these irregular UTF-32LE sequences shall not be generated by a conformant process.
        In UTF-32LE, <U+004D, U+0061, U+10000> is serialized as <4D 00 00 00 61 00 00 00 00 00 01 00>

    UTF-32
        (a) UTF-32 is the Unicode Transformation Format that serializes a Unicode code point as a sequence of four bytes, in either big-endian or little-endian format.
            An initial sequence corresponding to U+FEFF is interpreted as a byte order mark: it is used to distinguish between the two byte orders.
            The byte order mark is not considered part of the content of the text.
            A serialization of Unicode code points into UTF-32 may or may not begin with a byte order mark.
        (b) An illegal UTF-32 code unit sequence is any byte sequence that would correspond to a numeric value outside of the range 0 to 10FFFF.
        (c) An irregular UTF-32 code unit sequence is an eight-byte sequence where the first four bytes correspond to a high surrogate, and the next four bytes correspond to a low surrogate.
            As a consequence of C12, these irregular UTF-32 sequences shall not be generated by a conformant process.
        In UTF-32, <U+004D, U+0061, U+10000> is serialized as any of:
            <00 00 FE FF 00 00 00 4D 00 00 00 61 00 01 00 00>
            <FF FE 00 00 4D 00 00 00 61 00 00 00 00 00 01 00>
            <00 00 00 4D 00 00 00 61 00 01 00 00>


https://www.iana.org/assignments/character-sets/character-sets.xhtml
    Character Sets
    These are the official names for character sets that may be used in
     the Internet and may be referred to in Internet documentation.

*/

::attribute defaultEncoding class get
    expose defaultEncoding
    use strict arg -- none
    if \var("defaultEncoding") then defaultEncoding = .UTF8_Encoding
    return defaultEncoding


::attribute defaultEncoding class set
    expose defaultEncoding
    use strict arg encoding
    defaultEncoding = self~factory(encoding)


::attribute defaultInputEncoding class get
    expose defaultInputEncoding
    use strict arg -- none
    if \var("defaultInputEncoding") then defaultInputEncoding = self~defaultEncoding
    return defaultInputEncoding


::attribute defaultInputEncoding class set
    expose defaultInputEncoding
    use strict arg encoding
    defaultInputEncoding = self~factory(encoding)


::attribute defaultOutputEncoding class get
    expose defaultOutputEncoding
    use strict arg -- none
    if \var("defaultOutputEncoding") then defaultOutputEncoding = self~defaultEncoding
    return defaultOutputEncoding


::attribute defaultOutputEncoding class set
    expose defaultOutputEncoding
    use strict arg encoding
    defaultOutputEncoding = self~factory(encoding)


::method activate class
    expose encodings
    use strict arg -- none
    encodings = .directory~new

    -- windows-1250 (Central and Eastern Europe)
    -- encodings["CP1250"] = .CP1250_Encoding
    -- encodings["WINDOWS1250"] = .CP1250_Encoding

    -- windows-1251 (Bulgarian, Byelorussian, Macedonian, Russian, Serbian)
    -- encodings["CP1251"] = .CP1251_Encoding
    -- encodings["WINDOWS1251"] = .CP1251_Encoding

    -- windows-1253 (Greek)
    -- encodings["CP1253"] = .CP1253_Encoding
    -- encodings["WINDOWS1253"] = .CP1253_Encoding

    -- windows-1254 (Turkish)
    -- encodings["CP1254"] = .CP1254_Encoding
    -- encodings["WINDOWS1254"] = .CP1254_Encoding

    -- windows-1255 (Hebrew)
    -- encodings["CP1255"] = .CP1255_Encoding
    -- encodings["WINDOWS1255"] = .CP1255_Encoding

    -- windows-1256 (Arabic)
    -- encodings["CP1256"] = .CP1256_Encoding
    -- encodings["WINDOWS1256"] = .CP1256_Encoding

    -- windows-1257 (Baltic languages)
    -- encodings["CP1257"] = .CP1257_Encoding
    -- encodings["WINDOWS1257"] = .CP1257_Encoding

    -- windows-1258 (Vietnamese)
    -- encodings["CP1258"] = .CP1258_Encoding
    -- encodings["WINDOWS1258"] = .CP1258_Encoding

    -- ISO-8859-2 (Central and Eastern Europe)
    -- encodings["ISO88592"] = .ISO88592_Encoding
    -- encodings["L2"] = .ISO88592_Encoding
    -- encodings["LATIN2"] = .ISO88592_Encoding

    -- ISO-8859-3 (Esperanto, Maltese)
    -- encodings["ISO88593"] = .ISO88593_Encoding
    -- encodings["L3"] = .ISO88593_Encoding
    -- encodings["LATIN3"] = .ISO88593_Encoding

    -- ISO-8859-4 (Baltic languages)
    -- encodings["ISO88594"] = .ISO88594_Encoding
    -- encodings["L4"] = .ISO88594_Encoding
    -- encodings["LATIN4"] = .ISO88594_Encoding

    -- ISO-8859-5 (Bulgarian, Byelorussian, Macedonian, Russian, Serbian)
    -- encodings["ISO88595"] = .ISO88595_Encoding
    -- encodings["CYRILLIC"] = .ISO88595_Encoding

    -- ISO-8859-6 (Arabic)
    -- encodings["ISO88596"] = .ISO88596_Encoding
    -- encodings["ARABIC"] = .ISO88596_Encoding

    -- ISO-8859-7 (Greek)
    -- encodings["ISO88597"] = .ISO88597_Encoding
    -- encodings["GREEK"] = .ISO88597_Encoding
    -- encodings["GREEK8"] = .ISO88597_Encoding

    -- ISO-8859-8 (Hebrew)
    -- encodings["ISO88598"] = .ISO88598_Encoding
    -- encodings["HEBREW"] = .ISO88598_Encoding

    -- ISO-8859-9 (Turkish)
    -- encodings["ISO88599"] = .ISO88599_Encoding
    -- encodings["L5"] = .ISO88599_Encoding
    -- encodings["LATIN5"] = .ISO88599_Encoding

    -- ISO-8859-10 (Nordic languages)
    -- encodings["ISO885910"] = .ISO885910_Encoding
    -- encodings["L6"] = .ISO885910_Encoding
    -- encodings["LATIN6"] = .ISO885910_Encoding

    -- ISO-8859-11 (Thai languages)
    -- encodings["ISO885911"] = .ISO885911_Encoding
    -- encodings["THAI"] = .ISO885910_Encoding

    -- ISO-8859-13 (Baltic languages)
    -- encodings["ISO885913"] = .ISO885913_Encoding
    -- encodings["L7"] = .ISO885913_Encoding
    -- encodings["LATIN7"] = .ISO885913_Encoding

    -- ISO-8859-14 (Celtic languages)
    -- encodings["ISO885914"] = .ISO885914_Encoding
    -- encodings["L8"] = .ISO885914_Encoding
    -- encodings["LATIN8"] = .ISO885914_Encoding

    -- ISO-8859-15 (Western Europe)
    -- encodings["ISO885915"] = .ISO885915_Encoding
    -- encodings["L9"] = .ISO885915_Encoding
    -- encodings["LATIN9"] = .ISO885915_Encoding

    -- ISO-8859-16 (South-Eastern Europe)
    -- encodings["ISO885916"] = .ISO885916_Encoding
    -- encodings["L10"] = .ISO885916_Encoding
    -- encodings["LATIN10"] = .ISO885916_Encoding

    -- Mac Roman (Western Europe)
    -- encodings["MACINTOSH"] = .MACROMAN_Encoding
    -- encodings["MACROMAN"] = .MACROMAN_Encoding


::method normalizedName class
    use strict arg encodingName
    -- Remove all dash, underscore and spaces: "UTF8", "UTF_8", "UTF-8", "UTF 8" are all a valid encoding name
    return encodingName~translate(, "_- "," ")~space(0)~upper


::method register class
    expose encodings
    use strict arg encodingName, encoding
    encodingName = .Encoding~normalizedName(encodingName)
    encodings[encodingName] = encoding
    .environment~setentry(encoding~id, encoding) -- Mandatory otherwise the encoding classes are not visible from this package


::method supported class
    expose encodings
    use strict arg -- none
    return encodings~supplier


::method factory class
    expose encodings
    use strict arg encoding, string=""
    if encoding~isA(.Class), encoding~isSubClassOf(.StringIndexer) then return encoding
    encodingName = .Encoding~normalizedName(encoding~string)
    if encodingName == "DEFAULT" then return .Encoding~defaultEncoding
    if encodingName == "UTF16" then do
        if string~startsWith(.UTF16BE_Encoding~BOM) then return .UTF16BE_Encoding
        if string~startsWith(.UTF16LE_Encoding~BOM) then return .UTF16LE_Encoding
        return .UTF16BE_Encoding -- The Unicode norm specifies that the default UTF-16 is big endian
    end
    if encodingName == "WTF16" then do
        if string~startsWith(.WTF16BE_Encoding~BOM) then return .WTF16BE_Encoding
        if string~startsWith(.WTF16LE_Encoding~BOM) then return .WTF16LE_Encoding
        return .WTF16BE_Encoding -- Same logic of default as UTF-16
    end
    if encodingName == "UTF32" then do
        if string~startsWith(.UTF32BE_Encoding~BOM) then return .UTF32BE_Encoding
        if string~startsWith(.UTF32LE_Encoding~BOM) then return .UTF32LE_Encoding
        return .UTF32BE_Encoding -- The Unicode norm specifies that the default UTF-32 is big endian
    end
    if encodings~hasEntry(encodingName) then return encodings[encodingName]
    raise syntax 93.900 array("Encoding: '"encoding"' is not supported")


-- If you modify this method then see if asEncodingFor must be modified as well
::method forConcatenation class
    use strict arg left, right -- text or buffer or string

    left = left~requestTextOrBufferOrString
    if .nil == left then signal left_must_have_a_text_or_buffer_or_string_value
    leftEncoding = left~encoding
    leftIsCompatibleWithASCII = left~isCompatibleWithASCII

    right = right~requestTextOrBufferOrString
    if .nil == right then signal right_must_have_a_text_or_buffer_or_string_value
    rightEncoding = right~encoding
    rightIsCompatibleWithASCII = right~isCompatibleWithASCII

    if leftEncoding == rightEncoding then return leftEncoding

    if leftEncoding~isUTF8, rightEncoding~isWTF8 then return .WTF8_Encoding
    if leftEncoding~isWTF8, rightEncoding~isUTF8 then return .WTF8_Encoding
    -- Keep the following tests after the previous tests, to keep the priority for WTF8
    -- Give priority to unicode over byte-encoding
    -- When unicode on both sides then give priority to the left encoding
    if leftIsCompatibleWithASCII, (rightEncoding~isUTF8 | rightEncoding~isWTF8 | rightEncoding~isUnicode8) then do
        if leftEncoding~isUnicode then return leftEncoding
        return rightEncoding
    end
    if (leftEncoding~isUTF8 | leftEncoding~isWTF8 | leftEncoding~isUnicode8), rightIsCompatibleWithASCII then return leftEncoding

    if leftEncoding~isUTF16BE, rightEncoding~isWTF16BE then return .WTF16BE_Encoding
    if leftEncoding~isWTF16BE, rightEncoding~isUTF16BE then return .WTF16BE_Encoding
    if leftEncoding~isUTF16LE, rightEncoding~isWTF16LE then return .WTF16LE_Encoding
    if leftEncoding~isWTF16LE, rightEncoding~isUTF16LE then return .WTF16LE_Encoding

    -- TODO Discutable?
    -- Consider that Unicode32 is never compatible with UTF-32BE or UTF-32LE
    -- even if it can be compatible in function of the CPU endianness.
    -- It's to ensure that if a program works on a little-endian CPU then it works on a big-endian CPU, and vice-versa.

    raise syntax 23.900 array("Encoding: cannot append" right~descriptionForError "to" left~descriptionForError)

    left_must_have_a_text_or_buffer_or_string_value:  raise syntax 93.900 array("Method positional argument 'left' must have a text or buffer or string value")
    right_must_have_a_text_or_buffer_or_string_value: raise syntax 93.900 array("Method positional argument 'right' must have a text or buffer or string value")


::method comparisonMode class
    -- if a byte comparison is possible then return "b"
    -- if a unicode comparision is possible then return "u"
    -- otherwise raise an error
    use strict arg left, right -- text or string or buffer
    if left~encoding~isByte, right~encoding~isByte, left~encoding == right~encoding then return "b"
    if left~isCompatibleWithASCII, right~isCompatibleWithASCII then return "b"
    if left~isCompatibleWithASCII, (right~encoding~isUTF8 | right~encoding~isWTF8) then return "u"
    if (left~encoding~isUTF8 | left~encoding~isWTF8), right~isCompatibleWithASCII then return "u"
    if left~encoding~isUnicode & right~encoding~isUnicode then return "u"
    raise syntax 23.900 array("Encoding: cannot compare" left~descriptionForError "with" right~descriptionForError)
