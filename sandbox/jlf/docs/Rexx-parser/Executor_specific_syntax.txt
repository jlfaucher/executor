================================================================================
Notes for Rexx-parser adaptation
================================================================================

::extension
same as ::class
but only the INHERIT option is supported
options not supported: METACLASS, PUBLIC, PRIVATE, SUBCLASS, MIXINCLASS, ABSTRACT


1+2i
parsed as 1+(2<abuttal>i)


Instruction() is a function call, not an instruction
Executor:
    address()   Executes the shell whose name is returned
    arg()       bash: 0: command not found
    call()      Could not find routine "CALL"
    etc...
ooRexx:
    address()   Incorrect expression detected at "(".
    arg()       Missing expression following "(" of parse template.
    call()      Missing expression for calculated CALL name.
    etc...


The expression var==value is not an error when first instruction
Executor:   var==1      bash: 0: command not found
ooRexx:     var==1      Incorrect expression detected at "==".
Executor:   1==1        bash: 1: command not found
ooRexx:     1==1        Incorrect expression detected at "==".


The message name can be omitted in message term
Executor:   say "left"~("hello", 3)=        -- 'hel'
ooRexx:     say "left"~("hello", 3)         -- String or symbol expected after tilde (~).


(technical details moved to RexxSourceLiteral.txt)
RexxSource literal
a RexxSourceLiteral is an internal rexx object, created by the parser, not accessible from ooRexx scripts.
a RexxBlock is created each time the RexxSourceLiteral is evaluated, and is accessible from ooRexx scripts.
a RexxBlock is linked to the RexxSourceLiteral from which it was created.
A RexxBlock is not relevant to the parser, but it is useful in this review because it gives access to the information contained in the RexxSourceLiteral.
a RexxSourceLiteral has a type which is returned when sending the 'kind' message to the RexxBlock:
    {...}                               routine             "r"
    {::r[outine]...}                    routine             "r"
    {::co[activity]...}                 coactivity          "r.co"
    {expose...}                         closure             "cl"
    {::co[activity] expose v ...}       coactive closure    "cl.co"
A RexxSourceLiteral has a source code, which is the text between {}.
    {2}~source                          an array of lines: '2'
A RexxSourceLiteral has a raw executable, whose source is the result of a transformation of its own source.
    {2}~rawExecutable                   a routine
    {2}~rawExecutable~source            an array of lines: 'use auto named arg ; options "NOCOMMANDS" ; 2','if var("result") then return result'
Source literals can be nested: {...{...{...}...}...}.


Trailing blocks
f{...} is equivalent to f({...})
f(a1,a2,...){...} is equivalent to f(a1,a2,...,{...})


New options
    ::options COMMANDS          parser impacted
    ::options NOCOMMANDS        parser impacted
    options "COMMANDS"          parser not impacted
    options "NOCOMMANDS"        parser not impacted

    ::options MACROSPACE
    ::options NOMACROSPACE
    options "MACROSPACE"
    options "NOMACROSPACE"


Named arguments
Spec: https://github.com/jlfaucher/executor/blob/master/sandbox/jlf/docs/NamedArguments/NamedArguments-Spec.md
namespace:name collides with the usual syntax for named arguments.
In a list of arguments, the named argument notation must have priority over the namespace notation.
This is not blocking, you can surround by parentheses when passing a qualified symbol as positional argument.
    call myRoutine myNamedArgument:object
    call myRoutine (myNamespace:object)
    call myRoutine myNamedArgument:myNamespace:object


Compatibility with classic rexx
    Add support for variables # @ $ ¢.

    Add support for assignment V= -- assign ""

    Add support for instruction UPPER:
    same syntax as instruction DROP

    Regina supports the following characters as negators:
        \ Backslash (ANSI Standard)
        ^ Caret
        ~ Tilde
        ¬ Logical Not
    Add support for ^ and ¬ negators.
    Not possible to use ~ as a negator character.

    The operators /= and /== are supported in TSO/E REXX as alternatives to \= and \==, respectively.
    Add support for /= and /==
