
ooRexx> call loadUnicodeCharacterNames
Load the Unicode character names 15.1.0 
............................................
Total loaded character names: 149813
Total character name aliases: 473
Unicode character intervals not expanded, execute: call expandUnicodeCharacterIntervals

ooRexx> .Unicode~memorizeTranscodings = .false
ooRexx> .Unicode~memorizeTransformations = .false


-- ===============================================================================
-- 2024 Mar 17

/*
For consistency with other methods, add the optional named argument 'buffer' to
    []
    c2g
    c2x
    x2b
    x2d
Examples:
*/
ooRexx> buffer = .MutableBuffer~new
ooRexx> "T√™te √† t√™te"~text[2, 5, :buffer]=  -- M'√™te √†'
M'√™te √†'
ooRexx> "A"~text~c2g(:buffer)=              -- M'√™te √†41'
M'√™te √†41'
ooRexx> "A"~text~c2x(:buffer)=              -- M'√™te √†4141'
M'√™te √†4141'
ooRexx> "41"~text~x2b(:buffer)=             -- M'√™te √†414101000001'
M'√™te √†414101000001'
ooRexx> "41"~text~x2d(:buffer)=             -- M'√™te √†41410100000165'
M'√™te √†41410100000165'


/*
For compatibility with Python, add support for \N{Unicode name}.
Example:
*/
ooRexx> "\N{for all} x \N{there exists} y such that x+y=0"~text~unescape=       -- T'‚àÄ x ‚àÉ y such that x+y=0'
T'‚àÄ x ‚àÉ y such that x+y=0'


/*
Add support for code point labels.
Examples:
*/
ooRexx> .unicode~character("<control-000A>")=           -- ( ""    U+000A Cc 0 "", "LINE FEED", "NEW LINE", "END OF LINE", "LF", "NL", "EOL" )
( ""    U+000A Cc 0 "", "LINE FEED", "NEW LINE", "END OF LINE", "LF", "NL", "EOL" )
ooRexx> "hello\N{<control-000A>}bye"~text~unescape=     -- T'hello[0A]bye'
T'hello[0A]bye'
ooRexx> "hello\U{<control-000A>}bye"~text~unescape=     -- T'hello[0A]bye'
T'hello[0A]bye'


/*
Modify the display of UnicodeCharacter properties to show the codepoint values
in U+ and 0x notation.
*/
ooRexx> .Unicode["ü§∂"]~properties=
a Directory (30 items)
'aliases'               : (an Array no shape, 0 items)
'bidiClass'             :  19
'bidiClassName'         : 'ON'
'bidiMirrored'          :  0
'boundClass'            :  19
'boundClassName'        : 'EXTENDED_PICTOGRAPHIC'
'category'              :  22
'categoryName'          : 'So'
'charWidth'             :  2
'codepoint'             : 'U+1F936'
'combiningClass'        :  0
'controlBoundary'       :  0
'decompositionType'     :  0
'decompositionTypeName' : 'None'
'ignorable'             :  0
'isLower'               :  0
'isUpper'               :  0
'name'                  : 'MOTHER CHRISTMAS'
'toLowerFull'           : 'U+1F936'
'toLowerSimple'         : 'U+1F936'
'toTitleFull'           : 'U+1F936'
'toTitleSimple'         : 'U+1F936'
'toUpperFull'           : 'U+1F936'
'toUpperSimple'         : 'U+1F936'
'Unicode'               : '0x36F90100'
'UTF16BE'               : '0xD83EDD36'
'UTF16LE'               : '0x3ED836DD'
'UTF32BE'               : '0x0001F936'
'UTF32LE'               : '0x36F90100'
'UTF8'                  : '0xF09FA4B6'


/*
Modification of the rule for buffer encoding neutrality.
    old: If left is a        buffer with no encoding then use the right encoding.
    new: If left is an empty buffer with no encoding then use the right encoding.
Impacted methods:
    .Encoding~compatibleEncoding
    .StringIndexer~asEncodingFor
Examples:
*/
ooRexx> buffer = .MutableBuffer~new
-- This is an empty buffer with no explicit encoding:
-- The rule for encoding neutrality will apply.
ooRexx> buffer~description=                                                     -- 'UTF-8 ASCII by default (0 byte)'
'UTF-8 ASCII by default (0 byte)'
ooRexx> "Test"~text~utf16~left(2, :buffer)=                                     -- M'[00]T[00]e'
M'[00]T[00]e'
-- The buffer encoding is now UTF-16BE.
ooRexx> buffer~description=                                                     -- 'UTF-16BE (4 bytes)'
'UTF-16BE (4 bytes)'

ooRexx> buffer = .MutableBuffer~new("not empty")
ooRexx> buffer~description=                                                     -- 'UTF-8 ASCII by default (9 bytes)'
'UTF-8 ASCII by default (9 bytes)'
-- Here, the rule for encoding neutrality does not apply.
ooRexx> "Test"~text~utf16~left(2, :buffer)=                                     -- Encoding: cannot append UTF-16BE to UTF-8 ASCII by default 'not empty'
Encoding: cannot append UTF-16BE to UTF-8 ASCII by default 'not empty'.
Error code= 23.900


/*
New method ~u2c on String and RexxText.
Create a Unicode32 text from a sequence of U+xxxx.
The U+ string/text must be compatible with a byte encoding (Byte or subclass,
UTF-8 ASCII, WTF-8 ASCII).
In other words, will not support a sequence of U+xxxx encoded in UTF-16 or UTF-32.
Examples:
*/
-- U+ string
ooRexx> "U+004E u+006F U+00EB U+006C U+1F936 U+1F385"~u2c~description=          -- 'Unicode32 (6 characters, 6 codepoints, 24 bytes, 0 error)'
'Unicode32 (6 characters, 6 codepoints, 24 bytes, 0 error)'
ooRexx> "U+004E u+006F U+00EB U+006C U+1F936 U+1F385"~u2c~c2x=                  -- '4E000000 6F000000 EB000000 6C000000 36F90100 85F30100'
'4E000000 6F000000 EB000000 6C000000 36F90100 85F30100'
ooRexx> "U+004E u+006F U+00EB U+006C U+1F936 U+1F385"~u2c~utf8=                 -- T'No√´lü§∂üéÖ'
T'No√´lü§∂üéÖ'

-- U+ text
ooRexx> "U+004E u+006F U+00EB U+006C U+1F936 U+1F385"~text~u2c~description=     -- 'Unicode32 (6 characters, 6 codepoints, 24 bytes, 0 error)'
'Unicode32 (6 characters, 6 codepoints, 24 bytes, 0 error)'
ooRexx> "U+004E u+006F U+00EB U+006C U+1F936 U+1F385"~text~u2c~c2x=             -- '4E000000 6F000000 EB000000 6C000000 36F90100 85F30100'
'4E000000 6F000000 EB000000 6C000000 36F90100 85F30100'
ooRexx> "U+004E u+006F U+00EB U+006C U+1F936 U+1F385"~text~u2c~utf8=            -- T'No√´lü§∂üéÖ'
T'No√´lü§∂üéÖ'

ooRexx> buffer = .MutableBuffer~new
ooRexx> "U+0031 U+0032"~text~u2c(:buffer)=                                      -- M'1[000000]2[000000]'
M'1[000000]2[000000]'
-- The buffer encoding is now Unicode32.
ooRexx> buffer~description=                                                     -- 'Unicode32 (8 bytes)'
'Unicode32 (8 bytes)'

-- Examples of invalid U+ string/text
ooRexx> "U+004E u+006F U+00EB U+006C U+1F936 U+1F385"~text~utf16~u2c=           -- UTF-16BE '[00]U[00]+[00]0[00]0[00]4[00]E[00] ...' is not compatible with an U+ string.
UTF-16BE '[00]U[00]+[00]0[00]0[00]4[00]E[00] ...' is not compatible with an U+ string.
Error code= 23.900
ooRexx> "A+004E"~u2c=                                                           -- Expecting U+ or u+ followed by 4..6 hex digits, got 'A+004E'
Expecting U+ or u+ followed by 4..6 hex digits, got 'A+004E'.
Error code= 93.900
ooRexx> "u+4E"~u2c=                                                             -- Expecting U+ or u+ followed by 4..6 hex digits, got 'u+4E'
Expecting U+ or u+ followed by 4..6 hex digits, got 'u+4E'.
Error code= 93.900
ooRexx> "u+000004E"~u2c=                                                        -- Expecting U+ or u+ followed by 4..6 hex digits, got 'u+000004E'
Expecting U+ or u+ followed by 4..6 hex digits, got 'u+000004E'.
Error code= 93.900


/*
New supported methods on RexxText:
- d2c       forward to String, return a Text or a MutableBuffer
- d2x       forward to String, return a String or a MutableBuffer
Examples:
*/
ooRexx> "65"~text~d2c=              -- T'A'
T'A'
ooRexx> "65"~text~d2x=              -- 41
 41
ooRexx> buffer = .MutableBuffer~new
ooRexx> "65"~text~d2c(:buffer)=     -- M'A'
M'A'
ooRexx> "65"~text~d2x(:buffer)=     -- M'A41'
M'A41'
ooRexx> buffer~encoding = "utf16"
ooRexx> "65"~text~d2c(:buffer)=     -- Encoding: cannot append UTF-8 ASCII by default 'A' to UTF-16BE 'A41'
Encoding: cannot append UTF-8 ASCII by default 'A' to UTF-16BE 'A41'.
Error code= 23.900


/*
Partial implementation of translate (ASCII string only):
Examples:
*/
ooRexx> "hello"~text~translate=              -- 'HELLO'
T'HELLO'
ooRexx> "hello"~text~translate(,,"x")=       -- 'xxxxx'
T'xxxxx'
ooRexx> "hello"~text~translate(,"el","x")=   -- 'hxxxo'
T'hxxxo'


-- ===============================================================================
-- 2023 Dec 04

/*
Reworked the implementation of caselessMatchChar, matchCar.
*/

ooRexx> "Bundesschnellstra√üe"~text~caselessMatchChar(18, "s")=           -- now 0: "√ü" casefolded to "ss" doesn't match "s"
 0
ooRexx> "BAFFLE"~text~caselessMatchChar(5, "Ô¨Ñ")=                        -- now 0: "L" casefolded to "l" doesn't match "Ô¨Ñ" casefolded to "ffl" (no more iteration on each character of "ffl")
 0
ooRexx> "baÔ¨Ñe"~text~matchChar(3, "f", normalization:.Unicode~NFKD)=     -- now 0: "Ô¨Ñ" transformed to "ffl" doesn't match "f"
 0

/*
After rework, I have these other differences:
*/

-- Case 1 sounds good (no more iteration on each character of "ffl")
ooRexx> "BAFFLE"~text~caselessMatchChar(3, "Ô¨Ñ")=        -- 0    was 1 "Ô¨Ñ" becomes "ffl" (3 graphemes), there is a match on "f" at 3
 0
ooRexx> "BAFFLE"~text~caselessPos("Ô¨Ñ", aslist:, aligned:0)=
a List (1 items)
 0 : [+3.3,+6.6]
/*
    a List (1 items)
     0 : [+3.3,+6.6]
*/
-- I get the same result as before by explicitely decomposing the ligature "Ô¨Ñ" to "ffl" BEFORE :
ooRexx> "BAFFLE"~text~caselessMatchChar(3, "Ô¨Ñ"~text~transform(normalization:.Unicode~NFKD))=    -- 1
 1
-- here, it's ok because the match is on several characters
ooRexx> "BAFFLE"~text~caselessMatch(3, "Ô¨Ñ")=            -- 1
 1


-- Case 2 sounds good (no more iteration on each character of "ffl")
ooRexx> "BAFFLE"~text~caselessMatchChar(5, "Ô¨Ñ")=        -- 0    was 1 "Ô¨Ñ" becomes "ffl" (3 graphemes), there is a match on "l" at 5
 0
ooRexx> "BAFFLE"~text~caselessMatch(5, "Ô¨Ñ")=            -- 0
 0


-- Case 3 sounds good (no more iteration on each character of "ffl")
ooRexx> "baÔ¨Ñe"~text~caselessMatchChar(3, "F")=          -- 0    was 1 "Ô¨Ñ" at 3 (1 grapheme) becomes "ffl" (3 graphemes), there is a match on "f"
 0


-- Case 4 sound good (hum... did I really think that the character "Ô¨Ñ" at pos 3 can match an "l"?)
ooRexx> "baÔ¨Ñe"~text~caselessMatchChar(3, "L")=          -- 0    was 1 "Ô¨Ñ" at 3 (1 grapheme) becomes "ffl" (3 graphemes), there is a match on "l"
 0


-- ===============================================================================
-- 2023 Nov 28

/*
https://github.com/unicode-org/icu4x/issues/4365
Segmenter does not work correctly in some languages
        let text = "as `‡¶®‡¶Æ‡¶∏‡ßç‡¶ï‡¶æ‡ß∞, ‡¶Ü‡¶™‡ßã‡¶®‡¶æ‡ß∞ ‡¶ï‡¶ø ‡¶ñ‡¶¨‡ß∞?`
    hi `‡§π‡•à‡§≤‡•ã, ‡§ï‡•ç‡§Ø‡§æ ‡§π‡§æ‡§≤ ‡§π‡•à‡§Ç?`
    mai `‡§®‡§Æ‡§∏‡•ç‡§§‡•á ‡§Ö‡§π‡§æ‡§Å ‡§ï‡•á‡§®‡§æ ‡§õ‡§•‡§ø?`
    mr `‡§®‡§Æ‡§∏‡•ç‡§ï‡§æ‡§∞, ‡§ï‡§∏‡•á ‡§Ü‡§π‡§æ‡§§?`
    ne `‡§®‡§Æ‡§∏‡•ç‡§§‡•á, ‡§ï‡§∏‡•ç‡§§‡•ã ‡§π‡•Å‡§®‡•Å‡§π‡•Å‡§®‡•ç‡§õ?`
    or `‡¨®‡¨Æ‡¨∏‡≠ç‡¨ï‡¨æ‡¨∞ ‡¨§‡≠Å‡¨Æ‡≠á ‡¨ï‡≠á‡¨Æ‡¨ø‡¨§‡¨ø ‡¨Ö‡¨õ?`
    sa `‡§π‡•á ‡§§‡•ç‡§µ‡§Ç ‡§ï‡§ø‡§¶‡§Ç ‡§Ö‡§∏‡§ø?`
    te `‡∞π‡∞æ‡∞Ø‡±ç, ‡∞é‡∞≤‡∞æ ‡∞â‡∞®‡±ç‡∞®‡∞æ‡∞∞‡±Å?`";
icu4c: 151
rust: 161
---
ICU4X and ICU4C are just using different definitions of EGCs; ICU4C has had a
tailoring for years which has just been incorporated into Unicode 15.1, whereas
ICU4X implements the 15.0 version without that tailoring.
The difference is the handling of aksaras in some indic scripts:
in Unicode 15.1 (and in any recent ICU4C) ‡§ï‡•ç‡§Ø‡§æ is one EGC, but it is two EGCs
(‡§ï‡•ç, ‡§Ø‡§æ) in untailored Unicode 15.0 (and in ICU4X).
---
executor: 151
*/
ooRexx> s="as `‡¶®‡¶Æ‡¶∏‡ßç‡¶ï‡¶æ‡ß∞, ‡¶Ü‡¶™‡ßã‡¶®‡¶æ‡ß∞ ‡¶ï‡¶ø ‡¶ñ‡¶¨‡ß∞?`"'0D'x"hi `‡§π‡•à‡§≤‡•ã, ‡§ï‡•ç‡§Ø‡§æ ‡§π‡§æ‡§≤ ‡§π‡•à‡§Ç?`"'0D'x"mai `‡§®‡§Æ‡§∏‡•ç‡§§‡•á ‡§Ö‡§π‡§æ‡§Å ‡§ï‡•á‡§®‡§æ ‡§õ‡§•‡§ø?`"'0D'x"mr `‡§®‡§Æ‡§∏‡•ç‡§ï‡§æ‡§∞, ‡§ï‡§∏‡•á ‡§Ü‡§π‡§æ‡§§?`"'0D'x"ne `‡§®‡§Æ‡§∏‡•ç‡§§‡•á, ‡§ï‡§∏‡•ç‡§§‡•ã ‡§π‡•Å‡§®‡•Å‡§π‡•Å‡§®‡•ç‡§õ?`"'0D'x"or `‡¨®‡¨Æ‡¨∏‡≠ç‡¨ï‡¨æ‡¨∞ ‡¨§‡≠Å‡¨Æ‡≠á ‡¨ï‡≠á‡¨Æ‡¨ø‡¨§‡¨ø ‡¨Ö‡¨õ?`"'0D'x"sa `‡§π‡•á ‡§§‡•ç‡§µ‡§Ç ‡§ï‡§ø‡§¶‡§Ç ‡§Ö‡§∏‡§ø?`"'0D'x"te `‡∞π‡∞æ‡∞Ø‡±ç, ‡∞é‡∞≤‡∞æ ‡∞â‡∞®‡±ç‡∞®‡∞æ‡∞∞‡±Å?`"
ooRexx> s~text~length=  -- 151
 151


/*
https://boyter.org/posts/unicode-support-what-does-that-actually-mean/
According wikipedia the character ≈ø is a long s. Which means if you want to
support unicode you need to ensure that if someone does a case insensitive
comparison then the following examples are all string equivalent.
≈øecret == secret == Secret
≈øatisfaction == satisfaction == ≈øati≈øfaction == Sati≈øfaction == SatiSfaction === ≈øatiSfaction
*/
ooRexx> "≈ø"~text~casefold=                                      -- "s"
T's'
ooRexx> "≈øecret"~text~caselessEquals("secret")=                 -- 1
 1
ooRexx> "≈øecret"~text~caselessEquals("Secret")=                 -- 1
 1
ooRexx> "≈øatisfaction"~text~caselessEquals("satisfaction")=     -- 1
 1
ooRexx> "satisfaction"~text~caselessEquals("≈øati≈øfaction")=     -- 1
 1
ooRexx> "≈øati≈øfaction"~text~caselessEquals("Sati≈øfaction")=     -- 1
 1
ooRexx> "Sati≈øfaction"~text~caselessEquals("SatiSfaction")=     -- 1
 1
ooRexx> "SatiSfaction"~text~caselessEquals("≈øatiSfaction")=     -- 1
 1


-- ===============================================================================
-- 2023 Nov 21

/*
To rework? matchChar sometimes returns .true whereas pos returns 0.
Examples in demoTextCompatibility:

KO? 2023.12.04: yes
*/
ooRexx> "Bundesschnellstra√üe"~text~caselessMatchChar(18, "s")=      -- now 0, was 1 before 2023.12.04
 0
ooRexx> "Bundesschnellstra√üe"~text~caselessPos("s", aslist:, aligned:0)=
a List (5 items)
 0 : [+6.6,+7.7]
 1 : [+7.7,+8.8]
 2 : [+14.14,+15.15]
 3 : [+18.18,-18.19]
 4 : [-18.19,+19.20]
/*
    a List (5 items)
     0 : [+6.6,+7.7]
     1 : [+7.7,+8.8]
     2 : [+14.14,+15.15]
     3 : [+18.18,-18.19]
     4 : [-18.19,+19.20]
*/

/*
KO? 2023.12.04: yes
*/
ooRexx> "BAFFLE"~text~caselessMatchChar(5, "Ô¨Ñ")=                    -- now 0, was 1 before 2023.12.04
 0
ooRexx> "BAFFLE"~text~caselessPos("Ô¨Ñ", aslist:, aligned:0)=
a List (1 items)
 0 : [+3.3,+6.6]
/*
    a List (1 items)
     0 : [+3.3,+6.6]
*/

/*
KO? 2023.12.04: yes
*/
ooRexx> "baÔ¨Ñe"~text~matchChar(3, "f", normalization:.Unicode~NFKD)=     -- now 0, was 1 before 2023.12.04
 0
ooRexx> "baÔ¨Ñe"~text~pos("f", normalization:.Unicode~NFKD, aslist:, aligned:0)=
a List (2 items)
 0 : [+3.3,-3.4]
 1 : [-3.4,-3.5]
/*
    a List (2 items)
     0 : [+3.3,-3.4]
     1 : [-3.4,-3.5]
*/


-- ===============================================================================
-- 2023 Nov 17

/*
Rework the implementation of caselessCompare, to get the right answer here:
*/
ooRexx> "sss"~text~caselessCompare("", "√ü")=                --  3 (not  4 because the 3rd  's' matches only half of the casefolded pad "√ü" which is "ss")
 3
ooRexx> "stra√üss√ü√üssse"~text~caselessCompare("stra", "√ü")=  -- 12 (not 13 because the last 's' matches only half of the casefolded pad "√ü" which is "ss")
 12

/*
Analysis using Unicode scalars:

-----------------------------------------
CASE 1 : aligned in self, aligned in arg1
-----------------------------------------
*/

ooRexx> "stra√üss√ü√üssse"~text~compare("stra", "√ü")=          --  6
 6
/*
    "stra√üss√ü√üssse"~text~unicode~c2g=
         1  2  3  4  5  6  7  8  9  0  1  2  3      -- (external character indexes)
         s  t  r  a  √ü  s  s  √ü  √ü  s  s  s  e
         73 74 72 61 DF 73 73 DF DF 73 73 73 65     -- (unicode scalars)
    -------------------------------------------
    "stra√ü√ü√ü√ü√ü√ü√ü√ü√ü"~text~unicode~c2g=
         1  2  3  4  5  6  7  8  9  0  1  2  3      -- (external character indexes)
         s  t  r  a  √ü  √ü  √ü  √ü  √ü  √ü  √ü  √ü  √ü
         73 74 72 61 DF DF DF DF DF DF DF DF DF     -- (unicode scalars)
                        |
                        first different unicode scalar
*/

/*
Debug output: the indexer supports the named parameter debug
"stra√üss√ü√üssse"~text~indexer~compare("stra", "√ü", debug:.true)=
    selfTextTransformer~iSubtext~string = stra√üss√ü√üssse
    selfTextTransformer~iSubtext~c2g = 73 74 72 61 C39F 73 73 C39F C39F 73 73 73 65
    selfTextTransformedString~length = 16
    textTextTransformer~iSubtext~string = stra√ü√ü√ü√ü√ü√ü√ü√ü√ü
    textTextTransformer~iSubtext~c2g = 73 74 72 61 C39F C39F C39F C39F C39F C39F C39F C39F C39F
    textTextTransformedString~length = 22
    posB1 = 7
    posC1 = +6.7
    posB2 = 7
    posC2 = +6.7
     6
*/


/*
---------------------------------------------
CASE 2 : aligned in self, not aligned in arg1
---------------------------------------------
*/

ooRexx> "stra√üss√ü√üssse"~text~caselessCompare("stra", "√ü")=                              -- 12
 12
/*
    "stra√üss√ü√üssse"~text~unicode~c2g=
         1  2  3  4  5     6  7  8     9     0  1  2  3                         -- (external character indexes)
         s  t  r  a  √ü     s  s  √ü     √ü     s  s  s  e
         73 74 72 61 DF    73 73 DF    DF    73 73 73 65                        -- (unicode scalars)
    "stra√üss√ü√üssse"~text~casefold~unicode~c2g=
         1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6                         -- (internal byte indexes)
         s  t  r  a  s  s  s  s  s  s  s  s  s  s  s  e
         73 74 72 61 73 73 73 73 73 73 73 73 73 73 73 65                        -- (unicode scalars)
    ----------------------------------------------------
    "stra√ü√ü√ü√ü√ü√ü√ü√ü√ü"~text~unicode~c2g=
         1  2  3  4  5     6     7     8     9     0     1     2     3          -- (external character indexes)
         s  t  r  a  √ü     √ü     √ü     √ü     √ü     √ü     √ü     √ü     √ü
         73 74 72 61 DF    DF    DF    DF    DF    DF    DF    DF    DF         -- (unicode scalars)
    "stra√ü√ü√ü√ü√ü√ü√ü√ü√ü"~text~casefold~unicode~c2g=
         1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2       -- (internal byte indexes)
         s  t  r  a  √ü     √ü     √ü     √ü     √ü     √ü     √ü     √ü     √ü
         73 74 72 61 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73      -- (unicode scalars)
                                                   |  |
                                                   |  +-- 65 at (13,16) <> 73 at (-10,+16) but can't be 13 because would match only the first 73 of √ü at (10,15)
                                                   +-- yes, 12.
*/

/*
Debug output: the indexer supports the named parameter debug
"stra√üss√ü√üssse"~text~indexer~caselessCompare("stra", "√ü", debug:.true)=
    selfTextTransformer~iSubtext~string = strassssssssssse
    selfTextTransformer~iSubtext~c2g = 73 74 72 61 73 73 73 73 73 73 73 73 73 73 73 65
    selfTextTransformedString~length = 16
    textTextTransformer~iSubtext~string = strassssssssssssssssss
    textTextTransformer~iSubtext~c2g = 73 74 72 61 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73
    textTextTransformedString~length = 22
    posB1 = 16
    posC1 = +13.16
    posB2 = 16
    posC2 = -10.16
     12
*/

-- Another way to test: at which moment the growing padded string on the right will no longer be found at pos 1
--   1234567890123
ooRexx>     "stra√üss√ü√üssse"~text~caselessPos("stra√ü")=          -- 1
 1
--   stra√ü
ooRexx>     "stra√üss√ü√üssse"~text~caselessPos("stra√ü√ü")=         -- 1
 1
--   stra√ü√ü
ooRexx>     "stra√üss√ü√üssse"~text~caselessPos("stra√ü√ü√ü")=        -- 1
 1
--   stra√ü√ü √ü
ooRexx>     "stra√üss√ü√üssse"~text~caselessPos("stra√ü√ü√ü√ü")=       -- 1
 1
--   stra√ü√ü √ü√ü
ooRexx>     "stra√üss√ü√üssse"~text~caselessPos("stra√ü√ü√ü√ü√ü")=      -- 1
 1
--   stra√ü√ü √ü√ü√ü
ooRexx>     "stra√üss√ü√üssse"~text~caselessPos("stra√ü√ü√ü√ü√ü√ü")=     -- 0    The last √ü doesn't match "se" at 12
 0
--   stra√ü√ü √ü√ü√ü √ü


/*
---------------------------------------------
CASE 3 : not aligned in self, aligned in arg1
---------------------------------------------
*/

ooRexx> "stra"~text~caselessCompare("stra√üss√ü√üssse", "√ü")=  -- 9
 9
/*
    1  2  3  4  5     6     7     8     9     0     1     2     3               -- (external character indexes)
    s  t  r  a  √ü     √ü     √ü     √ü     √ü     √ü     √ü     √ü     √ü
    1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2            -- (internal byte indexes)
    73 74 72 61 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73           -- (unicode scalars of the casefolded string)
    -----------------------------------------------------------------
    1  2  3  4  5     6  7  8     9     0  1  2  3                              -- (external character indexes)
    s  t  r  a  √ü     s  s  √ü     √ü     s  s  s  e
    1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6                              -- (internal byte indexes)
    73 74 72 61 73 73 73 73 73 73 73 73 73 73 73 65                             -- (unicode scalars of the casefolded string)
                                        |        |
                                        |        + 73 at (-10,16) <> 65 at (13,16)
                                        +-- yes, 9.
*/

/*
Debug output: the indexer supports the named parameter debug
"stra"~text~indexer~caselessCompare("stra√üss√ü√üssse", "√ü", debug:.true)=
    selfTextTransformer~iSubtext~string = strassssssssssssssssss
    selfTextTransformer~iSubtext~c2g = 73 74 72 61 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73 73
    selfTextTransformedString~length = 22
    textTextTransformer~iSubtext~string = strassssssssssse
    textTextTransformer~iSubtext~c2g = 73 74 72 61 73 73 73 73 73 73 73 73 73 73 73 65
    textTextTransformedString~length = 16
    posB1 = 16
    posC1 = -10.16
    posB2 = 16
    posC2 = +13.16
     9
*/

ooRexx> "stra√ü"        ~text~caselessCompare("stra√üss√ü√üssse", "√ü")=  -- 9
 9
ooRexx> "stra√ü√ü"       ~text~caselessCompare("stra√üss√ü√üssse", "√ü")=  -- 9
 9
ooRexx> "stra√ü√ü√ü"      ~text~caselessCompare("stra√üss√ü√üssse", "√ü")=  -- 9
 9
ooRexx> "stra√ü√ü√ü√ü"     ~text~caselessCompare("stra√üss√ü√üssse", "√ü")=  -- 9
 9
ooRexx> "stra√ü√ü√ü√ü√ü"    ~text~caselessCompare("stra√üss√ü√üssse", "√ü")=  -- 9
 9
ooRexx> "stra√ü√ü√ü√ü√ü√ü"   ~text~caselessCompare("stra√üss√ü√üssse", "√ü")=  -- 9
 9
ooRexx> "stra√ü√ü√ü√ü√ü√ü√ü"  ~text~caselessCompare("stra√üss√ü√üssse", "√ü")=  -- 9
 9
ooRexx> "stra√ü√ü√ü√ü√ü√ü√ü√ü" ~text~caselessCompare("stra√üss√ü√üssse", "√ü")=  -- 9
 9

ooRexx> "stra√ü"        ~text~caselessCompareTo("stra√üss√ü√üssse")=  -- -1
-1
ooRexx> "stra√ü√ü"       ~text~caselessCompareTo("stra√üss√ü√üssse")=  -- -1
-1
ooRexx> "stra√ü√ü√ü"      ~text~caselessCompareTo("stra√üss√ü√üssse")=  -- -1
-1
ooRexx> "stra√ü√ü√ü√ü"     ~text~caselessCompareTo("stra√üss√ü√üssse")=  -- -1
-1
ooRexx> "stra√ü√ü√ü√ü√ü"    ~text~caselessCompareTo("stra√üss√ü√üssse")=  -- -1     up to 9 characters, it's lesser
-1
ooRexx> "stra√ü√ü√ü√ü√ü√ü"   ~text~caselessCompareTo("stra√üss√ü√üssse")=  -- 1      from 10 characters, it's greater
 1
ooRexx> "stra√ü√ü√ü√ü√ü√ü√ü"  ~text~caselessCompareTo("stra√üss√ü√üssse")=  -- 1
 1
ooRexx> "stra√ü√ü√ü√ü√ü√ü√ü√ü" ~text~caselessCompareTo("stra√üss√ü√üssse")=  -- 1
 1

ooRexx> "stra"     ~caselessCompare("strasssssse", "s")=    -- 11
 11
ooRexx> "stra"~text~caselessCompare("strasssssse", "s")=    -- 11
 11
ooRexx> "strasssssse"     ~caselessCompare("stra", "s")=    -- 11
 11
ooRexx> "strasssssse"~text~caselessCompare("stra", "s")=    -- 11
 11

ooRexx> "str√†"     ~caselessCompare("str√†sssssse", "s")=    -- 12
 12
ooRexx> "str√†"~text~caselessCompare("str√†sssssse", "s")=    -- 11
 11
ooRexx> "str√†sssssse"     ~caselessCompare("str√†", "s")=    -- 12
 12
ooRexx> "str√†sssssse"~text~caselessCompare("str√†", "s")=    -- 11
 11


/*
---------------------------------------------
CASE 4 : not aligned in self, aligned in arg1
---------------------------------------------
*/

ooRexx> iota_dt = "\u{GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS}"~text~unescape
ooRexx> ("a" iota_dt~casefold "b")~compare("a" iota_dt, normalization: 0)=  -- 3
 3

/*
Debug output: the indexer supports the named parameter debug
("a" iota_dt~casefold "b")~indexer~compare("a" iota_dt, normalization: 0, debug:.true)=
    selfTextTransformer~iSubtext~string = a ŒπÃàÃÅ b
    selfTextTransformer~iSubtext~c2g = 61 20 CEB9CC88CC81 20 62
    selfTextTransformedString~length = 10
    textTextTransformer~iSubtext~string = a Œê
    textTextTransformer~iSubtext~c2g = 61 20 CE90 20 20
    textTextTransformedString~length = 6
    posB1 = 4
    posC1 = -3.4
    posB2 = 4
    posC2 = -3.4
     3
*/


-- ===============================================================================
-- 2023 Oct 04

/*
Reactivate the constraint "self~isCompatibleWithByteString" when converting a
RexxText to a String. It can be disabled by setting
    .Unicode~unckeckedConversionToString = .true
Currently, the only case where this constraint is disabled is when testing
the regular expressions in diary_examples.rex.


Some checks of encoding compatibiliy were missing.
Added in:
- compareText: caselessCompare, compare
- compareToText: caselessCompareTo, compareTo
- endsWithText: caselessEndsWith, endsWith
- matchCharText: caselessMatchChar, matchChar
- matchText: caselessMatch, match
- posText: caselessPos, pos


New supported methods:
- abs       forward to String, return a String
- b2x       forward to String, return a String
- bitAnd    forward to String, return a String
- bitOr     forward to String, return a String
- bitXor    forward to String, return a String
Examples:
*/
ooRexx>     (-1)~text~abs=          -- 1
 1
ooRexx>     ("-x")~text~abs=        -- ABS method target must be a number; found "-x".
ABS method target must be a number; found "-x".
Error code= 93.943
ooRexx>     ("-√©")~text~abs=        -- UTF-8 not-ASCII '-√©' is not compatible with a Rexx numeric value.
UTF-8 not-ASCII '-√©' is not compatible with a Rexx numeric value.
Error code= 23.900

ooRexx>     100~text~b2x=           -- 4
 4
ooRexx>     "x"~text~b2x=           -- Only 0, 1, and whitespace characters are valid in a binary string; character found "x".
Only 0, 1, and whitespace characters are valid in a binary string; character found "x".
Error code= 93.934
ooRexx>     "√©"~text~b2x=           -- UTF-8 not-ASCII '√©' is not compatible with a Rexx numeric value.
UTF-8 not-ASCII '√©' is not compatible with a Rexx numeric value.
Error code= 23.900

ooRexx>     "12"x~text~bitAnd=                                  -- '[12]'   ("12"x)
'[12]'
ooRexx>     "73"x~text~bitAnd("27"x~text)=                      -- '#'      ("23"x)
'#'
ooRexx>     "13"x~text~bitAnd("5555"x~text)=                    -- '[11]U'  ("1155"x)
'[11]U'
ooRexx>     "13"x~text~bitAnd("5555"x~text,"74"x~text)=         -- '[11]T'  ("1154"x)
'[11]T'
ooRexx>     "pQrS"~text~bitAnd(,"DF"x~text("byte"))=            -- "PQRS"
'PQRS'

ooRexx>     "12"x~text~bitOr=                                   -- '[12]'       ("12"x)
'[12]'
ooRexx>     "15"x~text~bitOr("24"x~text)=                       -- 5            ("35"x)
 5
ooRexx>     "15"x~text~bitOr("2456"x~text)=                     -- '5V'         ("3556"x)
'5V'
ooRexx>     "15"x~text~bitOr("2456"x~text,"F0"x~text("byte"))=  -- '5?'         ("35F6"x)
'5ˆ'
ooRexx>     "1111"x~text~bitOr(,"4D"x~text)=                    -- ']]'         ("5D5D"x)
']]'
ooRexx>     "pQrS"~text~bitOr(,"20"x~text)=                     -- "pqrs"
'pqrs'

ooRexx>     "12"x~text~bitXor=                                  -- '[12]'       ("12"x)
'[12]'
ooRexx>     "12"x~text~bitXor("22"x~text)=                      -- 0            ("30"x)
 0
ooRexx>     "1211"x~text~bitXor("22"x~text)=                    -- '0[11]'      ("3011"x)
'0[11]'
ooRexx>     "1111"x~text~bitXor("444444"x~text)=                -- 'UUD'        ("555544"x)
'UUD'
ooRexx>     "1111"x~text~bitXor("444444"x~text,"40"x~text)=     -- 'UU[04]'     ("555504"x)
'UU[04]'
ooRexx>     "1111"x~text~bitXor(,"4D"x~text)=                   -- '\\'         ("5C5C"x)
'\\'
ooRexx>     "C711"x~text~bitXor("222222"x~text," "~text)=       -- '?3[02]'     ("E53302"x)
'Â3[02]'


/*
Implementation of caselessStartsWith, startsWith:
(forwards to caselessPos or pos, and returns .true if result == 1)
(was already implemented, waiting for 'pos' implementation)
Examples:
*/
ooRexx>     "P√®re"~text~c2g=                                -- '50 C3A8 72 65'
'50 C3A8 72 65'
ooRexx>     "P√®re"~text~startsWith("50"x)=                  -- true
 1
ooRexx>     "P√®re"~text~startsWith("50C3"x)=                -- Invalid UTF-8 string     (utf8proc error because "50C3"x is an invalid UTF-8 encoding)
Invalid UTF-8 string.
Error code= 22.900
ooRexx>     "P√®re"~text~startsWith("50C3"x~text("byte"))=   -- Encoding: cannot compare Byte not-ASCII 'P?' with UTF-8 not-ASCII 'P√®re'
Encoding: cannot compare Byte not-ASCII 'P√' with UTF-8 not-ASCII 'P√®re'.
Error code= 23.900
ooRexx>     "P√®re"~text~startsWith("50C3A8"x)=              -- true
 1

ooRexx>     "√©√üÔ¨Ñ"~text~c2g=                                 -- 'C3A9 C39F EFAC84'
'C3A9 C39F EFAC84'
ooRexx>     "√©√üÔ¨Ñ"~text~casefold~c2g=                        -- 'C3A9 73 73 66 66 6C'
'C3A9 73 73 66 66 6C'
ooRexx>     "√©√üÔ¨Ñ"~text~caselessStartsWith("√â")=             -- true
 1
ooRexx>     "√©√üÔ¨Ñ"~text~caselessStartsWith("√âs")=            -- false
 0
ooRexx>     "√©√üÔ¨Ñ"~text~caselessStartsWith("√âss")=           -- true
 1
ooRexx>     "√©√üÔ¨Ñ"~text~caselessStartsWith("√âssf")=          -- false
 0
ooRexx>     "√©√üÔ¨Ñ"~text~caselessStartsWith("√âssff")=         -- false
 0
ooRexx>     "√©√üÔ¨Ñ"~text~caselessStartsWith("√âssffl")=        -- true
 1

ooRexx>     "no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~startsWith("no√´lüë©")=                       -- false
 0
ooRexx>     "no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~startsWith("no√´lüë©", aligned:.false)=       -- true
 1
ooRexx>     "no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~startsWith("no√´lüë©‚Äçüë®‚Äçüë©‚Äç")=                  -- false
 0
ooRexx>     "no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~startsWith("no√´lüë©‚Äçüë®‚Äçüë©‚Äç", aligned:.false)=  -- true
 1
ooRexx>     "no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~startsWith("no√´lüë©‚Äçüë®‚Äçüë©‚Äçüëß")=                 -- true
 1


-- ===============================================================================
-- 2023 Oct 03

/*
Move the routine createCharacterTranscodingTable from byte_common.cls to
byte_encoding.cls. It's used only by Byte_Encoding and its subclasses.


The 'text' method of UnicodeCharacter has been replaced by 'transcodeTo'.
Reason 1: the byte encodings were not supported correctly.
Reason 2: the fact a transcoding is needed is against the definition of the
'text' method (apply a view on the bytes without modifying them).


Finalize the support of replacement character during transcoding.
A replacement character can be .nil or "" or a character.
When a character, it can be a String or a RexxText made of one codepoint or a UnicodeCharacter.
In all cases, the corresponding codepoint is used. This codepoint is transcoded to the target encoding.

Behavior when a source codepoint does not have a matching target codepoint:
- When the replacement character is .nil, an error is raised.
- When the replacement character is "", the source codepoint is ignored (not transcoded)
- Otherwise the source codepoint is replaced by the replacement character.

Reminder: if the 'strict' named argument is false (default) then the fallback
codepoint transcodings are used, if any. So when 'strict' is false, potentially
more source could be transcoded.

Examples:
*/
ooRexx>     -- The Windows-1252 encoding has some fallback codepoint transcodings.
ooRexx>     -- HOP is one of them: 81x --> +U0081 only when strict:.false
ooRexx>     ("No" || "EB"x || "l" || "81"x)~text("windows-1252")~utf8(strict:.false)=   -- T'No√´l¬Å (strict:.false is the default)
T'No√´l¬Å'
ooRexx>     ("No" || "EB"x || "l" || "81"x)~text("windows-1252")~utf8(strict:.false)~unicodecharacters==
an Array (shape [5], 5 items)
 1 : ( "N"   U+004E Lu 1 "LATIN CAPITAL LETTER N" )
 2 : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
 3 : ( "√´"   U+00EB Ll 1 "LATIN SMALL LETTER E WITH DIAERESIS" )
 4 : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
 5 : ( "¬Å"    U+0081 Cc 0 "", "HIGH OCTET PRESET", "HOP" )
ooRexx>     ("No" || "EB"x || "l" || "81"x)~text("windows-1252")~utf8(strict:.true)=    -- Cannot convert windows-1252 not-ASCII character 129 (81) at byte-position 5 to UTF-8.
Cannot convert windows-1252 not-ASCII character 129 (81) at byte-position 5 to UTF-8.
Error code= 23.900
ooRexx>     ("No" || "EB"x || "l" || "81"x)~text("windows-1252")~utf8(strict:.true, replacementCharacter:"")=       -- T'No√´l'
T'No√´l'
ooRexx>     ("No" || "EB"x || "l" || "81"x)~text("windows-1252")~utf8(strict:.true, replacementCharacter:"#")=      -- T'No√´l#'
T'No√´l#'
ooRexx>     ("No" || "EB"x || "l" || "81"x)~text("windows-1252")~utf8(strict:.true, replacementCharacter:"üéÖ")=     -- T'No√´lüéÖ'
T'No√´lüéÖ'

ooRexx>     "No√´l\u{HOP}"~text("utf8")~unescape~transcodeTo("byte")=                    -- Cannot convert UTF-8 not-ASCII codepoint 235 (EB) at position 3 to Byte.
Cannot convert UTF-8 not-ASCII codepoint 235 (EB) at position 3 to Byte.
Error code= 23.900
ooRexx>     "No√´l\u{HOP}"~text("utf8")~unescape~transcodeTo("windows-1252")=            -- T'No?l?'
T'NoÎlÅ'
ooRexx>     "No√´l\u{HOP}"~text("utf8")~unescape~transcodeTo("windows-1252")~c2x=        -- '4E 6F EB 6C 81'
'4E 6F EB 6C 81'
ooRexx>     "No√´l\u{HOP}"~text("utf8")~unescape~transcodeTo("windows-1252", strict:)=   -- Cannot convert UTF-8 not-ASCII codepoint 129 (81) at position 5 to windows-1252.
Cannot convert UTF-8 not-ASCII codepoint 129 (81) at position 5 to windows-1252.
Error code= 23.900

ooRexx>     -- "byte" encoding: only 00..7F can be transcoded
ooRexx>     ("No" || "EB"x || "l" || "81"x)~text("byte")~utf8=                                                      -- Cannot convert Byte not-ASCII character 235 (EB) at byte-position 3 to UTF-8.
Cannot convert Byte not-ASCII character 235 (EB) at byte-position 3 to UTF-8.
Error code= 23.900
ooRexx>     ("No" || "EB"x || "l" || "81"x)~text("byte")~utf8(replacementCharacter:"")=                             -- T'Nol'
T'Nol'
ooRexx>     ("No" || "EB"x || "l" || "81"x)~text("byte")~utf8(replacementCharacter:"#")=                            -- T'No#l#'      1 replacement character for √´ because "√´" is 'EB'x
T'No#l#'
ooRexx>     ("No" || "EB"x || "l" || "81"x)~text("byte")~utf8(replacementCharacter:"üéÖ")=                           -- T'NoüéÖlüéÖ'
T'NoüéÖlüéÖ'
ooRexx>     ("No" || "EB"x || "l" || "81"x)~text("byte")~utf8(replacementCharacter:"üéÖ"~text)=                      -- T'NoüéÖlüéÖ'
T'NoüéÖlüéÖ'
ooRexx>     ("No" || "EB"x || "l" || "81"x)~text("byte")~utf8(replacementCharacter:.unicode["Father Christmas"])=   -- T'NoüéÖlüéÖ'
T'NoüéÖlüéÖ'

ooRexx>     "No√´l"~text("byte")~utf8(replacementCharacter:"")=                          -- T'Nol'
T'Nol'
ooRexx>     "No√´l"~text("byte")~utf8(replacementCharacter:"#")=                         -- T'No##l'         2 replacement characters for √´ because "√´" is 'C3 AB'x
T'No##l'
ooRexx>     "No√´l"~text("byte")~utf8(replacementCharacter:"üéÖ")=                        -- T'NoüéÖüéÖl'
T'NoüéÖüéÖl'
ooRexx>     "No√´l"~text("byte")~utf8(replacementCharacter:"üéÖüéÖ")=                     -- The transcoded replacement character must have at most one codepoint, got UTF-8 not-ASCII (2 characters, 2 codepoints, 8 bytes, 0 error) 'üéÖüéÖ'.
The transcoded replacement character must have at most one codepoint, got UTF-8 not-ASCII (2 characters, 2 codepoints, 8 bytes, 0 error) 'üéÖüéÖ'.
Error code= 23.900
ooRexx>     "No√´l"~text("byte")~utf8(replacementCharacter:"üéÖüéÖ"~text)=                -- The transcoded replacement character must have at most one codepoint, got UTF-8 not-ASCII (2 characters, 2 codepoints, 8 bytes, 0 error) 'üéÖüéÖ'.
The transcoded replacement character must have at most one codepoint, got UTF-8 not-ASCII (2 characters, 2 codepoints, 8 bytes, 0 error) 'üéÖüéÖ'.
Error code= 23.900

ooRexx>     "No√´l"~text("utf8")~transcodeTo("byte")=                                    -- Cannot convert UTF-8 not-ASCII codepoint 235 (EB) at position 3 to Byte.
Cannot convert UTF-8 not-ASCII codepoint 235 (EB) at position 3 to Byte.
Error code= 23.900
ooRexx>     "No√´l"~text("utf8")~transcodeTo("byte", replacementCharacter:"")=           -- T'Nol'
T'Nol'
ooRexx>     "No√´l"~text("utf8")~transcodeTo("byte", replacementCharacter:"#")=          -- T'No#l'
T'No#l'
ooRexx>     "No√´l"~text("utf8")~transcodeTo("byte", replacementCharacter:"üéÖ")=         -- The replacement character UTF-8 not-ASCII 'üéÖ' cannot be transcoded to Byte.
The replacement character UTF-8 not-ASCII 'üéÖ' cannot be transcoded to Byte.
Error code= 93.900

ooRexx>     "No√´lü§∂"~text("utf8")~transcodeTo("unicode", replacementCharacter:"üéÖ")=        -- T'N[000000]o[000000]?[000000]l[000000]??[0100]'
T'N[000000]o[000000]Î[000000]l[000000]6˘[0100]'
ooRexx>     "No√´lü§∂"~text("utf8")~transcodeTo("unicode", replacementCharacter:"üéÖ")~c2x=    -- '4E000000 6F000000 EB000000 6C000000 36F90100'
'4E000000 6F000000 EB000000 6C000000 36F90100'
ooRexx>     "No√´lü§∂"~text("utf8")~transcodeTo("unicode", replacementCharacter:"üéÖ")~c2u=    -- 'U+004E U+006F U+00EB U+006C U+1F936'
'U+004E U+006F U+00EB U+006C U+1F936'

ooRexx>     "No√´lü§∂"~text("utf8")~transcodeTo("unicode8", replacementCharacter:"")=          -- T'No?l'
T'NoÎl'
ooRexx>     "No√´lü§∂"~text("utf8")~transcodeTo("unicode8", replacementCharacter:"")~c2x=      -- '4E 6F EB 6C'
'4E 6F EB 6C'
ooRexx>     "No√´lü§∂"~text("utf8")~transcodeTo("unicode8", replacementCharacter:"#")=         -- T'No?l#'
T'NoÎl#'
ooRexx>     "No√´lü§∂"~text("utf8")~transcodeTo("unicode8", replacementCharacter:"#")~c2x=     -- '4E 6F EB 6C 23'
'4E 6F EB 6C 23'
ooRexx>     "No√´lü§∂"~text("utf8")~transcodeTo("unicode8", replacementCharacter:"üéÖ")=       -- The replacement character UTF-8 not-ASCII 'üéÖ' cannot be transcoded to Unicode8.
The replacement character UTF-8 not-ASCII 'üéÖ' cannot be transcoded to Unicode8.
Error code= 93.900

ooRexx>     "No√´lü§∂"~text("utf8")~transcodeTo("unicode16", replacementCharacter:"")=         -- T'N[00]o[00]?[00]l[00]'
T'N[00]o[00]Î[00]l[00]'
ooRexx>     "No√´lü§∂"~text("utf8")~transcodeTo("unicode16", replacementCharacter:"#")=        -- T'N[00]o[00]?[00]l[00]#[00]'
T'N[00]o[00]Î[00]l[00]#[00]'
ooRexx>     "No√´lü§∂"~text("utf8")~transcodeTo("unicode16", replacementCharacter:"#")~c2x=    -- '4E00 6F00 EB00 6C00 2300'
'4E00 6F00 EB00 6C00 2300'
ooRexx>     "No√´lü§∂"~text("utf8")~transcodeTo("unicode16", replacementCharacter:"#")~c2u=    -- 'U+004E U+006F U+00EB U+006C U+0023'
'U+004E U+006F U+00EB U+006C U+0023'
ooRexx>     "No√´lü§∂"~text("utf8")~transcodeTo("unicode16", replacementCharacter:"üéÖ")=      -- The replacement character UTF-8 not-ASCII 'üéÖ' cannot be transcoded to Unicode16.
The replacement character UTF-8 not-ASCII 'üéÖ' cannot be transcoded to Unicode16.
Error code= 93.900

ooRexx>     "No√´lü§∂"~text("utf8")~transcodeTo("unicode32")=         -- T'N[000000]o[000000]?[000000]l[000000]6?[0100]'
T'N[000000]o[000000]Î[000000]l[000000]6˘[0100]'
ooRexx>     "No√´lü§∂"~text("utf8")~transcodeTo("unicode32")~c2x=     -- '4E000000 6F000000 EB000000 6C000000 36F90100'
'4E000000 6F000000 EB000000 6C000000 36F90100'
ooRexx>     "No√´lü§∂"~text("utf8")~transcodeTo("unicode32")~c2u=     -- 'U+004E U+006F U+00EB U+006C U+1F936'
'U+004E U+006F U+00EB U+006C U+1F936'


/*
The method c2u is no longer abstract for the byte encodings.
Now, a byte encoding is converted on the fly to UnicodeN in non strict mode,
replacing any unsupported character by .Unicode~replacementCharacter.
Idem for the method unicodeCharacters.
Examples:
*/
ooRexx>     "FF FE FD FC"x~text("byte")~c2x=                                               -- 'FF FE FD FC'
'FF FE FD FC'
ooRexx>     "FF FE FD FC"x~text("byte")~c2g=                                               -- 'FF FE FD FC'
'FF FE FD FC'
ooRexx>     "FF FE FD FC"x~text("byte")~codepoints==
a CodePointSupplier 
 1 :  255
 2 :  254
 3 :  253
 4 :  252
ooRexx>     "FF FE FD FC"x~text("byte")~c2u=                                               -- 'U+FFFD U+FFFD U+FFFD U+FFFD'
'U+FFFD U+FFFD U+FFFD U+FFFD'
ooRexx>     "FF FE FD FC"x~text("byte")~unicodeCharacters==
an Array (shape [4], 4 items)
 1 : ( "ÔøΩ"   U+FFFD So 1 "REPLACEMENT CHARACTER" )
 2 : ( "ÔøΩ"   U+FFFD So 1 "REPLACEMENT CHARACTER" )
 3 : ( "ÔøΩ"   U+FFFD So 1 "REPLACEMENT CHARACTER" )
 4 : ( "ÔøΩ"   U+FFFD So 1 "REPLACEMENT CHARACTER" )

ooRexx>     "FF FE FD FC"x~text("utf8")~c2x=                                               -- 'FF FE FD FC'
'FF FE FD FC'
ooRexx>     "FF FE FD FC"x~text("utf8")~c2g=                                               -- 'FF FE FD FC'
'FF FE FD FC'
ooRexx>     "FF FE FD FC"x~text("utf8")~c2u=                                               -- 'U+FFFD U+FFFD U+FFFD U+FFFD'
'U+FFFD U+FFFD U+FFFD U+FFFD'
ooRexx>     "FF FE FD FC"x~text("utf8")~codepoints==
a CodePointSupplier 
 1 :  65533
 2 :  65533
 3 :  65533
 4 :  65533

ooRexx>     "FF FE FD FC"x~text("unicode8")~c2x=                                           -- 'FF FE FD FC'
'FF FE FD FC'
ooRexx>     "FF FE FD FC"x~text("unicode8")~c2g=                                           -- 'FF FE FD FC'
'FF FE FD FC'
ooRexx>     "FF FE FD FC"x~text("unicode8")~codepoints==
a CodePointSupplier 
 1 :  255
 2 :  254
 3 :  253
 4 :  252
ooRexx>     "FF FE FD FC"x~text("unicode8")~c2u=                                           -- 'U+00FF U+00FE U+00FD U+00FC'
'U+00FF U+00FE U+00FD U+00FC'
ooRexx>     "FF FE FD FC"x~text("unicode8")~unicodecharacters==
an Array (shape [4], 4 items)
 1 : ( "√ø"   U+00FF Ll 1 "LATIN SMALL LETTER Y WITH DIAERESIS" )
 2 : ( "√æ"   U+00FE Ll 1 "LATIN SMALL LETTER THORN" )
 3 : ( "√Ω"   U+00FD Ll 1 "LATIN SMALL LETTER Y WITH ACUTE" )
 4 : ( "√º"   U+00FC Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS" )

ooRexx>     ("No" || "EB"x || "l" || "81"x)~text("byte")~c2x=                           -- '4E 6F EB 6C 81'
'4E 6F EB 6C 81'
ooRexx>     ("No" || "EB"x || "l" || "81"x)~text("byte")~c2g=                           -- '4E 6F EB 6C 81'
'4E 6F EB 6C 81'
ooRexx>     ("No" || "EB"x || "l" || "81"x)~text("byte")~c2u=                           -- 'U+004E U+006F U+FFFD U+006C U+FFFD'
'U+004E U+006F U+FFFD U+006C U+FFFD'
ooRexx>     ("No" || "EB"x || "l" || "81"x)~text("byte")~unicodecharacters==
an Array (shape [5], 5 items)
 1 : ( "N"   U+004E Lu 1 "LATIN CAPITAL LETTER N" )
 2 : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
 3 : ( "ÔøΩ"   U+FFFD So 1 "REPLACEMENT CHARACTER" )
 4 : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
 5 : ( "ÔøΩ"   U+FFFD So 1 "REPLACEMENT CHARACTER" )

ooRexx>     ("No" || "EB"x || "l" || "81"x)~text("windows-1252")~c2x=                   -- '4E 6F EB 6C 81'
'4E 6F EB 6C 81'
ooRexx>     ("No" || "EB"x || "l" || "81"x)~text("windows-1252")~c2g=                   -- '4E 6F EB 6C 81'
'4E 6F EB 6C 81'
ooRexx>     ("No" || "EB"x || "l" || "81"x)~text("windows-1252")~c2u=                   -- 'U+004E U+006F U+00EB U+006C U+0081'
'U+004E U+006F U+00EB U+006C U+0081'
ooRexx>     ("No" || "EB"x || "l" || "81"x)~text("windows-1252")~unicodecharacters==
an Array (shape [5], 5 items)
 1 : ( "N"   U+004E Lu 1 "LATIN CAPITAL LETTER N" )
 2 : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
 3 : ( "√´"   U+00EB Ll 1 "LATIN SMALL LETTER E WITH DIAERESIS" )
 4 : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
 5 : ( "¬Å"    U+0081 Cc 0 "", "HIGH OCTET PRESET", "HOP" )


-- ===============================================================================
-- 2023 Sep 27

/*
Add the named parameters 'stripCC' and 'stripNA' to all the methods supporting
the named parameter 'normalization'. This is utf8proc specific.
- stripCC: remove control characters (see utf8proc doc for more information:
  HorizontalTab (HT) and FormFeed (FF) are transformed into space)
- stripNA: remove unassigned codepoints
Example:
*/
ooRexx> .unicode["ESA"]=        -- ( "¬á"    U+0087 Cc 0 "", "END OF SELECTED AREA", "ESA"
( "¬á"    U+0087 Cc 0 "", "END OF SELECTED AREA", "ESA" )
ooRexx> .unicode["NBSP"]=       -- ( "¬†"   U+00A0 Zs 1 "NO-BREAK SPACE", "NBSP" )
( "¬†"   U+00A0 Zs 1 "NO-BREAK SPACE", "NBSP" )
ooRexx> .unicode["SSA"]=        -- ( "¬Ü"    U+0086 Cc 0 "", "START OF SELECTED AREA", "SSA"
( "¬Ü"    U+0086 Cc 0 "", "START OF SELECTED AREA", "SSA" )
ooRexx> .unicode["U+0378"]=     -- ( "Õ∏"   U+0378 Cn 1 "" )     unassigned
( "Õ∏"   U+0378 Cn 1 "" )

ooRexx> "\U{SSA}Mrs.\U{NBSP}ü§∂ a\u0378nd Mr.\U{NBSP}üéÖ\U{ESA}"~text~unescape=                                         -- T'¬ÜMrs.¬†ü§∂ aÕ∏nd Mr.¬†üéÖ
T'¬ÜMrs.¬†ü§∂ aÕ∏nd Mr.¬†üéÖ¬á'
ooRexx> "\U{SSA}Mrs.\U{NBSP}ü§∂ a\u0378nd Mr.\U{NBSP}üéÖ\U{ESA}"~text~unescape~c2g=                                     -- 'C286 4D 72 73 2E C2A0 F09FA4B6 20 61 CDB8 6E 64 20 4D 72 2E C2A0 F09F8E85 C287'
'C286 4D 72 73 2E C2A0 F09FA4B6 20 61 CDB8 6E 64 20 4D 72 2E C2A0 F09F8E85 C287'
ooRexx> "\U{SSA}Mrs.\U{NBSP}ü§∂ a\u0378nd Mr.\U{NBSP}üéÖ\U{ESA}"~text~unescape~transform(stripNA:)~c2g=                 -- 'C286 4D 72 73 2E C2A0 F09FA4B6 20 61      6E 64 20 4D 72 2E C2A0 F09F8E85 C287'
'C286 4D 72 73 2E C2A0 F09FA4B6 20 61 6E 64 20 4D 72 2E C2A0 F09F8E85 C287'
ooRexx> "\U{SSA}Mrs.\U{NBSP}ü§∂ a\u0378nd Mr.\U{NBSP}üéÖ\U{ESA}"~text~unescape~transform(stripNA:, stripCC:)~c2g=       -- '     4D 72 73 2E C2A0 F09FA4B6 20 61      6E 64 20 4D 72 2E C2A0 F09F8E85     '
'4D 72 73 2E C2A0 F09FA4B6 20 61 6E 64 20 4D 72 2E C2A0 F09F8E85'

ooRexx> "\U{SSA}Mrs.\U{NBSP}ü§∂ a\u0378nd Mr.\U{NBSP}üéÖ\U{ESA}"~text~unescape~pos("and")=                              -- 0
 0
ooRexx> "\U{SSA}Mrs.\U{NBSP}ü§∂ a\u0378nd Mr.\U{NBSP}üéÖ\U{ESA}"~text~unescape~pos("and", stripNA:)=                    -- 9
 9
ooRexx> "\U{SSA}Mrs.\U{NBSP}ü§∂ a\u0378nd Mr.\U{NBSP}üéÖ\U{ESA}"~text~unescape~pos("and", stripNA:, stripCC:)=          -- 9    yes! 9, not 8 because it's the EXTERNAL position
 9

ooRexx> "\U{SSA}Mrs.\U{NBSP}ü§∂ a\u0378nd Mr.\U{NBSP}üéÖ\U{ESA}"~text~unescape~caselessPos("mr.")=                      -- 14
 14
ooRexx> "\U{SSA}Mrs.\U{NBSP}ü§∂ a\u0378nd Mr.\U{NBSP}üéÖ\U{ESA}"~text~unescape~caselessPos("mr.", stripNA:)=            -- 14   yes! 14, not 13
 14
ooRexx> "\U{SSA}Mrs.\U{NBSP}ü§∂ a\u0378nd Mr.\U{NBSP}üéÖ\U{ESA}"~text~unescape~caselessPos("mr.", stripNA:, stripCC:)=  -- 14   yes! 14, not 12
 14

ooRexx> "\U{SSA}Mrs.\U{NBSP}ü§∂ a\u0378nd Mr.\U{NBSP}üéÖ\U{ESA}"~text~unescape~caselessPos("\U{SSA}"~text~unescape)=              -- 1
 1
ooRexx> "\U{SSA}Mrs.\U{NBSP}ü§∂ a\u0378nd Mr.\U{NBSP}üéÖ\U{ESA}"~text~unescape~caselessPos("\U{SSA}"~text~unescape, stripCC:)=    -- 0
 0

ooRexx> "\U{SSA}Mrs.\U{NBSP}ü§∂ a\u0378nd Mr.\U{NBSP}üéÖ\U{ESA}"~text~unescape~caselessPos("a\u0378nd"~text~unescape)=                        -- 9
 9
ooRexx> "\U{SSA}Mrs.\U{NBSP}ü§∂ a\u0378nd Mr.\U{NBSP}üéÖ\U{ESA}"~text~unescape~caselessPos("a\u0378nd"~text~unescape, stripCC:)=              -- 9
 9
ooRexx> "\U{SSA}Mrs.\U{NBSP}ü§∂ a\u0378nd Mr.\U{NBSP}üéÖ\U{ESA}"~text~unescape~caselessPos("a\u0378nd"~text~unescape, stripNA:)=              -- 9    yes! 9, not 0 because \u0378 is removed both in the needle and in thehaystack
 9
ooRexx> "\U{SSA}Mrs.\U{NBSP}ü§∂ a\u0378nd Mr.\U{NBSP}üéÖ\U{ESA}"~text~unescape~caselessPos("a\u0378nd"~text~unescape, stripNA:, stripCC:)=    -- 9    yes! 9, not 8
 9


/*
caselessEndsWith, endsWith: returns false if the start of the 'other' string is
not aligned with a character.
Examples
*/
ooRexx> "#√©√üÔ¨Ñ#‚Ä¶"~text~endsWith("‚Ä¶")=                      -- true
 1
ooRexx> "#√©√üÔ¨Ñ#‚Ä¶"~text~caselessEndsWith("‚Ä¶")=              -- true
 1

ooRexx> "#√©√üÔ¨Ñ#‚Ä¶"~text~endsWith("fl#‚Ä¶")=                   -- false, Ô¨Ñ remains Ô¨Ñ
 0
ooRexx> "#√©√üÔ¨Ñ#‚Ä¶"~text~caselessEndsWith("FL#‚Ä¶")=           -- false, Ô¨Ñ becomes ffl but FL is not aligned with ffl
 0

ooRexx> "#√©√üÔ¨Ñ#‚Ä¶"~text~endsWith("Ô¨Ñ#‚Ä¶")=                   -- true
 1
ooRexx> "#√©√üÔ¨Ñ#‚Ä¶"~text~caselessEndsWith("Ô¨Ñ#‚Ä¶")=           -- true
 1

ooRexx> "#√©√üÔ¨Ñ#‚Ä¶"~text~endsWith("ffl#‚Ä¶")=                  -- false, Ô¨Ñ remains Ô¨Ñ
 0
ooRexx> "#√©√üÔ¨Ñ#‚Ä¶"~text~caselessEndsWith("FFL#‚Ä¶")=          -- true,  Ô¨Ñ becomes ffl and FFL is aligned with ffl
 1

ooRexx> "#√©√üÔ¨Ñ#‚Ä¶"~text~endsWith("sÔ¨Ñ#‚Ä¶")=                  -- false, √ü remains √ü
 0
ooRexx> "#√©√üÔ¨Ñ#‚Ä¶"~text~caselessEndsWith("SÔ¨Ñ#‚Ä¶")=          -- false, √ü becomes ss but s is not aligned with ss
 0

ooRexx> "#√©√üÔ¨Ñ#‚Ä¶"~text~endsWith("√üÔ¨Ñ#‚Ä¶")=                  -- true
 1
ooRexx> "#√©√üÔ¨Ñ#‚Ä¶"~text~caselessEndsWith("√üÔ¨Ñ#‚Ä¶")=          -- true
 1

ooRexx> "#√©√üÔ¨Ñ#‚Ä¶"~text~endsWith("ssÔ¨Ñ#‚Ä¶")=                 -- false, √ü remains √ü
 0
ooRexx> "#√©√üÔ¨Ñ#‚Ä¶"~text~caselessEndsWith("SSÔ¨Ñ#‚Ä¶")=         -- true,  √ü becomes ss
 1

ooRexx> "#√©√üÔ¨Ñ#‚Ä¶"~text~endsWith("√©√üÔ¨Ñ#‚Ä¶")=                 -- true
 1
ooRexx> "#√©√üÔ¨Ñ#‚Ä¶"~text~caselessEndsWith("√âSSFFL#‚Ä¶")=       -- true
 1

ooRexx> "#√©√üÔ¨Ñ#‚Ä¶"~text~endsWith("#√©√üÔ¨Ñ#‚Ä¶")=                -- true
 1
ooRexx> "#√©√üÔ¨Ñ#‚Ä¶"~text~caselessEndsWith("#√âSSFFL#‚Ä¶")=      -- true
 1

ooRexx> "#e\U{COMBINING ACUTE ACCENT}√üÔ¨Ñ#‚Ä¶"~text~unescape~c2g=                                                                   -- '23 65CC81 C39F EFAC84 23 E280A6'
'23 65CC81 C39F EFAC84 23 E280A6'
ooRexx>   "\U{COMBINING ACUTE ACCENT}√üÔ¨Ñ#‚Ä¶"~text~unescape~c2g=                                                                   -- '     CC81 C39F EFAC84 23 E280A6'
'CC81 C39F EFAC84 23 E280A6'
ooRexx> "#e\U{COMBINING ACUTE ACCENT}√üÔ¨Ñ#‚Ä¶"~text~unescape~endsWith("\U{COMBINING ACUTE ACCENT}√üÔ¨Ñ#‚Ä¶"~text~unescape)=             -- false, not aligned with e\U{COMBINING ACUTE ACCENT}
 0

ooRexx> "#e\U{COMBINING ACUTE ACCENT}√üÔ¨Ñ#‚Ä¶"~text~unescape~casefold~c2g=                                                          -- '23 65CC81 73 73 66 66 6C 23 E280A6'
'23 65CC81 73 73 66 66 6C 23 E280A6'
ooRexx>   "\U{COMBINING ACUTE ACCENT}SSFFL#‚Ä¶"~text~unescape~casefold~c2g=                                                        -- '     CC81 73 73 66 66 6C 23 E280A6'
'CC81 73 73 66 66 6C 23 E280A6'
ooRexx> "#e\U{COMBINING ACUTE ACCENT}√üÔ¨Ñ#‚Ä¶"~text~unescape~caselessEndsWith("\U{COMBINING ACUTE ACCENT}SSFFL#‚Ä¶"~text~unescape)=   -- false, not aligned with e\U{COMBINING ACUTE ACCENT}
 0


/*
New 'RexxTextTransformer' class:
    - Converts positions in a transformed string to positions in the corresponding
      untransformed string. This is used for the caselessXXX methods which takes
      or return positions.
    - Supports inflating and deflating transformations.
      jlf 2023 Sep 28: better names are expansion and contraction.
    - The transformation can be made on a part of the string (from startC, for
      lengthC characters).
    - The methods for the transformation are the same as for RexxText:
      NFC, NFD, NFKC, NFKD, casefold, transform. The result is the instance of
      RexxTextTransformer, not the transformed text.
    - Only one call to a transformation method can be done. This is because the
      parameters of the transformation are memorized to re-apply internally the
      transformation character by character, when moving the cursors.
    - The 'transformer' method lets create an instance of RexxTextTransformer
      from a text.

    Example:
        - full text        = original text (untransformed)
        - external subtext = part of the full text to transform
        - internal subtext = transformed part of the full text

        The method ib2xc converts an internal byte (ib) position in the internal
        subtext (iSubtext) to an external character (xc) position in the external
        full text.
        ib2xc supports only growing positions. The only way to go backward is to
        use backupPos/restorePos or resetPos.

                                     --                          Transformed part of the full text
                                     --                       +-------------------------------------+               -- GLOBAL INDEXES (offsetC=3, offsetB=7)
                                     --  01   | 02   | 03     | 04 | 05     | 06    | 07       | 08 | 09            -- (external character indexes) <--------+
                                     --  1 2  | 3 4  | 5 6 7  | 8  | 9 0    | 1 2   | 3 4 5    | 6  | 7 8 9         -- (external byte indexes)               |
            "√©√üÔ¨Ñ#√©√üÔ¨Ñ#‚Ä¶"~text~c2g   --  C3A9 | C39F | EFAC84 | 23 | C3A9   | C39F  | EFAC84   | 23 | E280A6        -- (external bytes)                      |
                                     --  √©    | √ü    | Ô¨Ñ     | #  | √©      | √ü     | Ô¨Ñ       | #  | ‚Ä¶             -- (full text)                           ^
                                     --  1 2  | 3 4  | 5 6 7  | 8  | 9 0 1  | 2  3  | 4  5  6  | 7  | 8 9 0         -- (internal byte indexes, offset=7)     |
                                     --  C3A9 | C39F | EFAC84 | 23 | 65CC81 | 73 73 | 66 66 6C | 23 | E280A6        -- (internal bytes)                      |
                                                              +-------------------------------------+                                                        |
                                                                                                                    -- RELATIVE INDEXES                      |
                                                            --  01 | 02     | 03    | 04       | 05                 -- (external character indexes) <--------+
                                                            --  1  | 2 3    | 4 5   | 6 7 8    | 9                  -- (external byte indexes)               |
            "#√©√üÔ¨Ñ#"~text~c2g=                              --  23 | C3A9   | C39F  | EFAC84   | 23                 -- (external bytes)                      |
                                                            --  #  | √©      | √ü     | Ô¨Ñ       | #                  -- (external subtext)                    ^
                                                                                                                                                             |
                                                                                                                    -- RELATIVE INDEXES                      |
                                                            --  01 | 02     | 03 04 | 05 06 07 | 08                 -- (internal character indexes)          |
                                                            --  1  | 2 3 4  | 5  6  | 7  8  9  | 0                  -- (internal byte indexes) ------>-------+
            "#√©√üÔ¨Ñ#"~text~NFD(casefold:)~c2g=               --  23 | 65CC81 | 73 73 | 66 66 6C | 23                 -- (internal bytes)
                                                            --  #  | √©      | s  s  | f  f  l  | #                  -- (internal subtext)
*/
ooRexx> transformer = "√©√üÔ¨Ñ#√©√üÔ¨Ñ#‚Ä¶"~text~transformer(4, 5)~NFD(casefold:)
ooRexx> transformer~fulltext=       -- T'√©√üÔ¨Ñ#√©√üÔ¨Ñ#‚Ä¶'
T'√©√üÔ¨Ñ#√©√üÔ¨Ñ#‚Ä¶'
ooRexx> transformer~xSubtext=       -- T'#√©√üÔ¨Ñ#'
T'#√©√üÔ¨Ñ#'
ooRexx> transformer~iSubtext=       -- T'#eÃÅssffl#'
T'#eÃÅssffl#'

-- ib2xc supports only growing positions
ooRexx> transformer~ib2xc(1)=       -- 4    the internal byte position 1 in the internal subtext corresponds to the 4th external character in the full text
 4
ooRexx> transformer~ib2xc(7)=       -- 7
 7
ooRexx> transformer~ib2xc(2)=       -- Error RexxTextTransformer: You specified a byte position (2) lower than the previous one (7).
RexxTextTransformer: You specified a byte position (2) lower than the previous one (7).
Error code= 93.900

-- The previous error is avoided by backuping/restoring the current position
ooRexx> transformer~resetPos        -- reset to allow iteration again from internal byte position 1
ooRexx> transformer~ib2xc(1)=       -- 4
 4
ooRexx> transformer~backupPos
ooRexx> transformer~ib2xc(7)=       -- 7
 7
ooRexx> transformer~restorePos
ooRexx> transformer~ib2xc(2)=       -- 5
 5

ooRexx> transformer~resetPos
ooRexx> do i=1 to transformer~iSubtext~string~length; say "byte pos" i~right(2) "    character pos=" transformer~ib2xc(i)~string~left(20) transformer~ib2xc(i, aligned:.false); end
byte pos  1     character pos= 4                    +4.8
byte pos  2     character pos= 5                    +5.9
byte pos  3     character pos= -5                   -5.10
byte pos  4     character pos= -5                   -5.11
byte pos  5     character pos= 6                    +6.12
byte pos  6     character pos= -6                   -6.13
byte pos  7     character pos= 7                    +7.14
byte pos  8     character pos= -7                   -7.15
byte pos  9     character pos= -7                   -7.16
byte pos 10     character pos= 8                    +8.17
/*
    byte pos  1     character pos= 4                    +4.8    -- the 8th internal byte is aligned with the 4th external character
    byte pos  2     character pos= 5                    +5.9
    byte pos  3     character pos= The NIL object       -5.10   -- the 10th internal byte is part of the 5th external character, but is not aligned with it.
    byte pos  4     character pos= The NIL object       -5.11
    byte pos  5     character pos= 6                    +6.12
    byte pos  6     character pos= The NIL object       -6.13
    byte pos  7     character pos= 7                    +7.14
    byte pos  8     character pos= The NIL object       -7.15
    byte pos  9     character pos= The NIL object       -7.16
    byte pos 10     character pos= 8                    +8.17
*/
/*
    More details on positions mappings.
    transformer~iSubtext is the transformed part of the full text.
    The internal relative byte position 1 becomes the internal global byte position 8:
        There are 7 bytes (offsetB=7) before the part to transform: 1 + 7 = 8.
        It's the same offsetB=7 for external and internal bytes, because this part is not transformed.
        Remember:
        It doesn't make sense to return the external byte position, because some internal byte positions
        have no corresponding external byte position. For example the internal global byte position 11.
        For diagnostics and analysis, only internal byte positions are relevant.
    The external relative character position 1 becomes the external global character position 4:
        There are 3 characters (offsetC=3) before the part to transform: 1 + 3 = 4.
        It's the same offsetC=3 for external and internal characters, because this part is not transformed.
        Remember:
        The user works only with external global character positions.
        It wouldn't make sense to return internal character positions.
    Example of alignment:
        The internal relative byte position 1 becomes the internal global byte position 8,
        is part of the 4th external character and is aligned with it.
    Example of non-alignment:
        The internal relative byte position 3 becomes the internal global byte position 10,
        is part of the 5th external character and is not aligned with it.
*/


-- ===============================================================================
-- 2023 Sep 16

/*
Relax the constraint "self~isCompatibleWithByteString" when converting a RexxText
to a String.
That allows to go further in the tests of regular expression.
*/
ooRexx> unckeckedConversionToString = .Unicode~unckeckedConversionToString -- backup
ooRexx> .Unicode~unckeckedConversionToString = .true


-- bug in regex.cls
ooRexx> p = .Pattern~compile("(.)*foo")
ooRexx> p~matches("xfooxxxxxxfooXXXX")=         -- Invalid position argument specified; found "0".
Invalid position argument specified; found "0".
Error code= 93.924


-- False success in text mode
-- "√†" is 2 bytes 'C3A0', "üéÖ" is 4 bytes 'F09F8E85'
-- When compiling a String then each of the bytes of "√†" or "üéÖ" become candidate for matching
-- When compiling a RexxText then only the sequence of all the bytes of "√†" or "üéÖ" should match... But that's not the case.
ooRexx> pB = .Pattern~compile("[√†büéÖ]")
ooRexx> pT = .Pattern~compile("[√†büéÖ]"~text)
ooRexx> pB~startsWith('√†XXXX')=                             -- 1
 1
ooRexx> pT~startsWith('√†XXXX'~text)=                        -- 1 but matched only C3
 1
ooRexx> pB~startsWith('bXXXX')=                             -- 1
 1
ooRexx> pT~startsWith('bXXXX'~text)=                        -- 1
 1
ooRexx> pB~startsWith('üéÖXXXX')=                            -- 1
 1
ooRexx> pT~startsWith('üéÖXXXX'~text)=                       -- 1
 1
ooRexx> pB~startsWith('F0'x || 'XXXX')=                     -- 1
 1
ooRexx> pT~startsWith('F0'x || 'XXXX'~text)=                -- Invalid UTF-8 string (raised by utf8proc)
Invalid UTF-8 string.
Error code= 22.900
ooRexx> pT~startsWith('F0'x || 'XXXX')=                     -- 1 (not good)
 1
ooRexx> pB~startsWith('9F'x || 'XXXX')=                     -- 1
 1
ooRexx> pT~startsWith('9F'x || 'XXXX'~text)=                -- Invalid UTF-8 string (raised by utf8proc)
Invalid UTF-8 string.
Error code= 22.900
ooRexx> pT~startsWith('9F'x || 'XXXX')=                     -- 1 (not good)
 1


-- greedy pattern
ooRexx> pB = .Pattern~compile("(.)*f√¥üéÖ")
ooRexx> pT = .Pattern~compile("(.)*f√¥üéÖ"~text)
ooRexx> pB~matches("xfooxxxxxxf√¥üéÖ")=                        -- 1
 1
ooRexx> pT~matches("xfooxxxxxxf√¥üéÖ"~text)=                   -- 1
 1
ooRexx> pB~startsWith("xfooxxxxxxf√¥üéÖ")=                     -- 1
 1
ooRexx> pT~startsWith("xfooxxxxxxf√¥üéÖ"~text)=                -- 1
 1


-- zero or one occurrances of "a"
ooRexx> pB = .Pattern~compile("a?")
ooRexx> pT = .Pattern~compile("a?"~text)
ooRexx> pB~matches("")=                                     -- 1
 1
ooRexx> pT~matches(""~text)=                                -- 1
 1
ooRexx> pB~matches("a")=                                    -- 1
 1
ooRexx> pT~matches("a"~text)=                               -- 1
 1
ooRexx> pB~matches("aa")=                                   -- 0
 0
ooRexx> pT~matches("aa"~text)=                              -- 0
 0


-- zero or one occurrances of "üéÖ"
ooRexx> pB = .Pattern~compile("üéÖ?")
ooRexx> pT = .Pattern~compile("üéÖ?"~text)
ooRexx> pB~matches("")=                                     -- 0 (KO)
 0
ooRexx> pT~matches(""~text)=                                -- 1
 1
ooRexx> pB~matches("üéÖ")=                                   -- 1
 1
ooRexx> pT~matches("üéÖ"~text)=                              -- 1
 1
ooRexx> pB~matches("üéÖüéÖ")=                                 -- 0
 0
ooRexx> pT~matches("üéÖüéÖ"~text)=                            -- 0
 0


-- exactly 3 occurrences of "a"
ooRexx> pB = .Pattern~compile("a{3}")
ooRexx> pT = .Pattern~compile("a{3}"~text)
ooRexx> pB~matches("aa")=                                   -- 0
 0
ooRexx> pT~matches("aa"~text)=                              -- 0
 0
ooRexx> pB~matches("aaa")=                                  -- 1
 1
ooRexx> pT~matches("aaa"~text)=                             -- 1
 1
ooRexx> pB~matches("aaaa")=                                 -- 0
 0
ooRexx> pT~matches("aaaa"~text)=                            -- 0
 0


-- exactly 3 occurrences of "üéÖ"
ooRexx> pB = .Pattern~compile("üéÖ{3}")
ooRexx> pT = .Pattern~compile("üéÖ{3}"~text)
ooRexx> pB~matches("üéÖüéÖ")=                                 -- 0
 0
ooRexx> pT~matches("üéÖüéÖ"~text)=                            -- 0
 0
ooRexx> pB~matches("üéÖüéÖüéÖ")=                               -- 0    KO
 0
ooRexx> pT~matches("üéÖüéÖüéÖ"~text)=                          -- 1
 1
ooRexx> pB~matches("üéÖüéÖüéÖüéÖ")=                             -- 0
 0
ooRexx> pT~matches("üéÖüéÖüéÖüéÖ"~text)=                        -- 0
 0


-- repetitive "b" in the middle
ooRexx> pB = .Pattern~compile("ab{2}c")
ooRexx> pT = .Pattern~compile("ab{2}c"~text)
ooRexx> pB~matches("ac")=                                   -- 0
 0
ooRexx> pT~matches("ac"~text)=                              -- 0
 0
ooRexx> pB~matches("abc")=                                  -- 0
 0
ooRexx> pT~matches("abc"~text)=                             -- 0
 0
ooRexx> pB~matches("abbc")=                                 -- 1
 1
ooRexx> pT~matches("abbc"~text)=                            -- 1
 1
ooRexx> pB~matches("abbbc")=                                -- 0
 0
ooRexx> pT~matches("abbbc"~text)=                           -- 0
 0


-- repetitive "üéÖ" in the middle
ooRexx> pB = .Pattern~compile("aüéÖ{2}c")
ooRexx> pT = .Pattern~compile("aüéÖ{2}c"~text)
ooRexx> pB~matches("ac")=                                   -- 0
 0
ooRexx> pT~matches("ac"~text)=                              -- 0
 0
ooRexx> pB~matches("aüéÖc")=                                 -- 0
 0
ooRexx> pT~matches("aüéÖc"~text)=                            -- 0
 0
ooRexx> pB~matches("aüéÖüéÖc")=                               -- 0 (KO)
 0
ooRexx> pT~matches("aüéÖüéÖc"~text)=                          -- 1
 1
ooRexx> pB~matches("aüéÖüéÖüéÖc")=                             -- 0
 0
ooRexx> pT~matches("aüéÖüéÖüéÖc"~text)=                        -- 0
 0


-- "a" or "b"
ooRexx> pB = .Pattern~compile("a|b")
ooRexx> pT = .Pattern~compile("a|b"~text)
ooRexx> pB~matches("a")=                                    -- 1
 1
ooRexx> pT~matches("a"~text)=                               -- 1
 1
ooRexx> pB~matches("b")=                                    -- 1
 1
ooRexx> pT~matches("b"~text)=                               -- 1
 1
ooRexx> pB~matches("c")=                                    -- 0
 0
ooRexx> pT~matches("c"~text)=                               -- 0
 0
ooRexx> pB~startsWith("abc")=                               -- 1
 1
ooRexx> pT~startsWith("abc"~text)=                          -- 1
 1
ooRexx> pB~startsWith("bac")=                               -- 1
 1
ooRexx> pT~startsWith("bac"~text)=                          -- 1
 1
ooRexx> r = pB~find("xxxabcxxx")
ooRexx> r~matched=; r~start=; r~end=; r~text=; r~length=
 1
 4
 5
'a'
 1
ooRexx> r = pT~find("xxxabcxxx"~text)
ooRexx> r~matched=; r~start=; r~end=; r~text=; r~length=
 1
 4
 5
T'a'
 1
ooRexx> r = pB~find("xxxbacxxx")
ooRexx> r~matched=; r~start=; r~end=; r~text=; r~length=
 1
 4
 5
'b'
 1
ooRexx> r = pT~find("xxxbacxxx"~text)
ooRexx> r~matched=; r~start=; r~end=; r~text=; r~length=
 1
 4
 5
T'b'
 1


-- "ü§∂" or "üéÖ"
ooRexx> pB = .Pattern~compile("ü§∂|üéÖ")
ooRexx> pT = .Pattern~compile("ü§∂|üéÖ"~text)
ooRexx> pB~matches("ü§∂")=                                   -- 1
 1
ooRexx> pT~matches("ü§∂"~text)=                              -- 1
 1
ooRexx> pB~matches("üéÖ")=                                   -- 1
 1
ooRexx> pT~matches("üéÖ"~text)=                              -- 1
 1
ooRexx> pB~matches("c")=                                    -- 0
 0
ooRexx> pT~matches("c"~text)=                               -- 0
 0
ooRexx> pB~startsWith("ü§∂üéÖc")=                             -- 1
 1
ooRexx> pT~startsWith("ü§∂üéÖc"~text)=                        -- 1
 1
ooRexx> pB~startsWith("üéÖü§∂c")=                             -- 1
 1
ooRexx> pT~startsWith("üéÖü§∂c"~text)=                        -- 1
 1
ooRexx> r = pB~find("xxxü§∂üéÖcxxx")
ooRexx> r~matched=; r~start=; r~end=; r~text=; r~length=
 1
 4
 8
'ü§∂'
 4
ooRexx> r = pT~find("xxxü§∂üéÖcxxx"~text)
ooRexx> r~matched=; r~start=; r~end=; r~text=; r~length=
 1
 4
 5
T'ü§∂'
 1
ooRexx> r = pB~find("xxxüéÖü§∂cxxx")
ooRexx> r~matched=; r~start=; r~end=; r~text=; r~length=
 1
 4
 8
'üéÖ'
 4
ooRexx> r = pT~find("xxxüéÖü§∂cxxx"~text)
ooRexx> r~matched=; r~start=; r~end=; r~text=; r~length=
 1
 4
 5
T'üéÖ'
 1


ooRexx> .Unicode~unckeckedConversionToString = unckeckedConversionToString -- restore


-- ===============================================================================
-- 2023 Sep 14

/*
Fix implementation of caselessPos, pos for ligatures.
The results were not good for some byte indexes when using aligned:.false
*/

--------------
-- test case 1
--------------
-- pos with ligature "Ô¨Ñ" in strict mode (default)

ooRexx> "b√¢Ô¨Ñ√©"~text~c2u=                            -- 'U+0062 U+00E2 U+FB04 U+00E9'
'U+0062 U+00E2 U+FB04 U+00E9'

/*
                                             --  01 | 02   | 03     | 04     (external grapheme indexes)
                                             --  1  | 2 3  | 4 5 6  | 7 8    (external byte indexes)
"b√¢Ô¨Ñ√©"~text~c2g=                            -- '62 | C3A2 | EFAC84 | C3A9'
                                             --  b  | √¢    | Ô¨Ñ     | √©
*/

ooRexx> "b√¢Ô¨Ñ√©"~text~pos("√©")=                       -- 4
 4
ooRexx> "b√¢Ô¨Ñ√©"~text~pos("e")=                       -- 0
 0
ooRexx> "b√¢Ô¨Ñ√©"~text~pos("e", stripMark:)=           -- 4
 4
ooRexx> "b√¢Ô¨Ñ√©"~text~pos("f")=                       -- 0 because in strict mode, "Ô¨Ñ" remains U+FB04
 0
ooRexx> "b√¢Ô¨Ñ√©"~text~pos("f", asList:, overlap:, aligned:.false)=  -- a List (0 items)
a List (0 items)

--------------
-- test case 2
--------------
-- caselessPos with ligature "Ô¨Ñ" in strict mode (default)
-- (apply casefold internally but returns external indexes)
-- The ligature is decomposed by casefold.

/*
                                             --  01 | 02   | 03       | 04     (external grapheme indexes)
                                             --  1  | 2 3  | 4 5 6    | 7 8    (external byte indexes)
"b√¢Ô¨Ñ√©"~text~c2g=                            -- '62 | C3A2 | EFAC84   | C3A9'
                                             --  b  | √¢    | Ô¨Ñ       | √©

                                             --  01 | 02   | 03 04 05 | 06     (internal grapheme indexes)
                                             --  1  | 2 3  | 4  5  6  | 7 8    (internal byte indexes)
"b√¢Ô¨Ñ√©"~text~casefold~c2g=                   -- '62 | C3A2 | 66 66 6C | C3A9'
                                             --  b  | √¢    | f  f  l  | √©
*/

ooRexx> "b√¢Ô¨Ñ√©"~text~caselessPos("√â")=               -- 4
 4
ooRexx> "b√¢Ô¨Ñ√©"~text~caselessPos("E")=               -- 0
 0
ooRexx> "b√¢Ô¨Ñ√©"~text~caselessPos("E", stripMark:)=   -- 4
 4
ooRexx> "b√¢Ô¨Ñ√©"~text~caselessPos("F")=               -- 0 because "F" matches only a subset of "Ô¨Ñ"-->"ffl"
 0
ooRexx> "b√¢Ô¨Ñ√©"~text~caselessPos("FF")=              -- 0 because "FF" matches only a subset of "Ô¨Ñ"-->"ffl"
 0
ooRexx> "b√¢Ô¨Ñ√©"~text~caselessPos("FL")=              -- 0 because "FL" matches only a subset of "Ô¨Ñ"-->"ffl"
 0
ooRexx> "b√¢Ô¨Ñ√©"~text~caselessPos("FFL")=             -- 3 because "FFL" matches all of "Ô¨Ñ"-->"ffl"
 3
ooRexx> "b√¢Ô¨Ñ√©"~text~caselessPos("F", asList:, overlap:, aligned:.false)=
a List (2 items)
 0 : [+3.4,-3.5]
 1 : [-3.5,-3.6]
ooRexx> "b√¢Ô¨ÑÔ¨Ñ√©"~text~caselessPos("√â")=              -- 5
 5
ooRexx> "b√¢Ô¨ÑÔ¨Ñ√©"~text~caselessPos("FFL", asList:, overlap:, aligned:.false)=
a List (2 items)
 0 : [+3.4,+4.7]
 1 : [+4.7,+5.10]
ooRexx> "b√¢Ô¨ÑÔ¨Ñ√©"~text~caselessPos("F", asList:, overlap:, aligned:.false)=
a List (4 items)
 0 : [+3.4,-3.5]
 1 : [-3.5,-3.6]
 2 : [+4.7,-4.8]
 3 : [-4.8,-4.9]
ooRexx> "b√¢Ô¨ÑÔ¨Ñ√©"~text~caselessPos("FLFF")=                   -- 0
 0
ooRexx> "b√¢Ô¨ÑÔ¨Ñ√©"~text~caselessPos("FLFF", aligned:.false)=   -- [-3.5,-4.9]
[-3.5,-4.9]
ooRexx> "b√¢Ô¨ÑÔ¨Ñ√©"~text~caselessPos("FFLFFL")=                 -- 3
 3

--------------
-- test case 3
--------------
-- pos with ligature "Ô¨Ñ" in non-strict mode
-- (in non-strict mode, the normalization is NFKD, but returns external indexes)
-- The ligature is decomposed by NFKD

/*
                                             --  01 | 02     | 03       | 04     (external grapheme indexes)
                                             --  1  | 2 3    | 4 5 6    | 7 8    (external byte indexes)
"b√¢Ô¨Ñ√©"~text~c2g=                            -- '62 | C3A2   | EFAC84   | C3A9'
                                             --  b  | √¢      | Ô¨Ñ       | √©

                                             --  01 | 02     | 03 04 05 | 06     (internal grapheme indexes)
                                             --  1  | 2 3 4  | 5  6  7  | 8 9 0  (internal byte indexes)
"b√¢Ô¨Ñ√©"~text~NFKD~c2g=                       -- '62 | 61CC82 | 66 66 6C | 65CC81'
                                             --  b  | a ^    | f  f  l  | e ¬¥
*/

ooRexx> "b√¢Ô¨Ñ√©"~text~pos("√©", strict:.false)=                -- 4
 4
ooRexx> "b√¢Ô¨Ñ√©"~text~pos("e", strict:.false)=                -- 0
 0
ooRexx> "b√¢Ô¨Ñ√©"~text~pos("e", strict:.false, stripMark:)=    -- 4
 4
ooRexx> "b√¢Ô¨Ñ√©"~text~pos("f", strict:.false)=                -- 0 because "f" matches only a subset of "Ô¨Ñ"-->"ffl"
 0
ooRexx> "b√¢Ô¨Ñ√©"~text~pos("ff", strict:.false)=               -- 0 because "ff" matches only a subset of "Ô¨Ñ"-->"ffl"
 0
ooRexx> "b√¢Ô¨Ñ√©"~text~pos("ffl", strict:.false)=              -- 3 because "ffl" matches all of "Ô¨Ñ"-->"ffl"
 3
ooRexx> "b√¢Ô¨Ñ√©"~text~pos("f", strict:.false, asList:, overlap:, aligned:.false)=
a List (2 items)
 0 : [+3.5,-3.6]
 1 : [-3.6,-3.7]
ooRexx> "b√¢Ô¨ÑÔ¨Ñ√©"~text~pos("√©", strict:.false)=               -- 5
 5
ooRexx> "b√¢Ô¨ÑÔ¨Ñ√©"~text~pos("ffl", strict:.false, asList:, overlap:, aligned:.false)=
a List (2 items)
 0 : [+3.5,+4.8]
 1 : [+4.8,+5.11]
ooRexx> "b√¢Ô¨ÑÔ¨Ñ√©"~text~pos("f", strict:.false, asList:, overlap:, aligned:.false)=
a List (4 items)
 0 : [+3.5,-3.6]
 1 : [-3.6,-3.7]
 2 : [+4.8,-4.9]
 3 : [-4.9,-4.10]
ooRexx> "b√¢Ô¨ÑÔ¨Ñ√©"~text~pos("flff", strict:.false)=                    -- 0
 0
ooRexx> "b√¢Ô¨ÑÔ¨Ñ√©"~text~pos("flff", strict:.false, aligned:.false)=    -- [-3.6,-4.10]
[-3.6,-4.10]
ooRexx> "b√¢Ô¨ÑÔ¨Ñ√©"~text~pos("fflffl", strict:.false)=                  -- 3
 3

--------------
-- test case 4
--------------
-- caselessPos with ligature "Ô¨Ñ" in non-strict mode
-- (apply casefold internally but returns external indexes)
-- (in non-strict mode, the normalization is NFKD, but returns external indexes)
-- The ligature is decomposed both by casefold and by NFKD.

/*
                                             --  01 | 02     | 03       | 04     (external grapheme indexes)
                                             --  1  | 2 3    | 4 5 6    | 7 8    (external byte indexes)
"b√¢Ô¨Ñ√©"~text~c2g=                            -- '62 | C3A2   | EFAC84   | C3A9'
                                             --  b  | √¢      | Ô¨Ñ       | √©

                                             --  01 | 02     | 03 04 05 | 06     (internal grapheme indexes)
                                             --  1  | 2 3 4  | 5  6  7  | 8 9 0  (internal byte indexes)
"b√¢Ô¨Ñ√©"~text~NFKD~c2g=                       -- '62 | 61CC82 | 66 66 6C | 65CC81'
                                             --  b  | a ^    | f  f  l  | e ¬¥
*/

ooRexx> "b√¢Ô¨Ñ√©"~text~caselessPos("√â", strict:.false)=               -- 4
 4
ooRexx> "b√¢Ô¨Ñ√©"~text~caselessPos("E", strict:.false)=               -- 0
 0
ooRexx> "b√¢Ô¨Ñ√©"~text~caselessPos("E", strict:.false, stripMark:)=   -- 4
 4
ooRexx> "b√¢Ô¨Ñ√©"~text~caselessPos("F", strict:.false)=               -- 0 because "F" matches only a subset of "Ô¨Ñ"-->"ffl"
 0
ooRexx> "b√¢Ô¨Ñ√©"~text~caselessPos("FF", strict:.false)=              -- 0 because "FF" matches only a subset of "Ô¨Ñ"-->"ffl"
 0
ooRexx> "b√¢Ô¨Ñ√©"~text~caselessPos("FFL", strict:.false)=             -- 3 because "FFL" matches all of "Ô¨Ñ"-->"ffl"
 3
ooRexx> "b√¢Ô¨Ñ√©"~text~caselessPos("F", strict:.false, asList:, overlap:, aligned:.false)=
a List (2 items)
 0 : [+3.5,-3.6]
 1 : [-3.6,-3.7]
ooRexx> "b√¢Ô¨ÑÔ¨Ñ√©"~text~caselessPos("√â", strict:.false)=              -- 5
 5
ooRexx> "b√¢Ô¨ÑÔ¨Ñ√©"~text~caselessPos("FFL", strict:.false, asList:, overlap:, aligned:.false)=
a List (2 items)
 0 : [+3.5,+4.8]
 1 : [+4.8,+5.11]
ooRexx> "b√¢Ô¨ÑÔ¨Ñ√©"~text~caselessPos("F", strict:.false, asList:, overlap:, aligned:.false)=
a List (4 items)
 0 : [+3.5,-3.6]
 1 : [-3.6,-3.7]
 2 : [+4.8,-4.9]
 3 : [-4.9,-4.10]
ooRexx> "b√¢Ô¨ÑÔ¨Ñ√©"~text~caselessPos("FLFF", strict:.false)=                    -- 0
 0
ooRexx> "b√¢Ô¨ÑÔ¨Ñ√©"~text~caselessPos("FLFF", strict:.false, aligned:.false)=    -- [-3.6,-4.10]
[-3.6,-4.10]
ooRexx> "b√¢Ô¨ÑÔ¨Ñ√©"~text~caselessPos("FFLFFL", strict:.false)=                  -- 3
 3


-- ===============================================================================
-- 2023 Sep 11

/*
casefold now supports the option stripMark.

Rework the implementation of caselessPos, pos.
- Thanks to Raku and Chrome, I realize that a matching should be succesful only
  if all the bytes of a grapheme are matched.
- New named argument 'asList', to return a list of positions
  (similar to Raku's method .indices).
- New named argument overlap: (same as Raku)
  If the optional named argument 'overlap' is specified, the search continues
  from the position directly following the previous match, otherwise the search
  will continue after the previous match.
*/

/*
Remember:
aligned=.false is intended for analysis of matchings and [non-]regression tests.
Otherwise, I don't see any use.
When aligned:.false, a returned position has the form +/-posC.posB where posB is
the position of the matched byte in the transformed haystack, and posC is the
corresponding grapheme position in the untransformed haystack.
Don't use trunc(abs(position)) because you may need up to numeric digits 40:
    position max can be +/-(2**64-1)||"."||(2**64-1)
Use instead:
    if position~matchChar(1, "+-") then parse var position 2 posC "." posB
*/

/*
Additional test cases to cover corner cases for caselessPos, pos.
*/

--------------
-- test case 1
--------------
-- case no overlap versus overlap

/*
                                --  01   | 02   | 03   | 04   | 05   | 06
                                --  1 2  | 3 4  | 5 6  | 7 8  | 9 0  | 1 2
"√†√†√†√†√†√†"~text~c2g=              -- 'C3A0 | C3A0 | C3A0 | C3A0 | C3A0 | C3A0'
                                --  √†    | √†    | √†    | √†    | √†    | √†

                                --  01   | 02   | 03   | 04   | 05   | 06
                                --  1 2  | 3 4  | 5 6  | 7 8  | 9 0  | 1 2
"√†√†√†√†√†√†"~text~casefold~c2g=     -- 'C3A0 | C3A0 | C3A0 | C3A0 | C3A0 | C3A0'
                                --  √†    | √†    | √†    | √†    | √†    | √†
*/

ooRexx> "√†√†√†√†√†√†"~text~caselessPos("aa", stripMark:)=                                    -- 1
 1
ooRexx> "√†√†√†√†√†√†"~text~caselessPos("aa", stripMark:, asList:)~allItems=                  -- [ 1, 3, 5]
[ 1, 3, 5]
ooRexx> "√†√†√†√†√†√†"~text~caselessPos("aa", stripMark:, asList:, overlap:)~allItems=        -- [ 1, 2, 3, 4, 5]
[ 1, 2, 3, 4, 5]
ooRexx> "√†√†√†√†√†√†"~text~caselessPos("aa", stripMark:, asList:, aligned:.false)=
a List (3 items)
 0 : [+1.1,+3.3]
 1 : [+3.3,+5.5]
 2 : [+5.5,+7.7]
ooRexx> "√†√†√†√†√†√†"~text~caselessPos("aa", stripMark:, asList:, overlap:, aligned:.false)=
a List (5 items)
 0 : [+1.1,+3.3]
 1 : [+2.2,+4.4]
 2 : [+3.3,+5.5]
 3 : [+4.4,+6.6]
 4 : [+5.5,+7.7]

--------------
-- test case 2
--------------
-- case where the end of the matching is inside the untransformed grapheme

/*
                            --  01
                            --  1 2
"√ü"~text~c2g=               -- 'C39F'
                            --  √ü

                            --  01 02
                            --  1  2
"√ü"~text~casefold~c2g=      -- '73 73'
                            --  s  s
*/

ooRexx> "√ü"~text~caselessPos("s")=                                  -- 0, not 1 because 1 would match only the first byte of "√ü"-->"ss"
 0
ooRexx> "√ü"~text~caselessPos("s", asList:)=                         -- a List (0 items)
a List (0 items)
ooRexx> "√ü"~text~caselessPos("s", asList:, overlap:)=               -- a List (0 items)
a List (0 items)
ooRexx> "√ü"~text~caselessPos("s", asList:, aligned:.false)=
a List (2 items)
 0 : [+1.1,-1.2]
 1 : [-1.2,+2.3]
ooRexx> "√ü"~text~caselessPos("s", asList:, overlap:, aligned:.false)=
a List (2 items)
 0 : [+1.1,-1.2]
 1 : [-1.2,+2.3]

/*
                            --  01 | 02
                            --  1  | 2 3
"s√ü"~text~c2g=              -- '73 | C39F'
                            --  s  | √ü

                            --  01 | 02 03
                            --  1  | 2  3
"s√ü"~text~casefold~c2g=     -- '73 | 73 73'
                            --  s  | s  s
*/

ooRexx> "s√ü"~text~caselessPos("ss")=                                -- 2, not 1 because 1 would match only the first byte of "√ü"-->"ss"
 2
ooRexx> "s√ü"~text~caselessPos("ss", asList:)~allItems=              -- [ 2]
[ 2]
ooRexx> "s√ü"~text~caselessPos("ss", asList:, overlap:)~allItems=    -- [ 2]
[ 2]
ooRexx> "s√ü"~text~caselessPos("ss", asList:, aligned:.false)=
a List (1 items)
 0 : [+1.1,-2.3]
ooRexx> "s√ü"~text~caselessPos("ss", asList:, overlap:, aligned:.false)=
a List (2 items)
 0 : [+1.1,-2.3]
 1 : [+2.2,+3.4]

/*
                            --  01 | 02    | 03
                            --  1  | 2 3   | 4
"s√üs"~text~c2g=             -- '73 | C39F  | 73'
                            --  s  | √ü     | s

                            --  01 | 02 03 | 04
                            --  1  | 2  3  | 4
"s√üs"~text~casefold~c2g=    -- '73 | 73 73 | 73'
                            --  s  | s  s  | s
*/

ooRexx> "s√üs"~text~caselessPos("s", 2)=                             -- 3, not 2 because 2 would match only the first byte of "√ü"-->"ss"
 3
ooRexx> "s√üs"~text~caselessPos("s", 2, asList:)~allItems=           -- [ 3]
[ 3]
ooRexx> "s√üs"~text~caselessPos("s", 2, asList:, overlap:)~allItems= -- [ 3]
[ 3]
ooRexx> "s√üs"~text~caselessPos("s", 2, asList:, aligned:.false)=
a List (3 items)
 0 : [+2.2,-2.3]
 1 : [-2.3,+3.4]
 2 : [+3.4,+4.5]
ooRexx> "s√üs"~text~caselessPos("s", 2, asList:, overlap:, aligned:.false)=
a List (3 items)
 0 : [+2.2,-2.3]
 1 : [-2.3,+3.4]
 2 : [+3.4,+4.5]

ooRexx> "s√üs"~text~caselessPos("ss")=                               -- 2, not 1 because 1 would match only the first byte of "√ü"-->"ss"
 2
ooRexx> "s√üs"~text~caselessPos("ss", asList:)~allItems=             -- [ 2]
[ 2]
ooRexx> "s√üs"~text~caselessPos("ss", asList:, overlap:)~allItems=   -- [ 2]
[ 2]
ooRexx> "s√üs"~text~caselessPos("ss", asList:, aligned:.false)=
a List (2 items)
 0 : [+1.1,-2.3]
 1 : [-2.3,+4.5]
ooRexx> "s√üs"~text~caselessPos("ss", asList:, overlap:, aligned:.false)=
a List (3 items)
 0 : [+1.1,-2.3]
 1 : [+2.2,+3.4]
 2 : [-2.3,+4.5]

--------------
-- test case 3
--------------
-- caselessPos (apply casefold internally but returns external indexes)
-- search 1 character, no overlap when searching a single character.

/*
                                                        --  01 | 02 | 03 | 04 | 05 | 06 | 07 | 08 | 09 | 10 | 11    | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19    | 20 | 21 | 22 | 23
                                                        --  1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 0  | 1 2   | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 0 1   | 2  | 3  | 4  | 5
"Bundesstra√üe sss s√üs ss"~text~c2g=                     -- '42 | 75 | 6E | 64 | 65 | 73 | 73 | 74 | 72 | 61 | C39F  | 65 | 20 | 73 | 73 | 73 | 20 | 73 | C39F  | 73 | 20 | 73 | 73'
                                                        --  B  | u  | n  | d  | e  | s  | s  | t  | r  | a  | √ü     | e  | _  | s  | s  | s  | _  | s  | √ü     | s  | _  | s  | s
                                                        --                           ^    ^                   ^                 ^    ^    ^         ^    ^       ^         ^    ^

                                                        --  01 | 02 | 03 | 04 | 05 | 06 | 07 | 08 | 09 | 10 | 11    | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19    | 20 | 21 | 22 | 23
                                                        --  1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 0  | 1  2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 0  1  | 2  | 3  | 4  | 5
"Bundesstra√üe sss s√üs ss"~text~casefold~c2g=            -- '62 | 75 | 6E | 64 | 65 | 73 | 73 | 74 | 72 | 61 | 73 73 | 65 | 20 | 73 | 73 | 73 | 20 | 73 | 73 73 | 73 | 20 | 73 | 73'
                                                        --  B  | u  | n  | d  | e  | s  | s  | t  | r  | a  | √ü     | e  | _  | s  | s  | s  | _  | s  | √ü     | s  | _  | s  | s
*/

ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("s")=        -- 6
 6
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("s", 7)=     -- 7
 7
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("s", 8)=     -- 14
 14
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("s", 15)=    -- 15
 15
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("s", 16)=    -- 16
 16
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("s", 17)=    -- 18
 18
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("s", 19)=    -- 20
 20
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("s", 21)=    -- 22
 22
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("s", 23)=    -- 23
 23
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("s", 24)=    -- 0
 0
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("s", asList:)~allItems=              -- [ 6, 7, 14, 15, 16, 18, 20, 22, 23]
[ 6, 7, 14, 15, 16, 18, 20, 22, 23]
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("s", asList:, overlap:)~allItems=    -- [ 6, 7, 14, 15, 16, 18, 20, 22, 23]
[ 6, 7, 14, 15, 16, 18, 20, 22, 23]
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("s", asList:, aligned:.false)=
a List (13 items)
 0  : [+6.6,+7.7]
 1  : [+7.7,+8.8]
 2  : [+11.11,-11.12]
 3  : [-11.12,+12.13]
 4  : [+14.15,+15.16]
 5  : [+15.16,+16.17]
 6  : [+16.17,+17.18]
 7  : [+18.19,+19.20]
 8  : [+19.20,-19.21]
 9  : [-19.21,+20.22]
 10 : [+20.22,+21.23]
 11 : [+22.24,+23.25]
 12 : [+23.25,+24.26]
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("s", asList:, overlap:, aligned:.false)=
a List (13 items)
 0  : [+6.6,+7.7]
 1  : [+7.7,+8.8]
 2  : [+11.11,-11.12]
 3  : [-11.12,+12.13]
 4  : [+14.15,+15.16]
 5  : [+15.16,+16.17]
 6  : [+16.17,+17.18]
 7  : [+18.19,+19.20]
 8  : [+19.20,-19.21]
 9  : [-19.21,+20.22]
 10 : [+20.22,+21.23]
 11 : [+22.24,+23.25]
 12 : [+23.25,+24.26]

--------------
-- test case 4
--------------
-- caselessPos (apply casefold internally but returns external indexes)
-- search 3 characters

/*
                                                        --  01 02 03 04 05 06 07 08 09 10 11   12 13 14 15 16 17 18 19   20 21 22 23
"Bundesstra√üe sss s√üs ss"~text~c2g=                     -- '42 75 6E 64 65 73 73 74 72 61 C39F 65 20 73 73 73 20 73 C39F 73 20 73 73'
                                                        --  B  u  n  d  e  s  s  t  r  a  √ü    e  _  s  s  s  _  s  √ü    s  _  s  s
                                                        --                                           |           |  |
*/

ooRexx>                                                                                 --                  Raku                Chrome
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("sSs")=                              -- 14               13                  y
 14
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("sSs", 15)=                          -- 18               17                  y
 18
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("sSs", 19)=                          -- 19   (overlap)   18 (if overlap)     y
 19
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("sSs", 20)=                          -- 0
 0
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("sSs", asList:)~allItems=            -- [ 14, 18]
[ 14, 18]
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("sSs", asList:, overlap:)~allItems=  -- [ 14, 18, 19]
[ 14, 18, 19]
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("sSs", asList:, aligned:.false)=
a List (2 items)
 0 : [+14.15,+17.18]
 1 : [+18.19,+20.22]
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("sSs", asList:, overlap:, aligned:.false)=
a List (3 items)
 0 : [+14.15,+17.18]
 1 : [+18.19,+20.22]
 2 : [+19.20,+21.23]

--------------
-- test case 5
--------------
-- caselessPos (apply casefold internally but returns external indexes)
-- search 4 characters

/*
                                                        --  01 02 03 04 05 06 07 08 09 10 11   12 13 14 15 16 17 18 19   20 21 22 23
"Bundesstra√üe sss s√üs ss"~text~c2g=                     -- '42 75 6E 64 65 73 73 74 72 61 C39F 65 20 73 73 73 20 73 C39F 73 20 73 73'
                                                        --  B  u  n  d  e  s  s  t  r  a  √ü    e  _  s  s  s  _  s  √ü    s  _  s  s
                                                        --                                                       |
*/

ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("sSsS")=                             -- 18 (good, same result as Raku and Chrome)
 18
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("sSsS", asList:)~allItems=           -- [ 18]
[ 18]
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("sSsS", asList:, overlap:)~allItems= -- [ 18]
[ 18]
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("sSsS", asList:, aligned:.false)=
a List (1 items)
 0 : [+18.19,+21.23]
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("sSsS", asList:, overlap:, aligned:.false)=
a List (1 items)
 0 : [+18.19,+21.23]

--------------
-- test case 6
--------------
-- caselessPos (apply casefold internally but returns external indexes)
-- search 2 characters in a long sequence

/*
                                                        --  01 02 03 04 05   06 07 08   09   10 11 12 13
"stra√üss√ü√üssse"~text~c2g=                               -- '73 74 72 61 C39F 73 73 C39F C39F 73 73 73 65'
                                                        --  s  t  r  a  √ü    s  s  √ü    √ü    s  s  s  e
                                                        --              |    |  |  |    |    |  |
*/

ooRexx>                                                         --                  Raku                Chome
ooRexx> "stra√üss√ü√üssse"~text~caselessPos("Ss")=                 -- 5                4                   y
 5
ooRexx> "stra√üss√ü√üssse"~text~caselessPos("Ss", 6)=              -- 6                5 (if overlap)      y       why Raku needs overlap?
 6
ooRexx> "stra√üss√ü√üssse"~text~caselessPos("Ss", 7)=              -- 8                7                   y
 8
ooRexx> "stra√üss√ü√üssse"~text~caselessPos("Ss", 9)=              -- 9                8 (if overlap)      y       why Raku needs overlap?
 9
ooRexx> "stra√üss√ü√üssse"~text~caselessPos("Ss", 10)=             -- 10               9                   y
 10
ooRexx> "stra√üss√ü√üssse"~text~caselessPos("Ss", 11)=             -- 11   (overlap)   10 (if overlap)     y
 11
ooRexx> "stra√üss√ü√üssse"~text~caselessPos("Ss", 12)=             -- 0
 0
ooRexx> "stra√üss√ü√üssse"~text~caselessPos("Ss", asList:)~allItems=           -- [ 5, 6, 8, 9, 10]
[ 5, 6, 8, 9, 10]
ooRexx> "stra√üss√ü√üssse"~text~caselessPos("Ss", asList:, overlap:)~allItems= -- [ 5, 6, 8, 9, 10, 11]
[ 5, 6, 8, 9, 10, 11]
ooRexx> "stra√üss√ü√üssse"~text~caselessPos("Ss", asList:, aligned:.false)=
a List (5 items)
 0 : [+5.5,+6.7]
 1 : [+6.7,+8.9]
 2 : [+8.9,+9.11]
 3 : [+9.11,+10.13]
 4 : [+10.13,+12.15]
ooRexx> "stra√üss√ü√üssse"~text~caselessPos("Ss", asList:, overlap:, aligned:.false)=
a List (10 items)
 0 : [+5.5,+6.7]
 1 : [-5.6,+7.8]
 2 : [+6.7,+8.9]
 3 : [+7.8,-8.10]
 4 : [+8.9,+9.11]
 5 : [-8.10,-9.12]
 6 : [+9.11,+10.13]
 7 : [-9.12,+11.14]
 8 : [+10.13,+12.15]
 9 : [+11.14,+13.16]

--------------
-- test case 7
--------------
-- pos, caselessPos

/*
                                                    --  01 02 03 04 05   06 07 08 09 10   11 12                                                 13
                                                    --  0                         1                      2                   3                    4
                                                    --  1  2  3  4  5 6  7  8  9  0  1 2  3  4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8  9 0 1 2
"stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~c2g=                         -- '73 74 72 61 C39F 65 20 6E 6F C3AB 6C F09F91A9E2808DF09F91A8E2808DF09F91A9E2808DF09F91A7 F09F8E85'
                                                    --                                                                                 |
*/

ooRexx> "üëßüéÖ"~text~c2g=                                   -- 'F09F91A7 F09F8E85'
'F09F91A7 F09F8E85'
ooRexx> "üëßüéÖ"~text~casefold~c2g=                          -- 'F09F91A7 F09F8E85'
'F09F91A7 F09F8E85'

ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~pos("üëßüéÖ", 1, aligned:.false)=         -- [-12.35,+14.43]
[-12.35,+14.43]
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~pos("üëßüéÖ", 12, aligned:.false)=        -- [-12.35,+14.43]
[-12.35,+14.43]
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~pos("üëßüéÖ", 13, aligned:.false)=        -- 0
 0
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~pos("üëßüéÖ", 13, asList:)=               -- a List (0 items)
a List (0 items)
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~pos("üëßüéÖ", 13, asList:, overlap:)=     -- a List (0 items)
a List (0 items)
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~pos("üëßüéÖ", asList:, aligned:.false)=
a List (1 items)
 0 : [-12.35,+14.43]
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~pos("üëßüéÖ", asList:, overlap:, aligned:.false)=
a List (1 items)
 0 : [-12.35,+14.43]

ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~caselessPos("üëßüéÖ", 1, aligned:.false)=     -- [-12.35,+14.43]
[-12.35,+14.43]
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~caselessPos("üëßüéÖ", 12, aligned:.false)=    -- [-12.35,+14.43]
[-12.35,+14.43]
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~caselessPos("üëßüéÖ", 13, aligned:.false)=    -- 0
 0
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~caselessPos("üëßüéÖ", asList:, aligned:.false)=
a List (1 items)
 0 : [-12.35,+14.43]
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~caselessPos("üëßüéÖ", asList:, overlap:, aligned:.false)=
a List (1 items)
 0 : [-12.35,+14.43]

-- yes, 12.35, not 12.34 even if "√´" (2 bytes) becomes internally "e" (1 byte)
-- because the indexes are external (relative to the target string, not related to the internal transformed string)
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~caselessPos("üëßüéÖ", 1, aligned:.false, stripMark:)=     -- [-12.35,+14.43]
[-12.34,+14.42]
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~caselessPos("üëßüéÖ", 12, aligned:.false, stripMark:)=    -- [-12.35,+14.43]
[-12.35,+14.43]
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~caselessPos("üëßüéÖ", 13, aligned:.false, stripMark:)=    -- 0
 0
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~caselessPos("üëßüéÖ", asList:, aligned:.false, stripMark:)=
a List (1 items)
 0 : [-12.34,+14.42]
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~caselessPos("üëßüéÖ", asList:, overlap:, aligned:.false, stripMark:)=
a List (1 items)
 0 : [-12.34,+14.42]

--------------
-- test case 8
--------------
-- casefold

/*
                                                    --  01 02 03 04 05 06 07 08 09 10 11   12 13                                                 14
                                                    --  0                          1                      2                   3                    4
                                                    --  1  2  3  4  5  6  7  8  9  0  1 2  3  4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8  9 0 1 2
"stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~casefold~c2g=                -- '73 74 72 61 73 73 65 20 6E 6F C3AB 6C F09F91A9E2808DF09F91A8E2808DF09F91A9E2808DF09F91A7 F09F8E85'
                                                    --                                                                                  |
*/

-- here we get 13 because "√ü" is replaced by "ss" before calling pos
-- the byte position .35 is unchanged because "√ü" is 2 bytes, as is "ss".
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~casefold~pos("üëßüéÖ", 1, aligned:.false)=                -- [-13.35,+15.43]
[-13.35,+15.43]
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~casefold~pos("üëßüéÖ", asList:, aligned:.false)=
a List (1 items)
 0 : [-13.35,+15.43]
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~casefold~pos("üëßüéÖ", asList:, overlap:, aligned:.false)=
a List (1 items)
 0 : [-13.35,+15.43]

-- stripMark has no impact on the byte position because it's an internal transformation
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~casefold~pos("üëßüéÖ", 1, aligned:.false, stripMark:)=    -- [-13.35,+15.43]
[-13.34,+15.42]
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~casefold~pos("üëßüéÖ", asList:, aligned:.false, stripMark:)=
a List (1 items)
 0 : [-13.34,+15.42]
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~casefold~pos("üëßüéÖ", asList:, overlap:, aligned:.false, stripMark:)=
a List (1 items)
 0 : [-13.34,+15.42]

-- here we get 13.34 because stripMark has an impact on the byte position:
-- "√´" (2 bytes" becomes "e" (1 byte) before calling pos.
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~casefold(stripMark:)~pos("üëßüéÖ", 1, aligned:.false)=    -- [-13.34,+15.42]
[-13.34,+15.42]
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~casefold(stripMark:)~pos("üëßüéÖ", asList:, aligned:.false)=
a List (1 items)
 0 : [-13.34,+15.42]
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~casefold(stripMark:)~pos("üëßüéÖ", asList:, overlap:, aligned:.false)=
a List (1 items)
 0 : [-13.34,+15.42]

--------------
-- test case 9
--------------
-- pos with a needle inside a grapheme of the haystack
-- Raku consider there is no matching.

ooRexx> "üë®‚Äçüë©"~text~c2g=                                  -- 'F09F91A8E2808DF09F91A9'
'F09F91A8E2808DF09F91A9'

ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~pos("üë®‚Äçüë©")=                   -- 0
 0
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~pos("üë®‚Äçüë©", aligned:.false)=   -- [-12.21,-12.32]
[-12.21,-12.32]
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~pos("üë®‚Äçüë©", asList:, aligned:.false)=
a List (1 items)
 0 : [-12.21,-12.32]
ooRexx> "stra√üe no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~pos("üë®‚Äçüë©", asList:, overlap:, aligned:.false)=
a List (1 items)
 0 : [-12.21,-12.32]

---------------
-- test case 10
---------------
-- pos with ignorable (no internal transformation)
-- TAG SPACE is ignorable

/*
                                                                                --  01 02   03         04 05 06 07 08 09 10 11   12 13 14 15 16 17         18   19 20
"T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~c2g=             -- '54 C38A 74F3A080A0 65 20 73 73 73 20 73 C39F 73 20 73 73 20 74F3A080A0 C3AA 54 45'
                                                                                --  T  √ä    t TAG SPAC e  _  s  s  s  _  s  √ü    s  _  s  s  _  t TAG SPAC √™    T  E
                                                                                --                           |  |                      |
*/

ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~pos("ss", asList:)~allItems=             -- [ 6, 14]
[ 6, 14]
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~pos("ss", asList:, overlap:)~allItems=   -- [ 6, 7, 14]
[ 6, 7, 14]
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~pos("ss", asList:, aligned:.false)=
a List (2 items)
 0 : [+6.11,+8.13]
 1 : [+14.20,+16.22]
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~pos("ss", asList:, overlap:, aligned:.false)=
a List (3 items)
 0 : [+6.11,+8.13]
 1 : [+7.12,+9.14]
 2 : [+14.20,+16.22]

--------------
-- test case 11
--------------
-- caselessPos with ignorable (apply casefold internally but returns external indexes)
-- TAG SPACE is ignorable

/*
                                                                                --  01 02   03         04 05 06 07 08 09 10 11   12 13 14 15 16 17         18   19 20
"T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~c2g=             -- '54 C38A 74F3A080A0 65 20 73 73 73 20 73 C39F 73 20 73 73 20 74F3A080A0 C3AA 54 45'
                                                                                --  T  √ä    t TAG SPAC e  _  s  s  s  _  s  √ü    s  _  s  s  _  t TAG SPAC √™    T  E
                                                                                --                           |  |           |          |
*/

ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("ss", asList:)~allItems=             -- [ 6, 11, 14]
[ 6, 11, 14]
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("ss", asList:, overlap:)~allItems=   -- [ 6, 7, 11, 14]
[ 6, 7, 11, 14]
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("ss", asList:, aligned:.false)=
a List (4 items)
 0 : [+6.11,+8.13]
 1 : [+10.15,-11.17]
 2 : [-11.17,+13.19]
 3 : [+14.20,+16.22]
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("ss", asList:, overlap:, aligned:.false)=
a List (6 items)
 0 : [+6.11,+8.13]
 1 : [+7.12,+9.14]
 2 : [+10.15,-11.17]
 3 : [+11.16,+12.18]
 4 : [-11.17,+13.19]
 5 : [+14.20,+16.22]


ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("te", asList:)~allItems=             -- [ 19]
[ 19]
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("te", asList:, overlap:)~allItems=   -- [ 19]
[ 19]
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("te", asList:, aligned:.false)=
a List (1 items)
 0 : [+19.30,+21.32]
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("te", asList:, overlap:, aligned:.false)=
a List (1 items)
 0 : [+19.30,+21.32]

---------------
-- test case 12
---------------
-- pos with ignorable (apply casefold + stripMark internally but returns external indexes)
-- TAG SPACE is ignorable

ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~pos("te", stripMark:, asList:)=              -- a List (0 items)
a List (0 items)
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~pos("te", stripMark:, asList:, overlap:)=    -- a List (0 items)
a List (0 items)

---------------
-- test case 13
---------------
-- caselessPos with ignorable (apply casefold + stripMark internally but returns external indexes)
-- TAG SPACE is ignorable

ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("te", stripMark:, asList:)~allItems=             -- [ 1, 19]
[ 1, 19]
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("te", stripMark:, asList:, overlap:)~allItems=   -- [ 1, 19]
[ 1, 19]
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("te", stripMark:, asList:, aligned:.false)=
a List (2 items)
 0 : [+1.1,+3.3]
 1 : [+19.28,+21.30]
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("te", stripMark:, asList:, overlap:, aligned:.false)=
a List (2 items)
 0 : [+1.1,+3.3]
 1 : [+19.28,+21.30]

---------------
-- test case 14
---------------
-- caselessPos with ignorable (apply casefold + stripIgnorable internally but returns external indexes)
-- TAG SPACE is ignorable

/*
                                                                                --  01 02   03         04 05 06 07 08 09 10 11   12 13 14 15 16 17         18   19 20
"T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~c2g=             -- '54 C38A 74F3A080A0 65 20 73 73 73 20 73 C39F 73 20 73 73 20 74F3A080A0 C3AA 54 45'
                                                                                --  T  √ä    t TAG SPAC e  _  s  s  s  _  s  √ü    s  _  s  s  _  t TAG SPAC √™    T  E
                                                                                --  |       |                                                   |               |
*/

ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("te", stripMark:, stripIgnorable:, asList:)~allItems=            -- [ 1, 3, 17, 19]
[ 1, 3, 17, 19]
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("te", stripMark:, stripIgnorable:, asList:, overlap:)~allItems=  -- [ 1, 3, 17, 19]
[ 1, 3, 17, 19]
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("te", stripMark:, stripIgnorable:, asList:, aligned:.false)=
a List (4 items)
 0 : [+1.1,+3.3]
 1 : [+3.3,+5.5]
 2 : [+17.18,+19.20]
 3 : [+19.20,+21.22]
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("te", stripMark:, stripIgnorable:, asList:, overlap:, aligned:.false)=
a List (4 items)
 0 : [+1.1,+3.3]
 1 : [+3.3,+5.5]
 2 : [+17.18,+19.20]
 3 : [+19.20,+21.22]


-- ===============================================================================
-- 2023 Sep 06

/*
Fix the implementation of caselessPos, pos.
Was not returning the right position when the length of the string changed
internally. Now the results are identical to Raku's (with a few exceptions).
*/

ooRexx> "Bundesstra√üe im Freiland"~text~pos("Freiland")=                -- 17
 17
ooRexx> "Bundesstra√üe im Freiland"~text~caselessPos("freiland")=        -- 17
 17

--------------
-- test case 1
--------------
-- pos (no internal transformation)

/*
                                                        --  01 02 03 04 05 06 07 08 09 10 11   12 13 14 15 16 17 18 19   20 21 22 23
"Bundesstra√üe sss s√üs ss"~text~c2g=                     -- '42 75 6E 64 65 73 73 74 72 61 C39F 65 20 73 73 73 20 73 C39F 73 20 73 73'
                                                        --  B  u  n  d  e  s  s  t  r  a  √ü    e  _  s  s  s  _  s  √ü    s  _  s  s
                                                        --                 |                         |                         |        no overlap
                                                        --                 |                         |  |                      |        with overlap
*/

ooRexx> "Bundesstra√üe sss s√üs ss"~text~pos("ss")=               -- 6
 6
ooRexx> "Bundesstra√üe sss s√üs ss"~text~pos("ss", 7)=            -- 14
 14
ooRexx> "Bundesstra√üe sss s√üs ss"~text~pos("ss", 15)=           -- 15 (overlap)
 15
ooRexx> "Bundesstra√üe sss s√üs ss"~text~pos("ss", 16)=           -- 22
 22
ooRexx> "Bundesstra√üe sss s√üs ss"~text~pos("ss", 23)=           -- 0
 0

--------------
-- test case 2
--------------
-- caselessPos (apply casefold internally but returns external indexes)

/*
                                                        --  01 02 03 04 05 06 07 08 09 10 11   12 13 14 15 16 17 18 19   20 21 22 23
"Bundesstra√üe sss s√üs ss"~text~c2g=                     -- '42 75 6E 64 65 73 73 74 72 61 C39F 65 20 73 73 73 20 73 C39F 73 20 73 73'
                                                        --  B  u  n  d  e  s  s  t  r  a  √ü    e  _  s  s  s  _  s  √ü    s  _  s  s
                                                        --                 |              |          |           |             |        no overlap
                                                        --                 |              |          |  |        |  |          |        with overlap
*/

ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("ss")=       -- 6
 6
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("ss", 7)=    -- 11
 11
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("ss", 12)=   -- 14
 14
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("ss", 15)=   -- 15 (overlap)
 15
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("ss", 16)=   -- 19           (Raku doesn't return this index, am I wrong? sounds good to me...)
 19
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("ss", 20)=   -- 22
 22
ooRexx> "Bundesstra√üe sss s√üs ss"~text~caselessPos("ss", 23)=   -- 0
 0

--------------
-- test case 3
--------------
-- casefold~pos (the returned indexes are different from caselessPos because the string is transformed before calling ~pos)
-- Use "√º" instead of "u" to have a non-ASCII string.
-- Without "√º", the 'pos' method would forward to String.

/*
                                                        --  01 02   03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
"B√ºndesstra√üe sss s√üs ss"~text~casefold~c2g=            -- '62 C3BC 6E 64 65 73 73 74 72 61 73 73 65 20 73 73 73 20 73 73 73 73 20 73 73'
                                                        --  b  √º    n  d  e  s  s  t  r  a  s  s  e  _  s  s  s  _  s  s  s  s  _  s  s
                                                        --                   |              |           |           |     |        |    no overlap
                                                        --                   |              |           |  |        |  |  |        |    with overlap
*/

ooRexx> "B√ºndesstra√üe sss s√üs ss"~text~casefold~pos("ss")=      -- 6
 6
ooRexx> "B√ºndesstra√üe sss s√üs ss"~text~casefold~pos("ss", 7)=   -- 11
 11
ooRexx> "B√ºndesstra√üe sss s√üs ss"~text~casefold~pos("ss", 12)=  -- 15
 15
ooRexx> "B√ºndesstra√üe sss s√üs ss"~text~casefold~pos("ss", 16)=  -- 16 (overlap)
 16
ooRexx> "B√ºndesstra√üe sss s√üs ss"~text~casefold~pos("ss", 17)=  -- 19
 19
ooRexx> "B√ºndesstra√üe sss s√üs ss"~text~casefold~pos("ss", 20)=  -- 20 (overlap)
 20
ooRexx> "B√ºndesstra√üe sss s√üs ss"~text~casefold~pos("ss", 21)=  -- 21 (overlap)
 21
ooRexx> "B√ºndesstra√üe sss s√üs ss"~text~casefold~pos("ss", 22)=  -- 24
 24
ooRexx> "B√ºndesstra√üe sss s√üs ss"~text~casefold~pos("ss", 25)=  -- 0
 0


--------------
-- test case 4
--------------
-- TAG SPACE is ignorable
ooRexx> "T√ät\u{TAG SPACE}e"~text~unescape~length=                                       -- 4
 4
ooRexx> "T√ät\u{TAG SPACE}e"~text~unescape~c2g=                                          -- '54 C38A 74F3A080A0 65'
'54 C38A 74F3A080A0 65'
ooRexx> "T√ät\u{TAG SPACE}e"~text~unescape~transform(stripIgnorable:)~c2g=               -- '54 C38A 74 65'
'54 C38A 74 65'

--------------
-- test case 5
--------------
-- pos with ignorable (no internal transformation)

/*
                                                                                --  01 02   03         04 05 06 07 08 09 10 11   12 13 14 15 16 17         18   19 20
"T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~c2g=             -- '54 C38A 74F3A080A0 65 20 73 73 73 20 73 C39F 73 20 73 73 20 74F3A080A0 C3AA 54 45'
                                                                                --  T  √ä    t TAG SPAC e  _  s  s  s  _  s  √ü    s  _  s  s  _  t TAG SPAC √™    T  E
                                                                                --                           |  |                      |
*/

ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~pos("ss")=       -- 6
 6
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~pos("ss", 7)=    -- 7
 7
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~pos("ss", 8)=    -- 14
 14
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~pos("ss", 15)=   -- 0
 0

ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~pos("te")=       -- 0
 0

--------------
-- test case 6
--------------
-- caselessPos with ignorable (apply casefold internally but returns external indexes)

/*
                                                                                --  01 02   03         04 05 06 07 08 09 10 11   12 13 14 15 16 17         18   19 20
"T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~c2g=             -- '54 C38A 74F3A080A0 65 20 73 73 73 20 73 C39F 73 20 73 73 20 74F3A080A0 C3AA 54 45'
                                                                                --  T  √ä    t TAG SPAC e  _  s  s  s  _  s  √ü    s  _  s  s  _  t TAG SPAC √™    T  E
                                                                                --                           |  |        |  |          |
*/

ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("ss")=       -- 6
 6
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("ss", 7)=    -- 7 (overlap)
 7
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("ss", 8)=    -- 11
 11
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("ss", 12)=   -- 14
 14
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("ss", 15)=   -- 0
 0

ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("te")=       -- 19
 19
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("te", 20)=   -- 0
 0

--------------
-- test case 7
--------------
-- pos with ignorable (apply casefold + stripMark internally but returns external indexes)
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~pos("te", stripMark:)=   -- 0
 0

--------------
-- test case 8
--------------
-- caselessPos with ignorable (apply casefold + stripMark internally but returns external indexes)
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("te", stripMark:)=       -- 1
 1
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("te", 2, stripMark:)=    -- 19
 19
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("te", 20, stripMark:)=   -- 0
 0

--------------
-- test case 9
--------------
-- caselessPos with ignorable (apply casefold + stripIgnorable internally but returns external indexes)

/*
                                                                                --  01 02   03         04 05 06 07 08 09 10 11   12 13 14 15 16 17         18   19 20
"T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~c2g=             -- '54 C38A 74F3A080A0 65 20 73 73 73 20 73 C39F 73 20 73 73 20 74F3A080A0 C3AA 54 45'
                                                                                --  T  √ä    t TAG SPAC e  _  s  s  s  _  s  √ü    s  _  s  s  _  t TAG SPAC √™    T  E
                                                                                --  |       |                                                   |               |
*/

ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("te", stripMark:, stripIgnorable:)=      -- 1
 1
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("te", 2, stripMark:, stripIgnorable:)=   -- 3
 3
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("te", 4, stripMark:, stripIgnorable:)=   -- 17
 17
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("te", 18, stripMark:, stripIgnorable:)=  -- 19
 19
ooRexx> "T√ät\u{TAG SPACE}e sss s√üs ss t\u{TAG SPACE}√™TE"~text~unescape~caselessPos("te", 20, stripMark:, stripIgnorable:)=  -- 0
 0


-- ===============================================================================
-- 2023 Aug 29

/*
Implementation of caselessContains, contains:
(forwards to caselessPos or pos, and returns .true if result <> 0)
(was already implemented, waiting for 'pos' implementation)
Examples:
*/
ooRexx>     "P√®re No√´l P√®re No√´l"~text~contains("o√´")=                   -- .true
 1
ooRexx>     "P√®re No√´l P√®re No√´l"~text~contains("o√´", , 7)=              -- .false
 0
ooRexx>     "P√®re No√´l P√®re No√´l"~text~contains("o√´", , 8)=              -- .true
 1
ooRexx>     "P√®re No√´l P√®re No√´l"~text~contains("o√´", 8)=                -- .true
 1
ooRexx>     "P√®re No√´l P√®re No√´l"~text~contains("o√´", 8, 10)=            -- .false
 0
ooRexx>     "P√®re No√´l P√®re No√´l"~text~contains("o√´", 8, 11)=            -- .true
 1
ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessContains("O√ã", 8, 11)=    -- .true
 1

ooRexx>     "no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~contains("üëßüéÖ")=                            -- .false
 0
ooRexx>     "no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~contains("üëßüéÖ", aligned:.false)=            -- .true
 1
ooRexx>     "no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~contains("üë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ", aligned:.false)=            -- .true
 1


-- ===============================================================================
-- 2023 Aug 28

/*
Add a named argument 'aligned' to caselessPos, pos:
- If aligned=.true (default) then return the first character position in the
  untransformed haystack such as all the bytes of the transformed needle are
  matched with corresponding bytes in the transformed haystack AND the first
  and last byte positions are aligned with character positions.
  If no match then return 0.
- If aligned=.false then return a couple (array) of numbers +/-posC.posB where
  posB is the position of the matched byte in the transformed haystack, and posC
  is the corresponding grapheme position in the untransformed haystack.
  A number is negative if the byte position is not aligned with the corresponding
  character position.
  The first number is the start of the matching.
  The second number is the end of the matching + 1.

aligned=.false is intended for analysis of matchings and [non-]regression tests.
Otherwise, I don't see any use.

Example:
*/
ooRexx>     "no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~pos("üëßüéÖ")=                           -- 0
 0
ooRexx>     "no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~pos("üëßüéÖ", aligned:.false)=           -- [-5.27,+7.35]
[-5.27,+7.35]
ooRexx>     "no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~pos("üë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ", aligned:.false)=           -- [+5.6,+7.35]
[+5.6,+7.35]


/*
Comparison operators:
Take into account the default normalization managed by the .Unicode class
*/
ooRexx> .Unicode~normalizationName(.Unicode~defaultNormalization(strict:.true))=    -- NFC when strict
'NFC'
ooRexx> .Unicode~normalizationName(.Unicode~defaultNormalization(strict:.false))=   -- NFKD when not strict
'NFKD'
/*
Example:
*/
ooRexx>     ("baÔ¨Ñe"~text == "baffle"~text) =    -- false
 0
ooRexx>     ("baÔ¨Ñe"~text = "baffle"~text) =     -- true
 1
/*
Reminder: the non-strict mode supports all the Unicode spaces, not just U+0032.
*/
ooRexx>     string1 = " Le\u{IDEOGRAPHIC SPACE}P√®\u{ZERO-WIDTH-SPACE}re\u{HYPHEN}No√´l"~text~unescape
ooRexx>     string2 = "Le\u{OGHAM SPACE MARK}P√®re\u{EN DASH}No\u{ZERO-WIDTH-SPACE}√´l "~text~unescape
ooRexx>     (string1 == string2) =              -- false
 0
ooRexx>     (string1 = string2) =               -- true
 1


-- ===============================================================================
-- 2023 Aug 26

ooRexx> t = "no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text; t~c2g=    -- '6E 6F C3AB 6C F09F91A9E2808DF09F91A8E2808DF09F91A9E2808DF09F91A7 F09F8E85'
'6E 6F C3AB 6C F09F91A9E2808DF09F91A8E2808DF09F91A9E2808DF09F91A7 F09F8E85'
ooRexx> t = "no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text; do indexB=1 to t~string~length + 2; indexC = t~indexer~characterIndexC(indexB); character = t~character(abs(indexC)); say "indexB" indexB~right(3) "--> indexC" indexC~right(4) "    " character~c2x; end
indexB   1 --> indexC    1      6E
indexB   2 --> indexC    2      6F
indexB   3 --> indexC    3      C3AB
indexB   4 --> indexC   -3      C3AB
indexB   5 --> indexC    4      6C
indexB   6 --> indexC    5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB   7 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB   8 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB   9 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB  10 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB  11 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB  12 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB  13 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB  14 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB  15 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB  16 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB  17 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB  18 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB  19 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB  20 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB  21 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB  22 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB  23 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB  24 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB  25 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB  26 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB  27 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB  28 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB  29 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB  30 --> indexC   -5      F09F91A9 E2808D F09F91A8 E2808D F09F91A9 E2808D F09F91A7
indexB  31 --> indexC    6      F09F8E85
indexB  32 --> indexC   -6      F09F8E85
indexB  33 --> indexC   -6      F09F8E85
indexB  34 --> indexC   -6      F09F8E85
indexB  35 --> indexC    7      
indexB  36 --> indexC    7      


-- Implementation of caselessCompare, compare
-- ------------------------------------------
ooRexx>     "hello"~text~compare("hello")=                          -- 0
 0
ooRexx>     "hello"~text~compare("helloo")=                         -- 6
 6
ooRexx>     "hello"~text~compare("hell√¥")=                          -- 5
 5
ooRexx>     "hello"~text~caselessCompare("hell√¥",stripMark:)=       -- 0
 0
ooRexx>     "hell√î"~text~caselessCompare("hell√¥")=                  -- 0
 0
ooRexx>     "hell√î"~text~caselessCompare("")=                       -- 1
 1
ooRexx>     "hell√î"~text~caselessCompare("", "h")=                  -- 2
 2
ooRexx>     zwsp = "\u{ZERO WIDTH SPACE}"~text~unescape             -- ignorable
ooRexx>     ("he"zwsp"llo")~compare("hell√¥")=                       -- 3 (ok)
 3
ooRexx>     ("he"zwsp"llo")~compare("hell√¥", stripIgnorable:)=      -- 6 (ok? not 5 because the ignorable character count as a character)
 6


-- casefold 2 characters: "√ü" becomes "ss"
ooRexx>     "Bundesstra√üe im Freiland"~text~caselessCompare("Bundesstra√üe")=        -- 14 (good)
 14
ooRexx>     "Bundesstra√üe im Freiland"~text~caselessCompare("Bundesstra√üe", "_")=   -- 13 (good)
 13
ooRexx>     "Bundesstra√üe im Freiland"~text~caselessCompare("bundesstrasse")=       -- 14 (good)
 14
ooRexx>     "Bundesstrasse im Freiland"~text~caselessCompare("bundesstra√üe")=       -- 15 (good)
 15
ooRexx>     "stra√üss√ü√üssse"~text~compare("stra", "√ü")=                              --  6 (good)
 6
ooRexx>     "stra√üss√ü√üssse"~text~caselessCompare("stra", "√ü")=                      -- 12 (not 13 because the last 's' match half of the pad 'ss')
 12

/*
This test case is a little bit strange because:
- the case-folded character looks identical to the original character.
- the normalization and the casefold have the same effect.
*/
-- casefold 3 characters: "Œê" 'U+0390' becomes "ŒπÃàÃÅ" 'U+03B9 U+0308 U+0301'
ooRexx>     iota_dt = "\u{GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS}"~text~unescape
ooRexx>     iota_dt~casefold~UnicodeCharacters==
an Array (shape [3], 3 items)
 1 : ( "Œπ"   U+03B9 Ll 1 "GREEK SMALL LETTER IOTA" )
 2 : ( "Ãà"    U+0308 Mn 0 "COMBINING DIAERESIS" )
 3 : ( "ÃÅ"    U+0301 Mn 0 "COMBINING ACUTE ACCENT" )
ooRexx>     ("a" iota_dt "b")~compare("a")=                         -- 3
 3
ooRexx>     ("a" iota_dt "b")~compare("a" iota_dt)=                 -- 5
 5
ooRexx>     ("a" iota_dt~casefold "b")~compare("a" iota_dt)=                                -- 5 (yes! not 3 because the default NFC transforms iota_dt~casefold 'U+03B9 U+0308 U+0301' into 'U+0390')
 5
ooRexx>     ("a" iota_dt~casefold "b")~compare("a" iota_dt, normalization: .Unicode~NFD)=   -- 5 (yes! not 3 because NFD transforms iota_dt 'U+0390' into 'U+03B9 U+0308 U+0301'
 5
ooRexx>     ("a" iota_dt~casefold "b")~compare("a" iota_dt, normalization: 0)=              -- 3 because normalization deactivated
 3
ooRexx>     ("a" iota_dt "b")~caselessCompare("a")=                 -- 3
 3
ooRexx>     ("a" iota_dt "b")~caselessCompare("a" iota_dt)=         -- 5
 5
ooRexx>     ("a" iota_dt "b")~caselessCompare("a ", iota_dt)=       -- 4
 4


-- Implementation of caselessEndsWith, endsWith
-- --------------------------------------------
ooRexx>     "hello"~text~endsWith("")=                              -- false
 0
ooRexx>     "hello"~text~endsWith("o")=                             -- true
 1
ooRexx>     "hello"~text~endsWith("√¥")=                             -- false
 0
ooRexx>     "hello"~text~endsWith("√¥", stripMark:)=                 -- true
 1
ooRexx>     "hello"~text~endsWith("O")=                             -- false
 0
ooRexx>     "hello"~text~caselessEndsWith("O")=                     -- true
 1


-- Rework implementation of caselessMatchChar, matchChar
-- -----------------------------------------------------
ooRexx>     "BAFFLE"~text~caselessMatchChar(3, "Ô¨Ñ")=               -- 0, was 1 before 2023.12.04      "Ô¨Ñ" becomes "ffl" (3 graphemes), there is a match on "f" at 3
 0
ooRexx>     "BAFFLE"~text~caselessMatchChar(5, "Ô¨Ñ")=               -- 0, was 1 before 2023.12.04      "Ô¨Ñ" becomes "ffl" (3 graphemes), there is a match on "l" at 5
 0
ooRexx>     "baffle"~text~caselessMatchChar(5, "L")=               -- 1      there is a match on "l" at 5 (forward to string)
 1
ooRexx>     "baÔ¨Ñe"~text~caselessMatchChar(3, "Ô¨Ñ")=                 -- 1      "Ô¨Ñ" at 3 (1 grapheme) becomes "ffl" (3 graphemes), there is a match on "l"
 1
ooRexx>     "baÔ¨Ñe"~text~caselessMatchChar(3, "F")=                 -- 0, was 1 before 2023.12.04      "Ô¨Ñ" at 3 (1 grapheme) becomes "ffl" (3 graphemes), there is a match on "f"
 0
ooRexx>     "baÔ¨Ñe"~text~caselessMatchChar(3, "L")=                 -- 0, was 1 before 2023.12.04      "Ô¨Ñ" at 3 (1 grapheme) becomes "ffl" (3 graphemes), there is a match on "l"
 0
ooRexx>     "baÔ¨Ñe"~text~caselessMatchChar(4, "E")=                 -- 1      the grapheme at 4 is "e", not "f". There is a match with "e"
 1


-- Rework implementation of caselessCompareTo, compareTo
-- -----------------------------------------------------
ooRexx>     "P√®re No√´l"~text~nfc~compareTo("P√®re No√´l"~text~nfc)=                       -- 0 (equal)
 0
ooRexx>     "P√®re No√´l"~text~nfc~compareTo("P√®re No√´l"~text~nfd)=                       -- 0 (equal)
 0
ooRexx>     "P√®re No√´l"~text~nfd~compareTo("P√®re No√´l"~text~nfc)=                       -- 0 (equal)
 0
ooRexx>     "P√®re No√´l"~text~nfd~compareTo("P√®re No√´l"~text~nfd)=                       -- 0 (equal)
 0
ooRexx>     ---
ooRexx>     "Pere No√´l"~text~nfc~compareTo("P√®re Noel"~text~nfc, stripMark:)=           -- 0 (equal)
 0
ooRexx>     "Pere No√´l"~text~nfc~compareTo("P√®re Noel"~text~nfd, stripMark:)=           -- 0 (equal)
 0
ooRexx>     "Pere No√´l"~text~nfd~compareTo("P√®re Noel"~text~nfc, stripMark:)=           -- 0 (equal)
 0
ooRexx>     "Pere No√´l"~text~nfd~compareTo("P√®re Noel"~text~nfd, stripMark:)=           -- 0 (equal)
 0
ooRexx>     ---
ooRexx>     "1st P√®re No√´l"~text~nfc~compareTo("2nd P√®re No√´l"~text~nfc)=               -- -1 (lesser)
-1
ooRexx>     "1st P√®re No√´l"~text~nfc~compareTo("2nd P√®re No√´l"~text~nfd)=               -- -1 (lesser)
-1
ooRexx>     "1st P√®re No√´l"~text~nfd~compareTo("2nd P√®re No√´l"~text~nfc)=               -- -1 (lesser)
-1
ooRexx>     "1st P√®re No√´l"~text~nfd~compareTo("2nd P√®re No√´l"~text~nfd)=               -- -1 (lesser)
-1
ooRexx>     ---
ooRexx>     "P√®re No√´l 2nd"~text~nfc~compareTo("P√®re No√´l 1st"~text~nfc)=               -- 1 (greater)
 1
ooRexx>     "P√®re No√´l 2nd"~text~nfc~compareTo("P√®re No√´l 1st"~text~nfd)=               -- 1 (greater)
 1
ooRexx>     "P√®re No√´l 2nd"~text~nfd~compareTo("P√®re No√´l 1st"~text~nfc)=               -- 1 (greater)
 1
ooRexx>     "P√®re No√´l 2nd"~text~nfd~compareTo("P√®re No√´l 1st"~text~nfd)=               -- 1 (greater)
 1
ooRexx>     ---
ooRexx>     "Pere No√´l"~text~nfc~compareTo("P√®re Noel"~text~nfc, 3, 4)=                 -- 0 (equal)
 0
ooRexx>     "Pere No√´l"~text~nfc~compareTo("P√®re Noel"~text~nfd, 3, 4)=                 -- 0 (equal)
 0
ooRexx>     "Pere No√´l"~text~nfd~compareTo("P√®re Noel"~text~nfc, 3, 4)=                 -- 0 (equal)
 0
ooRexx>     "Pere No√´l"~text~nfd~compareTo("P√®re Noel"~text~nfd, 3, 4)=                 -- 0 (equal)
 0
ooRexx>     ---
ooRexx>     "P√àRE NO√ãL"~text~nfc~compareTo("P√®re No√´l"~text~nfc)=                       -- -1 (lesser)
-1
ooRexx>     "P√àRE NO√ãL"~text~nfc~compareTo("P√®re No√´l"~text~nfd)=                       -- -1 (lesser)
-1
ooRexx>     "P√àRE NO√ãL"~text~nfd~compareTo("P√®re No√´l"~text~nfc)=                       -- -1 (lesser)
-1
ooRexx>     "P√àRE NO√ãL"~text~nfd~compareTo("P√®re No√´l"~text~nfd)=                       -- -1 (lesser)
-1
ooRexx>     ---
ooRexx>     "P√àRE NO√ãL"~text~nfc~caselessCompareTo("P√®re No√´l"~text~nfc)=               -- 0 (equal)
 0
ooRexx>     "P√àRE NO√ãL"~text~nfc~caselessCompareTo("P√®re No√´l"~text~nfd)=               -- 0 (equal)
 0
ooRexx>     "P√àRE NO√ãL"~text~nfd~caselessCompareTo("P√®re No√´l"~text~nfc)=               -- 0 (equal)
 0
ooRexx>     "P√àRE NO√ãL"~text~nfd~caselessCompareTo("P√®re No√´l"~text~nfd)=               -- 0 (equal)
 0
ooRexx>     ---
ooRexx>     "PERE NO√ãL"~text~nfc~caselessCompareTo("P√®re Noel"~text~nfc, 3, 4)=         -- 0 (equal)
 0
ooRexx>     "PERE NO√ãL"~text~nfc~caselessCompareTo("P√®re Noel"~text~nfd, 3, 4)=         -- 0 (equal)
 0
ooRexx>     "PERE NO√ãL"~text~nfd~caselessCompareTo("P√®re Noel"~text~nfc, 3, 4)=         -- 0 (equal)
 0
ooRexx>     "PERE NO√ãL"~text~nfd~caselessCompareTo("P√®re Noel"~text~nfd, 3, 4)=         -- 0 (equal)
 0


-- Implementation of caselessPos, pos
-- ----------------------------------

/*
    --       P  √®       r  e  _  N  o  √´       l
    --       1  2       3  4  5  6  7  8       9
    -- NFC  '50 C3A8    72 65 20 4E 6F C3AB    6C'
    --       1  2 3     4  5  6  7  8  9 10    11
    -- NFD  '50 65 CC80 72 65 20 4E 6F 65 CC88 6C'
    --       1  2  3 4  5  6  7  8  9  19 1112 13
*/
ooRexx>                                                             --      self needle
ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("l")=                    -- 9    NFC, NFC
 9
ooRexx>     "P√®re No√´l P√®re No√´l"     ~pos("l")=                    -- 11   NFC, NFC
 11

ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("l", , 8)=               -- 0    NFC, NFC
 0
ooRexx>     "P√®re No√´l P√®re No√´l"     ~pos("l", , 10)=              -- 0    NFC, NFC
 0

ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("l", , 9)=               -- 9    NFC, NFC
 9
ooRexx>     "P√®re No√´l P√®re No√´l"     ~pos("l", , 11)=              -- 11   NFC, NFC
 11

ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("l", 10)=                -- 19   NFC, NFC
 19
ooRexx>     "P√®re No√´l P√®re No√´l"     ~pos("l", 12)=                -- 23   NFC, NFC
 23

ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("l", 10, 9)=             -- 0    NFC, NFC
 0
ooRexx>     "P√®re No√´l P√®re No√´l"     ~pos("l", 12, 11)=            -- 0    NFC, NFC
 0

ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("l", 10, 10)=            -- 19   NFC, NFC
 19
ooRexx>     "P√®re No√´l P√®re No√´l"     ~pos("l", 12, 12)=            -- 23   NFC, NFC
 23

ooRexx>     ---

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~pos("l")=                    -- 9    NFD, NFC
 9
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~pos("l")=                    -- 13   NFD, NFC
 13

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~pos("l", , 8)=               -- 0    NFD, NFC
 0
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~pos("l", , 12)=              -- 0    NFD, NFC
 0

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~pos("l", , 9)=               -- 9    NFD, NFC
 9
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~pos("l", , 13)=              -- 13   NFD, NFC
 13

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~pos("l", 10)=                -- 19   NFD, NFC
 19
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~pos("l", 14)=                -- 27   NFD, NFC
 27

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~pos("l", 10, 9)=             -- 0    NFD, NFC
 0
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~pos("l", 14, 13)=            -- 0    NFD, NFC
 0

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~pos("l", 10, 10)=            -- 19   NFD, NFC
 19
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~pos("l", 14, 14)=            -- 27   NFD, NFC
 27

ooRexx>     ---

ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("o√´")=                   -- 7    NFC, NFC
 7
ooRexx>     "P√®re No√´l P√®re No√´l"     ~pos("o√´")=                   -- 8    NFC, NFC
 8

ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("o√´", , 7)=              -- 0    NFC, NFC
 0
ooRexx>     "P√®re No√´l P√®re No√´l"     ~pos("o√´", , 9)=              -- 0    NFC, NFC
 0

ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("o√´", , 8)=              -- 7    NFC, NFC
 7
ooRexx>     "P√®re No√´l P√®re No√´l"     ~pos("o√´", , 10)=             -- 8    NFC, NFC
 8

ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("o√´", 8)=                -- 17   NFC, NFC
 17
ooRexx>     "P√®re No√´l P√®re No√´l"     ~pos("o√´", 9)=                -- 20   NFC, NFC
 20

ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("o√´", 8, 10)=            -- 0    NFC, NFC
 0
ooRexx>     "P√®re No√´l P√®re No√´l"     ~pos("o√´", 9, 13)=            -- 0    NFC, NFC
 0

ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("o√´", 8, 11)=            -- 17   NFC, NFC
 17
ooRexx>     "P√®re No√´l P√®re No√´l"     ~pos("o√´", 9, 14)=            -- 20   NFC, NFC
 20

ooRexx>     ---

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~pos("o√´")=                   -- 7    NFD, NFC
 7
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~pos("o√´")=                   -- 0    NFD, NFC    always 0, no need to test all the combinations
 0

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~pos("o√´", , 7)=              -- 0    NFD, NFC
 0

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~pos("o√´", , 8)=              -- 7    NFD, NFC
 7

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~pos("o√´", 8)=                -- 17   NFD, NFC
 17

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~pos("o√´", 8, 10)=            -- 0    NFD, NFC
 0

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~pos("o√´", 8, 11)=            -- 17   NFD, NFC
 17

ooRexx>     ---

ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("oeÃà")=                   -- 7    NFC, NFD
 7
ooRexx>     "P√®re No√´l P√®re No√´l"     ~pos("oeÃà")=                   -- 0    NFC, NFD   always 0, no need to test all the combinations
 0

ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("oeÃà", , 7)=              -- 0    NFC, NFD
 0

ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("oeÃà", , 8)=              -- 7    NFC, NFD
 7

ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("oeÃà", 8)=                -- 17   NFC, NFD
 17

ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("oeÃà", 8, 10)=            -- 0    NFC, NFD
 0

ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("oeÃà", 8, 11)=            -- 17   NFC, NFD
 17

ooRexx>     ---

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~pos("oeÃà")=                   -- 7    NFD, NFD
 7
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~pos("oeÃà")=                   -- 9    NFD, NFD
 9

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~pos("oeÃà", , 7)=              -- 0    NFD, NFD
 0
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~pos("oeÃà", , 11)=             -- 0    NFD, NFD
 0

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~pos("oeÃà", , 8)=              -- 7    NFD, NFD
 7
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~pos("oeÃà", , 12)=             -- 9    NFD, NFD
 9

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~pos("oeÃà", 8)=                -- 17   NFD, NFD
 17
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~pos("oeÃà", 10)=               -- 23   NFD, NFD
 23

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~pos("oeÃà", 8, 10)=            -- 0    NFD, NFD
 0
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~pos("oeÃà", 10, 16)=           -- 0    NFD, NFD
 0

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~pos("oeÃà", 8, 11)=            -- 17   NFD, NFD
 17
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~pos("oeÃà", 10, 17)=           -- 23   NFD, NFD
 23

ooRexx>     ---

ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("oe")=                   -- 0    NFC, NFC    always 0, no need to test all the combinations
 0
ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("oe", stripMark:)=       -- 7    NFC, NFC
 7

ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("oe", , 7, stripMark:)=  -- 0    NFC, NFC
 0

ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("oe", , 8, stripMark:)=  -- 7    NFC, NFC
 7

ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("oe", 8, stripMark:)=    -- 17   NFC, NFC
 17

ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("oe", 8, 10, stripMark:)=-- 0    NFC, NFC
 0

ooRexx>     "P√®re No√´l P√®re No√´l"~text~pos("oe", 8, 11, stripMark:)=-- 17   NFC, NFC
 17

ooRexx>     ---
ooRexx>     -- caseless tests not in the diary:
ooRexx>     ---

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("L")=                    -- 9    NFC, NFC
 9
ooRexx>     "P√®re No√´l P√®re No√´l"     ~caselessPos("L")=                    -- 11   NFC, NFC
 11

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("L", , 8)=               -- 0    NFC, NFC
 0
ooRexx>     "P√®re No√´l P√®re No√´l"     ~caselessPos("L", , 10)=              -- 0    NFC, NFC
 0

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("L", , 9)=               -- 9    NFC, NFC
 9
ooRexx>     "P√®re No√´l P√®re No√´l"     ~caselessPos("L", , 11)=              -- 11   NFC, NFC
 11

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("L", 10)=                -- 19   NFC, NFC
 19
ooRexx>     "P√®re No√´l P√®re No√´l"     ~caselessPos("L", 12)=                -- 23   NFC, NFC
 23

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("L", 10, 9)=             -- 0    NFC, NFC
 0
ooRexx>     "P√®re No√´l P√®re No√´l"     ~caselessPos("L", 12, 11)=            -- 0    NFC, NFC
 0

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("L", 10, 10)=            -- 19   NFC, NFC
 19
ooRexx>     "P√®re No√´l P√®re No√´l"     ~caselessPos("L", 12, 12)=            -- 23   NFC, NFC
 23

ooRexx>     ---

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~caselessPos("L")=                    -- 9    NFD, NFC
 9
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~caselessPos("L")=                    -- 13   NFD, NFC
 13

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~caselessPos("L", , 8)=               -- 0    NFD, NFC
 0
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~caselessPos("L", , 12)=              -- 0    NFD, NFC
 0

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~caselessPos("L", , 9)=               -- 9    NFD, NFC
 9
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~caselessPos("L", , 13)=              -- 13   NFD, NFC
 13

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~caselessPos("L", 10)=                -- 19   NFD, NFC
 19
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~caselessPos("L", 14)=                -- 27   NFD, NFC
 27

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~caselessPos("L", 10, 9)=             -- 0    NFD, NFC
 0
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~caselessPos("L", 14, 13)=            -- 0    NFD, NFC
 0

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~caselessPos("L", 10, 10)=            -- 19   NFD, NFC
 19
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~caselessPos("L", 14, 14)=            -- 27   NFD, NFC
 27

ooRexx>     ---

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("O√ã")=                   -- 7    NFC, NFC
 7
ooRexx>     "P√®re No√´l P√®re No√´l"     ~caselessPos("O√ã")=                   -- 0    NFC, NFC    yes, 0, not 8 because "O√ã"~lower=='o√ã'
 0

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("O√ã", , 7)=              -- 0    NFC, NFC
 0
ooRexx>     "P√®re No√´l P√®re No√´l"     ~caselessPos("O√ã", , 9)=              -- 0    NFC, NFC
 0

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("O√ã", , 8)=              -- 7    NFC, NFC
 7
ooRexx>     "P√®re No√´l P√®re No√´l"     ~caselessPos("O√ã", , 10)=             -- 0    NFC, NFC    yes, 0, not 8 because "O√ã"~lower=='o√ã'
 0

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("O√ã", 8)=                -- 17   NFC, NFC
 17
ooRexx>     "P√®re No√´l P√®re No√´l"     ~caselessPos("O√ã", 9)=                -- 0    NFC, NFC    yes, 0, not 20 because "O√ã"~lower=='o√ã'
 0

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("O√ã", 8, 10)=            -- 0    NFC, NFC
 0
ooRexx>     "P√®re No√´l P√®re No√´l"     ~caselessPos("O√ã", 9, 13)=            -- 0    NFC, NFC
 0

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("O√ã", 8, 11)=            -- 17   NFC, NFC
 17
ooRexx>     "P√®re No√´l P√®re No√´l"     ~caselessPos("O√ã", 9, 14)=            -- 0    NFC, NFC    yes, 0, not 20 because "O√ã"~lower=='o√ã'
 0

ooRexx>     ---

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~caselessPos("O√ã")=                   -- 7    NFD, NFC
 7
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~caselessPos("O√ã")=                   -- 0    NFD, NFC    always 0, no need to test all the combinations
 0

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~caselessPos("O√ã", , 7)=              -- 0    NFD, NFC
 0

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~caselessPos("O√ã", , 8)=              -- 7    NFD, NFC
 7

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~caselessPos("O√ã", 8)=                -- 17   NFD, NFC
 17

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~caselessPos("O√ã", 8, 10)=            -- 0    NFD, NFC
 0

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~caselessPos("O√ã", 8, 11)=            -- 17   NFD, NFC
 17

ooRexx>     ---

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("OEÃà")=                   -- 7    NFC, NFD
 7
ooRexx>     "P√®re No√´l P√®re No√´l"     ~caselessPos("OEÃà")=                   -- 0    NFC, NFD   always 0, no need to test all the combinations
 0

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("OEÃà", , 7)=              -- 0    NFC, NFD
 0

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("OEÃà", , 8)=              -- 7    NFC, NFD
 7

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("OEÃà", 8)=                -- 17   NFC, NFD
 17

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("OEÃà", 8, 10)=            -- 0    NFC, NFD
 0

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("OEÃà", 8, 11)=            -- 17   NFC, NFD
 17

ooRexx>     ---

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~caselessPos("OEÃà")=                   -- 7    NFD, NFD
 7
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~caselessPos("OEÃà")=                   -- 9    NFD, NFD   yes, 9 (it works...) because the NFD representation isolate the accent: "oeÃà"~c2x=='6F65CC88',  "OEÃà"~lower~c2x=='6F65CC88'
 9

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~caselessPos("OEÃà", , 7)=              -- 0    NFD, NFD
 0
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~caselessPos("OEÃà", , 11)=             -- 0    NFD, NFD
 0

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~caselessPos("OEÃà", , 8)=              -- 7    NFD, NFD
 7
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~caselessPos("OEÃà", , 12)=             -- 9    NFD, NFD   yes, 9 (it works thanks to the NFD), see previous comment
 9

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~caselessPos("OEÃà", 8)=                -- 17   NFD, NFD
 17
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~caselessPos("OEÃà", 10)=               -- 23   NFD, NFD   yes, 23 (it works thanks to the NFD), see previous comment
 23

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~caselessPos("OEÃà", 8, 10)=            -- 0    NFD, NFD
 0
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~caselessPos("OEÃà", 10, 16)=           -- 0    NFD, NFD
 0

ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"~text~caselessPos("OEÃà", 8, 11)=            -- 17   NFD, NFD
 17
ooRexx>     "PeÃÄre NoeÃàl PeÃÄre NoeÃàl"     ~caselessPos("OEÃà", 10, 17)=           -- 23   NFD, NFD   yes, 23 (it works thanks to the NFD), see previous comment
 23

ooRexx>     ---

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("OE")=                   -- 0    NFC, NFC    always 0, no need to test all the combinations
 0
ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("OE", stripMark:)=       -- 7    NFC, NFC
 7

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("OE", , 7, stripMark:)=  -- 0    NFC, NFC
 0

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("OE", , 8, stripMark:)=  -- 7    NFC, NFC
 7

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("OE", 8, stripMark:)=    -- 17   NFC, NFC
 17

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("OE", 8, 10, stripMark:)=-- 0    NFC, NFC
 0

ooRexx>     "P√®re No√´l P√®re No√´l"~text~caselessPos("OE", 8, 11, stripMark:)=-- 17   NFC, NFC
 17


-- ===============================================================================
-- 2023 Aug 07

-- Add conversion from a Unicode encoding to a Byte encoding.
ooRexx> "P√®re No√´l"~text~transcodeTo("cp437")~c2x=                                  -- '50 8A 72 65 20 4E 6F 89 6C'
'50 8A 72 65 20 4E 6F 89 6C'
ooRexx> '50 8A 72 65 20 4E 6F 89 6C'x~text("cp437")~utf8~c2x=                       -- '50 C3A8 72 65 20 4E 6F C3AB 6C'
'50 C3A8 72 65 20 4E 6F C3AB 6C'
ooRexx> '50 8A 72 65 20 4E 6F 89 6C'x~text("cp437")~transcodeTo("utf8")~c2x=        -- '50 C3A8 72 65 20 4E 6F C3AB 6C'
'50 C3A8 72 65 20 4E 6F C3AB 6C'

-- The replacementCharacter "FF"x is interpreted as a UTF-8 string (default encoding). "FF"x~text~c2u= -- 'U+FFFD'
-- Hence the error "The replacement character UTF-8 not-ASCII '[FF]' cannot be transcoded to ISO-8859-1."
ooRexx> text = "P√®re No√´l üéÖ 10‚Ç¨"~text; do encoding over .Byte_Encoding~subclasses~~append(.Byte_Encoding); say encoding~name~left(13)":" text~transcodeTo(encoding, replacementCharacter:"FF"x)~c2x; end
The replacement character UTF-8 not-ASCII '[FF]' cannot be transcoded to ISO-8859-1.
Error code= 93.900

-- Here, the replacementCharacter is interpreted as a byte string encoded in the target encoding
ooRexx> text = "P√®re No√´l üéÖ 10‚Ç¨"~text; do encoding over .Byte_Encoding~subclasses~~append(.Byte_Encoding); say encoding~name~left(13)":" text~transcodeTo(encoding, replacementCharacter:"FF"x~text(encoding))~c2x; end
ISO-8859-1   : 50 E8 72 65 20 4E 6F EB 6C 20 FF 20 31 30 FF
ibm-1252     : 50 E8 72 65 20 4E 6F EB 6C 20 FF 20 31 30 FF
windows-1252 : 50 E8 72 65 20 4E 6F EB 6C 20 FF 20 31 30 80
IBM437       : 50 8A 72 65 20 4E 6F 89 6C 20 FF 20 31 30 FF
Byte         : 50 FF 72 65 20 4E 6F FF 6C 20 FF 20 31 30 FF


-- ===============================================================================
-- 2023 Aug 04


--- Following expressions return the same result correctly tagged 'ISO-8859-1'
ooRexx> b = .MutableBuffer~new; "Pere"~text("windows-1252")~append(" "~text("windows-1252"), buffer:b)~appendEncoded("No√´l"~text("iso-8859-1"), buffer:b)=; result~description=
M'Pere No√´l'
'ISO-8859-1 not-ASCII (10 bytes)'
ooRexx> b = .MutableBuffer~new; "Pere"~text("windows-1252")~appendEncoded(" "~text("windows-1252"), buffer:b)~appendEncoded("No√´l"~text("iso-8859-1"), buffer:b)=; result~description=
M'Pere No√´l'
'ISO-8859-1 not-ASCII (10 bytes)'
ooRexx> b = .MutableBuffer~new; b~appendEncoded("Pere"~text("windows-1252"), " "~text("windows-1252"), "No√´l"~text("iso-8859-1"))=; result~description=
M'Pere No√´l'
'ISO-8859-1 not-ASCII (10 bytes)'

-- Following expressions (not using 'appendEncoded') return the same result as above, but wrongly tagged 'windows-1252' or 'UTF-8'
ooRexx> b = .MutableBuffer~new; "Pere"~text("windows-1252")~append(" "~text("windows-1252"), buffer:b)~append("No√´l"~text("iso-8859-1"), buffer:b)=; result~description=
M'Pere No√´l'
'windows-1252 not-ASCII (10 bytes)'
ooRexx> b = .MutableBuffer~new; b~append("Pere"~text("windows-1252"), " "~text("windows-1252"), "No√´l"~text("iso-8859-1"))=; result~description=
M'Pere No√´l'
'UTF-8 not-ASCII by default (10 bytes)'


-- ===============================================================================
-- 2023 Jun 28

-- Bitkey is now 2 bytes (4 hex digits) always.

-- For debug, give temporarily access to the flags stored on an indexer.
ooRexx> "P√®re No√´l"~text~nfc(casefold:, stripMark:)~indexer~flags=
a Directory (10 items)
'FLAG_CASEFOLD'        :  1
'FLAG_LUMP'            : -1
'FLAG_NFC'             :  1
'FLAG_NFD'             : -1
'FLAG_NFKC'            : -1
'FLAG_NFKD'            : -1
'FLAG_STRIP_CC'        : -1
'FLAG_STRIP_IGNORABLE' : -1
'FLAG_STRIP_MARK'      :  1
'FLAG_STRIP_NA'        : -1


-- ===============================================================================
-- 2023 May 31

-- Add support for functional methods to RexxText.

-- Example inspired by https://elixir-lang.org/
-- Frequency of each character, ignoring the accents:
ooRexx> "Notre p√®re No√´l üéÖ"~text~transform(stripMark:)~reduce(by: "characters", initial: .stem~new~~put(0)){accu[item~string] += 1}=
a Stem (9 items)
'üéÖ' :  1
' '    :  3
'e'    :  4
'l'    :  1
'N'    :  2
'o'    :  2
'p'    :  1
'r'    :  2
't'    :  1

-- Add support for generator methods to RexxText.

ooRexx> g="No√´l üéÖ"~text~generateC
ooRexx> g~()=       -- T'N'
T'N'
ooRexx> g~()=       -- T'o'
T'o'
ooRexx> g~()=       -- T'√´'
T'√´'
ooRexx> g~()=       -- T'l'
T'l'
ooRexx> g~()=       -- T' '
T' '
ooRexx> g~()=       -- T'üéÖ'
T'üéÖ'
ooRexx> g~()=       -- [no result]
[no result]


-- ===============================================================================
-- 2023 May 29

-- For convenience, additional way to search a character:
-- with a routine
ooRexx> .UnicodeCharacter("bed")=                   -- ( "üõè"   U+1F6CF So 1 "BED" )
( "üõè"   U+1F6CF So 1 "BED" )
ooRexx> .UnicodeCharacter("bed", hexadecimal:)=     -- ( "‡Ø≠"   U+0BED Nd 1 "TAMIL DIGIT SEVEN" )
( "‡Ø≠"   U+0BED Nd 1 "TAMIL DIGIT SEVEN" )
-- with the operator []
ooRexx> .UnicodeCharacter["bed"]=                   -- ( "üõè"   U+1F6CF So 1 "BED" )
( "üõè"   U+1F6CF So 1 "BED" )
ooRexx> .UnicodeCharacter["bed", hexadecimal:]=     -- ( "‡Ø≠"   U+0BED Nd 1 "TAMIL DIGIT SEVEN" )
( "‡Ø≠"   U+0BED Nd 1 "TAMIL DIGIT SEVEN" )

-- This comes in complement of:
ooRexx> .Unicode["bed", hexadecimal:]=              -- ( "‡Ø≠"   U+0BED Nd 1 "TAMIL DIGIT SEVEN" )
( "‡Ø≠"   U+0BED Nd 1 "TAMIL DIGIT SEVEN" )
ooRexx> .Unicode~character("bed", hexadecimal:)=    -- ( "‡Ø≠"   U+0BED Nd 1 "TAMIL DIGIT SEVEN" )
( "‡Ø≠"   U+0BED Nd 1 "TAMIL DIGIT SEVEN" )


-- New method UnicodeCharacter~properties at class level: return a list of property names.
ooRexx> .UnicodeCharacter~properties=
['aliases','bidiClass','bidiClassName','bidiMirrored','boundClass','boundClassName','category','categoryName','charWidth','codepoint','combiningClass','controlBoundary','decompositionTypeName','decompositionType','ignorable','isLower','isUpper','name','toLowerFull','toLowerSimple','toTitleFull','toTitleSimple','toUpperFull','toUpperSimple','Unicode','UTF16BE','UTF16LE','UTF32BE','UTF32LE','UTF8']


-- ===============================================================================
-- 2023 May 24

-- For convenience, it's now possible to search directly a character if it's made of one codepoint only:
ooRexx> .Unicode~character("a")=    -- ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
ooRexx> .Unicode~character("√†")=    -- ( "√†"   U+00E0 Ll 1 "LATIN SMALL LETTER A WITH GRAVE" )
( "√†"   U+00E0 Ll 1 "LATIN SMALL LETTER A WITH GRAVE" )
ooRexx> .Unicode~character("aÃÄ")=    -- Error: The character 'aÃÄ' is made of several codepoints: U+0061 U+0300
The character 'aÃÄ' is made of several codepoints: U+0061 U+0300.
Error code= 93.900

-- For the last example, you can get an array of characters:
ooRexx> "aÃÄ"~text~UnicodeCharacters==
an Array (shape [2], 2 items)
 1 : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
 2 : ( "ÃÄ"    U+0300 Mn 0 "COMBINING GRAVE ACCENT" )


-- New method UnicodeCharacter~properties at instance level: Return a directory of properties.
ooRexx> .Unicode~character("U+000D")~properties=
a Directory (30 items)
'aliases'               : [(CARRIAGE RETURN),(CR)]
'bidiClass'             :  16
'bidiClassName'         : 'B'
'bidiMirrored'          :  0
'boundClass'            :  2
'boundClassName'        : 'CR'
'category'              :  26
'categoryName'          : 'Cc'
'charWidth'             :  0
'codepoint'             : 'U+000D'
'combiningClass'        :  0
'controlBoundary'       :  1
'decompositionType'     :  0
'decompositionTypeName' : 'None'
'ignorable'             :  0
'isLower'               :  0
'isUpper'               :  0
'name'                  : ''
'toLowerFull'           : 'U+000D'
'toLowerSimple'         : 'U+000D'
'toTitleFull'           : 'U+000D'
'toTitleSimple'         : 'U+000D'
'toUpperFull'           : 'U+000D'
'toUpperSimple'         : 'U+000D'
'Unicode'               : '0x0D'
'UTF16BE'               : '0x000D'
'UTF16LE'               : '0x0D00'
'UTF32BE'               : '0x0000000D'
'UTF32LE'               : '0x0D000000'
'UTF8'                  : '0x0D'


-- ===============================================================================
-- 2023 March 20

-- Rework implementation of caselessMatch to support correctly
ooRexx> "Bundesstra√üe im Freiland"~text~caselessMatch(14, "im")=    -- .true
 1


-- ===============================================================================
-- 2023 March 08

-- Implementation of caselessMatchChar, matchChar
ooRexx> "No√´lle"~text~matchChar(2, "aeiouy")=                       -- 1
 1
ooRexx> "No√´lle"~text~matchChar(3, "aeiouy")=                       -- 0
 0
ooRexx> "No√´lle"~text~matchChar(3, "ae√´iouy")=                      -- 1    include the accents in the list of accepted characters
 1
ooRexx> "No√´lle"~text~matchChar(3, "aeiouy", stripMark:)=           -- 1    or remove the accents from the tested string
 1
ooRexx> "No√´lle"~text~matchChar(6, "aeiouy")=                       -- 1
 1

ooRexx> "Bundesschnellstra√üe"~text~matchChar(14, "s")=              -- 1
 1
ooRexx> "Bundesschnellstra√üe"~text~matchChar(18, "s")=              -- 0
 0
ooRexx> "Bundesschnellstra√üe"~text~matchChar(18, "s√ü")=             -- 1
 1
ooRexx> "Bundesschnellstra√üe"~text~caselessMatchChar(18, "s")=      -- 0, was 1 before 2023.12.04    "√ü" becomes "ss" which is 2 graphemes. The first grapheme at 18 matches "s"
 0
ooRexx> "Bundesschnellstra√üe"~text~caselessMatchChar(19, "s")=      -- 0    "√ü" becomes "ss" which is 2 graphemes. The grapheme at 19 is "e", not the second "s"
 0
ooRexx> "Bundesschnellstra√üe"~text~caselessMatchChar(19, "e")=      -- 1    "√ü" becomes "ss" which is 2 graphemes. The grapheme at 19 is "e", not the second "s"
 1

-- The ligature disappears in NFK[CD] but not in NF[CD]
ooRexx> "baÔ¨Ñe"~text~NFKC=                                            -- T'baffle'
T'baffle'
ooRexx> "baÔ¨Ñe"~text~NFKD=                                            -- T'baffle'
T'baffle'
ooRexx> "baÔ¨Ñe"~text~matchChar(3, "f")=                               -- 0     "Ô¨Ñ" is ONE grapheme because NFC
 0
ooRexx> "baÔ¨Ñe"~text~matchChar(3, "Ô¨Ñ")=                               -- 1     "Ô¨Ñ" is ONE grapheme because NFC
 1
ooRexx> "baÔ¨Ñe"~text~matchChar(3, "Ô¨Ñ", normalization:.Unicode~NFKD)=  -- 1     "Ô¨Ñ" becomes "ffl" (3 graphemes). There is a match because the first grapheme is "f"
 1
ooRexx> "baÔ¨Ñe"~text~matchChar(3, "f", normalization:.Unicode~NFKD)=  -- 0, was 1 before 2023.12.04     "Ô¨Ñ" becomes "ffl" (3 graphemes). There is a match because the first grapheme is "f"
 0
ooRexx> "baÔ¨Ñe"~text~matchChar(4, "f", normalization:.Unicode~NFKD)=  -- 0     "Ô¨Ñ" becomes "ffl" (3 graphemes). The grapheme at 4 is "e", not the second "f"
 0
ooRexx> "baÔ¨Ñe"~text~matchChar(4, "e", normalization:.Unicode~NFKD)=  -- 1     "Ô¨Ñ" becomes "ffl" (3 graphemes). The grapheme at 4 is "e", not the second "f"
 1

-- The ligature disappears when casefolded
ooRexx> "baÔ¨Ñe"~text~casefold=                                        -- T'baffle'
T'baffle'
ooRexx> "BAFFLE"~text~caselessMatchChar(3, "Ô¨Ñ")=                     -- 0, was 1 before 2023.12.04     "Ô¨Ñ" becomes "ffl" (3 graphemes), there is a match on "f" at 3
 0
ooRexx> "BAFFLE"~text~caselessMatchChar(5, "Ô¨Ñ")=                     -- 0, was 1 before 2023.12.04     "Ô¨Ñ" becomes "ffl" (3 graphemes), there is a match on "l" at 5
 0
ooRexx> "BAFFLE"~text~caselessMatchChar(5, "L")=                     -- 1      there is a match on "l" at 5 (forward to String)
 1


-- Implementation of caselessEquals, equals
ooRexx> "≈íUF"~text~caselessEquals("≈ìuf")=           -- 1
 1
ooRexx> "≈ìuf"~text~caselessEquals("≈íUF")=           -- 1
 1
ooRexx> "Stra√üe"~text~caselessEquals("strasse")=    -- 1
 1
ooRexx> "strasse"~text~caselessEquals("Stra√üe")=    -- 1
 1


-- Some ligatures are not decomposed by NFKC.
ooRexx> "≈íUF"~text~caselessEquals("oeuf")=                                  -- 0
 0
ooRexx> "≈íUF"~text~caselessEquals("oeuf", normalization:.Unicode~NFKC)=     -- 0
 0


-- ===============================================================================
-- 2022 November 20

/*
For consistency, all the conversion methods accept the named argument 'strict',
even if it's not needed for the unicode encodings.
Previously, was supported only for the byte encodings.
The default value of 'strict' is now .false.

The conversion methods accept the named argument 'memorize(3)'.
Its default value is given by .unicode~memorizeTranscodings (was memorizeConversions) which is .false by default.
Example:
    s = "hello"
    t = s~text
    utf16 = t~utf16(memorize:)
    utf32 = t~utf32(memorize:)
    t~utf16~"==":.object(utf16)=         -- 1
    t~utf32~"==":.object(utf32)=         -- 1
*/

/*
CP1252 to UTF-8, UTF-16, UTF-32
"Un ≈ìuf de chez MaPoule‚Ñ¢ co√ªte ¬±0.40‚Ç¨"
*/
ooRexx> str_cp1252 = "Un " || "9C"x || "uf de chez MaPoule" || "99"x || " co" || "FB"x || "te " || "B1"x || "0.40" || "80"x
ooRexx> txt_cp1252 = str_cp1252~text("cp1252")
ooRexx> utf8  = txt_cp1252~utf8(memorize:)
ooRexx> utf16 = txt_cp1252~utf16(memorize:)
ooRexx> utf32 = txt_cp1252~utf32(memorize:)
ooRexx> txt_cp1252~utf8 ~"==":.object(utf8) =         -- 1
 1
ooRexx> txt_cp1252~utf16~"==":.object(utf16)=         -- 1
 1
ooRexx> txt_cp1252~utf32~"==":.object(utf32)=         -- 1
 1

/*
When an optional buffer is passed, must check that its encoding is compatible.
Done for the conversion methods.
Example:
*/
ooRexx> b = .mutablebuffer~new            -- No encoding yet
ooRexx> "hello"~text~utf16(buffer:b)      -- now the buffer's encoding is UTF-16
ooRexx> "bye"~text~utf8(buffer:b)         -- Encoding: cannot append UTF-8 to UTF-16BE '[00]h[00]e[00]l[00]l[00]o'.
Encoding: cannot append UTF-8 to UTF-16BE '[00]h[00]e[00]l[00]l[00]o'.
Error code= 23.900


-- ===============================================================================
-- 2022 November 08

/*
Additional arguments are supported by NFC, NFD, NFKC, NFKD, Casefold:
    lump
        Lumps certain different codepoints together.
        All the concerned characters become the same character, but still remain distinct characters.
        E.g. HYPHEN U+2010 and MINUS U+2212 to ASCII "-"
             all space characters (general category Zs) to U+0020
    stripIgnorable
        Strips the characters whose property Default_Ignorable_Code_Point = true
        such as SOFT-HYPHEN or ZERO-WIDTH-SPACE
    stripCC
        Strips and/or converts control characters:
        characters 00-1F and 7F-9F, except 09 which is replaced by 20.
    stripMark
        Strips all character markings:
        characters whose category is Mc Me Mn (i.e. accents)
            Mc Spacing Mark
            Me Enclosing Mark
            Mn Nonspacing Mark
        This option works only with normalization.
    stripNA
        Strips the characters whose category is Cn Unassigned
        Note that the value gc=Cn does not actually occur in UnicodeData.txt,
        because that data file does not list unassigned code points.

Remark: the normalization NFKC_Casefold (short alias NFKC_CF) is done with
    ~NFKC(Casefold: .true, stripIgnorable: .true)
*/

/*
Two RexxText values are considered equal if their extended grapheme clusters are canonically equivalent.
This is the definition of Swift.
Q&A https://lists.isocpp.org/sg16/2018/08/0121.php
TODO: confirm that it's NFC, and only that.
The definition of canonical equivalence by the Unicode standard seems not limited to NFC.
https://unicode.org/notes/tn5/

The strict comparison operators now use the NFC normalization (update: use .Unicode~defaultNormalization(strict:.true)).
After normalization, they delegate to the String's strict comparison operators.

The non-strict comparison operators now use the NFC normalization (update: use .Unicode~defaultNormalization(strict:.false))
plus
    stripIgnorable:.true
    lump:.true
After normalization + transformations, they delegate to the String's non-strict comparison operators.
Thanks to the lump transformation, all the Unicode spaces are supported.

Examples:
*/

ooRexx> textNFC = "No√´l"~text~NFC
ooRexx> textNFC~UnicodeCharacters==
an Array (shape [4], 4 items)
 1 : ( "N"   U+004E Lu 1 "LATIN CAPITAL LETTER N" )
 2 : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
 3 : ( "√´"   U+00EB Ll 1 "LATIN SMALL LETTER E WITH DIAERESIS" )
 4 : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
ooRexx> textNFD="No√´l"~text~NFD
ooRexx> textNFD~UnicodeCharacters==
an Array (shape [5], 5 items)
 1 : ( "N"   U+004E Lu 1 "LATIN CAPITAL LETTER N" )
 2 : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
 3 : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )
 4 : ( "Ãà"    U+0308 Mn 0 "COMBINING DIAERESIS" )
 5 : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
ooRexx> (textNFC == textNFD)=                                               -- 1
 1
ooRexx> (textNFC = textNFD)=                                                -- 1
 1
ooRexx> (" "textNFC == textNFD" ")=                                         -- 0 because strict
 0
ooRexx> (" "textNFC = textNFD" ")=                                          -- 1
 1
ooRexx> (" "textNFC = (textNFD"\u{NBSP}")~unescape)=                        -- 1
 1
ooRexx> (" "textNFC = (textNFD"\u{ZWSP}")~unescape)=                        -- 1
 1
ooRexx> ("-"textNFC = ("\u{OBLIQUE HYPHEN}"textNFD"\u{ZWSP}")~unescape)=    -- 1
 1

ooRexx> "pere noel"~text~caselessCompareTo("P√®re No√´l")=                    -- -1 (lesser)
-1
ooRexx> "pere noel"~text~caselessCompareTo("P√®re No√´l", stripMark:.true)=   --  0 (equal because the accents are ignored)
 0

-- Add support for ISO-8859-1 encoding (alias Latin1).
-- Example:
-- all the supported characters: ranges 20-7E and A0-FF
ooRexx> text = xrange("20"x, "7E"x, "A0"x, "FF"x)~text("ISO-8859-1")

-- The ? are just ISO-8859-1 encoded characters that can't be displayed as-is in a console UTF-8 (copy-paste of the console output)
-- After conversion to UTF-8, all is good.
ooRexx> text=       -- T' !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~???????????????????????????????????????????????????????????????????????????????????????????????[FF]'
T' !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛[FF]'
ooRexx> text~utf8=  -- T' !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√ú√ù√û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω√æ√ø'
T' !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√ú√ù√û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω√æ√ø'

-- ranges 00-1F and 7F-9F are undefined
-- an error is triggered even with the option strict: .false, because there is no fallback mapping
ooRexx> text = xrange("20"x, "FF"x)~text("ISO-8859-1")
ooRexx> text~utf8(strict: .false)=                      -- Error ISO-8859-1 encoding: cannot convert ISO-8859-1 not-ASCII character 127 (7F) at byte-position 96 to UTF-8.
T' !"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~¬Ä¬Å¬Ç¬É¬Ñ¬Ö¬Ü¬á¬à¬â¬ä¬ã¬å¬ç¬é¬è¬ê¬ë¬í¬ì¬î¬ï¬ñ¬ó¬ò¬ô¬ö¬õ¬ú¬ù¬û¬ü¬†¬°¬¢¬£¬§¬•¬¶¬ß¬®¬©¬™¬´¬¨¬≠¬Æ¬Ø¬∞¬±¬≤¬≥¬¥¬µ¬∂¬∑¬∏¬π¬∫¬ª¬º¬Ω¬æ¬ø√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ó√ò√ô√ö√õ√ú√ù√û√ü√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∑√∏√π√∫√ª√º√Ω√æ√ø'


-- ===============================================================================
-- 2022 November 06

/*
Refactoring
    Prefix the native methods by the library name (utf8proc_, ziglyph_ or icu4x_).
    That will make more easy the comparison of similar services.

    Remove the native methods 'NFC', 'NFD', 'NFKC', 'NFKD' and 'NFKC_Casefold':
    all replaced by 'utf8proc_transform'.

    ~Casefold is now limited to case fold.
    Previously, NKFC + case fold was applied (because the method NFKC_Casefold of utf8proc was called).

    NFC, NFD, NFKC and NFKD now supports the named argument 'casefold' (default = .false).

Examples
*/
ooRexx> "P√®re No√´l √ü „éí"~text~casefold=                      -- T'p√®re no√´l ss „éí'
T'p√®re no√´l ss „éí'
ooRexx> "P√®re No√´l √ü „éí"~text~NFKC=                          -- T'P√®re No√´l √ü MHz'
T'P√®re No√´l √ü MHz'
ooRexx> "P√®re No√´l √ü „éí"~text~NFKC(casefold:.true)=          -- T'p√®re no√´l ss mhz'
T'p√®re no√´l ss mhz'

/*
Performance
    NFC, NFD, NFKC, NFKD and Casefold now supports the named argument 'returnString'.
    - When true, the returned value is a String.
    - When false (default), the returned value is a RexxText.
    Maybe this optimization will be replaced by a more general optimization: RexxText indexation on need.

    2 cached values are managed in case of memorization:
    - one for the main transformation,
    - one for the main transformation + case fold.
    That makes 9 possible cached value and 5 indicators per indexer (so per string).
        isCasefold                  CasefoldString
        isNFC       NFCString       NFCCasefoldString
        isNFD       NFDString       NFDCasefoldString
        isNFKC      NFKCString      NFKCCasefoldString
        isNFKD      NFKDString      NFKDCasefoldString

    The memorization can be activated globally:
    .Unicode~memorizeTransformations = .true

Examples
*/
-- Direct access to utf8proc, returns a string
ooRexx> s = "P√®re No√´l √ü „éí"; do 10000; .Unicode~utf8proc_transform(s, normalization:3, casefold:.true); end -- Duration:   0.05
---
ooRexx> t = "P√®re No√´l √ü „éí"~text; do 10000; t~NFKC(casefold:.true); end                                     -- Duration:   7.70
ooRexx> t = "P√®re No√´l √ü „éí"~text; do 10000; t~NFKC(casefold:.true, returnString:.true); end                 -- Duration:   0.33
ooRexx> t = "P√®re No√´l √ü „éí"~text; do 10000; t~NFKC(casefold:.true, returnString:.true, memorize:.true); end -- Duration:   0.11
-- The cache for NFKC  + casefold is different from the cache for NFKC only:
ooRexx> t = "P√®re No√´l √ü „éí"~text; do 10000; t~NFKC; end                                                     -- Duration:   6.50
ooRexx> t = "P√®re No√´l √ü „éí"~text; do 10000; t~NFKC(returnString:.true); end                                 -- Duration:   0.30
ooRexx> t = "P√®re No√´l √ü „éí"~text; do 10000; t~NFKC(returnString:.true, memorize:.true); end                 -- Duration:   0.10


-- ===============================================================================
-- 2022 November 05

/*
New methods on RexxText
    caselessContains        (not ready: posText)
    caselessCompareTo
    caselessMatch
    caselessMatchChar       (not ready: matchCharText)
    caselessEndsWith        (not ready: endsWithText)
    caselessPos             (not ready: posText)
    caselessStartsWith      (not ready: posText)
    compareTo
    contains                (not ready: posText)
    endsWith                (not ready: endsWithText)
    match
    matchChar               (not ready: matchCharText)
    pos                     (not ready: posText)
    startsWith              (not ready: posText)

For caseless, apply NFC Casefold to all the text/string arguments.
Compared to the ooRexx methods, the purpose of these methods is to convert the grapheme indexes to/from byte indexes.
The real work is done by the ooRexx methods, called with the right byte indexes.
From a byte index returned by an ooRexx method, a grapheme index is derived.


Examples:
*/
ooRexx>                                                 --  1  2    3  4  5  6  7  8 9  10 (grapheme indexes)
ooRexx>                                                 --  1  2 3  4  5  6  7  8  9 10 11 (byte indexes)
ooRexx>     "p√®re No√´l"~text~c2x=                       -- '70 C3A8 72 65 20 4E 6F C3AB 6C'
'70 C3A8 72 65 20 4E 6F C3AB 6C'
ooRexx>                                                 --  p  √®    r  e     N  o  √´    l
ooRexx>     "p√®re No√´l"~match(1, "No√´l")=               -- .false (byte indexes)
 0
ooRexx>     "p√®re No√´l"~text~match(1, "No√´l")=          -- .false (grapheme indexes)
 0
ooRexx>     "p√®re No√´l"~match(7, "No√´l")=               -- .true (byte indexes)
 1
ooRexx>     "p√®re No√´l"~text~match(6, "No√´l")=          -- .true (grapheme indexes)
 1
ooRexx>     "p√®re No√´l"~match(11, "No√´l", 5)=           -- .true (byte indexes)
 1
ooRexx>     "p√®re No√´l"~text~match(9, "No√´l", 4)=       -- .true (grapheme indexes)
 1

ooRexx>     "p√®re No√´l"~text~caselessMatch(1, "NO√ãL")=  -- .false
 0
ooRexx>     "p√®re No√´l"~text~caselessMatch(6, "NO√ãL")=  -- .true
 1

ooRexx>     -- the first "√§X√º" is NFC, the second "aÃàXÃàuÃà" is NFD
ooRexx>     nfcString = "√§X√º"
ooRexx>         nfcText = nfcString~text
ooRexx>         nfcText~c2x=                            -- 'C3A4 58 C3BC'
'C3A4 58 C3BC'
ooRexx>         nfcText~UnicodeCharacters==
an Array (shape [3], 3 items)
 1 : ( "√§"   U+00E4 Ll 1 "LATIN SMALL LETTER A WITH DIAERESIS" )
 2 : ( "X"   U+0058 Lu 1 "LATIN CAPITAL LETTER X" )
 3 : ( "√º"   U+00FC Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS" )
ooRexx>     nfdString = "aÃàXuÃà"
ooRexx>         nfdText = nfdString~text
ooRexx>         nfdText~c2x=                            -- '61 CC88 58 75 CC88'
'61 CC88 58 75 CC88'
ooRexx>         nfdText~UnicodeCharacters==
an Array (shape [5], 5 items)
 1 : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
 2 : ( "Ãà"    U+0308 Mn 0 "COMBINING DIAERESIS" )
 3 : ( "X"   U+0058 Lu 1 "LATIN CAPITAL LETTER X" )
 4 : ( "u"   U+0075 Ll 1 "LATIN SMALL LETTER U" )
 5 : ( "Ãà"    U+0308 Mn 0 "COMBINING DIAERESIS" )

ooRexx>     nfcString~match(1, nfdString)=              -- 0 (because binary representation is different)
 0
ooRexx>     nfcText  ~match(1, nfdText)=                -- 1
 1
ooRexx>     nfdText  ~match(1, nfcText)=                -- 1
 1

ooRexx>     -- match with "X"

ooRexx>     nfcString~match(3, nfdString, 4, 1)=        -- 1 (byte indexes)
 1
ooRexx>     nfcText  ~match(2, nfdText,   2, 1)=        -- 1 (grapheme indexes)
 1

ooRexx>     nfdString~match(4, nfcString, 3, 1)=        -- 1 (byte indexes)
 1
ooRexx>     nfdText  ~match(2, nfcText,   2, 2)=        -- 1 (grapheme indexes)
 1

-- ===============================================================================
-- 2022 October 15

/*
New native method .Unicode~transform
Mainly for internal use, will replace the current native methods NFC, NFD, NFKC, NFKD.
The purpose of this method is to support additional transformations provided by utf8proc.
Takes a byte string as input (UTF-8 encoded), returns a new transformed byte string as output (UTF-8).

Examples:
*/
ooRexx>     string = "\u{BEL}Le\u{IDEOGRAPHIC SPACE}\u{OGHAM SPACE MARK}\u{ZERO-WIDTH-SPACE}P√®re\t\u{HYPHEN}\u{SOFT-HYPHEN}\u{EN DASH}\u{EM DASH}No√´l\x{EFB790}\r\n"
ooRexx>     text = string~text~unescape
ooRexx>     text~UnicodeCharacters==
an Array (shape [22], 22 items)
 1  : ( ""    U+0007 Cc 0 "", "ALERT", "BEL" )
 2  : ( "L"   U+004C Lu 1 "LATIN CAPITAL LETTER L" )
 3  : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )
 4  : ( "„ÄÄ"  U+3000 Zs 2 "IDEOGRAPHIC SPACE" )
 5  : ( "·öÄ"   U+1680 Zs 1 "OGHAM SPACE MARK" )
 6  : ( "‚Äã"    U+200B Cf 0 "ZERO WIDTH SPACE", "ZWSP" )
 7  : ( "P"   U+0050 Lu 1 "LATIN CAPITAL LETTER P" )
 8  : ( "√®"   U+00E8 Ll 1 "LATIN SMALL LETTER E WITH GRAVE" )
 9  : ( "r"   U+0072 Ll 1 "LATIN SMALL LETTER R" )
 10 : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )
 11 : ( ""    U+0009 Cc 0 "", "CHARACTER TABULATION", "HORIZONTAL TABULATION", "HT", "TAB" )
 12 : ( "‚Äê"   U+2010 Pd 1 "HYPHEN" )
 13 : ( "¬≠"   U+00AD Cf 1 "SOFT HYPHEN", "SHY" )
 14 : ( "‚Äì"   U+2013 Pd 1 "EN DASH" )
 15 : ( "‚Äî"   U+2014 Pd 1 "EM DASH" )
 16 : ( "N"   U+004E Lu 1 "LATIN CAPITAL LETTER N" )
 17 : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
 18 : ( "√´"   U+00EB Ll 1 "LATIN SMALL LETTER E WITH DIAERESIS" )
 19 : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
 20 : ( "Ô∑ê"   U+FDD0 Cn 1 "" )
 21 : ( ""    U+000D Cc 0 "", "CARRIAGE RETURN", "CR" )
 22 : ( ""    U+000A Cc 0 "", "LINE FEED", "NEW LINE", "END OF LINE", "LF", "NL", "EOL" )

ooRexx>     text=                                                               -- T'[07]Le„ÄÄ·öÄ‚ÄãP√®re[09]‚Äê¬≠‚Äì‚ÄîNo√´lÔ∑ê[0D0A]'
T'[07]Le„ÄÄ·öÄ‚ÄãP√®re[09]‚Äê¬≠‚Äì‚ÄîNo√´lÔ∑ê[0D0A]'

ooRexx>     -- Performs unicode case folding, to be able to do a case-insensitive string comparison.
ooRexx>     .Unicode~utf8proc_transform(text~string, casefold:.true)=           --  '[07]le„ÄÄ·öÄ‚Äãp√®re[09]‚Äê¬≠‚Äì‚Äîno√´lÔ∑ê[0D0A]'
'[07]le„ÄÄ·öÄ‚Äãp√®re[09]‚Äê¬≠‚Äì‚Äîno√´lÔ∑ê[0D0A]'

ooRexx>     -- Strip "default ignorable characters" such as SOFT-HYPHEN or ZERO-WIDTH-SPACE
ooRexx>     .Unicode~utf8proc_transform(text~string, stripIgnorable:.true)=     --  '[07]Le„ÄÄ·öÄP√®re[09]‚Äê‚Äì‚ÄîNo√´lÔ∑ê[0D0A]'
'[07]Le„ÄÄ·öÄP√®re[09]‚Äê‚Äì‚ÄîNo√´lÔ∑ê[0D0A]'

ooRexx>     -- Lumps certain characters together. See lump.md for details:
ooRexx>     -- https://github.com/JuliaStrings/utf8proc/blob/master/lump.md
ooRexx>     -- E.g. HYPHEN U+2010 and MINUS U+2212 to ASCII "-"
ooRexx>     -- jlf: I was expecting to have only one space and one "-" but that's not the case
ooRexx>     -- Seems working as designed... All the concerned characters become the same character, but still remain distinct characters.
ooRexx>     .Unicode~utf8proc_transform(text~string, lump:.true)=               --  '[07]Le  ‚ÄãP√®re[09]-¬≠--No√´lÔ∑ê[0D0A]'
'[07]Le  ‚ÄãP√®re[09]-¬≠--No√´lÔ∑ê[0D0A]'

ooRexx>     -- NLF2LF: Convert LF, CRLF, CR and NEL into LF
ooRexx>     .Unicode~utf8proc_transform(text~string, NLF:1)=                    --  '[07]Le„ÄÄ·öÄ‚ÄãP√®re[09]‚Äê¬≠‚Äì‚ÄîNo√´lÔ∑ê[0A]'
'[07]Le„ÄÄ·öÄ‚ÄãP√®re[09]‚Äê¬≠‚Äì‚ÄîNo√´lÔ∑ê[0A]'

ooRexx>     -- NLF2LS: Convert LF, CRLF, CR and NEL into LS (U+2028 Zl 0 "LINE SEPARATOR")
ooRexx>     .Unicode~utf8proc_transform(text~string, NLF:2)=                    --  '[07]Le„ÄÄ·öÄ‚ÄãP√®re[09]‚Äê¬≠‚Äì‚ÄîNo√´lÔ∑ê'
'[07]Le„ÄÄ·öÄ‚ÄãP√®re[09]‚Äê¬≠‚Äì‚ÄîNo√´lÔ∑ê‚Ä®'

ooRexx>     -- NLF2PS: convert LF, CRLF, CR and NEL into PS (U+2029 Zp 0 "PARAGRAPH SEPARATOR")
ooRexx>     .Unicode~utf8proc_transform(text~string, NLF:3)=                    --  '[07]Le„ÄÄ·öÄ‚ÄãP√®re[09]‚Äê¬≠‚Äì‚ÄîNo√´lÔ∑ê‚Ä©'
'[07]Le„ÄÄ·öÄ‚ÄãP√®re[09]‚Äê¬≠‚Äì‚ÄîNo√´lÔ∑ê‚Ä©'

ooRexx>     -- Strips and/or converts control characters.
ooRexx>     .Unicode~utf8proc_transform(text~string, stripCC:.true)=            --  'Le„ÄÄ·öÄ‚ÄãP√®re ‚Äê¬≠‚Äì‚ÄîNo√´lÔ∑ê '
'Le„ÄÄ·öÄ‚ÄãP√®re ‚Äê¬≠‚Äì‚ÄîNo√´lÔ∑ê '

ooRexx>     -- Strips all character markings.
ooRexx>     -- This includes non-spacing, spacing and enclosing (i.e. accents).
ooRexx>     -- This option works only with normalization.
ooRexx>     .Unicode~utf8proc_transform(text~string, stripMark:.true, normalization:1)=  --  '[07]Le„ÄÄ·öÄ‚ÄãPere[09]‚Äê¬≠‚Äì‚ÄîNoelÔ∑ê[0D0A]'
'[07]Le„ÄÄ·öÄ‚ÄãPere[09]‚Äê¬≠‚Äì‚ÄîNoelÔ∑ê[0D0A]'

ooRexx>     -- Strips unassigned codepoints.
ooRexx>     .Unicode~utf8proc_transform(text~string, stripNA:.true)=            --  '[07]Le„ÄÄ·öÄ‚ÄãP√®re[09]‚Äê¬≠‚Äì‚ÄîNo√´l[0D0A]'
'[07]Le„ÄÄ·öÄ‚ÄãP√®re[09]‚Äê¬≠‚Äì‚ÄîNo√´l[0D0A]'

ooRexx>     -- Application of several options
ooRexx>     .Unicode~utf8proc_transform(text~string, casefold:.true, lump:.true, normalization:1, stripIgnorable:.true, stripCC:.true, stripMark:.true, stripNA:.true)= --  'le  pere ---noel '
'le  pere ---noel '


-- ===============================================================================
-- 2022 September 14

/*
New methods on RexxText
    center
    centre
Examples:
*/
ooRexx>     "no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~description=                  -- 'UTF-8 not-ASCII (6 graphemes, 12 codepoints, 34 bytes, 0 error)'
'UTF-8 not-ASCII (6 characters, 12 codepoints, 34 bytes, 0 error)'
ooRexx>     "no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~center(10)=                   -- T'  no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ  '
T'  no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ  '
ooRexx>     "no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~center(10)~description=       -- 'UTF-8 not-ASCII (10 graphemes, 16 codepoints, 38 bytes, 0 error)'
'UTF-8 not-ASCII (10 characters, 16 codepoints, 38 bytes, 0 error)'
ooRexx>     pad = "‚ïê"
ooRexx>     pad~description=                                          -- 'UTF-8 not-ASCII (1 grapheme, 1 codepoint, 3 bytes, 0 error)'
'UTF-8 not-ASCII by default (3 bytes)'
ooRexx>     pad~c2x=                                                  -- 'E29590'
'E29590'
ooRexx>     "no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~center(10, pad)=              -- T'‚ïê‚ïêno√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ‚ïê‚ïê'
T'‚ïê‚ïêno√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ‚ïê‚ïê'
ooRexx>     "no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~center(10, pad)~description=  -- 'UTF-8 not-ASCII (10 graphemes, 16 codepoints, 46 bytes, 0 error)'
'UTF-8 not-ASCII (10 characters, 16 codepoints, 46 bytes, 0 error)'


-- ===============================================================================
-- 2022 September 09


-- Start working on encoding~previousCodepointIndexB:
ooRexx>     "üéÖno√´l"~text~c2x=  -- 'F09F8E85 6E 6F C3AB 6C'
'F09F8E85 6E 6F C3AB 6C'
ooRexx>     .utf8_encoding~previousCodepointIndexB("üéÖno√´l", 0)=   -- 0
 0
ooRexx>     .utf8_encoding~previousCodepointIndexB("üéÖno√´l", 1)=   -- 1
 1
ooRexx>     .utf8_encoding~previousCodepointIndexB("üéÖno√´l", 2)=   -- 1
 1
ooRexx>     .utf8_encoding~previousCodepointIndexB("üéÖno√´l", 3)=   -- 1
 1
ooRexx>     .utf8_encoding~previousCodepointIndexB("üéÖno√´l", 4)=   -- 1
 1
ooRexx>     .utf8_encoding~previousCodepointIndexB("üéÖno√´l", 5)=   -- 1
 1
ooRexx>     .utf8_encoding~previousCodepointIndexB("üéÖno√´l", 6)=   -- 5
 5
ooRexx>     .utf8_encoding~previousCodepointIndexB("üéÖno√´l", 7)=   -- 6
 6
-- Currently, only Byte_encoding and UTF8_encoding supports this new method.
-- Still lot of work to detect the same errors as nextCodepointIndex.


-- ===============================================================================
-- 2022 September 08

-- Set/get an encoding on a string without having an associated RexxText
-- (similar to MutableBuffer)
ooRexx> s = "nonsense"
ooRexx> s~encoding =                      -- returns the default encoding: (The UTF8_Encoding class)
(The UTF8_Encoding class)
ooRexx> s~hasText =                       -- 0
 0
ooRexx> s~encoding = .UTF16BE_Encoding    -- tag the string: encoded UTF16BE
ooRexx> s~encoding =                      -- (The UTF16BE_Encoding class)
(The UTF16BE_Encoding class)
ooRexx> s~hasText =                       -- still no associated RexxText: 0
 0
ooRexx> t = s~text                        -- associates a RexxText to the string
ooRexx> s~hasText =                       -- the string has an associated text: 1
 1
ooRexx> t~encoding =                      -- the encoding of the text is the one of the string: (The UTF16BE_Encoding class)
(The UTF16BE_Encoding class)
ooRexx> t~utf8 =                          -- T'ÊπØÊπ≥ÊïÆÁç•'      Soup
T'ÊπØÊπ≥ÊïÆÁç•'
-- Setting/getting the encoding of the string will set/get the encoding of the associated RexxText
ooRexx> s~encoding = .UTF16LE_Encoding
ooRexx> t~encoding =                      -- the encoding of the text has been changed: (The UTF16LE_Encoding class)
(The UTF16LE_Encoding class)
ooRexx> t~utf8 =                          -- T'ÊΩÆÁçÆÊπ•Êï≥'      tide
T'ÊΩÆÁçÆÊπ•Êï≥'


-- ===============================================================================
-- 2022 September 07

/*
Add method MutableBuffer~isASCII
Implementation more complex than for String, because mutable.
Try to avoid to rescan the whole buffer, when possible.
The native methods that modify the buffer are never scanning the buffer, they
are just setting the boolean indicators is_ASCII_checked and is_ASCII.
It's only the Rexx method ~isASCII which scans the whole buffer, if needed.
Impacted methods:
    append
    caselessChangeStr
    changeStr
    delete
    delWord
    insert
    overlay
    replaceAt
    setBufferSize
    space
    translate
*/

ooRexx> b = .MutableBuffer~new("pere")
ooRexx> b~isASCII =                             -- 1
 1
ooRexx> b~insert("no√´l", 5)=                    -- M'pere no√´l'
M'pere no√´l'
ooRexx> b~isASCII =                             -- 0
 0
ooRexx> b~setBufferSize(7)=                     -- M'pere no'
M'pere no'
ooRexx> b~isASCII=                              -- 1
 1
ooRexx> b~append("√´", "l")=                     -- M'pere no√´l'
M'pere no√´l'
ooRexx> b~isASCII=                              -- 0
 0
ooRexx> b~replaceAt("e", 8, 2)=                 -- M'pere noel'
M'pere noel'
ooRexx> b~isASCII=                              -- 1
 0
ooRexx> b~changeStr("noel", "no√´l")=            -- M'pere no√´l'
M'pere no√´l'
ooRexx> b~isASCII=                              -- 0
 0
ooRexx> b~delete(8,2)=                          -- M'pere nol'
M'pere nol'
ooRexx> b~isASCII=                              -- 1
 1
ooRexx> b~overlay("√´l", 8)=                     -- M'pere no√´l'
M'pere no√´l'
ooRexx> b~isASCII=                              -- 0
 0
ooRexx> b~delWord(2)=                           -- M'pere '
M'pere '
ooRexx> b~isASCII=                              -- 1
 1
ooRexx> b~translate("√®" || "91"x, "er ")=       -- M'p√®√ë'    ("√®" is "C3A8"x so "e"-->"C3"x, "r"-->A8"x and " "-->"91"x
M'p√®√ë'
ooRexx> b~isASCII=                              -- 0
 0


-- ===============================================================================
-- 2022 August 18

/*
Added Unicode case folding.
See https://www.w3.org/TR/charmod-norm/
Case folding is the process of making two texts which differ only in case identical for comparison purposes.
Implemented with utf8proc, which applies an NFKC normalization on the case-folded string.

Methods on RexxText:
    ~Casefold   ~isCasefold
*/
ooRexx> "√ü"~text~casefold=               -- T'ss'
T'ss'
ooRexx> "„éí"~text~casefold=              -- T'mhz'   (jlf Nov 8, 2022: now unchanged because no longer NFKC)
T'„éí'

ooRexx> ("sTrasse", "stra√üe", "STRASSE")~each{item~text~casefold}==
an Array (shape [3], 3 items)
 1 : T'strasse'
 2 : T'strasse'
 3 : T'strasse'

-- utf8proc doesn't support language-sensitive case-folding.
-- Example:
-- The name of the second largest city in Turkey is "Diyarbakƒ±r", which contains both the dotted and dotless letters i.
ooRexx> "Diyarbakƒ±r"~text~upper=        -- T'DIYARBAKIR'   should be Dƒ∞YARBAKIR
T'DIYARBAKIR'
ooRexx> "Dƒ∞YARBAKIR"~text~casefold=     -- T'diÃáyarbakir'   should be diyarbakƒ±r
T'diÃáyarbakir'

-- The Julia developers, who uses utf8proc, have decided to remain locale-independent.
-- See https://github.com/JuliaLang/julia/issues/7848


-- ===============================================================================
-- 2022 August 07

/*
Added normalization NFC, NFD, NFKC, NFKD.
http://unicode.org/faq/normalization.html
Implemented with utf8proc.

Methods on RexxText:
    ~NFC    ~isNFC
    ~NFD    ~isNFD
    ~NFKC   ~isNFKC
    ~NFKD   ~isNFKD

Possible values for isNFxx:
    -1  unknown
     0  no
     1  yes
A same text can be in several normalization forms.
Text exclusively containing ASCII characters (U+0000..U+007F) is left unaffected
by all of the Normalization Forms: The 4 indicators isNFxx are 1.

The methods NFxx sets the corresponding indicator isNFxx
- on the source text : 0 or 1 (test if both strings are equal)
- on the result text : 1
*/

-- The normalized text can be memorized on the original text:
ooRexx>     text = "p√®re No√´l"~text
ooRexx>     textNFD = text~nfd(memorize:.true)
-- From now, the returned NFD is always the memorized text:
ooRexx>     text~nfd == textNFD=                    -- .true
 1


/*
    Some remarks about the string used in this demo:
    - the first "√§√∂√º" is NFC, the second "aÃàoÃàuÃà" is NFD
    - "xÃÇ" is two codepoints in any normalization.
    - "œî" normalization forms are all different.
    - "Ô∑∫" is one of the worst cases regarding the expansion factor in NFKS/NFKS: 18x
    - "baÔ¨Ñe"~text~subchar(3)=     -- T'Ô¨Ñ'
      "baÔ¨Ñe"~text~upper=          -- T'BAÔ¨ÑE', should be BAFFLE (to rework: utf8proc supports only simple uppercase)
      The ligature disappears in NFK[CD] but not in NF[CD]
*/
ooRexx> "√§√∂√º aÃàoÃàuÃà xÃÇ œî Ô∑∫ baÔ¨Ñe"~text~UnicodeCharacters==
an Array (shape [22], 22 items)
 1  : ( "√§"   U+00E4 Ll 1 "LATIN SMALL LETTER A WITH DIAERESIS" )
 2  : ( "√∂"   U+00F6 Ll 1 "LATIN SMALL LETTER O WITH DIAERESIS" )
 3  : ( "√º"   U+00FC Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS" )
 4  : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 5  : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
 6  : ( "Ãà"    U+0308 Mn 0 "COMBINING DIAERESIS" )
 7  : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
 8  : ( "Ãà"    U+0308 Mn 0 "COMBINING DIAERESIS" )
 9  : ( "u"   U+0075 Ll 1 "LATIN SMALL LETTER U" )
 10 : ( "Ãà"    U+0308 Mn 0 "COMBINING DIAERESIS" )
 11 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 12 : ( "x"   U+0078 Ll 1 "LATIN SMALL LETTER X" )
 13 : ( "ÃÇ"    U+0302 Mn 0 "COMBINING CIRCUMFLEX ACCENT" )
 14 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 15 : ( "œî"   U+03D4 Lu 1 "GREEK UPSILON WITH DIAERESIS AND HOOK SYMBOL" )
 16 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 17 : ( "Ô∑∫"   U+FDFA Lo 1 "ARABIC LIGATURE SALLALLAHOU ALAYHE WASALLAM" )
 18 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 19 : ( "b"   U+0062 Ll 1 "LATIN SMALL LETTER B" )
 20 : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
 21 : ( "Ô¨Ñ"   U+FB04 Ll 1 "LATIN SMALL LIGATURE FFL" )
 22 : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )
ooRexx> "√§√∂√º aÃàoÃàuÃà xÃÇ œî Ô∑∫ baÔ¨Ñe"~text~description=      -- 'UTF-8 not-ASCII (18 graphemes, 22 codepoints, 34 bytes, 0 error)'
'UTF-8 not-ASCII (18 characters, 22 codepoints, 34 bytes, 0 error)'
ooRexx> "√§√∂√º aÃàoÃàuÃà xÃÇ œî Ô∑∫ baÔ¨Ñe"~text~upper=            -- T'√Ñ√ñ√ú AÃàOÃàUÃà XÃÇ œî Ô∑∫ BAÔ¨ÑE
T'√Ñ√ñ√ú AÃàOÃàUÃà XÃÇ œî Ô∑∫ BAÔ¨ÑE'

/*
    NFD
    Normalization Form D
    Canonical Decomposition
    Characters are decomposed by canonical equivalence, and multiple combining characters are arranged in a specific order.
*/
ooRexx> "√§√∂√º aÃàoÃàuÃà xÃÇ œî Ô∑∫ baÔ¨Ñe"~text~nfd~UnicodeCharacters==
an Array (shape [26], 26 items)
 1  : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
 2  : ( "Ãà"    U+0308 Mn 0 "COMBINING DIAERESIS" )
 3  : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
 4  : ( "Ãà"    U+0308 Mn 0 "COMBINING DIAERESIS" )
 5  : ( "u"   U+0075 Ll 1 "LATIN SMALL LETTER U" )
 6  : ( "Ãà"    U+0308 Mn 0 "COMBINING DIAERESIS" )
 7  : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 8  : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
 9  : ( "Ãà"    U+0308 Mn 0 "COMBINING DIAERESIS" )
 10 : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
 11 : ( "Ãà"    U+0308 Mn 0 "COMBINING DIAERESIS" )
 12 : ( "u"   U+0075 Ll 1 "LATIN SMALL LETTER U" )
 13 : ( "Ãà"    U+0308 Mn 0 "COMBINING DIAERESIS" )
 14 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 15 : ( "x"   U+0078 Ll 1 "LATIN SMALL LETTER X" )
 16 : ( "ÃÇ"    U+0302 Mn 0 "COMBINING CIRCUMFLEX ACCENT" )
 17 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 18 : ( "œí"   U+03D2 Lu 1 "GREEK UPSILON WITH HOOK SYMBOL" )
 19 : ( "Ãà"    U+0308 Mn 0 "COMBINING DIAERESIS" )
 20 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 21 : ( "Ô∑∫"   U+FDFA Lo 1 "ARABIC LIGATURE SALLALLAHOU ALAYHE WASALLAM" )
 22 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 23 : ( "b"   U+0062 Ll 1 "LATIN SMALL LETTER B" )
 24 : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
 25 : ( "Ô¨Ñ"   U+FB04 Ll 1 "LATIN SMALL LIGATURE FFL" )
 26 : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )
ooRexx> "√§√∂√º aÃàoÃàuÃà xÃÇ œî Ô∑∫ baÔ¨Ñe"~text~nfd~description=  -- 'UTF-8 not-ASCII (18 graphemes, 26 codepoints, 39 bytes, 0 error)'
'UTF-8 not-ASCII (18 characters, 26 codepoints, 39 bytes, 0 error)'
ooRexx> "√§√∂√º aÃàoÃàuÃà xÃÇ œî Ô∑∫ baÔ¨Ñe"~text~nfd~upper=        -- T'AÃàOÃàUÃà AÃàOÃàUÃà XÃÇ œíÃà Ô∑∫ BAÔ¨ÑE'
T'AÃàOÃàUÃà AÃàOÃàUÃà XÃÇ œíÃà Ô∑∫ BAÔ¨ÑE'

/*
    NFC
    Normalization Form C
    Canonical Decomposition, followed by Canonical Composition
    Characters are decomposed and then recomposed by canonical equivalence.
*/
ooRexx> "√§√∂√º aÃàoÃàuÃà xÃÇ œî Ô∑∫ baÔ¨Ñe"~text~nfc~UnicodeCharacters==
an Array (shape [19], 19 items)
 1  : ( "√§"   U+00E4 Ll 1 "LATIN SMALL LETTER A WITH DIAERESIS" )
 2  : ( "√∂"   U+00F6 Ll 1 "LATIN SMALL LETTER O WITH DIAERESIS" )
 3  : ( "√º"   U+00FC Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS" )
 4  : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 5  : ( "√§"   U+00E4 Ll 1 "LATIN SMALL LETTER A WITH DIAERESIS" )
 6  : ( "√∂"   U+00F6 Ll 1 "LATIN SMALL LETTER O WITH DIAERESIS" )
 7  : ( "√º"   U+00FC Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS" )
 8  : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 9  : ( "x"   U+0078 Ll 1 "LATIN SMALL LETTER X" )
 10 : ( "ÃÇ"    U+0302 Mn 0 "COMBINING CIRCUMFLEX ACCENT" )
 11 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 12 : ( "œî"   U+03D4 Lu 1 "GREEK UPSILON WITH DIAERESIS AND HOOK SYMBOL" )
 13 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 14 : ( "Ô∑∫"   U+FDFA Lo 1 "ARABIC LIGATURE SALLALLAHOU ALAYHE WASALLAM" )
 15 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 16 : ( "b"   U+0062 Ll 1 "LATIN SMALL LETTER B" )
 17 : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
 18 : ( "Ô¨Ñ"   U+FB04 Ll 1 "LATIN SMALL LIGATURE FFL" )
 19 : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )
ooRexx> "√§√∂√º aÃàoÃàuÃà xÃÇ œî Ô∑∫ baÔ¨Ñe"~text~nfc~description=  -- 'UTF-8 not-ASCII (18 graphemes, 19 codepoints, 31 bytes, 0 error)'
'UTF-8 not-ASCII (18 characters, 19 codepoints, 31 bytes, 0 error)'
ooRexx> "√§√∂√º aÃàoÃàuÃà xÃÇ œî Ô∑∫ baÔ¨Ñe"~text~nfc~upper=        -- T'√Ñ√ñ√ú √Ñ√ñ√ú XÃÇ œî Ô∑∫ BAÔ¨ÑE'
T'√Ñ√ñ√ú √Ñ√ñ√ú XÃÇ œî Ô∑∫ BAÔ¨ÑE'

/*
    NFKD
    Normalization Form KD
    Compatibility Decomposition (K is used to stand for compatibility to avoid confusion with the C standing for composition)
    Characters are decomposed by compatibility, and multiple combining characters are arranged in a specific order.
*/
ooRexx> "√§√∂√º aÃàoÃàuÃà xÃÇ œî Ô∑∫ baÔ¨Ñe"~text~nfkd~UnicodeCharacters==
an Array (shape [45], 45 items)
 1  : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
 2  : ( "Ãà"    U+0308 Mn 0 "COMBINING DIAERESIS" )
 3  : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
 4  : ( "Ãà"    U+0308 Mn 0 "COMBINING DIAERESIS" )
 5  : ( "u"   U+0075 Ll 1 "LATIN SMALL LETTER U" )
 6  : ( "Ãà"    U+0308 Mn 0 "COMBINING DIAERESIS" )
 7  : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 8  : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
 9  : ( "Ãà"    U+0308 Mn 0 "COMBINING DIAERESIS" )
 10 : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
 11 : ( "Ãà"    U+0308 Mn 0 "COMBINING DIAERESIS" )
 12 : ( "u"   U+0075 Ll 1 "LATIN SMALL LETTER U" )
 13 : ( "Ãà"    U+0308 Mn 0 "COMBINING DIAERESIS" )
 14 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 15 : ( "x"   U+0078 Ll 1 "LATIN SMALL LETTER X" )
 16 : ( "ÃÇ"    U+0302 Mn 0 "COMBINING CIRCUMFLEX ACCENT" )
 17 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 18 : ( "Œ•"   U+03A5 Lu 1 "GREEK CAPITAL LETTER UPSILON" )
 19 : ( "Ãà"    U+0308 Mn 0 "COMBINING DIAERESIS" )
 20 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 21 : ( "ÿµ"   U+0635 Lo 1 "ARABIC LETTER SAD" )
 22 : ( "ŸÑ"   U+0644 Lo 1 "ARABIC LETTER LAM" )
 23 : ( "Ÿâ"   U+0649 Lo 1 "ARABIC LETTER ALEF MAKSURA" )
 24 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 25 : ( "ÿß"   U+0627 Lo 1 "ARABIC LETTER ALEF" )
 26 : ( "ŸÑ"   U+0644 Lo 1 "ARABIC LETTER LAM" )
 27 : ( "ŸÑ"   U+0644 Lo 1 "ARABIC LETTER LAM" )
 28 : ( "Ÿá"   U+0647 Lo 1 "ARABIC LETTER HEH" )
 29 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 30 : ( "ÿπ"   U+0639 Lo 1 "ARABIC LETTER AIN" )
 31 : ( "ŸÑ"   U+0644 Lo 1 "ARABIC LETTER LAM" )
 32 : ( "Ÿä"   U+064A Lo 1 "ARABIC LETTER YEH" )
 33 : ( "Ÿá"   U+0647 Lo 1 "ARABIC LETTER HEH" )
 34 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 35 : ( "Ÿà"   U+0648 Lo 1 "ARABIC LETTER WAW" )
 36 : ( "ÿ≥"   U+0633 Lo 1 "ARABIC LETTER SEEN" )
 37 : ( "ŸÑ"   U+0644 Lo 1 "ARABIC LETTER LAM" )
 38 : ( "ŸÖ"   U+0645 Lo 1 "ARABIC LETTER MEEM" )
 39 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 40 : ( "b"   U+0062 Ll 1 "LATIN SMALL LETTER B" )
 41 : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
 42 : ( "f"   U+0066 Ll 1 "LATIN SMALL LETTER F" )
 43 : ( "f"   U+0066 Ll 1 "LATIN SMALL LETTER F" )
 44 : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
 45 : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )
ooRexx> "√§√∂√º aÃàoÃàuÃà xÃÇ œî Ô∑∫ baÔ¨Ñe"~text~nfkd~description= -- 'UTF-8 not-ASCII (37 graphemes, 45 codepoints, 69 bytes, 0 error)'
'UTF-8 not-ASCII (37 characters, 45 codepoints, 69 bytes, 0 error)'
ooRexx> "√§√∂√º aÃàoÃàuÃà xÃÇ œî Ô∑∫ baÔ¨Ñe"~text~nfkd~upper=       -- T'AÃàOÃàUÃà AÃàOÃàUÃà XÃÇ Œ•Ãà ÿµŸÑŸâ ÿßŸÑŸÑŸá ÿπŸÑŸäŸá Ÿàÿ≥ŸÑŸÖ BAFFLE
T'AÃàOÃàUÃà AÃàOÃàUÃà XÃÇ Œ•Ãà ÿµŸÑŸâ ÿßŸÑŸÑŸá ÿπŸÑŸäŸá Ÿàÿ≥ŸÑŸÖ BAFFLE'

/*
    NFKC
    Normalization Form KC
    Compatibility Decomposition, followed by Canonical Composition
    Characters are decomposed by compatibility, then recomposed by canonical equivalence.
*/
ooRexx> "√§√∂√º aÃàoÃàuÃà xÃÇ œî Ô∑∫ baÔ¨Ñe"~text~nfkc~UnicodeCharacters==
an Array (shape [38], 38 items)
 1  : ( "√§"   U+00E4 Ll 1 "LATIN SMALL LETTER A WITH DIAERESIS" )
 2  : ( "√∂"   U+00F6 Ll 1 "LATIN SMALL LETTER O WITH DIAERESIS" )
 3  : ( "√º"   U+00FC Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS" )
 4  : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 5  : ( "√§"   U+00E4 Ll 1 "LATIN SMALL LETTER A WITH DIAERESIS" )
 6  : ( "√∂"   U+00F6 Ll 1 "LATIN SMALL LETTER O WITH DIAERESIS" )
 7  : ( "√º"   U+00FC Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS" )
 8  : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 9  : ( "x"   U+0078 Ll 1 "LATIN SMALL LETTER X" )
 10 : ( "ÃÇ"    U+0302 Mn 0 "COMBINING CIRCUMFLEX ACCENT" )
 11 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 12 : ( "Œ´"   U+03AB Lu 1 "GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA" )
 13 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 14 : ( "ÿµ"   U+0635 Lo 1 "ARABIC LETTER SAD" )
 15 : ( "ŸÑ"   U+0644 Lo 1 "ARABIC LETTER LAM" )
 16 : ( "Ÿâ"   U+0649 Lo 1 "ARABIC LETTER ALEF MAKSURA" )
 17 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 18 : ( "ÿß"   U+0627 Lo 1 "ARABIC LETTER ALEF" )
 19 : ( "ŸÑ"   U+0644 Lo 1 "ARABIC LETTER LAM" )
 20 : ( "ŸÑ"   U+0644 Lo 1 "ARABIC LETTER LAM" )
 21 : ( "Ÿá"   U+0647 Lo 1 "ARABIC LETTER HEH" )
 22 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 23 : ( "ÿπ"   U+0639 Lo 1 "ARABIC LETTER AIN" )
 24 : ( "ŸÑ"   U+0644 Lo 1 "ARABIC LETTER LAM" )
 25 : ( "Ÿä"   U+064A Lo 1 "ARABIC LETTER YEH" )
 26 : ( "Ÿá"   U+0647 Lo 1 "ARABIC LETTER HEH" )
 27 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 28 : ( "Ÿà"   U+0648 Lo 1 "ARABIC LETTER WAW" )
 29 : ( "ÿ≥"   U+0633 Lo 1 "ARABIC LETTER SEEN" )
 30 : ( "ŸÑ"   U+0644 Lo 1 "ARABIC LETTER LAM" )
 31 : ( "ŸÖ"   U+0645 Lo 1 "ARABIC LETTER MEEM" )
 32 : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 33 : ( "b"   U+0062 Ll 1 "LATIN SMALL LETTER B" )
 34 : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
 35 : ( "f"   U+0066 Ll 1 "LATIN SMALL LETTER F" )
 36 : ( "f"   U+0066 Ll 1 "LATIN SMALL LETTER F" )
 37 : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
 38 : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )
ooRexx> "√§√∂√º aÃàoÃàuÃà xÃÇ œî Ô∑∫ baÔ¨Ñe"~text~nfkc~description= -- 'UTF-8 not-ASCII (37 graphemes, 38 codepoints, 61 bytes, 0 error)'
'UTF-8 not-ASCII (37 characters, 38 codepoints, 61 bytes, 0 error)'
ooRexx> "√§√∂√º aÃàoÃàuÃà xÃÇ œî Ô∑∫ baÔ¨Ñe"~text~nfkc~upper=       -- T'√Ñ√ñ√ú √Ñ√ñ√ú XÃÇ Œ´ ÿµŸÑŸâ ÿßŸÑŸÑŸá ÿπŸÑŸäŸá Ÿàÿ≥ŸÑŸÖ BAFFLE'
T'√Ñ√ñ√ú √Ñ√ñ√ú XÃÇ Œ´ ÿµŸÑŸâ ÿßŸÑŸÑŸá ÿπŸÑŸäŸá Ÿàÿ≥ŸÑŸÖ BAFFLE'


-- The normalization forms are implemented only for UTF-8 and WTF-8.
ooRexx> "D800 DC01"x~text("utf16")~nfd~UnicodeCharacters==  -- Method TRANSFORM is ABSTRACT and cannot be directly invoked.
Method TRANSFORM is ABSTRACT and cannot be directly invoked.
Error code= 93.965
ooRexx> "D800 DC01"x~text("utf16")~utf8~nfd~UnicodeCharacters==
an Array (shape [1], 1 items)
 1 : ( "êÄÅ"   U+10001 Lo 1 "LINEAR B SYLLABLE B038 E" )
ooRexx> "\uD800\uDC01"~text("wtf8")~unescape~nfd~UnicodeCharacters==
an Array (shape [1], 1 items)
 1 : ( "êÄÅ"   U+10001 Lo 1 "LINEAR B SYLLABLE B038 E" )

-- If the WTF-8 string is not a valid UTF-8 string then an error is raised by utf8proc
ooRexx> "D800"x     ~text("wtf16")~wtf8~nfd~UnicodeCharacters==    -- Invalid UTF-8 string
Invalid UTF-8 string.
Error code= 22.900
ooRexx> "\uD800"~text("wtf8")~unescape~nfd~UnicodeCharacters==     -- Invalid UTF-8 string
Invalid UTF-8 string.
Error code= 22.900


-- ===============================================================================
-- 2022 August 03

/*
https://discourse.julialang.org/t/stupid-question-on-unicode/27674/10
    Should I support this when unescaping?
    (High surrogate followed by low surrogate)
    Surrogate pairs are a UTF-16-specific construct.
    However, string escapes aren‚Äôt byte sequences of a particular encoding.
    They are somewhat arbitrary substitutions / macros.
*/

ooRexx>         "\uD83D\uDE3F"~text~unescape~errors==
an Array (shape [6], 6 items)
 1 : 'UTF-8 encoding: byte sequence at byte-position 1 has an invalid continuation byte 160 (A0x) at byte-position 2 (high surrogate, use WTF-8).'
 2 : 'UTF-8 encoding: byte sequence at byte-position 2 has an invalid start byte 160 (A0x) (non-shortest form).'
 3 : 'UTF-8 encoding: byte sequence at byte-position 3 has an invalid start byte 189 (BDx) (non-shortest form).'
 4 : 'UTF-8 encoding: byte sequence at byte-position 4 has an invalid continuation byte 184 (B8x) at byte-position 5 (low surrogate, use WTF-8).'
 5 : 'UTF-8 encoding: byte sequence at byte-position 5 has an invalid start byte 184 (B8x) (non-shortest form).'
 6 : 'UTF-8 encoding: byte sequence at byte-position 6 has an invalid start byte 191 (BFx) (non-shortest form).'

ooRexx>         "\uD83D\uDE3F"~text~wtf8~unescape~errors==
(The NIL object)

--    Yes, I should support it when the encoding is WTF-8, because the concatenation manages correctly this case:
ooRexx>         ("\uD83D"~text~wtf8~unescape || "\uDE3F"~text~wtf8~unescape)~UnicodeCharacters==
an Array (shape [1], 1 items)
 1 : ( "üòø"  U+1F63F So 2 "CRYING CAT FACE" )

ooRexx>         ("\uD83D"~text~wtf8~unescape || "\uDE3F"~text~wtf8~unescape)~description=
'WTF-8 not-ASCII (1 character, 1 codepoint, 4 bytes, 0 error)'

--    Done, now "\uD83D\uDE3F"~text~wtf8~unescape=    -- "üòø"


-- ===============================================================================
-- 2022 July 20

/*
I realize that I can pass options when filtering the unicode characters.
Same options as when sending the message "matcher" to a string.

-- Options: not wholestring, trace with prefix "> "
*/
ooRexx> .unicode~characters("father", wholeString:0, trace:1, prefix:">")
>description: stringChunkPattern="father" wholeString=0 caseless=1
>stringPattern="father"
>matcher: expose description stringPattern; use strict arg string; return string~caselessPos(stringPattern) <> 0

-- Same options with a regular expression.
-- "/father" is faster than "/.*father.*" but still very slow compared to "father"
ooRexx> .unicode~characters("/father", wholeString:0, trace:1, prefix:"> ")
> description: stringChunkPattern="/father" wholeString=0 caseless=1
> stringPattern="father"
> pattern = .Pattern~compile(stringPattern, .RegexCompiler~new(.RegexCompiler~caseless))
> matcher: expose description pattern; use strict arg string; return pattern~find(string)~matched

-- Note that "/.*father.*" in mode not wholestring is just unusable: 419 sec under MBP 2010 Intel Core 2 Duo
-- [2022 Dec 22] Still unusable under MBP 2021 M1 Pro: 78s (only 5.37 faster)


-- ===============================================================================
-- 2022 July 17


-- For convenience, add an optional parameter 'filter' to the method .unicode~characters
ooRexx>     .unicode~characters("*rex*")==
an Array (shape [15], 15 items)
 1  : ( "Íúå"   U+A70C Sk 1 "MODIFIER LETTER EXTRA-LOW DOTTED TONE BAR" )
 2  : ( "À©"   U+02E9 Sk 1 "MODIFIER LETTER EXTRA-LOW TONE BAR" )
 3  : ( "Íúç"   U+A70D Sk 1 "MODIFIER LETTER EXTRA-HIGH DOTTED LEFT-STEM TONE BAR" )
 4  : ( "Íúë"   U+A711 Sk 1 "MODIFIER LETTER EXTRA-LOW DOTTED LEFT-STEM TONE BAR" )
 5  : ( "À•"   U+02E5 Sk 1 "MODIFIER LETTER EXTRA-HIGH TONE BAR" )
 6  : ( "Íúà"   U+A708 Sk 1 "MODIFIER LETTER EXTRA-HIGH DOTTED TONE BAR" )
 7  : ( "üñï"  U+1F595 So 2 "REVERSED HAND WITH MIDDLE FINGER EXTENDED" )
 8  : ( "ÍéÖ"  U+A385 Lo 2 "YI SYLLABLE RREX" )
 9  : ( "Íúí"   U+A712 Sk 1 "MODIFIER LETTER EXTRA-HIGH LEFT-STEM TONE BAR" )
 10 : ( "Íèë"  U+A3D1 Lo 2 "YI SYLLABLE REX" )
 11 : ( "Íéú"  U+A39C Lo 2 "YI SYLLABLE NREX" )
 12 : ( "Íúñ"   U+A716 Sk 1 "MODIFIER LETTER EXTRA-LOW LEFT-STEM TONE BAR" )
 13 : ( "ñ©ø"   U+16A7F Lo 1 "TANGSA LETTER EX" )
 14 : ( "ùçä"   U+1D34A So 1 "TETRAGRAM FOR EXHAUSTION" )
 15 : ( "ü¶ñ"  U+1F996 So 2 "T-REX" )
-- is equivalent to
ooRexx>     matcher = "*rex*"~matcher; .unicode~characters~select{expose matcher; matcher~(item~name)}==
an Array (shape [4], 4 items)
 1 : ( "ÍéÖ"  U+A385 Lo 2 "YI SYLLABLE RREX" )
 2 : ( "Íéú"  U+A39C Lo 2 "YI SYLLABLE NREX" )
 3 : ( "Íèë"  U+A3D1 Lo 2 "YI SYLLABLE REX" )
 4 : ( "ü¶ñ"  U+1F996 So 2 "T-REX" )

-- Regular expressions are supported:
-- returns all the characters whose name starts with "math" and ends with "psi"
ooRexx>     .unicode~characters("/^math.*psi$")==
an Array (shape [10], 10 items)
 1  : ( "ùöø"   U+1D6BF Lu 1 "MATHEMATICAL BOLD CAPITAL PSI" )
 2  : ( "ùõô"   U+1D6D9 Ll 1 "MATHEMATICAL BOLD SMALL PSI" )
 3  : ( "ùõπ"   U+1D6F9 Lu 1 "MATHEMATICAL ITALIC CAPITAL PSI" )
 4  : ( "ùúì"   U+1D713 Ll 1 "MATHEMATICAL ITALIC SMALL PSI" )
 5  : ( "ùú≥"   U+1D733 Lu 1 "MATHEMATICAL BOLD ITALIC CAPITAL PSI" )
 6  : ( "ùùç"   U+1D74D Ll 1 "MATHEMATICAL BOLD ITALIC SMALL PSI" )
 7  : ( "ùù≠"   U+1D76D Lu 1 "MATHEMATICAL SANS-SERIF BOLD CAPITAL PSI" )
 8  : ( "ùûá"   U+1D787 Ll 1 "MATHEMATICAL SANS-SERIF BOLD SMALL PSI" )
 9  : ( "ùûß"   U+1D7A7 Lu 1 "MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL PSI" )
 10 : ( "ùüÅ"   U+1D7C1 Ll 1 "MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL PSI" )

/*
The regular expressions are implemented with 100% ooRexx code, and as such
can be particularly inefficient...
When applied to a collection of 43885 Unicode characters, we have:
    .unicode~characters("/.*father.*")    -- 30.5 sec
The same filter without regular expression:
    .unicode~characters("*father*")       -- 0.9 sec

Something to clarify:
Why such a difference of duration for the following pieces of code?
In the end, it's the same code in both cases:
matcher = "/.*father.*"~matcher; supplier = .unicode~characters; collectedItems = .Array~new; do while supplier~available; item = supplier~item; if matcher~(item~name) then collectedItems~append(item); supplier~next; end; collectedItems==
64 sec
matcher = "/.*father.*"~matcher; .unicode~characters~select{expose matcher; matcher~(item~name)}==
31 sec
*/

-- ===============================================================================
-- 2022 July 13

/*
Rework ~unescape to be closer to other languages:
\u{...} and \U{...} are equivalent
\u{X..X} is now hexadecimal, no more decimal codepoint. The first character must be 0..9.
\uXXXX is now supported
\UXXXXXXXX is now supported

Ex:
*/
ooRexx> "\u{bed} is different from \u{0bed}"~text~unescape=                         -- T'üõè is different from ‡Ø≠'
T'üõè is different from ‡Ø≠'
ooRexx> .unicode~character("bed")=                                                  -- ( "üõè"   U+1F6CF So 1 "BED" )
( "üõè"   U+1F6CF So 1 "BED" )
ooRexx> .unicode~character("bed", hexadecimal:.true)=                               -- ( "‡Ø≠"   U+0BED Nd 1 "TAMIL DIGIT SEVEN" )
( "‡Ø≠"   U+0BED Nd 1 "TAMIL DIGIT SEVEN" )
ooRexx> .unicode~character("U+0bed")=                                               -- ( "‡Ø≠"   U+0BED Nd 1 "TAMIL DIGIT SEVEN" )
( "‡Ø≠"   U+0BED Nd 1 "TAMIL DIGIT SEVEN" )
ooRexx> "The \u{t-rex} shows his \u{flexed biceps}!"~text~unescape=                 -- T'The ü¶ñ shows his üí™!'
T'The ü¶ñ shows his üí™!'
ooRexx> "\u0031 + \u0032\u0033 = \u0032\u0034"~text~unescape=                       -- T'1 + 23 = 24'
T'1 + 23 = 24'
ooRexx> "\U00000031 + \U00000032\U00000033 = \U00000032\U00000034"~text~unescape=   -- T'1 + 23 = 24'
T'1 + 23 = 24'

-- ===============================================================================
-- 2022 February 13

/*
New method unescape, available only for Byte, UTF-8 and WTF-8.
    \b                  backspace (BS)
    \t                  horizontal tab (HT)
    \n                  linefeed (LF)
    \f                  form feed (FF)
    \r                  carriage return (CR)
    \u{Unicode name}    Character name in the Unicode database
    \u{N..N}            Unicode character denoted by 1-8 hex digits. The first character must be a digit 0..9.
    \u{U+X..X}          Unicode character denoted by 1-n hex digits
    \x{X..X}            sequence of 1..n hexadecimal digits
Examples:
*/
ooRexx>     "hello\u{space}John\n"~text~unescape=           -- T'hello John[0A]'
T'hello John[0A]'
ooRexx>     "hello\u{20}John\n"~text~unescape=
T'hello John[0A]'
ooRexx>     "hello\u{U+20}John\n"~text~unescape=
Expected U+ or u+ followed by 4..6 hex digits, got '20'.
Error code= 93.900

ooRexx>     -- \u is not supported for Byte encoding, you can use \x
ooRexx>     "hello\u{U+20}John\n"~text("byte")~unescape=    -- Byte encoding: \u not supported.
Byte encoding: \u not supported.
Error code= 23.900
ooRexx>     "hello\x{20}John\n"~text("byte")~unescape       -- T'hello John[0A]'

ooRexx>     -- No implementation for UTF-16, WTF-16, UTF-32.
ooRexx>     "hello\u{U+20}John\n"~text~utf16~unescape=      -- Method UNESCAPE is ABSTRACT and cannot be directly invoked.
Method UNESCAPE is ABSTRACT and cannot be directly invoked.
Error code= 93.965


-- ===============================================================================
-- 2021 September 30

/*
New methods:
.String
    join (was concatenateSeparated)

.MutableBuffer
    join (was concatenateSeparated)

.Unicode
    []  (equivalent to .Unicode~character)

.UnicodeCharacter
    makeRexxText
    text
    wtf8
    wtf16
    wtf16be
    wtf16le

.RexxText
    join
    left
    right
    x2d

Examples:
*/

-- https://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries
-- no break before ZWJ (GB9), but break after if not emoji modifier sequence or emoji zwj sequence (GB11)
ooRexx> .unicode["zwj"]~utf8~join("ab", "cd", .unicode["woman"]~utf8, .unicode["father christmas"]~utf8)~c2g=  -- '61 62E2808D 63 64E2808D F09F91A9E2808DF09F8E85'
'61 62E2808D 63 64E2808D F09F91A9E2808DF09F8E85'
ooRexx> .unicode["zwj"]~utf8~join("ab", "cd", .unicode["woman"]~utf8, .unicode["father christmas"]~utf8)~graphemes==
a CharacterSupplier 
 1 : T'a'
 2 : T'b‚Äç'
 3 : T'c'
 4 : T'd‚Äç'
 5 : T'üë©‚ÄçüéÖ'

ooRexx> "no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~UnicodeCharacters==
an Array (shape [12], 12 items)
 1  : ( "n"   U+006E Ll 1 "LATIN SMALL LETTER N" )
 2  : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
 3  : ( "√´"   U+00EB Ll 1 "LATIN SMALL LETTER E WITH DIAERESIS" )
 4  : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
 5  : ( "üë©"  U+1F469 So 2 "WOMAN" )
 6  : ( "‚Äç"    U+200D Cf 0 "ZERO WIDTH JOINER", "ZWJ" )
 7  : ( "üë®"  U+1F468 So 2 "MAN" )
 8  : ( "‚Äç"    U+200D Cf 0 "ZERO WIDTH JOINER", "ZWJ" )
 9  : ( "üë©"  U+1F469 So 2 "WOMAN" )
 10 : ( "‚Äç"    U+200D Cf 0 "ZERO WIDTH JOINER", "ZWJ" )
 11 : ( "üëß"  U+1F467 So 2 "GIRL" )
 12 : ( "üéÖ"  U+1F385 So 2 "FATHER CHRISTMAS" )

-- https://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries
-- Do not break within emoji modifier sequences or emoji zwj sequences (GB11).
ooRexx> "no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~graphemes==
a CharacterSupplier 
 1 : T'n'
 2 : T'o'
 3 : T'√´'
 4 : T'l'
 5 : T'üë©‚Äçüë®‚Äçüë©‚Äçüëß'
 6 : T'üéÖ'

ooRexx> do i=0 to 9; "left("i") = " || "no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~left(i)=; end
T'left(0) = '
T'left(1) = n'
T'left(2) = no'
T'left(3) = no√´'
T'left(4) = no√´l'
T'left(5) = no√´lüë©‚Äçüë®‚Äçüë©‚Äçüëß'
T'left(6) = no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ'
T'left(7) = no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ '
T'left(8) = no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ  '
T'left(9) = no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ   '

ooRexx> do i=0 to 9; "right("i") = " || "no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~right(i)=; end
T'right(0) = '
T'right(1) = üéÖ'
T'right(2) = üë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ'
T'right(3) = lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ'
T'right(4) = √´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ'
T'right(5) = o√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ'
T'right(6) = no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ'
T'right(7) =  no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ'
T'right(8) =   no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ'
T'right(9) =    no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ'


-- ===============================================================================
-- 2021 September 28

/*
New methods:
.RexxText
    reverse

Examples:
*/

-- Correct reverse
ooRexx> "no√´l"~text~c2x=            -- '6E 6F C3AB 6C'
'6E 6F C3AB 6C'
ooRexx> "no√´l"~text~reverse~c2x=    -- '6C C3AB 6F 6E'
'6C C3AB 6F 6E'
ooRexx> "no√´l"~text~reverse=        -- T'l√´on'
T'l√´on'

-- Wrong reverse
ooRexx> "no√´l"~c2x=             -- '6E6FC3AB6C'
'6E6FC3AB6C'
ooRexx> "no√´l"~reverse~c2x=     -- '6CABC36F6E'
'6CABC36F6E'
ooRexx> "no√´l"~reverse=         -- 'l??on'
'l´√on'


-- ===============================================================================
-- 2021 September 27

/*
New native methods:
.Unicode
    codepointToLower
    codepointToUpper
    codepointToTitle
    codepointIsLower
    codepointIsUpper

New methods:
.RexxText
    lower
    upper
    isLower
    isUpper
    characters

Examples:
*/

ooRexx> "a√†√¢√§e√©√®√™√´i√Æ√Øo√¥√∂u√ª√º"~text~isUpper=              -- .false
 0
ooRexx> "a√†√¢√§e√©√®√™√´i√Æ√Øo√¥√∂u√ª√º"~text~isLower=              -- .true
 1
ooRexx> "A√Ä√Ç√ÑE√â√à√ä√ãI√é√èO√î√ñU√õ√ú"~text~isUpper=              -- .true
 1
ooRexx> "A√Ä√Ç√ÑE√â√à√ä√ãI√é√èO√î√ñU√õ√ú"~text~isLower=              -- .false
 0
ooRexx> "Le p√®re No√´l est fatigu√©..."~text~upper=       -- T'LE P√àRE NO√ãL EST FATIGU√â...'
T'LE P√àRE NO√ãL EST FATIGU√â...'
ooRexx> "LE P√àRE NO√ãL EST FATIGU√â..."~text~lower=       -- T'le p√®re no√´l est fatigu√©...'
T'le p√®re no√´l est fatigu√©...'

/*
utf8proc supports only the basic cases (those in UnicodeData.txt).
The cases described in SpecialCasing.txt are not supported by utf8proc.
Examples:
*/
-- # The German es-zed is special--the normal mapping is to SS.
-- # Note: the titlecase should never occur in practice. It is equal to titlecase(uppercase(<es-zed>))
-- # <code>; <lower>; <title>; <upper>; (<condition_list>;)? # <comment>
-- 00DF; 00DF; 0053 0073; 0053 0053; # LATIN SMALL LETTER SHARP S

/*
TODO: full casing not yet implemented
    .Unicode~codepointToLowerFull
    .Unicode~codepointToUpperFull
    .Unicode~codepointToTitleFull
The rest of the framework is ready for full casing.
*/

ooRexx> .unicode~character("LATIN SMALL LETTER SHARP S")~utf8=          -- T'√ü'
T'√ü'
ooRexx> .unicode~character("LATIN SMALL LETTER SHARP S")~toUpperSimple= -- 7838, which is the codepoint of (U+1E9E Lu "LATIN CAPITAL LETTER SHARP S")
 7838
ooRexx> .unicode~character(7838)~utf8=                                  -- T'·∫û'
T'·∫û'
-- T'√ü' to uppercase should be T'SS':
ooRexx> "0053 0053"x~text("utf16")~UnicodeCharacters==
an Array (shape [2], 2 items)
 1 : ( "S"   U+0053 Lu 1 "LATIN CAPITAL LETTER S" )
 2 : ( "S"   U+0053 Lu 1 "LATIN CAPITAL LETTER S" )

-- # Preserve canonical equivalence for I with dot. Turkic is handled below.
-- 0130; 0069 0307; 0130; 0130; # LATIN CAPITAL LETTER I WITH DOT ABOVE
ooRexx> .unicode~character("LATIN CAPITAL LETTER I WITH DOT ABOVE")~utf8=           -- T'ƒ∞'
T'ƒ∞'
ooRexx> .unicode~character("LATIN CAPITAL LETTER I WITH DOT ABOVE")~toLowerSimple=  -- 105, which is the codepoint of (U+0069 Ll "LATIN SMALL LETTER I")
 105
ooRexx> .unicode~character(105)~utf8=                                               -- T'i'
T'i'
-- T'ƒ∞' to lowercase should be T'iÃáÃá':
ooRexx> "0069 0307"x~text("utf16")~UnicodeCharacters==
an Array (shape [2], 2 items)
 1 : ( "i"   U+0069 Ll 1 "LATIN SMALL LETTER I" )
 2 : ( "Ãá"    U+0307 Mn 0 "COMBINING DOT ABOVE" )

-- # Turkish and Azeri
-- # I and i-dotless; I-dot and i are case pairs in Turkish and Azeri
-- # The following rules handle those cases.
-- 0130; 0069; 0130; 0130; tr; # LATIN CAPITAL LETTER I WITH DOT ABOVE
-- 0130; 0069; 0130; 0130; az; # LATIN CAPITAL LETTER I WITH DOT ABOVE

-- # Note: the following case is already in the UnicodeData.txt file.
-- # 0131; 0131; 0049; 0049; tr; # LATIN SMALL LETTER DOTLESS I
ooRexx> .unicode~character("LATIN SMALL LETTER DOTLESS I")~utf8=            -- T'ƒ±'
T'ƒ±'
ooRexx> .unicode~character("LATIN SMALL LETTER DOTLESS I")~toUpperSimple=   -- 73, which is the codepoint of (U+0049 Lu "LATIN CAPITAL LETTER I")
 73
ooRexx> .unicode~character(73)~utf8=                                        -- T'I'
T'I'


-- Which characters have their title character different from their upper character?
ooRexx> .unicode~characters~select{item~toTitleSimple <> item~toUpperSimple}~each{.Unicode[item~toTitleSimple]~utf8 .Unicode[item~ToUpperSimple]~utf8 item~utf8 item}==
an Array (shape [58], 58 items)
 1  : T'«Ö «Ñ «Ñ  "«Ñ"   U+01C4 Lu 1 "LATIN CAPITAL LETTER DZ WITH CARON" '
 2  : T'«Ö «Ñ «Ö  "«Ö"   U+01C5 Lt 1 "LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON" '
 3  : T'«Ö «Ñ «Ü  "«Ü"   U+01C6 Ll 1 "LATIN SMALL LETTER DZ WITH CARON" '
 4  : T'«à «á «á  "«á"   U+01C7 Lu 1 "LATIN CAPITAL LETTER LJ" '
 5  : T'«à «á «à  "«à"   U+01C8 Lt 1 "LATIN CAPITAL LETTER L WITH SMALL LETTER J" '
 6  : T'«à «á «â  "«â"   U+01C9 Ll 1 "LATIN SMALL LETTER LJ" '
 7  : T'«ã «ä «ä  "«ä"   U+01CA Lu 1 "LATIN CAPITAL LETTER NJ" '
 8  : T'«ã «ä «ã  "«ã"   U+01CB Lt 1 "LATIN CAPITAL LETTER N WITH SMALL LETTER J" '
 9  : T'«ã «ä «å  "«å"   U+01CC Ll 1 "LATIN SMALL LETTER NJ" '
 10 : T'«≤ «± «±  "«±"   U+01F1 Lu 1 "LATIN CAPITAL LETTER DZ" '
 11 : T'«≤ «± «≤  "«≤"   U+01F2 Lt 1 "LATIN CAPITAL LETTER D WITH SMALL LETTER Z" '
 12 : T'«≤ «± «≥  "«≥"   U+01F3 Ll 1 "LATIN SMALL LETTER DZ" '
 13 : T'·Éê ·≤ê ·Éê  "·Éê"   U+10D0 Ll 1 "GEORGIAN LETTER AN" '
 14 : T'·Éë ·≤ë ·Éë  "·Éë"   U+10D1 Ll 1 "GEORGIAN LETTER BAN" '
 15 : T'·Éí ·≤í ·Éí  "·Éí"   U+10D2 Ll 1 "GEORGIAN LETTER GAN" '
 16 : T'·Éì ·≤ì ·Éì  "·Éì"   U+10D3 Ll 1 "GEORGIAN LETTER DON" '
 17 : T'·Éî ·≤î ·Éî  "·Éî"   U+10D4 Ll 1 "GEORGIAN LETTER EN" '
 18 : T'·Éï ·≤ï ·Éï  "·Éï"   U+10D5 Ll 1 "GEORGIAN LETTER VIN" '
 19 : T'·Éñ ·≤ñ ·Éñ  "·Éñ"   U+10D6 Ll 1 "GEORGIAN LETTER ZEN" '
 20 : T'·Éó ·≤ó ·Éó  "·Éó"   U+10D7 Ll 1 "GEORGIAN LETTER TAN" '
 21 : T'·Éò ·≤ò ·Éò  "·Éò"   U+10D8 Ll 1 "GEORGIAN LETTER IN" '
 22 : T'·Éô ·≤ô ·Éô  "·Éô"   U+10D9 Ll 1 "GEORGIAN LETTER KAN" '
 23 : T'·Éö ·≤ö ·Éö  "·Éö"   U+10DA Ll 1 "GEORGIAN LETTER LAS" '
 24 : T'·Éõ ·≤õ ·Éõ  "·Éõ"   U+10DB Ll 1 "GEORGIAN LETTER MAN" '
 25 : T'·Éú ·≤ú ·Éú  "·Éú"   U+10DC Ll 1 "GEORGIAN LETTER NAR" '
 26 : T'·Éù ·≤ù ·Éù  "·Éù"   U+10DD Ll 1 "GEORGIAN LETTER ON" '
 27 : T'·Éû ·≤û ·Éû  "·Éû"   U+10DE Ll 1 "GEORGIAN LETTER PAR" '
 28 : T'·Éü ·≤ü ·Éü  "·Éü"   U+10DF Ll 1 "GEORGIAN LETTER ZHAR" '
 29 : T'·É† ·≤† ·É†  "·É†"   U+10E0 Ll 1 "GEORGIAN LETTER RAE" '
 30 : T'·É° ·≤° ·É°  "·É°"   U+10E1 Ll 1 "GEORGIAN LETTER SAN" '
 31 : T'·É¢ ·≤¢ ·É¢  "·É¢"   U+10E2 Ll 1 "GEORGIAN LETTER TAR" '
 32 : T'·É£ ·≤£ ·É£  "·É£"   U+10E3 Ll 1 "GEORGIAN LETTER UN" '
 33 : T'·É§ ·≤§ ·É§  "·É§"   U+10E4 Ll 1 "GEORGIAN LETTER PHAR" '
 34 : T'·É• ·≤• ·É•  "·É•"   U+10E5 Ll 1 "GEORGIAN LETTER KHAR" '
 35 : T'·É¶ ·≤¶ ·É¶  "·É¶"   U+10E6 Ll 1 "GEORGIAN LETTER GHAN" '
 36 : T'·Éß ·≤ß ·Éß  "·Éß"   U+10E7 Ll 1 "GEORGIAN LETTER QAR" '
 37 : T'·É® ·≤® ·É®  "·É®"   U+10E8 Ll 1 "GEORGIAN LETTER SHIN" '
 38 : T'·É© ·≤© ·É©  "·É©"   U+10E9 Ll 1 "GEORGIAN LETTER CHIN" '
 39 : T'·É™ ·≤™ ·É™  "·É™"   U+10EA Ll 1 "GEORGIAN LETTER CAN" '
 40 : T'·É´ ·≤´ ·É´  "·É´"   U+10EB Ll 1 "GEORGIAN LETTER JIL" '
 41 : T'·É¨ ·≤¨ ·É¨  "·É¨"   U+10EC Ll 1 "GEORGIAN LETTER CIL" '
 42 : T'·É≠ ·≤≠ ·É≠  "·É≠"   U+10ED Ll 1 "GEORGIAN LETTER CHAR" '
 43 : T'·ÉÆ ·≤Æ ·ÉÆ  "·ÉÆ"   U+10EE Ll 1 "GEORGIAN LETTER XAN" '
 44 : T'·ÉØ ·≤Ø ·ÉØ  "·ÉØ"   U+10EF Ll 1 "GEORGIAN LETTER JHAN" '
 45 : T'·É∞ ·≤∞ ·É∞  "·É∞"   U+10F0 Ll 1 "GEORGIAN LETTER HAE" '
 46 : T'·É± ·≤± ·É±  "·É±"   U+10F1 Ll 1 "GEORGIAN LETTER HE" '
 47 : T'·É≤ ·≤≤ ·É≤  "·É≤"   U+10F2 Ll 1 "GEORGIAN LETTER HIE" '
 48 : T'·É≥ ·≤≥ ·É≥  "·É≥"   U+10F3 Ll 1 "GEORGIAN LETTER WE" '
 49 : T'·É¥ ·≤¥ ·É¥  "·É¥"   U+10F4 Ll 1 "GEORGIAN LETTER HAR" '
 50 : T'·Éµ ·≤µ ·Éµ  "·Éµ"   U+10F5 Ll 1 "GEORGIAN LETTER HOE" '
 51 : T'·É∂ ·≤∂ ·É∂  "·É∂"   U+10F6 Ll 1 "GEORGIAN LETTER FI" '
 52 : T'·É∑ ·≤∑ ·É∑  "·É∑"   U+10F7 Ll 1 "GEORGIAN LETTER YN" '
 53 : T'·É∏ ·≤∏ ·É∏  "·É∏"   U+10F8 Ll 1 "GEORGIAN LETTER ELIFI" '
 54 : T'·Éπ ·≤π ·Éπ  "·Éπ"   U+10F9 Ll 1 "GEORGIAN LETTER TURNED GAN" '
 55 : T'·É∫ ·≤∫ ·É∫  "·É∫"   U+10FA Ll 1 "GEORGIAN LETTER AIN" '
 56 : T'·ÉΩ ·≤Ω ·ÉΩ  "·ÉΩ"   U+10FD Ll 1 "GEORGIAN LETTER AEN" '
 57 : T'·Éæ ·≤æ ·Éæ  "·Éæ"   U+10FE Ll 1 "GEORGIAN LETTER HARD SIGN" '
 58 : T'·Éø ·≤ø ·Éø  "·Éø"   U+10FF Ll 1 "GEORGIAN LETTER LABIAL SIGN" '


-- ===============================================================================
-- 2021 September 22

/*
New native methods:
.Unicode
    codepointBidiMirrored
    codepointDecompositionType


Add character aliases.
.unicode~characters returns now a supplier, instead of the internal array of characters.
The indexes of the characters supplier are the codepoints, not the indexes of the
internal array which are codepoint+2.
*/
ooRexx> .unicode~characters==
an UnicodeCharacterSupplier 
 0    : ( ""    U+0000 Cc 0 "", "NULL", "NUL" )
 1    : ( ""    U+0001 Cc 0 "", "START OF HEADING", "SOH" )
 2    : ( ""    U+0002 Cc 0 "", "START OF TEXT", "STX" )
 3    : ( ""    U+0003 Cc 0 "", "END OF TEXT", "ETX" )
 4    : ( ""    U+0004 Cc 0 "", "END OF TRANSMISSION", "EOT" )
 5    : ( ""    U+0005 Cc 0 "", "ENQUIRY", "ENQ" )
 6    : ( ""    U+0006 Cc 0 "", "ACKNOWLEDGE", "ACK" )
 7    : ( ""    U+0007 Cc 0 "", "ALERT", "BEL" )
 8    : ( ""    U+0008 Cc 0 "", "BACKSPACE", "BS" )
 9    : ( ""    U+0009 Cc 0 "", "CHARACTER TABULATION", "HORIZONTAL TABULATION", "HT", "TAB" )
 10   : ( ""    U+000A Cc 0 "", "LINE FEED", "NEW LINE", "END OF LINE", "LF", "NL", "EOL" )
 11   : ( ""    U+000B Cc 0 "", "LINE TABULATION", "VERTICAL TABULATION", "VT" )
 12   : ( ""    U+000C Cc 0 "", "FORM FEED", "FF" )
 13   : ( ""    U+000D Cc 0 "", "CARRIAGE RETURN", "CR" )
 14   : ( ""    U+000E Cc 0 "", "SHIFT OUT", "LOCKING-SHIFT ONE", "SO" )
 15   : ( ""    U+000F Cc 0 "", "SHIFT IN", "LOCKING-SHIFT ZERO", "SI" )
 16   : ( ""    U+0010 Cc 0 "", "DATA LINK ESCAPE", "DLE" )
 17   : ( ""    U+0011 Cc 0 "", "DEVICE CONTROL ONE", "DC1" )
 18   : ( ""    U+0012 Cc 0 "", "DEVICE CONTROL TWO", "DC2" )
 19   : ( ""    U+0013 Cc 0 "", "DEVICE CONTROL THREE", "DC3" )
 20   : ( ""    U+0014 Cc 0 "", "DEVICE CONTROL FOUR", "DC4" )
 21   : ( ""    U+0015 Cc 0 "", "NEGATIVE ACKNOWLEDGE", "NAK" )
 22   : ( ""    U+0016 Cc 0 "", "SYNCHRONOUS IDLE", "SYN" )
 23   : ( ""    U+0017 Cc 0 "", "END OF TRANSMISSION BLOCK", "ETB" )
 24   : ( ""    U+0018 Cc 0 "", "CANCEL", "CAN" )
 25   : ( ""    U+0019 Cc 0 "", "END OF MEDIUM", "EOM", "EM" )
 26   : ( ""    U+001A Cc 0 "", "SUBSTITUTE", "SUB" )
 27   : ( ""    U+001B Cc 0 "", "ESCAPE", "ESC" )
 28   : ( ""    U+001C Cc 0 "", "INFORMATION SEPARATOR FOUR", "FILE SEPARATOR", "FS" )
 29   : ( ""    U+001D Cc 0 "", "INFORMATION SEPARATOR THREE", "GROUP SEPARATOR", "GS" )
 30   : ( ""    U+001E Cc 0 "", "INFORMATION SEPARATOR TWO", "RECORD SEPARATOR", "RS" )
 31   : ( ""    U+001F Cc 0 "", "INFORMATION SEPARATOR ONE", "UNIT SEPARATOR", "US" )
 32   : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 33   : ( "!"   U+0021 Po 1 "EXCLAMATION MARK" )
 34   : ( """   U+0022 Po 1 "QUOTATION MARK" )
 35   : ( "#"   U+0023 Po 1 "NUMBER SIGN" )
 36   : ( "$"   U+0024 Sc 1 "DOLLAR SIGN" )
 37   : ( "%"   U+0025 Po 1 "PERCENT SIGN" )
 38   : ( "&"   U+0026 Po 1 "AMPERSAND" )
 39   : ( "'"   U+0027 Po 1 "APOSTROPHE" )
 40   : ( "("   U+0028 Ps 1 "LEFT PARENTHESIS" )
 41   : ( ")"   U+0029 Pe 1 "RIGHT PARENTHESIS" )
 42   : ( "*"   U+002A Po 1 "ASTERISK" )
 43   : ( "+"   U+002B Sm 1 "PLUS SIGN" )
 44   : ( ","   U+002C Po 1 "COMMA" )
 45   : ( "-"   U+002D Pd 1 "HYPHEN-MINUS" )
 46   : ( "."   U+002E Po 1 "FULL STOP" )
 47   : ( "/"   U+002F Po 1 "SOLIDUS" )
 48   : ( "0"   U+0030 Nd 1 "DIGIT ZERO" )
 49   : ( "1"   U+0031 Nd 1 "DIGIT ONE" )
 50   : ( "2"   U+0032 Nd 1 "DIGIT TWO" )
 51   : ( "3"   U+0033 Nd 1 "DIGIT THREE" )
 52   : ( "4"   U+0034 Nd 1 "DIGIT FOUR" )
 53   : ( "5"   U+0035 Nd 1 "DIGIT FIVE" )
 54   : ( "6"   U+0036 Nd 1 "DIGIT SIX" )
 55   : ( "7"   U+0037 Nd 1 "DIGIT SEVEN" )
 56   : ( "8"   U+0038 Nd 1 "DIGIT EIGHT" )
 57   : ( "9"   U+0039 Nd 1 "DIGIT NINE" )
 58   : ( ":"   U+003A Po 1 "COLON" )
 59   : ( ";"   U+003B Po 1 "SEMICOLON" )
 60   : ( "<"   U+003C Sm 1 "LESS-THAN SIGN" )
 61   : ( "="   U+003D Sm 1 "EQUALS SIGN" )
 62   : ( ">"   U+003E Sm 1 "GREATER-THAN SIGN" )
 63   : ( "?"   U+003F Po 1 "QUESTION MARK" )
 64   : ( "@"   U+0040 Po 1 "COMMERCIAL AT" )
 65   : ( "A"   U+0041 Lu 1 "LATIN CAPITAL LETTER A" )
 66   : ( "B"   U+0042 Lu 1 "LATIN CAPITAL LETTER B" )
 67   : ( "C"   U+0043 Lu 1 "LATIN CAPITAL LETTER C" )
 68   : ( "D"   U+0044 Lu 1 "LATIN CAPITAL LETTER D" )
 69   : ( "E"   U+0045 Lu 1 "LATIN CAPITAL LETTER E" )
 70   : ( "F"   U+0046 Lu 1 "LATIN CAPITAL LETTER F" )
 71   : ( "G"   U+0047 Lu 1 "LATIN CAPITAL LETTER G" )
 72   : ( "H"   U+0048 Lu 1 "LATIN CAPITAL LETTER H" )
 73   : ( "I"   U+0049 Lu 1 "LATIN CAPITAL LETTER I" )
 74   : ( "J"   U+004A Lu 1 "LATIN CAPITAL LETTER J" )
 75   : ( "K"   U+004B Lu 1 "LATIN CAPITAL LETTER K" )
 76   : ( "L"   U+004C Lu 1 "LATIN CAPITAL LETTER L" )
 77   : ( "M"   U+004D Lu 1 "LATIN CAPITAL LETTER M" )
 78   : ( "N"   U+004E Lu 1 "LATIN CAPITAL LETTER N" )
 79   : ( "O"   U+004F Lu 1 "LATIN CAPITAL LETTER O" )
 80   : ( "P"   U+0050 Lu 1 "LATIN CAPITAL LETTER P" )
 81   : ( "Q"   U+0051 Lu 1 "LATIN CAPITAL LETTER Q" )
 82   : ( "R"   U+0052 Lu 1 "LATIN CAPITAL LETTER R" )
 83   : ( "S"   U+0053 Lu 1 "LATIN CAPITAL LETTER S" )
 84   : ( "T"   U+0054 Lu 1 "LATIN CAPITAL LETTER T" )
 85   : ( "U"   U+0055 Lu 1 "LATIN CAPITAL LETTER U" )
 86   : ( "V"   U+0056 Lu 1 "LATIN CAPITAL LETTER V" )
 87   : ( "W"   U+0057 Lu 1 "LATIN CAPITAL LETTER W" )
 88   : ( "X"   U+0058 Lu 1 "LATIN CAPITAL LETTER X" )
 89   : ( "Y"   U+0059 Lu 1 "LATIN CAPITAL LETTER Y" )
 90   : ( "Z"   U+005A Lu 1 "LATIN CAPITAL LETTER Z" )
 91   : ( "["   U+005B Ps 1 "LEFT SQUARE BRACKET" )
 92   : ( "\"   U+005C Po 1 "REVERSE SOLIDUS" )
 93   : ( "]"   U+005D Pe 1 "RIGHT SQUARE BRACKET" )
 94   : ( "^"   U+005E Sk 1 "CIRCUMFLEX ACCENT" )
 95   : ( "_"   U+005F Pc 1 "LOW LINE" )
 96   : ( "`"   U+0060 Sk 1 "GRAVE ACCENT" )
 97   : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
 98   : ( "b"   U+0062 Ll 1 "LATIN SMALL LETTER B" )
 99   : ( "c"   U+0063 Ll 1 "LATIN SMALL LETTER C" )
 100  : ( "d"   U+0064 Ll 1 "LATIN SMALL LETTER D" )
 101  : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )
 102  : ( "f"   U+0066 Ll 1 "LATIN SMALL LETTER F" )
 103  : ( "g"   U+0067 Ll 1 "LATIN SMALL LETTER G" )
 104  : ( "h"   U+0068 Ll 1 "LATIN SMALL LETTER H" )
 105  : ( "i"   U+0069 Ll 1 "LATIN SMALL LETTER I" )
 106  : ( "j"   U+006A Ll 1 "LATIN SMALL LETTER J" )
 107  : ( "k"   U+006B Ll 1 "LATIN SMALL LETTER K" )
 108  : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
 109  : ( "m"   U+006D Ll 1 "LATIN SMALL LETTER M" )
 110  : ( "n"   U+006E Ll 1 "LATIN SMALL LETTER N" )
 111  : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
 112  : ( "p"   U+0070 Ll 1 "LATIN SMALL LETTER P" )
 113  : ( "q"   U+0071 Ll 1 "LATIN SMALL LETTER Q" )
 114  : ( "r"   U+0072 Ll 1 "LATIN SMALL LETTER R" )
 115  : ( "s"   U+0073 Ll 1 "LATIN SMALL LETTER S" )
 116  : ( "t"   U+0074 Ll 1 "LATIN SMALL LETTER T" )
 117  : ( "u"   U+0075 Ll 1 "LATIN SMALL LETTER U" )
 118  : ( "v"   U+0076 Ll 1 "LATIN SMALL LETTER V" )
 119  : ( "w"   U+0077 Ll 1 "LATIN SMALL LETTER W" )
 120  : ( "x"   U+0078 Ll 1 "LATIN SMALL LETTER X" )
 121  : ( "y"   U+0079 Ll 1 "LATIN SMALL LETTER Y" )
 122  : ( "z"   U+007A Ll 1 "LATIN SMALL LETTER Z" )
 123  : ( "{"   U+007B Ps 1 "LEFT CURLY BRACKET" )
 124  : ( "|"   U+007C Sm 1 "VERTICAL LINE" )
 125  : ( "}"   U+007D Pe 1 "RIGHT CURLY BRACKET" )
 126  : ( "~"   U+007E Sm 1 "TILDE" )
 127  : ( ""    U+007F Cc 0 "", "DELETE", "DEL" )
 128  : ( "¬Ä"    U+0080 Cc 0 "", "PADDING CHARACTER", "PAD" )
 129  : ( "¬Å"    U+0081 Cc 0 "", "HIGH OCTET PRESET", "HOP" )
 130  : ( "¬Ç"    U+0082 Cc 0 "", "BREAK PERMITTED HERE", "BPH" )
 131  : ( "¬É"    U+0083 Cc 0 "", "NO BREAK HERE", "NBH" )
 132  : ( "¬Ñ"    U+0084 Cc 0 "", "INDEX", "IND" )
 133  : ( "¬Ö"    U+0085 Cc 0 "", "NEXT LINE", "NEL" )
 134  : ( "¬Ü"    U+0086 Cc 0 "", "START OF SELECTED AREA", "SSA" )
 135  : ( "¬á"    U+0087 Cc 0 "", "END OF SELECTED AREA", "ESA" )
 136  : ( "¬à"    U+0088 Cc 0 "", "CHARACTER TABULATION SET", "HORIZONTAL TABULATION SET", "HTS" )
 137  : ( "¬â"    U+0089 Cc 0 "", "CHARACTER TABULATION WITH JUSTIFICATION", "HORIZONTAL TABULATION WITH JUSTIFICATION", "HTJ" )
 138  : ( "¬ä"    U+008A Cc 0 "", "LINE TABULATION SET", "VERTICAL TABULATION SET", "VTS" )
 139  : ( "¬ã"    U+008B Cc 0 "", "PARTIAL LINE FORWARD", "PARTIAL LINE DOWN", "PLD" )
 140  : ( "¬å"    U+008C Cc 0 "", "PARTIAL LINE BACKWARD", "PARTIAL LINE UP", "PLU" )
 141  : ( "¬ç"    U+008D Cc 0 "", "REVERSE LINE FEED", "REVERSE INDEX", "RI" )
 142  : ( "¬é"    U+008E Cc 0 "", "SINGLE SHIFT TWO", "SINGLE-SHIFT-2", "SS2" )
 143  : ( "¬è"    U+008F Cc 0 "", "SINGLE SHIFT THREE", "SINGLE-SHIFT-3", "SS3" )
 144  : ( "¬ê"    U+0090 Cc 0 "", "DEVICE CONTROL STRING", "DCS" )
 145  : ( "¬ë"    U+0091 Cc 0 "", "PRIVATE USE ONE", "PRIVATE USE-1", "PU1" )
 146  : ( "¬í"    U+0092 Cc 0 "", "PRIVATE USE TWO", "PRIVATE USE-2", "PU2" )
 147  : ( "¬ì"    U+0093 Cc 0 "", "SET TRANSMIT STATE", "STS" )
 148  : ( "¬î"    U+0094 Cc 0 "", "CANCEL CHARACTER", "CCH" )
 149  : ( "¬ï"    U+0095 Cc 0 "", "MESSAGE WAITING", "MW" )
 150  : ( "¬ñ"    U+0096 Cc 0 "", "START OF GUARDED AREA", "START OF PROTECTED AREA", "SPA" )
 151  : ( "¬ó"    U+0097 Cc 0 "", "END OF GUARDED AREA", "END OF PROTECTED AREA", "EPA" )
 152  : ( "¬ò"    U+0098 Cc 0 "", "START OF STRING", "SOS" )
 153  : ( "¬ô"    U+0099 Cc 0 "", "SINGLE GRAPHIC CHARACTER INTRODUCER", "SGC" )
 154  : ( "¬ö"    U+009A Cc 0 "", "SINGLE CHARACTER INTRODUCER", "SCI" )
 155  : ( "¬õ"    U+009B Cc 0 "", "CONTROL SEQUENCE INTRODUCER", "CSI" )
 156  : ( "¬ú"    U+009C Cc 0 "", "STRING TERMINATOR", "ST" )
 157  : ( "¬ù"    U+009D Cc 0 "", "OPERATING SYSTEM COMMAND", "OSC" )
 158  : ( "¬û"    U+009E Cc 0 "", "PRIVACY MESSAGE", "PM" )
 159  : ( "¬ü"    U+009F Cc 0 "", "APPLICATION PROGRAM COMMAND", "APC" )
 160  : ( "¬†"   U+00A0 Zs 1 "NO-BREAK SPACE", "NBSP" )
 161  : ( "¬°"   U+00A1 Po 1 "INVERTED EXCLAMATION MARK" )
 162  : ( "¬¢"   U+00A2 Sc 1 "CENT SIGN" )
 163  : ( "¬£"   U+00A3 Sc 1 "POUND SIGN" )
 164  : ( "¬§"   U+00A4 Sc 1 "CURRENCY SIGN" )
 165  : ( "¬•"   U+00A5 Sc 1 "YEN SIGN" )
 166  : ( "¬¶"   U+00A6 So 1 "BROKEN BAR" )
 167  : ( "¬ß"   U+00A7 Po 1 "SECTION SIGN" )
 168  : ( "¬®"   U+00A8 Sk 1 "DIAERESIS" )
 169  : ( "¬©"   U+00A9 So 1 "COPYRIGHT SIGN" )
 170  : ( "¬™"   U+00AA Lo 1 "FEMININE ORDINAL INDICATOR" )
 171  : ( "¬´"   U+00AB Pi 1 "LEFT-POINTING DOUBLE ANGLE QUOTATION MARK" )
 172  : ( "¬¨"   U+00AC Sm 1 "NOT SIGN" )
 173  : ( "¬≠"   U+00AD Cf 1 "SOFT HYPHEN", "SHY" )
 174  : ( "¬Æ"   U+00AE So 1 "REGISTERED SIGN" )
 175  : ( "¬Ø"   U+00AF Sk 1 "MACRON" )
 176  : ( "¬∞"   U+00B0 So 1 "DEGREE SIGN" )
 177  : ( "¬±"   U+00B1 Sm 1 "PLUS-MINUS SIGN" )
 178  : ( "¬≤"   U+00B2 No 1 "SUPERSCRIPT TWO" )
 179  : ( "¬≥"   U+00B3 No 1 "SUPERSCRIPT THREE" )
 180  : ( "¬¥"   U+00B4 Sk 1 "ACUTE ACCENT" )
 181  : ( "¬µ"   U+00B5 Ll 1 "MICRO SIGN" )
 182  : ( "¬∂"   U+00B6 Po 1 "PILCROW SIGN" )
 183  : ( "¬∑"   U+00B7 Po 1 "MIDDLE DOT" )
 184  : ( "¬∏"   U+00B8 Sk 1 "CEDILLA" )
 185  : ( "¬π"   U+00B9 No 1 "SUPERSCRIPT ONE" )
 186  : ( "¬∫"   U+00BA Lo 1 "MASCULINE ORDINAL INDICATOR" )
 187  : ( "¬ª"   U+00BB Pf 1 "RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK" )
 188  : ( "¬º"   U+00BC No 1 "VULGAR FRACTION ONE QUARTER" )
 189  : ( "¬Ω"   U+00BD No 1 "VULGAR FRACTION ONE HALF" )
 190  : ( "¬æ"   U+00BE No 1 "VULGAR FRACTION THREE QUARTERS" )
 191  : ( "¬ø"   U+00BF Po 1 "INVERTED QUESTION MARK" )
 192  : ( "√Ä"   U+00C0 Lu 1 "LATIN CAPITAL LETTER A WITH GRAVE" )
 193  : ( "√Å"   U+00C1 Lu 1 "LATIN CAPITAL LETTER A WITH ACUTE" )
 194  : ( "√Ç"   U+00C2 Lu 1 "LATIN CAPITAL LETTER A WITH CIRCUMFLEX" )
 195  : ( "√É"   U+00C3 Lu 1 "LATIN CAPITAL LETTER A WITH TILDE" )
 196  : ( "√Ñ"   U+00C4 Lu 1 "LATIN CAPITAL LETTER A WITH DIAERESIS" )
 197  : ( "√Ö"   U+00C5 Lu 1 "LATIN CAPITAL LETTER A WITH RING ABOVE" )
 198  : ( "√Ü"   U+00C6 Lu 1 "LATIN CAPITAL LETTER AE" )
 199  : ( "√á"   U+00C7 Lu 1 "LATIN CAPITAL LETTER C WITH CEDILLA" )
 200  : ( "√à"   U+00C8 Lu 1 "LATIN CAPITAL LETTER E WITH GRAVE" )
 201  : ( "√â"   U+00C9 Lu 1 "LATIN CAPITAL LETTER E WITH ACUTE" )
 202  : ( "√ä"   U+00CA Lu 1 "LATIN CAPITAL LETTER E WITH CIRCUMFLEX" )
 203  : ( "√ã"   U+00CB Lu 1 "LATIN CAPITAL LETTER E WITH DIAERESIS" )
 204  : ( "√å"   U+00CC Lu 1 "LATIN CAPITAL LETTER I WITH GRAVE" )
 205  : ( "√ç"   U+00CD Lu 1 "LATIN CAPITAL LETTER I WITH ACUTE" )
 206  : ( "√é"   U+00CE Lu 1 "LATIN CAPITAL LETTER I WITH CIRCUMFLEX" )
 207  : ( "√è"   U+00CF Lu 1 "LATIN CAPITAL LETTER I WITH DIAERESIS" )
 208  : ( "√ê"   U+00D0 Lu 1 "LATIN CAPITAL LETTER ETH" )
 209  : ( "√ë"   U+00D1 Lu 1 "LATIN CAPITAL LETTER N WITH TILDE" )
 210  : ( "√í"   U+00D2 Lu 1 "LATIN CAPITAL LETTER O WITH GRAVE" )
 211  : ( "√ì"   U+00D3 Lu 1 "LATIN CAPITAL LETTER O WITH ACUTE" )
 212  : ( "√î"   U+00D4 Lu 1 "LATIN CAPITAL LETTER O WITH CIRCUMFLEX" )
 213  : ( "√ï"   U+00D5 Lu 1 "LATIN CAPITAL LETTER O WITH TILDE" )
 214  : ( "√ñ"   U+00D6 Lu 1 "LATIN CAPITAL LETTER O WITH DIAERESIS" )
 215  : ( "√ó"   U+00D7 Sm 1 "MULTIPLICATION SIGN" )
 216  : ( "√ò"   U+00D8 Lu 1 "LATIN CAPITAL LETTER O WITH STROKE" )
 217  : ( "√ô"   U+00D9 Lu 1 "LATIN CAPITAL LETTER U WITH GRAVE" )
 218  : ( "√ö"   U+00DA Lu 1 "LATIN CAPITAL LETTER U WITH ACUTE" )
 219  : ( "√õ"   U+00DB Lu 1 "LATIN CAPITAL LETTER U WITH CIRCUMFLEX" )
 220  : ( "√ú"   U+00DC Lu 1 "LATIN CAPITAL LETTER U WITH DIAERESIS" )
 221  : ( "√ù"   U+00DD Lu 1 "LATIN CAPITAL LETTER Y WITH ACUTE" )
 222  : ( "√û"   U+00DE Lu 1 "LATIN CAPITAL LETTER THORN" )
 223  : ( "√ü"   U+00DF Ll 1 "LATIN SMALL LETTER SHARP S" )
 224  : ( "√†"   U+00E0 Ll 1 "LATIN SMALL LETTER A WITH GRAVE" )
 225  : ( "√°"   U+00E1 Ll 1 "LATIN SMALL LETTER A WITH ACUTE" )
 226  : ( "√¢"   U+00E2 Ll 1 "LATIN SMALL LETTER A WITH CIRCUMFLEX" )
 227  : ( "√£"   U+00E3 Ll 1 "LATIN SMALL LETTER A WITH TILDE" )
 228  : ( "√§"   U+00E4 Ll 1 "LATIN SMALL LETTER A WITH DIAERESIS" )
 229  : ( "√•"   U+00E5 Ll 1 "LATIN SMALL LETTER A WITH RING ABOVE" )
 230  : ( "√¶"   U+00E6 Ll 1 "LATIN SMALL LETTER AE" )
 231  : ( "√ß"   U+00E7 Ll 1 "LATIN SMALL LETTER C WITH CEDILLA" )
 232  : ( "√®"   U+00E8 Ll 1 "LATIN SMALL LETTER E WITH GRAVE" )
 233  : ( "√©"   U+00E9 Ll 1 "LATIN SMALL LETTER E WITH ACUTE" )
 234  : ( "√™"   U+00EA Ll 1 "LATIN SMALL LETTER E WITH CIRCUMFLEX" )
 235  : ( "√´"   U+00EB Ll 1 "LATIN SMALL LETTER E WITH DIAERESIS" )
 236  : ( "√¨"   U+00EC Ll 1 "LATIN SMALL LETTER I WITH GRAVE" )
 237  : ( "√≠"   U+00ED Ll 1 "LATIN SMALL LETTER I WITH ACUTE" )
 238  : ( "√Æ"   U+00EE Ll 1 "LATIN SMALL LETTER I WITH CIRCUMFLEX" )
 239  : ( "√Ø"   U+00EF Ll 1 "LATIN SMALL LETTER I WITH DIAERESIS" )
 240  : ( "√∞"   U+00F0 Ll 1 "LATIN SMALL LETTER ETH" )
 241  : ( "√±"   U+00F1 Ll 1 "LATIN SMALL LETTER N WITH TILDE" )
 242  : ( "√≤"   U+00F2 Ll 1 "LATIN SMALL LETTER O WITH GRAVE" )
 243  : ( "√≥"   U+00F3 Ll 1 "LATIN SMALL LETTER O WITH ACUTE" )
 244  : ( "√¥"   U+00F4 Ll 1 "LATIN SMALL LETTER O WITH CIRCUMFLEX" )
 245  : ( "√µ"   U+00F5 Ll 1 "LATIN SMALL LETTER O WITH TILDE" )
 246  : ( "√∂"   U+00F6 Ll 1 "LATIN SMALL LETTER O WITH DIAERESIS" )
 247  : ( "√∑"   U+00F7 Sm 1 "DIVISION SIGN" )
 248  : ( "√∏"   U+00F8 Ll 1 "LATIN SMALL LETTER O WITH STROKE" )
 249  : ( "√π"   U+00F9 Ll 1 "LATIN SMALL LETTER U WITH GRAVE" )
 250  : ( "√∫"   U+00FA Ll 1 "LATIN SMALL LETTER U WITH ACUTE" )
 251  : ( "√ª"   U+00FB Ll 1 "LATIN SMALL LETTER U WITH CIRCUMFLEX" )
 252  : ( "√º"   U+00FC Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS" )
 253  : ( "√Ω"   U+00FD Ll 1 "LATIN SMALL LETTER Y WITH ACUTE" )
 254  : ( "√æ"   U+00FE Ll 1 "LATIN SMALL LETTER THORN" )
 255  : ( "√ø"   U+00FF Ll 1 "LATIN SMALL LETTER Y WITH DIAERESIS" )
 256  : ( "ƒÄ"   U+0100 Lu 1 "LATIN CAPITAL LETTER A WITH MACRON" )
 257  : ( "ƒÅ"   U+0101 Ll 1 "LATIN SMALL LETTER A WITH MACRON" )
 258  : ( "ƒÇ"   U+0102 Lu 1 "LATIN CAPITAL LETTER A WITH BREVE" )
 259  : ( "ƒÉ"   U+0103 Ll 1 "LATIN SMALL LETTER A WITH BREVE" )
 260  : ( "ƒÑ"   U+0104 Lu 1 "LATIN CAPITAL LETTER A WITH OGONEK" )
 261  : ( "ƒÖ"   U+0105 Ll 1 "LATIN SMALL LETTER A WITH OGONEK" )
 262  : ( "ƒÜ"   U+0106 Lu 1 "LATIN CAPITAL LETTER C WITH ACUTE" )
 263  : ( "ƒá"   U+0107 Ll 1 "LATIN SMALL LETTER C WITH ACUTE" )
 264  : ( "ƒà"   U+0108 Lu 1 "LATIN CAPITAL LETTER C WITH CIRCUMFLEX" )
 265  : ( "ƒâ"   U+0109 Ll 1 "LATIN SMALL LETTER C WITH CIRCUMFLEX" )
 266  : ( "ƒä"   U+010A Lu 1 "LATIN CAPITAL LETTER C WITH DOT ABOVE" )
 267  : ( "ƒã"   U+010B Ll 1 "LATIN SMALL LETTER C WITH DOT ABOVE" )
 268  : ( "ƒå"   U+010C Lu 1 "LATIN CAPITAL LETTER C WITH CARON" )
 269  : ( "ƒç"   U+010D Ll 1 "LATIN SMALL LETTER C WITH CARON" )
 270  : ( "ƒé"   U+010E Lu 1 "LATIN CAPITAL LETTER D WITH CARON" )
 271  : ( "ƒè"   U+010F Ll 1 "LATIN SMALL LETTER D WITH CARON" )
 272  : ( "ƒê"   U+0110 Lu 1 "LATIN CAPITAL LETTER D WITH STROKE" )
 273  : ( "ƒë"   U+0111 Ll 1 "LATIN SMALL LETTER D WITH STROKE" )
 274  : ( "ƒí"   U+0112 Lu 1 "LATIN CAPITAL LETTER E WITH MACRON" )
 275  : ( "ƒì"   U+0113 Ll 1 "LATIN SMALL LETTER E WITH MACRON" )
 276  : ( "ƒî"   U+0114 Lu 1 "LATIN CAPITAL LETTER E WITH BREVE" )
 277  : ( "ƒï"   U+0115 Ll 1 "LATIN SMALL LETTER E WITH BREVE" )
 278  : ( "ƒñ"   U+0116 Lu 1 "LATIN CAPITAL LETTER E WITH DOT ABOVE" )
 279  : ( "ƒó"   U+0117 Ll 1 "LATIN SMALL LETTER E WITH DOT ABOVE" )
 280  : ( "ƒò"   U+0118 Lu 1 "LATIN CAPITAL LETTER E WITH OGONEK" )
 281  : ( "ƒô"   U+0119 Ll 1 "LATIN SMALL LETTER E WITH OGONEK" )
 282  : ( "ƒö"   U+011A Lu 1 "LATIN CAPITAL LETTER E WITH CARON" )
 283  : ( "ƒõ"   U+011B Ll 1 "LATIN SMALL LETTER E WITH CARON" )
 284  : ( "ƒú"   U+011C Lu 1 "LATIN CAPITAL LETTER G WITH CIRCUMFLEX" )
 285  : ( "ƒù"   U+011D Ll 1 "LATIN SMALL LETTER G WITH CIRCUMFLEX" )
 286  : ( "ƒû"   U+011E Lu 1 "LATIN CAPITAL LETTER G WITH BREVE" )
 287  : ( "ƒü"   U+011F Ll 1 "LATIN SMALL LETTER G WITH BREVE" )
 288  : ( "ƒ†"   U+0120 Lu 1 "LATIN CAPITAL LETTER G WITH DOT ABOVE" )
 289  : ( "ƒ°"   U+0121 Ll 1 "LATIN SMALL LETTER G WITH DOT ABOVE" )
 290  : ( "ƒ¢"   U+0122 Lu 1 "LATIN CAPITAL LETTER G WITH CEDILLA" )
 291  : ( "ƒ£"   U+0123 Ll 1 "LATIN SMALL LETTER G WITH CEDILLA" )
 292  : ( "ƒ§"   U+0124 Lu 1 "LATIN CAPITAL LETTER H WITH CIRCUMFLEX" )
 293  : ( "ƒ•"   U+0125 Ll 1 "LATIN SMALL LETTER H WITH CIRCUMFLEX" )
 294  : ( "ƒ¶"   U+0126 Lu 1 "LATIN CAPITAL LETTER H WITH STROKE" )
 295  : ( "ƒß"   U+0127 Ll 1 "LATIN SMALL LETTER H WITH STROKE" )
 296  : ( "ƒ®"   U+0128 Lu 1 "LATIN CAPITAL LETTER I WITH TILDE" )
 297  : ( "ƒ©"   U+0129 Ll 1 "LATIN SMALL LETTER I WITH TILDE" )
 298  : ( "ƒ™"   U+012A Lu 1 "LATIN CAPITAL LETTER I WITH MACRON" )
 299  : ( "ƒ´"   U+012B Ll 1 "LATIN SMALL LETTER I WITH MACRON" )
 300  : ( "ƒ¨"   U+012C Lu 1 "LATIN CAPITAL LETTER I WITH BREVE" )
 301  : ( "ƒ≠"   U+012D Ll 1 "LATIN SMALL LETTER I WITH BREVE" )
 302  : ( "ƒÆ"   U+012E Lu 1 "LATIN CAPITAL LETTER I WITH OGONEK" )
 303  : ( "ƒØ"   U+012F Ll 1 "LATIN SMALL LETTER I WITH OGONEK" )
 304  : ( "ƒ∞"   U+0130 Lu 1 "LATIN CAPITAL LETTER I WITH DOT ABOVE" )
 305  : ( "ƒ±"   U+0131 Ll 1 "LATIN SMALL LETTER DOTLESS I" )
 306  : ( "ƒ≤"   U+0132 Lu 1 "LATIN CAPITAL LIGATURE IJ" )
 307  : ( "ƒ≥"   U+0133 Ll 1 "LATIN SMALL LIGATURE IJ" )
 308  : ( "ƒ¥"   U+0134 Lu 1 "LATIN CAPITAL LETTER J WITH CIRCUMFLEX" )
 309  : ( "ƒµ"   U+0135 Ll 1 "LATIN SMALL LETTER J WITH CIRCUMFLEX" )
 310  : ( "ƒ∂"   U+0136 Lu 1 "LATIN CAPITAL LETTER K WITH CEDILLA" )
 311  : ( "ƒ∑"   U+0137 Ll 1 "LATIN SMALL LETTER K WITH CEDILLA" )
 312  : ( "ƒ∏"   U+0138 Ll 1 "LATIN SMALL LETTER KRA" )
 313  : ( "ƒπ"   U+0139 Lu 1 "LATIN CAPITAL LETTER L WITH ACUTE" )
 314  : ( "ƒ∫"   U+013A Ll 1 "LATIN SMALL LETTER L WITH ACUTE" )
 315  : ( "ƒª"   U+013B Lu 1 "LATIN CAPITAL LETTER L WITH CEDILLA" )
 316  : ( "ƒº"   U+013C Ll 1 "LATIN SMALL LETTER L WITH CEDILLA" )
 317  : ( "ƒΩ"   U+013D Lu 1 "LATIN CAPITAL LETTER L WITH CARON" )
 318  : ( "ƒæ"   U+013E Ll 1 "LATIN SMALL LETTER L WITH CARON" )
 319  : ( "ƒø"   U+013F Lu 1 "LATIN CAPITAL LETTER L WITH MIDDLE DOT" )
 320  : ( "≈Ä"   U+0140 Ll 1 "LATIN SMALL LETTER L WITH MIDDLE DOT" )
 321  : ( "≈Å"   U+0141 Lu 1 "LATIN CAPITAL LETTER L WITH STROKE" )
 322  : ( "≈Ç"   U+0142 Ll 1 "LATIN SMALL LETTER L WITH STROKE" )
 323  : ( "≈É"   U+0143 Lu 1 "LATIN CAPITAL LETTER N WITH ACUTE" )
 324  : ( "≈Ñ"   U+0144 Ll 1 "LATIN SMALL LETTER N WITH ACUTE" )
 325  : ( "≈Ö"   U+0145 Lu 1 "LATIN CAPITAL LETTER N WITH CEDILLA" )
 326  : ( "≈Ü"   U+0146 Ll 1 "LATIN SMALL LETTER N WITH CEDILLA" )
 327  : ( "≈á"   U+0147 Lu 1 "LATIN CAPITAL LETTER N WITH CARON" )
 328  : ( "≈à"   U+0148 Ll 1 "LATIN SMALL LETTER N WITH CARON" )
 329  : ( "≈â"   U+0149 Ll 1 "LATIN SMALL LETTER N PRECEDED BY APOSTROPHE" )
 330  : ( "≈ä"   U+014A Lu 1 "LATIN CAPITAL LETTER ENG" )
 331  : ( "≈ã"   U+014B Ll 1 "LATIN SMALL LETTER ENG" )
 332  : ( "≈å"   U+014C Lu 1 "LATIN CAPITAL LETTER O WITH MACRON" )
 333  : ( "≈ç"   U+014D Ll 1 "LATIN SMALL LETTER O WITH MACRON" )
 334  : ( "≈é"   U+014E Lu 1 "LATIN CAPITAL LETTER O WITH BREVE" )
 335  : ( "≈è"   U+014F Ll 1 "LATIN SMALL LETTER O WITH BREVE" )
 336  : ( "≈ê"   U+0150 Lu 1 "LATIN CAPITAL LETTER O WITH DOUBLE ACUTE" )
 337  : ( "≈ë"   U+0151 Ll 1 "LATIN SMALL LETTER O WITH DOUBLE ACUTE" )
 338  : ( "≈í"   U+0152 Lu 1 "LATIN CAPITAL LIGATURE OE" )
 339  : ( "≈ì"   U+0153 Ll 1 "LATIN SMALL LIGATURE OE" )
 340  : ( "≈î"   U+0154 Lu 1 "LATIN CAPITAL LETTER R WITH ACUTE" )
 341  : ( "≈ï"   U+0155 Ll 1 "LATIN SMALL LETTER R WITH ACUTE" )
 342  : ( "≈ñ"   U+0156 Lu 1 "LATIN CAPITAL LETTER R WITH CEDILLA" )
 343  : ( "≈ó"   U+0157 Ll 1 "LATIN SMALL LETTER R WITH CEDILLA" )
 344  : ( "≈ò"   U+0158 Lu 1 "LATIN CAPITAL LETTER R WITH CARON" )
 345  : ( "≈ô"   U+0159 Ll 1 "LATIN SMALL LETTER R WITH CARON" )
 346  : ( "≈ö"   U+015A Lu 1 "LATIN CAPITAL LETTER S WITH ACUTE" )
 347  : ( "≈õ"   U+015B Ll 1 "LATIN SMALL LETTER S WITH ACUTE" )
 348  : ( "≈ú"   U+015C Lu 1 "LATIN CAPITAL LETTER S WITH CIRCUMFLEX" )
 349  : ( "≈ù"   U+015D Ll 1 "LATIN SMALL LETTER S WITH CIRCUMFLEX" )
 350  : ( "≈û"   U+015E Lu 1 "LATIN CAPITAL LETTER S WITH CEDILLA" )
 351  : ( "≈ü"   U+015F Ll 1 "LATIN SMALL LETTER S WITH CEDILLA" )
 352  : ( "≈†"   U+0160 Lu 1 "LATIN CAPITAL LETTER S WITH CARON" )
 353  : ( "≈°"   U+0161 Ll 1 "LATIN SMALL LETTER S WITH CARON" )
 354  : ( "≈¢"   U+0162 Lu 1 "LATIN CAPITAL LETTER T WITH CEDILLA" )
 355  : ( "≈£"   U+0163 Ll 1 "LATIN SMALL LETTER T WITH CEDILLA" )
 356  : ( "≈§"   U+0164 Lu 1 "LATIN CAPITAL LETTER T WITH CARON" )
 357  : ( "≈•"   U+0165 Ll 1 "LATIN SMALL LETTER T WITH CARON" )
 358  : ( "≈¶"   U+0166 Lu 1 "LATIN CAPITAL LETTER T WITH STROKE" )
 359  : ( "≈ß"   U+0167 Ll 1 "LATIN SMALL LETTER T WITH STROKE" )
 360  : ( "≈®"   U+0168 Lu 1 "LATIN CAPITAL LETTER U WITH TILDE" )
 361  : ( "≈©"   U+0169 Ll 1 "LATIN SMALL LETTER U WITH TILDE" )
 362  : ( "≈™"   U+016A Lu 1 "LATIN CAPITAL LETTER U WITH MACRON" )
 363  : ( "≈´"   U+016B Ll 1 "LATIN SMALL LETTER U WITH MACRON" )
 364  : ( "≈¨"   U+016C Lu 1 "LATIN CAPITAL LETTER U WITH BREVE" )
 365  : ( "≈≠"   U+016D Ll 1 "LATIN SMALL LETTER U WITH BREVE" )
 366  : ( "≈Æ"   U+016E Lu 1 "LATIN CAPITAL LETTER U WITH RING ABOVE" )
 367  : ( "≈Ø"   U+016F Ll 1 "LATIN SMALL LETTER U WITH RING ABOVE" )
 368  : ( "≈∞"   U+0170 Lu 1 "LATIN CAPITAL LETTER U WITH DOUBLE ACUTE" )
 369  : ( "≈±"   U+0171 Ll 1 "LATIN SMALL LETTER U WITH DOUBLE ACUTE" )
 370  : ( "≈≤"   U+0172 Lu 1 "LATIN CAPITAL LETTER U WITH OGONEK" )
 371  : ( "≈≥"   U+0173 Ll 1 "LATIN SMALL LETTER U WITH OGONEK" )
 372  : ( "≈¥"   U+0174 Lu 1 "LATIN CAPITAL LETTER W WITH CIRCUMFLEX" )
 373  : ( "≈µ"   U+0175 Ll 1 "LATIN SMALL LETTER W WITH CIRCUMFLEX" )
 374  : ( "≈∂"   U+0176 Lu 1 "LATIN CAPITAL LETTER Y WITH CIRCUMFLEX" )
 375  : ( "≈∑"   U+0177 Ll 1 "LATIN SMALL LETTER Y WITH CIRCUMFLEX" )
 376  : ( "≈∏"   U+0178 Lu 1 "LATIN CAPITAL LETTER Y WITH DIAERESIS" )
 377  : ( "≈π"   U+0179 Lu 1 "LATIN CAPITAL LETTER Z WITH ACUTE" )
 378  : ( "≈∫"   U+017A Ll 1 "LATIN SMALL LETTER Z WITH ACUTE" )
 379  : ( "≈ª"   U+017B Lu 1 "LATIN CAPITAL LETTER Z WITH DOT ABOVE" )
 380  : ( "≈º"   U+017C Ll 1 "LATIN SMALL LETTER Z WITH DOT ABOVE" )
 381  : ( "≈Ω"   U+017D Lu 1 "LATIN CAPITAL LETTER Z WITH CARON" )
 382  : ( "≈æ"   U+017E Ll 1 "LATIN SMALL LETTER Z WITH CARON" )
 383  : ( "≈ø"   U+017F Ll 1 "LATIN SMALL LETTER LONG S" )
 384  : ( "∆Ä"   U+0180 Ll 1 "LATIN SMALL LETTER B WITH STROKE" )
 385  : ( "∆Å"   U+0181 Lu 1 "LATIN CAPITAL LETTER B WITH HOOK" )
 386  : ( "∆Ç"   U+0182 Lu 1 "LATIN CAPITAL LETTER B WITH TOPBAR" )
 387  : ( "∆É"   U+0183 Ll 1 "LATIN SMALL LETTER B WITH TOPBAR" )
 388  : ( "∆Ñ"   U+0184 Lu 1 "LATIN CAPITAL LETTER TONE SIX" )
 389  : ( "∆Ö"   U+0185 Ll 1 "LATIN SMALL LETTER TONE SIX" )
 390  : ( "∆Ü"   U+0186 Lu 1 "LATIN CAPITAL LETTER OPEN O" )
 391  : ( "∆á"   U+0187 Lu 1 "LATIN CAPITAL LETTER C WITH HOOK" )
 392  : ( "∆à"   U+0188 Ll 1 "LATIN SMALL LETTER C WITH HOOK" )
 393  : ( "∆â"   U+0189 Lu 1 "LATIN CAPITAL LETTER AFRICAN D" )
 394  : ( "∆ä"   U+018A Lu 1 "LATIN CAPITAL LETTER D WITH HOOK" )
 395  : ( "∆ã"   U+018B Lu 1 "LATIN CAPITAL LETTER D WITH TOPBAR" )
 396  : ( "∆å"   U+018C Ll 1 "LATIN SMALL LETTER D WITH TOPBAR" )
 397  : ( "∆ç"   U+018D Ll 1 "LATIN SMALL LETTER TURNED DELTA" )
 398  : ( "∆é"   U+018E Lu 1 "LATIN CAPITAL LETTER REVERSED E" )
 399  : ( "∆è"   U+018F Lu 1 "LATIN CAPITAL LETTER SCHWA" )
 400  : ( "∆ê"   U+0190 Lu 1 "LATIN CAPITAL LETTER OPEN E" )
 401  : ( "∆ë"   U+0191 Lu 1 "LATIN CAPITAL LETTER F WITH HOOK" )
 402  : ( "∆í"   U+0192 Ll 1 "LATIN SMALL LETTER F WITH HOOK" )
 403  : ( "∆ì"   U+0193 Lu 1 "LATIN CAPITAL LETTER G WITH HOOK" )
 404  : ( "∆î"   U+0194 Lu 1 "LATIN CAPITAL LETTER GAMMA" )
 405  : ( "∆ï"   U+0195 Ll 1 "LATIN SMALL LETTER HV" )
 406  : ( "∆ñ"   U+0196 Lu 1 "LATIN CAPITAL LETTER IOTA" )
 407  : ( "∆ó"   U+0197 Lu 1 "LATIN CAPITAL LETTER I WITH STROKE" )
 408  : ( "∆ò"   U+0198 Lu 1 "LATIN CAPITAL LETTER K WITH HOOK" )
 409  : ( "∆ô"   U+0199 Ll 1 "LATIN SMALL LETTER K WITH HOOK" )
 410  : ( "∆ö"   U+019A Ll 1 "LATIN SMALL LETTER L WITH BAR" )
 411  : ( "∆õ"   U+019B Ll 1 "LATIN SMALL LETTER LAMBDA WITH STROKE" )
 412  : ( "∆ú"   U+019C Lu 1 "LATIN CAPITAL LETTER TURNED M" )
 413  : ( "∆ù"   U+019D Lu 1 "LATIN CAPITAL LETTER N WITH LEFT HOOK" )
 414  : ( "∆û"   U+019E Ll 1 "LATIN SMALL LETTER N WITH LONG RIGHT LEG" )
 415  : ( "∆ü"   U+019F Lu 1 "LATIN CAPITAL LETTER O WITH MIDDLE TILDE" )
 416  : ( "∆†"   U+01A0 Lu 1 "LATIN CAPITAL LETTER O WITH HORN" )
 417  : ( "∆°"   U+01A1 Ll 1 "LATIN SMALL LETTER O WITH HORN" )
 418  : ( "∆¢"   U+01A2 Lu 1 "LATIN CAPITAL LETTER OI", "LATIN CAPITAL LETTER GHA" )
 419  : ( "∆£"   U+01A3 Ll 1 "LATIN SMALL LETTER OI", "LATIN SMALL LETTER GHA" )
 420  : ( "∆§"   U+01A4 Lu 1 "LATIN CAPITAL LETTER P WITH HOOK" )
 421  : ( "∆•"   U+01A5 Ll 1 "LATIN SMALL LETTER P WITH HOOK" )
 422  : ( "∆¶"   U+01A6 Lu 1 "LATIN LETTER YR" )
 423  : ( "∆ß"   U+01A7 Lu 1 "LATIN CAPITAL LETTER TONE TWO" )
 424  : ( "∆®"   U+01A8 Ll 1 "LATIN SMALL LETTER TONE TWO" )
 425  : ( "∆©"   U+01A9 Lu 1 "LATIN CAPITAL LETTER ESH" )
 426  : ( "∆™"   U+01AA Ll 1 "LATIN LETTER REVERSED ESH LOOP" )
 427  : ( "∆´"   U+01AB Ll 1 "LATIN SMALL LETTER T WITH PALATAL HOOK" )
 428  : ( "∆¨"   U+01AC Lu 1 "LATIN CAPITAL LETTER T WITH HOOK" )
 429  : ( "∆≠"   U+01AD Ll 1 "LATIN SMALL LETTER T WITH HOOK" )
 430  : ( "∆Æ"   U+01AE Lu 1 "LATIN CAPITAL LETTER T WITH RETROFLEX HOOK" )
 431  : ( "∆Ø"   U+01AF Lu 1 "LATIN CAPITAL LETTER U WITH HORN" )
 432  : ( "∆∞"   U+01B0 Ll 1 "LATIN SMALL LETTER U WITH HORN" )
 433  : ( "∆±"   U+01B1 Lu 1 "LATIN CAPITAL LETTER UPSILON" )
 434  : ( "∆≤"   U+01B2 Lu 1 "LATIN CAPITAL LETTER V WITH HOOK" )
 435  : ( "∆≥"   U+01B3 Lu 1 "LATIN CAPITAL LETTER Y WITH HOOK" )
 436  : ( "∆¥"   U+01B4 Ll 1 "LATIN SMALL LETTER Y WITH HOOK" )
 437  : ( "∆µ"   U+01B5 Lu 1 "LATIN CAPITAL LETTER Z WITH STROKE" )
 438  : ( "∆∂"   U+01B6 Ll 1 "LATIN SMALL LETTER Z WITH STROKE" )
 439  : ( "∆∑"   U+01B7 Lu 1 "LATIN CAPITAL LETTER EZH" )
 440  : ( "∆∏"   U+01B8 Lu 1 "LATIN CAPITAL LETTER EZH REVERSED" )
 441  : ( "∆π"   U+01B9 Ll 1 "LATIN SMALL LETTER EZH REVERSED" )
 442  : ( "∆∫"   U+01BA Ll 1 "LATIN SMALL LETTER EZH WITH TAIL" )
 443  : ( "∆ª"   U+01BB Lo 1 "LATIN LETTER TWO WITH STROKE" )
 444  : ( "∆º"   U+01BC Lu 1 "LATIN CAPITAL LETTER TONE FIVE" )
 445  : ( "∆Ω"   U+01BD Ll 1 "LATIN SMALL LETTER TONE FIVE" )
 446  : ( "∆æ"   U+01BE Ll 1 "LATIN LETTER INVERTED GLOTTAL STOP WITH STROKE" )
 447  : ( "∆ø"   U+01BF Ll 1 "LATIN LETTER WYNN" )
 448  : ( "«Ä"   U+01C0 Lo 1 "LATIN LETTER DENTAL CLICK" )
 449  : ( "«Å"   U+01C1 Lo 1 "LATIN LETTER LATERAL CLICK" )
 450  : ( "«Ç"   U+01C2 Lo 1 "LATIN LETTER ALVEOLAR CLICK" )
 451  : ( "«É"   U+01C3 Lo 1 "LATIN LETTER RETROFLEX CLICK" )
 452  : ( "«Ñ"   U+01C4 Lu 1 "LATIN CAPITAL LETTER DZ WITH CARON" )
 453  : ( "«Ö"   U+01C5 Lt 1 "LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON" )
 454  : ( "«Ü"   U+01C6 Ll 1 "LATIN SMALL LETTER DZ WITH CARON" )
 455  : ( "«á"   U+01C7 Lu 1 "LATIN CAPITAL LETTER LJ" )
 456  : ( "«à"   U+01C8 Lt 1 "LATIN CAPITAL LETTER L WITH SMALL LETTER J" )
 457  : ( "«â"   U+01C9 Ll 1 "LATIN SMALL LETTER LJ" )
 458  : ( "«ä"   U+01CA Lu 1 "LATIN CAPITAL LETTER NJ" )
 459  : ( "«ã"   U+01CB Lt 1 "LATIN CAPITAL LETTER N WITH SMALL LETTER J" )
 460  : ( "«å"   U+01CC Ll 1 "LATIN SMALL LETTER NJ" )
 461  : ( "«ç"   U+01CD Lu 1 "LATIN CAPITAL LETTER A WITH CARON" )
 462  : ( "«é"   U+01CE Ll 1 "LATIN SMALL LETTER A WITH CARON" )
 463  : ( "«è"   U+01CF Lu 1 "LATIN CAPITAL LETTER I WITH CARON" )
 464  : ( "«ê"   U+01D0 Ll 1 "LATIN SMALL LETTER I WITH CARON" )
 465  : ( "«ë"   U+01D1 Lu 1 "LATIN CAPITAL LETTER O WITH CARON" )
 466  : ( "«í"   U+01D2 Ll 1 "LATIN SMALL LETTER O WITH CARON" )
 467  : ( "«ì"   U+01D3 Lu 1 "LATIN CAPITAL LETTER U WITH CARON" )
 468  : ( "«î"   U+01D4 Ll 1 "LATIN SMALL LETTER U WITH CARON" )
 469  : ( "«ï"   U+01D5 Lu 1 "LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON" )
 470  : ( "«ñ"   U+01D6 Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS AND MACRON" )
 471  : ( "«ó"   U+01D7 Lu 1 "LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE" )
 472  : ( "«ò"   U+01D8 Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE" )
 473  : ( "«ô"   U+01D9 Lu 1 "LATIN CAPITAL LETTER U WITH DIAERESIS AND CARON" )
 474  : ( "«ö"   U+01DA Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS AND CARON" )
 475  : ( "«õ"   U+01DB Lu 1 "LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE" )
 476  : ( "«ú"   U+01DC Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE" )
 477  : ( "«ù"   U+01DD Ll 1 "LATIN SMALL LETTER TURNED E" )
 478  : ( "«û"   U+01DE Lu 1 "LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON" )
 479  : ( "«ü"   U+01DF Ll 1 "LATIN SMALL LETTER A WITH DIAERESIS AND MACRON" )
 480  : ( "«†"   U+01E0 Lu 1 "LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON" )
 481  : ( "«°"   U+01E1 Ll 1 "LATIN SMALL LETTER A WITH DOT ABOVE AND MACRON" )
 482  : ( "«¢"   U+01E2 Lu 1 "LATIN CAPITAL LETTER AE WITH MACRON" )
 483  : ( "«£"   U+01E3 Ll 1 "LATIN SMALL LETTER AE WITH MACRON" )
 484  : ( "«§"   U+01E4 Lu 1 "LATIN CAPITAL LETTER G WITH STROKE" )
 485  : ( "«•"   U+01E5 Ll 1 "LATIN SMALL LETTER G WITH STROKE" )
 486  : ( "«¶"   U+01E6 Lu 1 "LATIN CAPITAL LETTER G WITH CARON" )
 487  : ( "«ß"   U+01E7 Ll 1 "LATIN SMALL LETTER G WITH CARON" )
 488  : ( "«®"   U+01E8 Lu 1 "LATIN CAPITAL LETTER K WITH CARON" )
 489  : ( "«©"   U+01E9 Ll 1 "LATIN SMALL LETTER K WITH CARON" )
 490  : ( "«™"   U+01EA Lu 1 "LATIN CAPITAL LETTER O WITH OGONEK" )
 491  : ( "«´"   U+01EB Ll 1 "LATIN SMALL LETTER O WITH OGONEK" )
 492  : ( "«¨"   U+01EC Lu 1 "LATIN CAPITAL LETTER O WITH OGONEK AND MACRON" )
 493  : ( "«≠"   U+01ED Ll 1 "LATIN SMALL LETTER O WITH OGONEK AND MACRON" )
 494  : ( "«Æ"   U+01EE Lu 1 "LATIN CAPITAL LETTER EZH WITH CARON" )
 495  : ( "«Ø"   U+01EF Ll 1 "LATIN SMALL LETTER EZH WITH CARON" )
 496  : ( "«∞"   U+01F0 Ll 1 "LATIN SMALL LETTER J WITH CARON" )
 497  : ( "«±"   U+01F1 Lu 1 "LATIN CAPITAL LETTER DZ" )
 498  : ( "«≤"   U+01F2 Lt 1 "LATIN CAPITAL LETTER D WITH SMALL LETTER Z" )
 499  : ( "«≥"   U+01F3 Ll 1 "LATIN SMALL LETTER DZ" )
 500  : ( "«¥"   U+01F4 Lu 1 "LATIN CAPITAL LETTER G WITH ACUTE" )
 501  : ( "«µ"   U+01F5 Ll 1 "LATIN SMALL LETTER G WITH ACUTE" )
 502  : ( "«∂"   U+01F6 Lu 1 "LATIN CAPITAL LETTER HWAIR" )
 503  : ( "«∑"   U+01F7 Lu 1 "LATIN CAPITAL LETTER WYNN" )
 504  : ( "«∏"   U+01F8 Lu 1 "LATIN CAPITAL LETTER N WITH GRAVE" )
 505  : ( "«π"   U+01F9 Ll 1 "LATIN SMALL LETTER N WITH GRAVE" )
 506  : ( "«∫"   U+01FA Lu 1 "LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE" )
 507  : ( "«ª"   U+01FB Ll 1 "LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE" )
 508  : ( "«º"   U+01FC Lu 1 "LATIN CAPITAL LETTER AE WITH ACUTE" )
 509  : ( "«Ω"   U+01FD Ll 1 "LATIN SMALL LETTER AE WITH ACUTE" )
 510  : ( "«æ"   U+01FE Lu 1 "LATIN CAPITAL LETTER O WITH STROKE AND ACUTE" )
 511  : ( "«ø"   U+01FF Ll 1 "LATIN SMALL LETTER O WITH STROKE AND ACUTE" )
 512  : ( "»Ä"   U+0200 Lu 1 "LATIN CAPITAL LETTER A WITH DOUBLE GRAVE" )
 513  : ( "»Å"   U+0201 Ll 1 "LATIN SMALL LETTER A WITH DOUBLE GRAVE" )
 514  : ( "»Ç"   U+0202 Lu 1 "LATIN CAPITAL LETTER A WITH INVERTED BREVE" )
 515  : ( "»É"   U+0203 Ll 1 "LATIN SMALL LETTER A WITH INVERTED BREVE" )
 516  : ( "»Ñ"   U+0204 Lu 1 "LATIN CAPITAL LETTER E WITH DOUBLE GRAVE" )
 517  : ( "»Ö"   U+0205 Ll 1 "LATIN SMALL LETTER E WITH DOUBLE GRAVE" )
 518  : ( "»Ü"   U+0206 Lu 1 "LATIN CAPITAL LETTER E WITH INVERTED BREVE" )
 519  : ( "»á"   U+0207 Ll 1 "LATIN SMALL LETTER E WITH INVERTED BREVE" )
 520  : ( "»à"   U+0208 Lu 1 "LATIN CAPITAL LETTER I WITH DOUBLE GRAVE" )
 521  : ( "»â"   U+0209 Ll 1 "LATIN SMALL LETTER I WITH DOUBLE GRAVE" )
 522  : ( "»ä"   U+020A Lu 1 "LATIN CAPITAL LETTER I WITH INVERTED BREVE" )
 523  : ( "»ã"   U+020B Ll 1 "LATIN SMALL LETTER I WITH INVERTED BREVE" )
 524  : ( "»å"   U+020C Lu 1 "LATIN CAPITAL LETTER O WITH DOUBLE GRAVE" )
 525  : ( "»ç"   U+020D Ll 1 "LATIN SMALL LETTER O WITH DOUBLE GRAVE" )
 526  : ( "»é"   U+020E Lu 1 "LATIN CAPITAL LETTER O WITH INVERTED BREVE" )
 527  : ( "»è"   U+020F Ll 1 "LATIN SMALL LETTER O WITH INVERTED BREVE" )
 528  : ( "»ê"   U+0210 Lu 1 "LATIN CAPITAL LETTER R WITH DOUBLE GRAVE" )
 529  : ( "»ë"   U+0211 Ll 1 "LATIN SMALL LETTER R WITH DOUBLE GRAVE" )
 530  : ( "»í"   U+0212 Lu 1 "LATIN CAPITAL LETTER R WITH INVERTED BREVE" )
 531  : ( "»ì"   U+0213 Ll 1 "LATIN SMALL LETTER R WITH INVERTED BREVE" )
 532  : ( "»î"   U+0214 Lu 1 "LATIN CAPITAL LETTER U WITH DOUBLE GRAVE" )
 533  : ( "»ï"   U+0215 Ll 1 "LATIN SMALL LETTER U WITH DOUBLE GRAVE" )
 534  : ( "»ñ"   U+0216 Lu 1 "LATIN CAPITAL LETTER U WITH INVERTED BREVE" )
 535  : ( "»ó"   U+0217 Ll 1 "LATIN SMALL LETTER U WITH INVERTED BREVE" )
 536  : ( "»ò"   U+0218 Lu 1 "LATIN CAPITAL LETTER S WITH COMMA BELOW" )
 537  : ( "»ô"   U+0219 Ll 1 "LATIN SMALL LETTER S WITH COMMA BELOW" )
 538  : ( "»ö"   U+021A Lu 1 "LATIN CAPITAL LETTER T WITH COMMA BELOW" )
 539  : ( "»õ"   U+021B Ll 1 "LATIN SMALL LETTER T WITH COMMA BELOW" )
 540  : ( "»ú"   U+021C Lu 1 "LATIN CAPITAL LETTER YOGH" )
 541  : ( "»ù"   U+021D Ll 1 "LATIN SMALL LETTER YOGH" )
 542  : ( "»û"   U+021E Lu 1 "LATIN CAPITAL LETTER H WITH CARON" )
 543  : ( "»ü"   U+021F Ll 1 "LATIN SMALL LETTER H WITH CARON" )
 544  : ( "»†"   U+0220 Lu 1 "LATIN CAPITAL LETTER N WITH LONG RIGHT LEG" )
 545  : ( "»°"   U+0221 Ll 1 "LATIN SMALL LETTER D WITH CURL" )
 546  : ( "»¢"   U+0222 Lu 1 "LATIN CAPITAL LETTER OU" )
 547  : ( "»£"   U+0223 Ll 1 "LATIN SMALL LETTER OU" )
 548  : ( "»§"   U+0224 Lu 1 "LATIN CAPITAL LETTER Z WITH HOOK" )
 549  : ( "»•"   U+0225 Ll 1 "LATIN SMALL LETTER Z WITH HOOK" )
 550  : ( "»¶"   U+0226 Lu 1 "LATIN CAPITAL LETTER A WITH DOT ABOVE" )
 551  : ( "»ß"   U+0227 Ll 1 "LATIN SMALL LETTER A WITH DOT ABOVE" )
 552  : ( "»®"   U+0228 Lu 1 "LATIN CAPITAL LETTER E WITH CEDILLA" )
 553  : ( "»©"   U+0229 Ll 1 "LATIN SMALL LETTER E WITH CEDILLA" )
 554  : ( "»™"   U+022A Lu 1 "LATIN CAPITAL LETTER O WITH DIAERESIS AND MACRON" )
 555  : ( "»´"   U+022B Ll 1 "LATIN SMALL LETTER O WITH DIAERESIS AND MACRON" )
 556  : ( "»¨"   U+022C Lu 1 "LATIN CAPITAL LETTER O WITH TILDE AND MACRON" )
 557  : ( "»≠"   U+022D Ll 1 "LATIN SMALL LETTER O WITH TILDE AND MACRON" )
 558  : ( "»Æ"   U+022E Lu 1 "LATIN CAPITAL LETTER O WITH DOT ABOVE" )
 559  : ( "»Ø"   U+022F Ll 1 "LATIN SMALL LETTER O WITH DOT ABOVE" )
 560  : ( "»∞"   U+0230 Lu 1 "LATIN CAPITAL LETTER O WITH DOT ABOVE AND MACRON" )
 561  : ( "»±"   U+0231 Ll 1 "LATIN SMALL LETTER O WITH DOT ABOVE AND MACRON" )
 562  : ( "»≤"   U+0232 Lu 1 "LATIN CAPITAL LETTER Y WITH MACRON" )
 563  : ( "»≥"   U+0233 Ll 1 "LATIN SMALL LETTER Y WITH MACRON" )
 564  : ( "»¥"   U+0234 Ll 1 "LATIN SMALL LETTER L WITH CURL" )
 565  : ( "»µ"   U+0235 Ll 1 "LATIN SMALL LETTER N WITH CURL" )
 566  : ( "»∂"   U+0236 Ll 1 "LATIN SMALL LETTER T WITH CURL" )
 567  : ( "»∑"   U+0237 Ll 1 "LATIN SMALL LETTER DOTLESS J" )
 568  : ( "»∏"   U+0238 Ll 1 "LATIN SMALL LETTER DB DIGRAPH" )
 569  : ( "»π"   U+0239 Ll 1 "LATIN SMALL LETTER QP DIGRAPH" )
 570  : ( "»∫"   U+023A Lu 1 "LATIN CAPITAL LETTER A WITH STROKE" )
 571  : ( "»ª"   U+023B Lu 1 "LATIN CAPITAL LETTER C WITH STROKE" )
 572  : ( "»º"   U+023C Ll 1 "LATIN SMALL LETTER C WITH STROKE" )
 573  : ( "»Ω"   U+023D Lu 1 "LATIN CAPITAL LETTER L WITH BAR" )
 574  : ( "»æ"   U+023E Lu 1 "LATIN CAPITAL LETTER T WITH DIAGONAL STROKE" )
 575  : ( "»ø"   U+023F Ll 1 "LATIN SMALL LETTER S WITH SWASH TAIL" )
 576  : ( "…Ä"   U+0240 Ll 1 "LATIN SMALL LETTER Z WITH SWASH TAIL" )
 577  : ( "…Å"   U+0241 Lu 1 "LATIN CAPITAL LETTER GLOTTAL STOP" )
 578  : ( "…Ç"   U+0242 Ll 1 "LATIN SMALL LETTER GLOTTAL STOP" )
 579  : ( "…É"   U+0243 Lu 1 "LATIN CAPITAL LETTER B WITH STROKE" )
 580  : ( "…Ñ"   U+0244 Lu 1 "LATIN CAPITAL LETTER U BAR" )
 581  : ( "…Ö"   U+0245 Lu 1 "LATIN CAPITAL LETTER TURNED V" )
 582  : ( "…Ü"   U+0246 Lu 1 "LATIN CAPITAL LETTER E WITH STROKE" )
 583  : ( "…á"   U+0247 Ll 1 "LATIN SMALL LETTER E WITH STROKE" )
 584  : ( "…à"   U+0248 Lu 1 "LATIN CAPITAL LETTER J WITH STROKE" )
 585  : ( "…â"   U+0249 Ll 1 "LATIN SMALL LETTER J WITH STROKE" )
 586  : ( "…ä"   U+024A Lu 1 "LATIN CAPITAL LETTER SMALL Q WITH HOOK TAIL" )
 587  : ( "…ã"   U+024B Ll 1 "LATIN SMALL LETTER Q WITH HOOK TAIL" )
 588  : ( "…å"   U+024C Lu 1 "LATIN CAPITAL LETTER R WITH STROKE" )
 589  : ( "…ç"   U+024D Ll 1 "LATIN SMALL LETTER R WITH STROKE" )
 590  : ( "…é"   U+024E Lu 1 "LATIN CAPITAL LETTER Y WITH STROKE" )
 591  : ( "…è"   U+024F Ll 1 "LATIN SMALL LETTER Y WITH STROKE" )
 592  : ( "…ê"   U+0250 Ll 1 "LATIN SMALL LETTER TURNED A" )
 593  : ( "…ë"   U+0251 Ll 1 "LATIN SMALL LETTER ALPHA" )
 594  : ( "…í"   U+0252 Ll 1 "LATIN SMALL LETTER TURNED ALPHA" )
 595  : ( "…ì"   U+0253 Ll 1 "LATIN SMALL LETTER B WITH HOOK" )
 596  : ( "…î"   U+0254 Ll 1 "LATIN SMALL LETTER OPEN O" )
 597  : ( "…ï"   U+0255 Ll 1 "LATIN SMALL LETTER C WITH CURL" )
 598  : ( "…ñ"   U+0256 Ll 1 "LATIN SMALL LETTER D WITH TAIL" )
 599  : ( "…ó"   U+0257 Ll 1 "LATIN SMALL LETTER D WITH HOOK" )
 600  : ( "…ò"   U+0258 Ll 1 "LATIN SMALL LETTER REVERSED E" )
 601  : ( "…ô"   U+0259 Ll 1 "LATIN SMALL LETTER SCHWA" )
 602  : ( "…ö"   U+025A Ll 1 "LATIN SMALL LETTER SCHWA WITH HOOK" )
 603  : ( "…õ"   U+025B Ll 1 "LATIN SMALL LETTER OPEN E" )
 604  : ( "…ú"   U+025C Ll 1 "LATIN SMALL LETTER REVERSED OPEN E" )
 605  : ( "…ù"   U+025D Ll 1 "LATIN SMALL LETTER REVERSED OPEN E WITH HOOK" )
 606  : ( "…û"   U+025E Ll 1 "LATIN SMALL LETTER CLOSED REVERSED OPEN E" )
 607  : ( "…ü"   U+025F Ll 1 "LATIN SMALL LETTER DOTLESS J WITH STROKE" )
 608  : ( "…†"   U+0260 Ll 1 "LATIN SMALL LETTER G WITH HOOK" )
 609  : ( "…°"   U+0261 Ll 1 "LATIN SMALL LETTER SCRIPT G" )
 610  : ( "…¢"   U+0262 Ll 1 "LATIN LETTER SMALL CAPITAL G" )
 611  : ( "…£"   U+0263 Ll 1 "LATIN SMALL LETTER GAMMA" )
 612  : ( "…§"   U+0264 Ll 1 "LATIN SMALL LETTER RAMS HORN" )
 613  : ( "…•"   U+0265 Ll 1 "LATIN SMALL LETTER TURNED H" )
 614  : ( "…¶"   U+0266 Ll 1 "LATIN SMALL LETTER H WITH HOOK" )
 615  : ( "…ß"   U+0267 Ll 1 "LATIN SMALL LETTER HENG WITH HOOK" )
 616  : ( "…®"   U+0268 Ll 1 "LATIN SMALL LETTER I WITH STROKE" )
 617  : ( "…©"   U+0269 Ll 1 "LATIN SMALL LETTER IOTA" )
 618  : ( "…™"   U+026A Ll 1 "LATIN LETTER SMALL CAPITAL I" )
 619  : ( "…´"   U+026B Ll 1 "LATIN SMALL LETTER L WITH MIDDLE TILDE" )
 620  : ( "…¨"   U+026C Ll 1 "LATIN SMALL LETTER L WITH BELT" )
 621  : ( "…≠"   U+026D Ll 1 "LATIN SMALL LETTER L WITH RETROFLEX HOOK" )
 622  : ( "…Æ"   U+026E Ll 1 "LATIN SMALL LETTER LEZH" )
 623  : ( "…Ø"   U+026F Ll 1 "LATIN SMALL LETTER TURNED M" )
 624  : ( "…∞"   U+0270 Ll 1 "LATIN SMALL LETTER TURNED M WITH LONG LEG" )
 625  : ( "…±"   U+0271 Ll 1 "LATIN SMALL LETTER M WITH HOOK" )
 626  : ( "…≤"   U+0272 Ll 1 "LATIN SMALL LETTER N WITH LEFT HOOK" )
 627  : ( "…≥"   U+0273 Ll 1 "LATIN SMALL LETTER N WITH RETROFLEX HOOK" )
 628  : ( "…¥"   U+0274 Ll 1 "LATIN LETTER SMALL CAPITAL N" )
 629  : ( "…µ"   U+0275 Ll 1 "LATIN SMALL LETTER BARRED O" )
 630  : ( "…∂"   U+0276 Ll 1 "LATIN LETTER SMALL CAPITAL OE" )
 631  : ( "…∑"   U+0277 Ll 1 "LATIN SMALL LETTER CLOSED OMEGA" )
 632  : ( "…∏"   U+0278 Ll 1 "LATIN SMALL LETTER PHI" )
 633  : ( "…π"   U+0279 Ll 1 "LATIN SMALL LETTER TURNED R" )
 634  : ( "…∫"   U+027A Ll 1 "LATIN SMALL LETTER TURNED R WITH LONG LEG" )
 635  : ( "…ª"   U+027B Ll 1 "LATIN SMALL LETTER TURNED R WITH HOOK" )
 636  : ( "…º"   U+027C Ll 1 "LATIN SMALL LETTER R WITH LONG LEG" )
 637  : ( "…Ω"   U+027D Ll 1 "LATIN SMALL LETTER R WITH TAIL" )
 638  : ( "…æ"   U+027E Ll 1 "LATIN SMALL LETTER R WITH FISHHOOK" )
 639  : ( "…ø"   U+027F Ll 1 "LATIN SMALL LETTER REVERSED R WITH FISHHOOK" )
 640  : ( " Ä"   U+0280 Ll 1 "LATIN LETTER SMALL CAPITAL R" )
 641  : ( " Å"   U+0281 Ll 1 "LATIN LETTER SMALL CAPITAL INVERTED R" )
 642  : ( " Ç"   U+0282 Ll 1 "LATIN SMALL LETTER S WITH HOOK" )
 643  : ( " É"   U+0283 Ll 1 "LATIN SMALL LETTER ESH" )
 644  : ( " Ñ"   U+0284 Ll 1 "LATIN SMALL LETTER DOTLESS J WITH STROKE AND HOOK" )
 645  : ( " Ö"   U+0285 Ll 1 "LATIN SMALL LETTER SQUAT REVERSED ESH" )
 646  : ( " Ü"   U+0286 Ll 1 "LATIN SMALL LETTER ESH WITH CURL" )
 647  : ( " á"   U+0287 Ll 1 "LATIN SMALL LETTER TURNED T" )
 648  : ( " à"   U+0288 Ll 1 "LATIN SMALL LETTER T WITH RETROFLEX HOOK" )
 649  : ( " â"   U+0289 Ll 1 "LATIN SMALL LETTER U BAR" )
 650  : ( " ä"   U+028A Ll 1 "LATIN SMALL LETTER UPSILON" )
 651  : ( " ã"   U+028B Ll 1 "LATIN SMALL LETTER V WITH HOOK" )
 652  : ( " å"   U+028C Ll 1 "LATIN SMALL LETTER TURNED V" )
 653  : ( " ç"   U+028D Ll 1 "LATIN SMALL LETTER TURNED W" )
 654  : ( " é"   U+028E Ll 1 "LATIN SMALL LETTER TURNED Y" )
 655  : ( " è"   U+028F Ll 1 "LATIN LETTER SMALL CAPITAL Y" )
 656  : ( " ê"   U+0290 Ll 1 "LATIN SMALL LETTER Z WITH RETROFLEX HOOK" )
 657  : ( " ë"   U+0291 Ll 1 "LATIN SMALL LETTER Z WITH CURL" )
 658  : ( " í"   U+0292 Ll 1 "LATIN SMALL LETTER EZH" )
 659  : ( " ì"   U+0293 Ll 1 "LATIN SMALL LETTER EZH WITH CURL" )
 660  : ( " î"   U+0294 Lo 1 "LATIN LETTER GLOTTAL STOP" )
 661  : ( " ï"   U+0295 Ll 1 "LATIN LETTER PHARYNGEAL VOICED FRICATIVE" )
 662  : ( " ñ"   U+0296 Ll 1 "LATIN LETTER INVERTED GLOTTAL STOP" )
 663  : ( " ó"   U+0297 Ll 1 "LATIN LETTER STRETCHED C" )
 664  : ( " ò"   U+0298 Ll 1 "LATIN LETTER BILABIAL CLICK" )
 665  : ( " ô"   U+0299 Ll 1 "LATIN LETTER SMALL CAPITAL B" )
 666  : ( " ö"   U+029A Ll 1 "LATIN SMALL LETTER CLOSED OPEN E" )
 667  : ( " õ"   U+029B Ll 1 "LATIN LETTER SMALL CAPITAL G WITH HOOK" )
 668  : ( " ú"   U+029C Ll 1 "LATIN LETTER SMALL CAPITAL H" )
 669  : ( " ù"   U+029D Ll 1 "LATIN SMALL LETTER J WITH CROSSED-TAIL" )
 670  : ( " û"   U+029E Ll 1 "LATIN SMALL LETTER TURNED K" )
 671  : ( " ü"   U+029F Ll 1 "LATIN LETTER SMALL CAPITAL L" )
 672  : ( " †"   U+02A0 Ll 1 "LATIN SMALL LETTER Q WITH HOOK" )
 673  : ( " °"   U+02A1 Ll 1 "LATIN LETTER GLOTTAL STOP WITH STROKE" )
 674  : ( " ¢"   U+02A2 Ll 1 "LATIN LETTER REVERSED GLOTTAL STOP WITH STROKE" )
 675  : ( " £"   U+02A3 Ll 1 "LATIN SMALL LETTER DZ DIGRAPH" )
 676  : ( " §"   U+02A4 Ll 1 "LATIN SMALL LETTER DEZH DIGRAPH" )
 677  : ( " •"   U+02A5 Ll 1 "LATIN SMALL LETTER DZ DIGRAPH WITH CURL" )
 678  : ( " ¶"   U+02A6 Ll 1 "LATIN SMALL LETTER TS DIGRAPH" )
 679  : ( " ß"   U+02A7 Ll 1 "LATIN SMALL LETTER TESH DIGRAPH" )
 680  : ( " ®"   U+02A8 Ll 1 "LATIN SMALL LETTER TC DIGRAPH WITH CURL" )
 681  : ( " ©"   U+02A9 Ll 1 "LATIN SMALL LETTER FENG DIGRAPH" )
 682  : ( " ™"   U+02AA Ll 1 "LATIN SMALL LETTER LS DIGRAPH" )
 683  : ( " ´"   U+02AB Ll 1 "LATIN SMALL LETTER LZ DIGRAPH" )
 684  : ( " ¨"   U+02AC Ll 1 "LATIN LETTER BILABIAL PERCUSSIVE" )
 685  : ( " ≠"   U+02AD Ll 1 "LATIN LETTER BIDENTAL PERCUSSIVE" )
 686  : ( " Æ"   U+02AE Ll 1 "LATIN SMALL LETTER TURNED H WITH FISHHOOK" )
 687  : ( " Ø"   U+02AF Ll 1 "LATIN SMALL LETTER TURNED H WITH FISHHOOK AND TAIL" )
 688  : ( " ∞"   U+02B0 Lm 1 "MODIFIER LETTER SMALL H" )
 689  : ( " ±"   U+02B1 Lm 1 "MODIFIER LETTER SMALL H WITH HOOK" )
 690  : ( " ≤"   U+02B2 Lm 1 "MODIFIER LETTER SMALL J" )
 691  : ( " ≥"   U+02B3 Lm 1 "MODIFIER LETTER SMALL R" )
 692  : ( " ¥"   U+02B4 Lm 1 "MODIFIER LETTER SMALL TURNED R" )
 693  : ( " µ"   U+02B5 Lm 1 "MODIFIER LETTER SMALL TURNED R WITH HOOK" )
 694  : ( " ∂"   U+02B6 Lm 1 "MODIFIER LETTER SMALL CAPITAL INVERTED R" )
 695  : ( " ∑"   U+02B7 Lm 1 "MODIFIER LETTER SMALL W" )
 696  : ( " ∏"   U+02B8 Lm 1 "MODIFIER LETTER SMALL Y" )
 697  : ( " π"   U+02B9 Lm 1 "MODIFIER LETTER PRIME" )
 698  : ( " ∫"   U+02BA Lm 1 "MODIFIER LETTER DOUBLE PRIME" )
 699  : ( " ª"   U+02BB Lm 1 "MODIFIER LETTER TURNED COMMA" )
 700  : ( " º"   U+02BC Lm 1 "MODIFIER LETTER APOSTROPHE" )
 701  : ( " Ω"   U+02BD Lm 1 "MODIFIER LETTER REVERSED COMMA" )
 702  : ( " æ"   U+02BE Lm 1 "MODIFIER LETTER RIGHT HALF RING" )
 703  : ( " ø"   U+02BF Lm 1 "MODIFIER LETTER LEFT HALF RING" )
 704  : ( "ÀÄ"   U+02C0 Lm 1 "MODIFIER LETTER GLOTTAL STOP" )
 705  : ( "ÀÅ"   U+02C1 Lm 1 "MODIFIER LETTER REVERSED GLOTTAL STOP" )
 706  : ( "ÀÇ"   U+02C2 Sk 1 "MODIFIER LETTER LEFT ARROWHEAD" )
 707  : ( "ÀÉ"   U+02C3 Sk 1 "MODIFIER LETTER RIGHT ARROWHEAD" )
 708  : ( "ÀÑ"   U+02C4 Sk 1 "MODIFIER LETTER UP ARROWHEAD" )
 709  : ( "ÀÖ"   U+02C5 Sk 1 "MODIFIER LETTER DOWN ARROWHEAD" )
 710  : ( "ÀÜ"   U+02C6 Lm 1 "MODIFIER LETTER CIRCUMFLEX ACCENT" )
 711  : ( "Àá"   U+02C7 Lm 1 "CARON" )
 712  : ( "Àà"   U+02C8 Lm 1 "MODIFIER LETTER VERTICAL LINE" )
 713  : ( "Àâ"   U+02C9 Lm 1 "MODIFIER LETTER MACRON" )
 714  : ( "Àä"   U+02CA Lm 1 "MODIFIER LETTER ACUTE ACCENT" )
 715  : ( "Àã"   U+02CB Lm 1 "MODIFIER LETTER GRAVE ACCENT" )
 716  : ( "Àå"   U+02CC Lm 1 "MODIFIER LETTER LOW VERTICAL LINE" )
 717  : ( "Àç"   U+02CD Lm 1 "MODIFIER LETTER LOW MACRON" )
 718  : ( "Àé"   U+02CE Lm 1 "MODIFIER LETTER LOW GRAVE ACCENT" )
 719  : ( "Àè"   U+02CF Lm 1 "MODIFIER LETTER LOW ACUTE ACCENT" )
 720  : ( "Àê"   U+02D0 Lm 1 "MODIFIER LETTER TRIANGULAR COLON" )
 721  : ( "Àë"   U+02D1 Lm 1 "MODIFIER LETTER HALF TRIANGULAR COLON" )
 722  : ( "Àí"   U+02D2 Sk 1 "MODIFIER LETTER CENTRED RIGHT HALF RING" )
 723  : ( "Àì"   U+02D3 Sk 1 "MODIFIER LETTER CENTRED LEFT HALF RING" )
 724  : ( "Àî"   U+02D4 Sk 1 "MODIFIER LETTER UP TACK" )
 725  : ( "Àï"   U+02D5 Sk 1 "MODIFIER LETTER DOWN TACK" )
 726  : ( "Àñ"   U+02D6 Sk 1 "MODIFIER LETTER PLUS SIGN" )
 727  : ( "Àó"   U+02D7 Sk 1 "MODIFIER LETTER MINUS SIGN" )
 728  : ( "Àò"   U+02D8 Sk 1 "BREVE" )
 729  : ( "Àô"   U+02D9 Sk 1 "DOT ABOVE" )
 730  : ( "Àö"   U+02DA Sk 1 "RING ABOVE" )
 731  : ( "Àõ"   U+02DB Sk 1 "OGONEK" )
 732  : ( "Àú"   U+02DC Sk 1 "SMALL TILDE" )
 733  : ( "Àù"   U+02DD Sk 1 "DOUBLE ACUTE ACCENT" )
 734  : ( "Àû"   U+02DE Sk 1 "MODIFIER LETTER RHOTIC HOOK" )
 735  : ( "Àü"   U+02DF Sk 1 "MODIFIER LETTER CROSS ACCENT" )
 736  : ( "À†"   U+02E0 Lm 1 "MODIFIER LETTER SMALL GAMMA" )
 737  : ( "À°"   U+02E1 Lm 1 "MODIFIER LETTER SMALL L" )
 738  : ( "À¢"   U+02E2 Lm 1 "MODIFIER LETTER SMALL S" )
 739  : ( "À£"   U+02E3 Lm 1 "MODIFIER LETTER SMALL X" )
 740  : ( "À§"   U+02E4 Lm 1 "MODIFIER LETTER SMALL REVERSED GLOTTAL STOP" )
 741  : ( "À•"   U+02E5 Sk 1 "MODIFIER LETTER EXTRA-HIGH TONE BAR" )
 742  : ( "À¶"   U+02E6 Sk 1 "MODIFIER LETTER HIGH TONE BAR" )
 743  : ( "Àß"   U+02E7 Sk 1 "MODIFIER LETTER MID TONE BAR" )
 744  : ( "À®"   U+02E8 Sk 1 "MODIFIER LETTER LOW TONE BAR" )
 745  : ( "À©"   U+02E9 Sk 1 "MODIFIER LETTER EXTRA-LOW TONE BAR" )
 746  : ( "À™"   U+02EA Sk 1 "MODIFIER LETTER YIN DEPARTING TONE MARK" )
 747  : ( "À´"   U+02EB Sk 1 "MODIFIER LETTER YANG DEPARTING TONE MARK" )
 748  : ( "À¨"   U+02EC Lm 1 "MODIFIER LETTER VOICING" )
 749  : ( "À≠"   U+02ED Sk 1 "MODIFIER LETTER UNASPIRATED" )
 750  : ( "ÀÆ"   U+02EE Lm 1 "MODIFIER LETTER DOUBLE APOSTROPHE" )
 751  : ( "ÀØ"   U+02EF Sk 1 "MODIFIER LETTER LOW DOWN ARROWHEAD" )
 752  : ( "À∞"   U+02F0 Sk 1 "MODIFIER LETTER LOW UP ARROWHEAD" )
 753  : ( "À±"   U+02F1 Sk 1 "MODIFIER LETTER LOW LEFT ARROWHEAD" )
 754  : ( "À≤"   U+02F2 Sk 1 "MODIFIER LETTER LOW RIGHT ARROWHEAD" )
 755  : ( "À≥"   U+02F3 Sk 1 "MODIFIER LETTER LOW RING" )
 756  : ( "À¥"   U+02F4 Sk 1 "MODIFIER LETTER MIDDLE GRAVE ACCENT" )
 757  : ( "Àµ"   U+02F5 Sk 1 "MODIFIER LETTER MIDDLE DOUBLE GRAVE ACCENT" )
 758  : ( "À∂"   U+02F6 Sk 1 "MODIFIER LETTER MIDDLE DOUBLE ACUTE ACCENT" )
 759  : ( "À∑"   U+02F7 Sk 1 "MODIFIER LETTER LOW TILDE" )
 760  : ( "À∏"   U+02F8 Sk 1 "MODIFIER LETTER RAISED COLON" )
 761  : ( "Àπ"   U+02F9 Sk 1 "MODIFIER LETTER BEGIN HIGH TONE" )
 762  : ( "À∫"   U+02FA Sk 1 "MODIFIER LETTER END HIGH TONE" )
 763  : ( "Àª"   U+02FB Sk 1 "MODIFIER LETTER BEGIN LOW TONE" )
 764  : ( "Àº"   U+02FC Sk 1 "MODIFIER LETTER END LOW TONE" )
 765  : ( "ÀΩ"   U+02FD Sk 1 "MODIFIER LETTER SHELF" )
 766  : ( "Àæ"   U+02FE Sk 1 "MODIFIER LETTER OPEN SHELF" )
 767  : ( "Àø"   U+02FF Sk 1 "MODIFIER LETTER LOW LEFT ARROW" )
 768  : ( "ÃÄ"    U+0300 Mn 0 "COMBINING GRAVE ACCENT" )
 769  : ( "ÃÅ"    U+0301 Mn 0 "COMBINING ACUTE ACCENT" )
 770  : ( "ÃÇ"    U+0302 Mn 0 "COMBINING CIRCUMFLEX ACCENT" )
 771  : ( "ÃÉ"    U+0303 Mn 0 "COMBINING TILDE" )
 772  : ( "ÃÑ"    U+0304 Mn 0 "COMBINING MACRON" )
 773  : ( "ÃÖ"    U+0305 Mn 0 "COMBINING OVERLINE" )
 774  : ( "ÃÜ"    U+0306 Mn 0 "COMBINING BREVE" )
 775  : ( "Ãá"    U+0307 Mn 0 "COMBINING DOT ABOVE" )
 776  : ( "Ãà"    U+0308 Mn 0 "COMBINING DIAERESIS" )
 777  : ( "Ãâ"    U+0309 Mn 0 "COMBINING HOOK ABOVE" )
 778  : ( "Ãä"    U+030A Mn 0 "COMBINING RING ABOVE" )
 779  : ( "Ãã"    U+030B Mn 0 "COMBINING DOUBLE ACUTE ACCENT" )
 780  : ( "Ãå"    U+030C Mn 0 "COMBINING CARON" )
 781  : ( "Ãç"    U+030D Mn 0 "COMBINING VERTICAL LINE ABOVE" )
 782  : ( "Ãé"    U+030E Mn 0 "COMBINING DOUBLE VERTICAL LINE ABOVE" )
 783  : ( "Ãè"    U+030F Mn 0 "COMBINING DOUBLE GRAVE ACCENT" )
 784  : ( "Ãê"    U+0310 Mn 0 "COMBINING CANDRABINDU" )
 785  : ( "Ãë"    U+0311 Mn 0 "COMBINING INVERTED BREVE" )
 786  : ( "Ãí"    U+0312 Mn 0 "COMBINING TURNED COMMA ABOVE" )
 787  : ( "Ãì"    U+0313 Mn 0 "COMBINING COMMA ABOVE" )
 788  : ( "Ãî"    U+0314 Mn 0 "COMBINING REVERSED COMMA ABOVE" )
 789  : ( "Ãï"    U+0315 Mn 0 "COMBINING COMMA ABOVE RIGHT" )
 790  : ( "Ãñ"    U+0316 Mn 0 "COMBINING GRAVE ACCENT BELOW" )
 791  : ( "Ãó"    U+0317 Mn 0 "COMBINING ACUTE ACCENT BELOW" )
 792  : ( "Ãò"    U+0318 Mn 0 "COMBINING LEFT TACK BELOW" )
 793  : ( "Ãô"    U+0319 Mn 0 "COMBINING RIGHT TACK BELOW" )
 794  : ( "Ãö"    U+031A Mn 0 "COMBINING LEFT ANGLE ABOVE" )
 795  : ( "Ãõ"    U+031B Mn 0 "COMBINING HORN" )
 796  : ( "Ãú"    U+031C Mn 0 "COMBINING LEFT HALF RING BELOW" )
 797  : ( "Ãù"    U+031D Mn 0 "COMBINING UP TACK BELOW" )
 798  : ( "Ãû"    U+031E Mn 0 "COMBINING DOWN TACK BELOW" )
 799  : ( "Ãü"    U+031F Mn 0 "COMBINING PLUS SIGN BELOW" )
 800  : ( "Ã†"    U+0320 Mn 0 "COMBINING MINUS SIGN BELOW" )
 801  : ( "Ã°"    U+0321 Mn 0 "COMBINING PALATALIZED HOOK BELOW" )
 802  : ( "Ã¢"    U+0322 Mn 0 "COMBINING RETROFLEX HOOK BELOW" )
 803  : ( "Ã£"    U+0323 Mn 0 "COMBINING DOT BELOW" )
 804  : ( "Ã§"    U+0324 Mn 0 "COMBINING DIAERESIS BELOW" )
 805  : ( "Ã•"    U+0325 Mn 0 "COMBINING RING BELOW" )
 806  : ( "Ã¶"    U+0326 Mn 0 "COMBINING COMMA BELOW" )
 807  : ( "Ãß"    U+0327 Mn 0 "COMBINING CEDILLA" )
 808  : ( "Ã®"    U+0328 Mn 0 "COMBINING OGONEK" )
 809  : ( "Ã©"    U+0329 Mn 0 "COMBINING VERTICAL LINE BELOW" )
 810  : ( "Ã™"    U+032A Mn 0 "COMBINING BRIDGE BELOW" )
 811  : ( "Ã´"    U+032B Mn 0 "COMBINING INVERTED DOUBLE ARCH BELOW" )
 812  : ( "Ã¨"    U+032C Mn 0 "COMBINING CARON BELOW" )
 813  : ( "Ã≠"    U+032D Mn 0 "COMBINING CIRCUMFLEX ACCENT BELOW" )
 814  : ( "ÃÆ"    U+032E Mn 0 "COMBINING BREVE BELOW" )
 815  : ( "ÃØ"    U+032F Mn 0 "COMBINING INVERTED BREVE BELOW" )
 816  : ( "Ã∞"    U+0330 Mn 0 "COMBINING TILDE BELOW" )
 817  : ( "Ã±"    U+0331 Mn 0 "COMBINING MACRON BELOW" )
 818  : ( "Ã≤"    U+0332 Mn 0 "COMBINING LOW LINE" )
 819  : ( "Ã≥"    U+0333 Mn 0 "COMBINING DOUBLE LOW LINE" )
 820  : ( "Ã¥"    U+0334 Mn 0 "COMBINING TILDE OVERLAY" )
 821  : ( "Ãµ"    U+0335 Mn 0 "COMBINING SHORT STROKE OVERLAY" )
 822  : ( "Ã∂"    U+0336 Mn 0 "COMBINING LONG STROKE OVERLAY" )
 823  : ( "Ã∑"    U+0337 Mn 0 "COMBINING SHORT SOLIDUS OVERLAY" )
 824  : ( "Ã∏"    U+0338 Mn 0 "COMBINING LONG SOLIDUS OVERLAY" )
 825  : ( "Ãπ"    U+0339 Mn 0 "COMBINING RIGHT HALF RING BELOW" )
 826  : ( "Ã∫"    U+033A Mn 0 "COMBINING INVERTED BRIDGE BELOW" )
 827  : ( "Ãª"    U+033B Mn 0 "COMBINING SQUARE BELOW" )
 828  : ( "Ãº"    U+033C Mn 0 "COMBINING SEAGULL BELOW" )
 829  : ( "ÃΩ"    U+033D Mn 0 "COMBINING X ABOVE" )
 830  : ( "Ãæ"    U+033E Mn 0 "COMBINING VERTICAL TILDE" )
 831  : ( "Ãø"    U+033F Mn 0 "COMBINING DOUBLE OVERLINE" )
 832  : ( "ÕÄ"    U+0340 Mn 0 "COMBINING GRAVE TONE MARK" )
 833  : ( "ÕÅ"    U+0341 Mn 0 "COMBINING ACUTE TONE MARK" )
 834  : ( "ÕÇ"    U+0342 Mn 0 "COMBINING GREEK PERISPOMENI" )
 835  : ( "ÕÉ"    U+0343 Mn 0 "COMBINING GREEK KORONIS" )
 836  : ( "ÕÑ"    U+0344 Mn 0 "COMBINING GREEK DIALYTIKA TONOS" )
 837  : ( "ÕÖ"    U+0345 Mn 0 "COMBINING GREEK YPOGEGRAMMENI" )
 838  : ( "ÕÜ"    U+0346 Mn 0 "COMBINING BRIDGE ABOVE" )
 839  : ( "Õá"    U+0347 Mn 0 "COMBINING EQUALS SIGN BELOW" )
 840  : ( "Õà"    U+0348 Mn 0 "COMBINING DOUBLE VERTICAL LINE BELOW" )
 841  : ( "Õâ"    U+0349 Mn 0 "COMBINING LEFT ANGLE BELOW" )
 842  : ( "Õä"    U+034A Mn 0 "COMBINING NOT TILDE ABOVE" )
 843  : ( "Õã"    U+034B Mn 0 "COMBINING HOMOTHETIC ABOVE" )
 844  : ( "Õå"    U+034C Mn 0 "COMBINING ALMOST EQUAL TO ABOVE" )
 845  : ( "Õç"    U+034D Mn 0 "COMBINING LEFT RIGHT ARROW BELOW" )
 846  : ( "Õé"    U+034E Mn 0 "COMBINING UPWARDS ARROW BELOW" )
 847  : ( "Õè"    U+034F Mn 0 "COMBINING GRAPHEME JOINER", "CGJ" )
 848  : ( "Õê"    U+0350 Mn 0 "COMBINING RIGHT ARROWHEAD ABOVE" )
 849  : ( "Õë"    U+0351 Mn 0 "COMBINING LEFT HALF RING ABOVE" )
 850  : ( "Õí"    U+0352 Mn 0 "COMBINING FERMATA" )
 851  : ( "Õì"    U+0353 Mn 0 "COMBINING X BELOW" )
 852  : ( "Õî"    U+0354 Mn 0 "COMBINING LEFT ARROWHEAD BELOW" )
 853  : ( "Õï"    U+0355 Mn 0 "COMBINING RIGHT ARROWHEAD BELOW" )
 854  : ( "Õñ"    U+0356 Mn 0 "COMBINING RIGHT ARROWHEAD AND UP ARROWHEAD BELOW" )
 855  : ( "Õó"    U+0357 Mn 0 "COMBINING RIGHT HALF RING ABOVE" )
 856  : ( "Õò"    U+0358 Mn 0 "COMBINING DOT ABOVE RIGHT" )
 857  : ( "Õô"    U+0359 Mn 0 "COMBINING ASTERISK BELOW" )
 858  : ( "Õö"    U+035A Mn 0 "COMBINING DOUBLE RING BELOW" )
 859  : ( "Õõ"    U+035B Mn 0 "COMBINING ZIGZAG ABOVE" )
 860  : ( "Õú"    U+035C Mn 0 "COMBINING DOUBLE BREVE BELOW" )
 861  : ( "Õù"    U+035D Mn 0 "COMBINING DOUBLE BREVE" )
 862  : ( "Õû"    U+035E Mn 0 "COMBINING DOUBLE MACRON" )
 863  : ( "Õü"    U+035F Mn 0 "COMBINING DOUBLE MACRON BELOW" )
 864  : ( "Õ†"    U+0360 Mn 0 "COMBINING DOUBLE TILDE" )
 865  : ( "Õ°"    U+0361 Mn 0 "COMBINING DOUBLE INVERTED BREVE" )
 866  : ( "Õ¢"    U+0362 Mn 0 "COMBINING DOUBLE RIGHTWARDS ARROW BELOW" )
 867  : ( "Õ£"    U+0363 Mn 0 "COMBINING LATIN SMALL LETTER A" )
 868  : ( "Õ§"    U+0364 Mn 0 "COMBINING LATIN SMALL LETTER E" )
 869  : ( "Õ•"    U+0365 Mn 0 "COMBINING LATIN SMALL LETTER I" )
 870  : ( "Õ¶"    U+0366 Mn 0 "COMBINING LATIN SMALL LETTER O" )
 871  : ( "Õß"    U+0367 Mn 0 "COMBINING LATIN SMALL LETTER U" )
 872  : ( "Õ®"    U+0368 Mn 0 "COMBINING LATIN SMALL LETTER C" )
 873  : ( "Õ©"    U+0369 Mn 0 "COMBINING LATIN SMALL LETTER D" )
 874  : ( "Õ™"    U+036A Mn 0 "COMBINING LATIN SMALL LETTER H" )
 875  : ( "Õ´"    U+036B Mn 0 "COMBINING LATIN SMALL LETTER M" )
 876  : ( "Õ¨"    U+036C Mn 0 "COMBINING LATIN SMALL LETTER R" )
 877  : ( "Õ≠"    U+036D Mn 0 "COMBINING LATIN SMALL LETTER T" )
 878  : ( "ÕÆ"    U+036E Mn 0 "COMBINING LATIN SMALL LETTER V" )
 879  : ( "ÕØ"    U+036F Mn 0 "COMBINING LATIN SMALL LETTER X" )
 880  : ( "Õ∞"   U+0370 Lu 1 "GREEK CAPITAL LETTER HETA" )
 881  : ( "Õ±"   U+0371 Ll 1 "GREEK SMALL LETTER HETA" )
 882  : ( "Õ≤"   U+0372 Lu 1 "GREEK CAPITAL LETTER ARCHAIC SAMPI" )
 883  : ( "Õ≥"   U+0373 Ll 1 "GREEK SMALL LETTER ARCHAIC SAMPI" )
 884  : ( "Õ¥"   U+0374 Lm 1 "GREEK NUMERAL SIGN" )
 885  : ( "Õµ"   U+0375 Sk 1 "GREEK LOWER NUMERAL SIGN" )
 886  : ( "Õ∂"   U+0376 Lu 1 "GREEK CAPITAL LETTER PAMPHYLIAN DIGAMMA" )
 887  : ( "Õ∑"   U+0377 Ll 1 "GREEK SMALL LETTER PAMPHYLIAN DIGAMMA" )
 890  : ( "Õ∫"   U+037A Lm 1 "GREEK YPOGEGRAMMENI" )
 891  : ( "Õª"   U+037B Ll 1 "GREEK SMALL REVERSED LUNATE SIGMA SYMBOL" )
 892  : ( "Õº"   U+037C Ll 1 "GREEK SMALL DOTTED LUNATE SIGMA SYMBOL" )
 893  : ( "ÕΩ"   U+037D Ll 1 "GREEK SMALL REVERSED DOTTED LUNATE SIGMA SYMBOL" )
 894  : ( "Õæ"   U+037E Po 1 "GREEK QUESTION MARK" )
 895  : ( "Õø"   U+037F Lu 1 "GREEK CAPITAL LETTER YOT" )
 900  : ( "ŒÑ"   U+0384 Sk 1 "GREEK TONOS" )
 901  : ( "ŒÖ"   U+0385 Sk 1 "GREEK DIALYTIKA TONOS" )
 902  : ( "ŒÜ"   U+0386 Lu 1 "GREEK CAPITAL LETTER ALPHA WITH TONOS" )
 903  : ( "Œá"   U+0387 Po 1 "GREEK ANO TELEIA" )
 904  : ( "Œà"   U+0388 Lu 1 "GREEK CAPITAL LETTER EPSILON WITH TONOS" )
 905  : ( "Œâ"   U+0389 Lu 1 "GREEK CAPITAL LETTER ETA WITH TONOS" )
 906  : ( "Œä"   U+038A Lu 1 "GREEK CAPITAL LETTER IOTA WITH TONOS" )
 908  : ( "Œå"   U+038C Lu 1 "GREEK CAPITAL LETTER OMICRON WITH TONOS" )
 910  : ( "Œé"   U+038E Lu 1 "GREEK CAPITAL LETTER UPSILON WITH TONOS" )
 911  : ( "Œè"   U+038F Lu 1 "GREEK CAPITAL LETTER OMEGA WITH TONOS" )
 912  : ( "Œê"   U+0390 Ll 1 "GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS" )
 913  : ( "Œë"   U+0391 Lu 1 "GREEK CAPITAL LETTER ALPHA" )
 914  : ( "Œí"   U+0392 Lu 1 "GREEK CAPITAL LETTER BETA" )
 915  : ( "Œì"   U+0393 Lu 1 "GREEK CAPITAL LETTER GAMMA" )
 916  : ( "Œî"   U+0394 Lu 1 "GREEK CAPITAL LETTER DELTA" )
 917  : ( "Œï"   U+0395 Lu 1 "GREEK CAPITAL LETTER EPSILON" )
 918  : ( "Œñ"   U+0396 Lu 1 "GREEK CAPITAL LETTER ZETA" )
 919  : ( "Œó"   U+0397 Lu 1 "GREEK CAPITAL LETTER ETA" )
 920  : ( "Œò"   U+0398 Lu 1 "GREEK CAPITAL LETTER THETA" )
 921  : ( "Œô"   U+0399 Lu 1 "GREEK CAPITAL LETTER IOTA" )
 922  : ( "Œö"   U+039A Lu 1 "GREEK CAPITAL LETTER KAPPA" )
 923  : ( "Œõ"   U+039B Lu 1 "GREEK CAPITAL LETTER LAMDA" )
 924  : ( "Œú"   U+039C Lu 1 "GREEK CAPITAL LETTER MU" )
 925  : ( "Œù"   U+039D Lu 1 "GREEK CAPITAL LETTER NU" )
 926  : ( "Œû"   U+039E Lu 1 "GREEK CAPITAL LETTER XI" )
 927  : ( "Œü"   U+039F Lu 1 "GREEK CAPITAL LETTER OMICRON" )
 928  : ( "Œ†"   U+03A0 Lu 1 "GREEK CAPITAL LETTER PI" )
 929  : ( "Œ°"   U+03A1 Lu 1 "GREEK CAPITAL LETTER RHO" )
 931  : ( "Œ£"   U+03A3 Lu 1 "GREEK CAPITAL LETTER SIGMA" )
 932  : ( "Œ§"   U+03A4 Lu 1 "GREEK CAPITAL LETTER TAU" )
 933  : ( "Œ•"   U+03A5 Lu 1 "GREEK CAPITAL LETTER UPSILON" )
 934  : ( "Œ¶"   U+03A6 Lu 1 "GREEK CAPITAL LETTER PHI" )
 935  : ( "Œß"   U+03A7 Lu 1 "GREEK CAPITAL LETTER CHI" )
 936  : ( "Œ®"   U+03A8 Lu 1 "GREEK CAPITAL LETTER PSI" )
 937  : ( "Œ©"   U+03A9 Lu 1 "GREEK CAPITAL LETTER OMEGA" )
 938  : ( "Œ™"   U+03AA Lu 1 "GREEK CAPITAL LETTER IOTA WITH DIALYTIKA" )
 939  : ( "Œ´"   U+03AB Lu 1 "GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA" )
 940  : ( "Œ¨"   U+03AC Ll 1 "GREEK SMALL LETTER ALPHA WITH TONOS" )
 941  : ( "Œ≠"   U+03AD Ll 1 "GREEK SMALL LETTER EPSILON WITH TONOS" )
 942  : ( "ŒÆ"   U+03AE Ll 1 "GREEK SMALL LETTER ETA WITH TONOS" )
 943  : ( "ŒØ"   U+03AF Ll 1 "GREEK SMALL LETTER IOTA WITH TONOS" )
 944  : ( "Œ∞"   U+03B0 Ll 1 "GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS" )
 945  : ( "Œ±"   U+03B1 Ll 1 "GREEK SMALL LETTER ALPHA" )
 946  : ( "Œ≤"   U+03B2 Ll 1 "GREEK SMALL LETTER BETA" )
 947  : ( "Œ≥"   U+03B3 Ll 1 "GREEK SMALL LETTER GAMMA" )
 948  : ( "Œ¥"   U+03B4 Ll 1 "GREEK SMALL LETTER DELTA" )
 949  : ( "Œµ"   U+03B5 Ll 1 "GREEK SMALL LETTER EPSILON" )
 950  : ( "Œ∂"   U+03B6 Ll 1 "GREEK SMALL LETTER ZETA" )
 951  : ( "Œ∑"   U+03B7 Ll 1 "GREEK SMALL LETTER ETA" )
 952  : ( "Œ∏"   U+03B8 Ll 1 "GREEK SMALL LETTER THETA" )
 953  : ( "Œπ"   U+03B9 Ll 1 "GREEK SMALL LETTER IOTA" )
 954  : ( "Œ∫"   U+03BA Ll 1 "GREEK SMALL LETTER KAPPA" )
 955  : ( "Œª"   U+03BB Ll 1 "GREEK SMALL LETTER LAMDA" )
 956  : ( "Œº"   U+03BC Ll 1 "GREEK SMALL LETTER MU" )
 957  : ( "ŒΩ"   U+03BD Ll 1 "GREEK SMALL LETTER NU" )
 958  : ( "Œæ"   U+03BE Ll 1 "GREEK SMALL LETTER XI" )
 959  : ( "Œø"   U+03BF Ll 1 "GREEK SMALL LETTER OMICRON" )
 960  : ( "œÄ"   U+03C0 Ll 1 "GREEK SMALL LETTER PI" )
 961  : ( "œÅ"   U+03C1 Ll 1 "GREEK SMALL LETTER RHO" )
 962  : ( "œÇ"   U+03C2 Ll 1 "GREEK SMALL LETTER FINAL SIGMA" )
 963  : ( "œÉ"   U+03C3 Ll 1 "GREEK SMALL LETTER SIGMA" )
 964  : ( "œÑ"   U+03C4 Ll 1 "GREEK SMALL LETTER TAU" )
 965  : ( "œÖ"   U+03C5 Ll 1 "GREEK SMALL LETTER UPSILON" )
 966  : ( "œÜ"   U+03C6 Ll 1 "GREEK SMALL LETTER PHI" )
 967  : ( "œá"   U+03C7 Ll 1 "GREEK SMALL LETTER CHI" )
 968  : ( "œà"   U+03C8 Ll 1 "GREEK SMALL LETTER PSI" )
 969  : ( "œâ"   U+03C9 Ll 1 "GREEK SMALL LETTER OMEGA" )
 970  : ( "œä"   U+03CA Ll 1 "GREEK SMALL LETTER IOTA WITH DIALYTIKA" )
 971  : ( "œã"   U+03CB Ll 1 "GREEK SMALL LETTER UPSILON WITH DIALYTIKA" )
 972  : ( "œå"   U+03CC Ll 1 "GREEK SMALL LETTER OMICRON WITH TONOS" )
 973  : ( "œç"   U+03CD Ll 1 "GREEK SMALL LETTER UPSILON WITH TONOS" )
 974  : ( "œé"   U+03CE Ll 1 "GREEK SMALL LETTER OMEGA WITH TONOS" )
 975  : ( "œè"   U+03CF Lu 1 "GREEK CAPITAL KAI SYMBOL" )
 976  : ( "œê"   U+03D0 Ll 1 "GREEK BETA SYMBOL" )
 977  : ( "œë"   U+03D1 Ll 1 "GREEK THETA SYMBOL" )
 978  : ( "œí"   U+03D2 Lu 1 "GREEK UPSILON WITH HOOK SYMBOL" )
 979  : ( "œì"   U+03D3 Lu 1 "GREEK UPSILON WITH ACUTE AND HOOK SYMBOL" )
 980  : ( "œî"   U+03D4 Lu 1 "GREEK UPSILON WITH DIAERESIS AND HOOK SYMBOL" )
 981  : ( "œï"   U+03D5 Ll 1 "GREEK PHI SYMBOL" )
 982  : ( "œñ"   U+03D6 Ll 1 "GREEK PI SYMBOL" )
 983  : ( "œó"   U+03D7 Ll 1 "GREEK KAI SYMBOL" )
 984  : ( "œò"   U+03D8 Lu 1 "GREEK LETTER ARCHAIC KOPPA" )
 985  : ( "œô"   U+03D9 Ll 1 "GREEK SMALL LETTER ARCHAIC KOPPA" )
 986  : ( "œö"   U+03DA Lu 1 "GREEK LETTER STIGMA" )
 987  : ( "œõ"   U+03DB Ll 1 "GREEK SMALL LETTER STIGMA" )
 988  : ( "œú"   U+03DC Lu 1 "GREEK LETTER DIGAMMA" )
 989  : ( "œù"   U+03DD Ll 1 "GREEK SMALL LETTER DIGAMMA" )
 990  : ( "œû"   U+03DE Lu 1 "GREEK LETTER KOPPA" )
 991  : ( "œü"   U+03DF Ll 1 "GREEK SMALL LETTER KOPPA" )
 992  : ( "œ†"   U+03E0 Lu 1 "GREEK LETTER SAMPI" )
 993  : ( "œ°"   U+03E1 Ll 1 "GREEK SMALL LETTER SAMPI" )
 994  : ( "œ¢"   U+03E2 Lu 1 "COPTIC CAPITAL LETTER SHEI" )
 995  : ( "œ£"   U+03E3 Ll 1 "COPTIC SMALL LETTER SHEI" )
 996  : ( "œ§"   U+03E4 Lu 1 "COPTIC CAPITAL LETTER FEI" )
 997  : ( "œ•"   U+03E5 Ll 1 "COPTIC SMALL LETTER FEI" )
 998  : ( "œ¶"   U+03E6 Lu 1 "COPTIC CAPITAL LETTER KHEI" )
 999  : ( "œß"   U+03E7 Ll 1 "COPTIC SMALL LETTER KHEI" )
 1000 : ( "œ®"   U+03E8 Lu 1 "COPTIC CAPITAL LETTER HORI" )
 1001 : ( "œ©"   U+03E9 Ll 1 "COPTIC SMALL LETTER HORI" )
 1002 : ( "œ™"   U+03EA Lu 1 "COPTIC CAPITAL LETTER GANGIA" )
 1003 : ( "œ´"   U+03EB Ll 1 "COPTIC SMALL LETTER GANGIA" )
 1004 : ( "œ¨"   U+03EC Lu 1 "COPTIC CAPITAL LETTER SHIMA" )
 1005 : ( "œ≠"   U+03ED Ll 1 "COPTIC SMALL LETTER SHIMA" )
 1006 : ( "œÆ"   U+03EE Lu 1 "COPTIC CAPITAL LETTER DEI" )
 1007 : ( "œØ"   U+03EF Ll 1 "COPTIC SMALL LETTER DEI" )
 1008 : ( "œ∞"   U+03F0 Ll 1 "GREEK KAPPA SYMBOL" )
...

/*
Add character intervals.
.UnicodeCharacterInterval
    codepointFrom
    codepointTo
    name
    isExpanded
*/
ooRexx> .unicode~characterIntervals==
an UnicodeCharacterIntervalSupplier 
 1  : (U+3400..U+4DBF "CJK UNIFIED IDEOGRAPH-*" 6591 characters)
 2  : (U+4E00..U+9FFF "CJK UNIFIED IDEOGRAPH-*" 20991 characters)
 3  : (U+F900..U+FA6D "CJK COMPATIBILITY IDEOGRAPH-*" 365 characters)
 4  : (U+FA70..U+FAD9 "CJK COMPATIBILITY IDEOGRAPH-*" 105 characters)
 5  : (U+17000..U+187F7 "TANGUT IDEOGRAPH-*" 6135 characters)
 6  : (U+18B00..U+18CD5 "KHITAN SMALL SCRIPT CHARACTER-*" 469 characters)
 7  : (U+18D00..U+18D08 "TANGUT IDEOGRAPH-*" 8 characters)
 8  : (U+1B170..U+1B2FB "NUSHU CHARACTER-*" 395 characters)
 9  : (U+20000..U+2A6DF "CJK UNIFIED IDEOGRAPH-*" 42719 characters)
 10 : (U+2A700..U+2B739 "CJK UNIFIED IDEOGRAPH-*" 4153 characters)
 11 : (U+2B740..U+2B81D "CJK UNIFIED IDEOGRAPH-*" 221 characters)
 12 : (U+2B820..U+2CEA1 "CJK UNIFIED IDEOGRAPH-*" 5761 characters)
 13 : (U+2CEB0..U+2EBE0 "CJK UNIFIED IDEOGRAPH-*" 7472 characters)
 14 : (U+2EBF0..U+2EE5D "CJK UNIFIED IDEOGRAPH-*" 621 characters)
 15 : (U+2F800..U+2FA1D "CJK COMPATIBILITY IDEOGRAPH-*" 541 characters)
 16 : (U+30000..U+3134A "CJK UNIFIED IDEOGRAPH-*" 4938 characters)
 17 : (U+31350..U+323AF "CJK UNIFIED IDEOGRAPH-*" 4191 characters)


-- Informations about Unicode:
-- Remove dataDirectory because the value is different between Windows and Macos/Linux
ooRexx> .Unicode~informations~~remove("dataDirectory")=
a Directory (12 items)
'characterIntervals'                 : (an UnicodeCharacterIntervalSupplier count=17 notExpanded:17 intervals, 105693 characters)
'characters'                         : (an UnicodeCharacterSupplier count=44189 size=918000)
'maxCodepoint'                       :  1114111
'memorizeTranscodings'               :  0
'memorizeTransformations'            :  0
'systemIsLittleEndian'               :  1
'totalCharacterNameAliases'          :  473
'totalCharactersLoaded'              :  149813
'totalIntervalCharacters'            :  105693
'totalIntervalCharactersNotExpanded' :  105693
'unckeckedConversionToString'        :  0
'version'                            : '15.1.0'


-- ===============================================================================
-- 2021 September 13, updated September 22

/*
Add character informations.

The loading of the character names is optional.
By default, they are not loaded.
From ooRexxShell, execute: call loadUnicodeCharacterNames
By default, the character intervals are not expanded.
From ooRexxShell, execute: call expandUnicodeCharacterIntervals

The other character properties are always loaded (provided by utf8proc)

.Unicode
    characters          --> supplier of UnicodeCharacter
    character(index)    --> UnicodeCharacter (index can be a loose matching name (UAX44-LM2) or a codepoint)
    characterIntervals  --> supplier of UnicodeCharacterInterval

.UnicodeCharacter
    codepoint       --> integer -1..1114111
    name            --> string
    aliases         --> array of .UnicodeAlias

    bidiClass       --> enum 1, 2, 3, ...
    bidiClassName   --> enum 'L', 'LRE', 'LRO', ...
    boundClass      --> enum 0, 1, 2, ...
    boundClassName  --> enum 'START', 'OTHER', 'CR', ...
    category        --> enum 0, 1, 2, ...
    categoryName    --> enum 'Cn', 'Lu', 'Ll', ...
    charWidth       --> integer
    combiningClass  --> integer 0..254
    controlBoundary --> boolean
    decompType      --> enum 0, 1, 2, ...
    decompTypeName  --> enum '<none>', '<font>', '<nobreak>, ...
    ignorable       --> boolean

Examples:
*/
-- All the Unicode characters (sparse array).
ooRexx> .unicode~characters==
an UnicodeCharacterSupplier 
 0    : ( ""    U+0000 Cc 0 "", "NULL", "NUL" )
 1    : ( ""    U+0001 Cc 0 "", "START OF HEADING", "SOH" )
 2    : ( ""    U+0002 Cc 0 "", "START OF TEXT", "STX" )
 3    : ( ""    U+0003 Cc 0 "", "END OF TEXT", "ETX" )
 4    : ( ""    U+0004 Cc 0 "", "END OF TRANSMISSION", "EOT" )
 5    : ( ""    U+0005 Cc 0 "", "ENQUIRY", "ENQ" )
 6    : ( ""    U+0006 Cc 0 "", "ACKNOWLEDGE", "ACK" )
 7    : ( ""    U+0007 Cc 0 "", "ALERT", "BEL" )
 8    : ( ""    U+0008 Cc 0 "", "BACKSPACE", "BS" )
 9    : ( ""    U+0009 Cc 0 "", "CHARACTER TABULATION", "HORIZONTAL TABULATION", "HT", "TAB" )
 10   : ( ""    U+000A Cc 0 "", "LINE FEED", "NEW LINE", "END OF LINE", "LF", "NL", "EOL" )
 11   : ( ""    U+000B Cc 0 "", "LINE TABULATION", "VERTICAL TABULATION", "VT" )
 12   : ( ""    U+000C Cc 0 "", "FORM FEED", "FF" )
 13   : ( ""    U+000D Cc 0 "", "CARRIAGE RETURN", "CR" )
 14   : ( ""    U+000E Cc 0 "", "SHIFT OUT", "LOCKING-SHIFT ONE", "SO" )
 15   : ( ""    U+000F Cc 0 "", "SHIFT IN", "LOCKING-SHIFT ZERO", "SI" )
 16   : ( ""    U+0010 Cc 0 "", "DATA LINK ESCAPE", "DLE" )
 17   : ( ""    U+0011 Cc 0 "", "DEVICE CONTROL ONE", "DC1" )
 18   : ( ""    U+0012 Cc 0 "", "DEVICE CONTROL TWO", "DC2" )
 19   : ( ""    U+0013 Cc 0 "", "DEVICE CONTROL THREE", "DC3" )
 20   : ( ""    U+0014 Cc 0 "", "DEVICE CONTROL FOUR", "DC4" )
 21   : ( ""    U+0015 Cc 0 "", "NEGATIVE ACKNOWLEDGE", "NAK" )
 22   : ( ""    U+0016 Cc 0 "", "SYNCHRONOUS IDLE", "SYN" )
 23   : ( ""    U+0017 Cc 0 "", "END OF TRANSMISSION BLOCK", "ETB" )
 24   : ( ""    U+0018 Cc 0 "", "CANCEL", "CAN" )
 25   : ( ""    U+0019 Cc 0 "", "END OF MEDIUM", "EOM", "EM" )
 26   : ( ""    U+001A Cc 0 "", "SUBSTITUTE", "SUB" )
 27   : ( ""    U+001B Cc 0 "", "ESCAPE", "ESC" )
 28   : ( ""    U+001C Cc 0 "", "INFORMATION SEPARATOR FOUR", "FILE SEPARATOR", "FS" )
 29   : ( ""    U+001D Cc 0 "", "INFORMATION SEPARATOR THREE", "GROUP SEPARATOR", "GS" )
 30   : ( ""    U+001E Cc 0 "", "INFORMATION SEPARATOR TWO", "RECORD SEPARATOR", "RS" )
 31   : ( ""    U+001F Cc 0 "", "INFORMATION SEPARATOR ONE", "UNIT SEPARATOR", "US" )
 32   : ( " "   U+0020 Zs 1 "SPACE", "SP" )
 33   : ( "!"   U+0021 Po 1 "EXCLAMATION MARK" )
 34   : ( """   U+0022 Po 1 "QUOTATION MARK" )
 35   : ( "#"   U+0023 Po 1 "NUMBER SIGN" )
 36   : ( "$"   U+0024 Sc 1 "DOLLAR SIGN" )
 37   : ( "%"   U+0025 Po 1 "PERCENT SIGN" )
 38   : ( "&"   U+0026 Po 1 "AMPERSAND" )
 39   : ( "'"   U+0027 Po 1 "APOSTROPHE" )
 40   : ( "("   U+0028 Ps 1 "LEFT PARENTHESIS" )
 41   : ( ")"   U+0029 Pe 1 "RIGHT PARENTHESIS" )
 42   : ( "*"   U+002A Po 1 "ASTERISK" )
 43   : ( "+"   U+002B Sm 1 "PLUS SIGN" )
 44   : ( ","   U+002C Po 1 "COMMA" )
 45   : ( "-"   U+002D Pd 1 "HYPHEN-MINUS" )
 46   : ( "."   U+002E Po 1 "FULL STOP" )
 47   : ( "/"   U+002F Po 1 "SOLIDUS" )
 48   : ( "0"   U+0030 Nd 1 "DIGIT ZERO" )
 49   : ( "1"   U+0031 Nd 1 "DIGIT ONE" )
 50   : ( "2"   U+0032 Nd 1 "DIGIT TWO" )
 51   : ( "3"   U+0033 Nd 1 "DIGIT THREE" )
 52   : ( "4"   U+0034 Nd 1 "DIGIT FOUR" )
 53   : ( "5"   U+0035 Nd 1 "DIGIT FIVE" )
 54   : ( "6"   U+0036 Nd 1 "DIGIT SIX" )
 55   : ( "7"   U+0037 Nd 1 "DIGIT SEVEN" )
 56   : ( "8"   U+0038 Nd 1 "DIGIT EIGHT" )
 57   : ( "9"   U+0039 Nd 1 "DIGIT NINE" )
 58   : ( ":"   U+003A Po 1 "COLON" )
 59   : ( ";"   U+003B Po 1 "SEMICOLON" )
 60   : ( "<"   U+003C Sm 1 "LESS-THAN SIGN" )
 61   : ( "="   U+003D Sm 1 "EQUALS SIGN" )
 62   : ( ">"   U+003E Sm 1 "GREATER-THAN SIGN" )
 63   : ( "?"   U+003F Po 1 "QUESTION MARK" )
 64   : ( "@"   U+0040 Po 1 "COMMERCIAL AT" )
 65   : ( "A"   U+0041 Lu 1 "LATIN CAPITAL LETTER A" )
 66   : ( "B"   U+0042 Lu 1 "LATIN CAPITAL LETTER B" )
 67   : ( "C"   U+0043 Lu 1 "LATIN CAPITAL LETTER C" )
 68   : ( "D"   U+0044 Lu 1 "LATIN CAPITAL LETTER D" )
 69   : ( "E"   U+0045 Lu 1 "LATIN CAPITAL LETTER E" )
 70   : ( "F"   U+0046 Lu 1 "LATIN CAPITAL LETTER F" )
 71   : ( "G"   U+0047 Lu 1 "LATIN CAPITAL LETTER G" )
 72   : ( "H"   U+0048 Lu 1 "LATIN CAPITAL LETTER H" )
 73   : ( "I"   U+0049 Lu 1 "LATIN CAPITAL LETTER I" )
 74   : ( "J"   U+004A Lu 1 "LATIN CAPITAL LETTER J" )
 75   : ( "K"   U+004B Lu 1 "LATIN CAPITAL LETTER K" )
 76   : ( "L"   U+004C Lu 1 "LATIN CAPITAL LETTER L" )
 77   : ( "M"   U+004D Lu 1 "LATIN CAPITAL LETTER M" )
 78   : ( "N"   U+004E Lu 1 "LATIN CAPITAL LETTER N" )
 79   : ( "O"   U+004F Lu 1 "LATIN CAPITAL LETTER O" )
 80   : ( "P"   U+0050 Lu 1 "LATIN CAPITAL LETTER P" )
 81   : ( "Q"   U+0051 Lu 1 "LATIN CAPITAL LETTER Q" )
 82   : ( "R"   U+0052 Lu 1 "LATIN CAPITAL LETTER R" )
 83   : ( "S"   U+0053 Lu 1 "LATIN CAPITAL LETTER S" )
 84   : ( "T"   U+0054 Lu 1 "LATIN CAPITAL LETTER T" )
 85   : ( "U"   U+0055 Lu 1 "LATIN CAPITAL LETTER U" )
 86   : ( "V"   U+0056 Lu 1 "LATIN CAPITAL LETTER V" )
 87   : ( "W"   U+0057 Lu 1 "LATIN CAPITAL LETTER W" )
 88   : ( "X"   U+0058 Lu 1 "LATIN CAPITAL LETTER X" )
 89   : ( "Y"   U+0059 Lu 1 "LATIN CAPITAL LETTER Y" )
 90   : ( "Z"   U+005A Lu 1 "LATIN CAPITAL LETTER Z" )
 91   : ( "["   U+005B Ps 1 "LEFT SQUARE BRACKET" )
 92   : ( "\"   U+005C Po 1 "REVERSE SOLIDUS" )
 93   : ( "]"   U+005D Pe 1 "RIGHT SQUARE BRACKET" )
 94   : ( "^"   U+005E Sk 1 "CIRCUMFLEX ACCENT" )
 95   : ( "_"   U+005F Pc 1 "LOW LINE" )
 96   : ( "`"   U+0060 Sk 1 "GRAVE ACCENT" )
 97   : ( "a"   U+0061 Ll 1 "LATIN SMALL LETTER A" )
 98   : ( "b"   U+0062 Ll 1 "LATIN SMALL LETTER B" )
 99   : ( "c"   U+0063 Ll 1 "LATIN SMALL LETTER C" )
 100  : ( "d"   U+0064 Ll 1 "LATIN SMALL LETTER D" )
 101  : ( "e"   U+0065 Ll 1 "LATIN SMALL LETTER E" )
 102  : ( "f"   U+0066 Ll 1 "LATIN SMALL LETTER F" )
 103  : ( "g"   U+0067 Ll 1 "LATIN SMALL LETTER G" )
 104  : ( "h"   U+0068 Ll 1 "LATIN SMALL LETTER H" )
 105  : ( "i"   U+0069 Ll 1 "LATIN SMALL LETTER I" )
 106  : ( "j"   U+006A Ll 1 "LATIN SMALL LETTER J" )
 107  : ( "k"   U+006B Ll 1 "LATIN SMALL LETTER K" )
 108  : ( "l"   U+006C Ll 1 "LATIN SMALL LETTER L" )
 109  : ( "m"   U+006D Ll 1 "LATIN SMALL LETTER M" )
 110  : ( "n"   U+006E Ll 1 "LATIN SMALL LETTER N" )
 111  : ( "o"   U+006F Ll 1 "LATIN SMALL LETTER O" )
 112  : ( "p"   U+0070 Ll 1 "LATIN SMALL LETTER P" )
 113  : ( "q"   U+0071 Ll 1 "LATIN SMALL LETTER Q" )
 114  : ( "r"   U+0072 Ll 1 "LATIN SMALL LETTER R" )
 115  : ( "s"   U+0073 Ll 1 "LATIN SMALL LETTER S" )
 116  : ( "t"   U+0074 Ll 1 "LATIN SMALL LETTER T" )
 117  : ( "u"   U+0075 Ll 1 "LATIN SMALL LETTER U" )
 118  : ( "v"   U+0076 Ll 1 "LATIN SMALL LETTER V" )
 119  : ( "w"   U+0077 Ll 1 "LATIN SMALL LETTER W" )
 120  : ( "x"   U+0078 Ll 1 "LATIN SMALL LETTER X" )
 121  : ( "y"   U+0079 Ll 1 "LATIN SMALL LETTER Y" )
 122  : ( "z"   U+007A Ll 1 "LATIN SMALL LETTER Z" )
 123  : ( "{"   U+007B Ps 1 "LEFT CURLY BRACKET" )
 124  : ( "|"   U+007C Sm 1 "VERTICAL LINE" )
 125  : ( "}"   U+007D Pe 1 "RIGHT CURLY BRACKET" )
 126  : ( "~"   U+007E Sm 1 "TILDE" )
 127  : ( ""    U+007F Cc 0 "", "DELETE", "DEL" )
 128  : ( "¬Ä"    U+0080 Cc 0 "", "PADDING CHARACTER", "PAD" )
 129  : ( "¬Å"    U+0081 Cc 0 "", "HIGH OCTET PRESET", "HOP" )
 130  : ( "¬Ç"    U+0082 Cc 0 "", "BREAK PERMITTED HERE", "BPH" )
 131  : ( "¬É"    U+0083 Cc 0 "", "NO BREAK HERE", "NBH" )
 132  : ( "¬Ñ"    U+0084 Cc 0 "", "INDEX", "IND" )
 133  : ( "¬Ö"    U+0085 Cc 0 "", "NEXT LINE", "NEL" )
 134  : ( "¬Ü"    U+0086 Cc 0 "", "START OF SELECTED AREA", "SSA" )
 135  : ( "¬á"    U+0087 Cc 0 "", "END OF SELECTED AREA", "ESA" )
 136  : ( "¬à"    U+0088 Cc 0 "", "CHARACTER TABULATION SET", "HORIZONTAL TABULATION SET", "HTS" )
 137  : ( "¬â"    U+0089 Cc 0 "", "CHARACTER TABULATION WITH JUSTIFICATION", "HORIZONTAL TABULATION WITH JUSTIFICATION", "HTJ" )
 138  : ( "¬ä"    U+008A Cc 0 "", "LINE TABULATION SET", "VERTICAL TABULATION SET", "VTS" )
 139  : ( "¬ã"    U+008B Cc 0 "", "PARTIAL LINE FORWARD", "PARTIAL LINE DOWN", "PLD" )
 140  : ( "¬å"    U+008C Cc 0 "", "PARTIAL LINE BACKWARD", "PARTIAL LINE UP", "PLU" )
 141  : ( "¬ç"    U+008D Cc 0 "", "REVERSE LINE FEED", "REVERSE INDEX", "RI" )
 142  : ( "¬é"    U+008E Cc 0 "", "SINGLE SHIFT TWO", "SINGLE-SHIFT-2", "SS2" )
 143  : ( "¬è"    U+008F Cc 0 "", "SINGLE SHIFT THREE", "SINGLE-SHIFT-3", "SS3" )
 144  : ( "¬ê"    U+0090 Cc 0 "", "DEVICE CONTROL STRING", "DCS" )
 145  : ( "¬ë"    U+0091 Cc 0 "", "PRIVATE USE ONE", "PRIVATE USE-1", "PU1" )
 146  : ( "¬í"    U+0092 Cc 0 "", "PRIVATE USE TWO", "PRIVATE USE-2", "PU2" )
 147  : ( "¬ì"    U+0093 Cc 0 "", "SET TRANSMIT STATE", "STS" )
 148  : ( "¬î"    U+0094 Cc 0 "", "CANCEL CHARACTER", "CCH" )
 149  : ( "¬ï"    U+0095 Cc 0 "", "MESSAGE WAITING", "MW" )
 150  : ( "¬ñ"    U+0096 Cc 0 "", "START OF GUARDED AREA", "START OF PROTECTED AREA", "SPA" )
 151  : ( "¬ó"    U+0097 Cc 0 "", "END OF GUARDED AREA", "END OF PROTECTED AREA", "EPA" )
 152  : ( "¬ò"    U+0098 Cc 0 "", "START OF STRING", "SOS" )
 153  : ( "¬ô"    U+0099 Cc 0 "", "SINGLE GRAPHIC CHARACTER INTRODUCER", "SGC" )
 154  : ( "¬ö"    U+009A Cc 0 "", "SINGLE CHARACTER INTRODUCER", "SCI" )
 155  : ( "¬õ"    U+009B Cc 0 "", "CONTROL SEQUENCE INTRODUCER", "CSI" )
 156  : ( "¬ú"    U+009C Cc 0 "", "STRING TERMINATOR", "ST" )
 157  : ( "¬ù"    U+009D Cc 0 "", "OPERATING SYSTEM COMMAND", "OSC" )
 158  : ( "¬û"    U+009E Cc 0 "", "PRIVACY MESSAGE", "PM" )
 159  : ( "¬ü"    U+009F Cc 0 "", "APPLICATION PROGRAM COMMAND", "APC" )
 160  : ( "¬†"   U+00A0 Zs 1 "NO-BREAK SPACE", "NBSP" )
 161  : ( "¬°"   U+00A1 Po 1 "INVERTED EXCLAMATION MARK" )
 162  : ( "¬¢"   U+00A2 Sc 1 "CENT SIGN" )
 163  : ( "¬£"   U+00A3 Sc 1 "POUND SIGN" )
 164  : ( "¬§"   U+00A4 Sc 1 "CURRENCY SIGN" )
 165  : ( "¬•"   U+00A5 Sc 1 "YEN SIGN" )
 166  : ( "¬¶"   U+00A6 So 1 "BROKEN BAR" )
 167  : ( "¬ß"   U+00A7 Po 1 "SECTION SIGN" )
 168  : ( "¬®"   U+00A8 Sk 1 "DIAERESIS" )
 169  : ( "¬©"   U+00A9 So 1 "COPYRIGHT SIGN" )
 170  : ( "¬™"   U+00AA Lo 1 "FEMININE ORDINAL INDICATOR" )
 171  : ( "¬´"   U+00AB Pi 1 "LEFT-POINTING DOUBLE ANGLE QUOTATION MARK" )
 172  : ( "¬¨"   U+00AC Sm 1 "NOT SIGN" )
 173  : ( "¬≠"   U+00AD Cf 1 "SOFT HYPHEN", "SHY" )
 174  : ( "¬Æ"   U+00AE So 1 "REGISTERED SIGN" )
 175  : ( "¬Ø"   U+00AF Sk 1 "MACRON" )
 176  : ( "¬∞"   U+00B0 So 1 "DEGREE SIGN" )
 177  : ( "¬±"   U+00B1 Sm 1 "PLUS-MINUS SIGN" )
 178  : ( "¬≤"   U+00B2 No 1 "SUPERSCRIPT TWO" )
 179  : ( "¬≥"   U+00B3 No 1 "SUPERSCRIPT THREE" )
 180  : ( "¬¥"   U+00B4 Sk 1 "ACUTE ACCENT" )
 181  : ( "¬µ"   U+00B5 Ll 1 "MICRO SIGN" )
 182  : ( "¬∂"   U+00B6 Po 1 "PILCROW SIGN" )
 183  : ( "¬∑"   U+00B7 Po 1 "MIDDLE DOT" )
 184  : ( "¬∏"   U+00B8 Sk 1 "CEDILLA" )
 185  : ( "¬π"   U+00B9 No 1 "SUPERSCRIPT ONE" )
 186  : ( "¬∫"   U+00BA Lo 1 "MASCULINE ORDINAL INDICATOR" )
 187  : ( "¬ª"   U+00BB Pf 1 "RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK" )
 188  : ( "¬º"   U+00BC No 1 "VULGAR FRACTION ONE QUARTER" )
 189  : ( "¬Ω"   U+00BD No 1 "VULGAR FRACTION ONE HALF" )
 190  : ( "¬æ"   U+00BE No 1 "VULGAR FRACTION THREE QUARTERS" )
 191  : ( "¬ø"   U+00BF Po 1 "INVERTED QUESTION MARK" )
 192  : ( "√Ä"   U+00C0 Lu 1 "LATIN CAPITAL LETTER A WITH GRAVE" )
 193  : ( "√Å"   U+00C1 Lu 1 "LATIN CAPITAL LETTER A WITH ACUTE" )
 194  : ( "√Ç"   U+00C2 Lu 1 "LATIN CAPITAL LETTER A WITH CIRCUMFLEX" )
 195  : ( "√É"   U+00C3 Lu 1 "LATIN CAPITAL LETTER A WITH TILDE" )
 196  : ( "√Ñ"   U+00C4 Lu 1 "LATIN CAPITAL LETTER A WITH DIAERESIS" )
 197  : ( "√Ö"   U+00C5 Lu 1 "LATIN CAPITAL LETTER A WITH RING ABOVE" )
 198  : ( "√Ü"   U+00C6 Lu 1 "LATIN CAPITAL LETTER AE" )
 199  : ( "√á"   U+00C7 Lu 1 "LATIN CAPITAL LETTER C WITH CEDILLA" )
 200  : ( "√à"   U+00C8 Lu 1 "LATIN CAPITAL LETTER E WITH GRAVE" )
 201  : ( "√â"   U+00C9 Lu 1 "LATIN CAPITAL LETTER E WITH ACUTE" )
 202  : ( "√ä"   U+00CA Lu 1 "LATIN CAPITAL LETTER E WITH CIRCUMFLEX" )
 203  : ( "√ã"   U+00CB Lu 1 "LATIN CAPITAL LETTER E WITH DIAERESIS" )
 204  : ( "√å"   U+00CC Lu 1 "LATIN CAPITAL LETTER I WITH GRAVE" )
 205  : ( "√ç"   U+00CD Lu 1 "LATIN CAPITAL LETTER I WITH ACUTE" )
 206  : ( "√é"   U+00CE Lu 1 "LATIN CAPITAL LETTER I WITH CIRCUMFLEX" )
 207  : ( "√è"   U+00CF Lu 1 "LATIN CAPITAL LETTER I WITH DIAERESIS" )
 208  : ( "√ê"   U+00D0 Lu 1 "LATIN CAPITAL LETTER ETH" )
 209  : ( "√ë"   U+00D1 Lu 1 "LATIN CAPITAL LETTER N WITH TILDE" )
 210  : ( "√í"   U+00D2 Lu 1 "LATIN CAPITAL LETTER O WITH GRAVE" )
 211  : ( "√ì"   U+00D3 Lu 1 "LATIN CAPITAL LETTER O WITH ACUTE" )
 212  : ( "√î"   U+00D4 Lu 1 "LATIN CAPITAL LETTER O WITH CIRCUMFLEX" )
 213  : ( "√ï"   U+00D5 Lu 1 "LATIN CAPITAL LETTER O WITH TILDE" )
 214  : ( "√ñ"   U+00D6 Lu 1 "LATIN CAPITAL LETTER O WITH DIAERESIS" )
 215  : ( "√ó"   U+00D7 Sm 1 "MULTIPLICATION SIGN" )
 216  : ( "√ò"   U+00D8 Lu 1 "LATIN CAPITAL LETTER O WITH STROKE" )
 217  : ( "√ô"   U+00D9 Lu 1 "LATIN CAPITAL LETTER U WITH GRAVE" )
 218  : ( "√ö"   U+00DA Lu 1 "LATIN CAPITAL LETTER U WITH ACUTE" )
 219  : ( "√õ"   U+00DB Lu 1 "LATIN CAPITAL LETTER U WITH CIRCUMFLEX" )
 220  : ( "√ú"   U+00DC Lu 1 "LATIN CAPITAL LETTER U WITH DIAERESIS" )
 221  : ( "√ù"   U+00DD Lu 1 "LATIN CAPITAL LETTER Y WITH ACUTE" )
 222  : ( "√û"   U+00DE Lu 1 "LATIN CAPITAL LETTER THORN" )
 223  : ( "√ü"   U+00DF Ll 1 "LATIN SMALL LETTER SHARP S" )
 224  : ( "√†"   U+00E0 Ll 1 "LATIN SMALL LETTER A WITH GRAVE" )
 225  : ( "√°"   U+00E1 Ll 1 "LATIN SMALL LETTER A WITH ACUTE" )
 226  : ( "√¢"   U+00E2 Ll 1 "LATIN SMALL LETTER A WITH CIRCUMFLEX" )
 227  : ( "√£"   U+00E3 Ll 1 "LATIN SMALL LETTER A WITH TILDE" )
 228  : ( "√§"   U+00E4 Ll 1 "LATIN SMALL LETTER A WITH DIAERESIS" )
 229  : ( "√•"   U+00E5 Ll 1 "LATIN SMALL LETTER A WITH RING ABOVE" )
 230  : ( "√¶"   U+00E6 Ll 1 "LATIN SMALL LETTER AE" )
 231  : ( "√ß"   U+00E7 Ll 1 "LATIN SMALL LETTER C WITH CEDILLA" )
 232  : ( "√®"   U+00E8 Ll 1 "LATIN SMALL LETTER E WITH GRAVE" )
 233  : ( "√©"   U+00E9 Ll 1 "LATIN SMALL LETTER E WITH ACUTE" )
 234  : ( "√™"   U+00EA Ll 1 "LATIN SMALL LETTER E WITH CIRCUMFLEX" )
 235  : ( "√´"   U+00EB Ll 1 "LATIN SMALL LETTER E WITH DIAERESIS" )
 236  : ( "√¨"   U+00EC Ll 1 "LATIN SMALL LETTER I WITH GRAVE" )
 237  : ( "√≠"   U+00ED Ll 1 "LATIN SMALL LETTER I WITH ACUTE" )
 238  : ( "√Æ"   U+00EE Ll 1 "LATIN SMALL LETTER I WITH CIRCUMFLEX" )
 239  : ( "√Ø"   U+00EF Ll 1 "LATIN SMALL LETTER I WITH DIAERESIS" )
 240  : ( "√∞"   U+00F0 Ll 1 "LATIN SMALL LETTER ETH" )
 241  : ( "√±"   U+00F1 Ll 1 "LATIN SMALL LETTER N WITH TILDE" )
 242  : ( "√≤"   U+00F2 Ll 1 "LATIN SMALL LETTER O WITH GRAVE" )
 243  : ( "√≥"   U+00F3 Ll 1 "LATIN SMALL LETTER O WITH ACUTE" )
 244  : ( "√¥"   U+00F4 Ll 1 "LATIN SMALL LETTER O WITH CIRCUMFLEX" )
 245  : ( "√µ"   U+00F5 Ll 1 "LATIN SMALL LETTER O WITH TILDE" )
 246  : ( "√∂"   U+00F6 Ll 1 "LATIN SMALL LETTER O WITH DIAERESIS" )
 247  : ( "√∑"   U+00F7 Sm 1 "DIVISION SIGN" )
 248  : ( "√∏"   U+00F8 Ll 1 "LATIN SMALL LETTER O WITH STROKE" )
 249  : ( "√π"   U+00F9 Ll 1 "LATIN SMALL LETTER U WITH GRAVE" )
 250  : ( "√∫"   U+00FA Ll 1 "LATIN SMALL LETTER U WITH ACUTE" )
 251  : ( "√ª"   U+00FB Ll 1 "LATIN SMALL LETTER U WITH CIRCUMFLEX" )
 252  : ( "√º"   U+00FC Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS" )
 253  : ( "√Ω"   U+00FD Ll 1 "LATIN SMALL LETTER Y WITH ACUTE" )
 254  : ( "√æ"   U+00FE Ll 1 "LATIN SMALL LETTER THORN" )
 255  : ( "√ø"   U+00FF Ll 1 "LATIN SMALL LETTER Y WITH DIAERESIS" )
 256  : ( "ƒÄ"   U+0100 Lu 1 "LATIN CAPITAL LETTER A WITH MACRON" )
 257  : ( "ƒÅ"   U+0101 Ll 1 "LATIN SMALL LETTER A WITH MACRON" )
 258  : ( "ƒÇ"   U+0102 Lu 1 "LATIN CAPITAL LETTER A WITH BREVE" )
 259  : ( "ƒÉ"   U+0103 Ll 1 "LATIN SMALL LETTER A WITH BREVE" )
 260  : ( "ƒÑ"   U+0104 Lu 1 "LATIN CAPITAL LETTER A WITH OGONEK" )
 261  : ( "ƒÖ"   U+0105 Ll 1 "LATIN SMALL LETTER A WITH OGONEK" )
 262  : ( "ƒÜ"   U+0106 Lu 1 "LATIN CAPITAL LETTER C WITH ACUTE" )
 263  : ( "ƒá"   U+0107 Ll 1 "LATIN SMALL LETTER C WITH ACUTE" )
 264  : ( "ƒà"   U+0108 Lu 1 "LATIN CAPITAL LETTER C WITH CIRCUMFLEX" )
 265  : ( "ƒâ"   U+0109 Ll 1 "LATIN SMALL LETTER C WITH CIRCUMFLEX" )
 266  : ( "ƒä"   U+010A Lu 1 "LATIN CAPITAL LETTER C WITH DOT ABOVE" )
 267  : ( "ƒã"   U+010B Ll 1 "LATIN SMALL LETTER C WITH DOT ABOVE" )
 268  : ( "ƒå"   U+010C Lu 1 "LATIN CAPITAL LETTER C WITH CARON" )
 269  : ( "ƒç"   U+010D Ll 1 "LATIN SMALL LETTER C WITH CARON" )
 270  : ( "ƒé"   U+010E Lu 1 "LATIN CAPITAL LETTER D WITH CARON" )
 271  : ( "ƒè"   U+010F Ll 1 "LATIN SMALL LETTER D WITH CARON" )
 272  : ( "ƒê"   U+0110 Lu 1 "LATIN CAPITAL LETTER D WITH STROKE" )
 273  : ( "ƒë"   U+0111 Ll 1 "LATIN SMALL LETTER D WITH STROKE" )
 274  : ( "ƒí"   U+0112 Lu 1 "LATIN CAPITAL LETTER E WITH MACRON" )
 275  : ( "ƒì"   U+0113 Ll 1 "LATIN SMALL LETTER E WITH MACRON" )
 276  : ( "ƒî"   U+0114 Lu 1 "LATIN CAPITAL LETTER E WITH BREVE" )
 277  : ( "ƒï"   U+0115 Ll 1 "LATIN SMALL LETTER E WITH BREVE" )
 278  : ( "ƒñ"   U+0116 Lu 1 "LATIN CAPITAL LETTER E WITH DOT ABOVE" )
 279  : ( "ƒó"   U+0117 Ll 1 "LATIN SMALL LETTER E WITH DOT ABOVE" )
 280  : ( "ƒò"   U+0118 Lu 1 "LATIN CAPITAL LETTER E WITH OGONEK" )
 281  : ( "ƒô"   U+0119 Ll 1 "LATIN SMALL LETTER E WITH OGONEK" )
 282  : ( "ƒö"   U+011A Lu 1 "LATIN CAPITAL LETTER E WITH CARON" )
 283  : ( "ƒõ"   U+011B Ll 1 "LATIN SMALL LETTER E WITH CARON" )
 284  : ( "ƒú"   U+011C Lu 1 "LATIN CAPITAL LETTER G WITH CIRCUMFLEX" )
 285  : ( "ƒù"   U+011D Ll 1 "LATIN SMALL LETTER G WITH CIRCUMFLEX" )
 286  : ( "ƒû"   U+011E Lu 1 "LATIN CAPITAL LETTER G WITH BREVE" )
 287  : ( "ƒü"   U+011F Ll 1 "LATIN SMALL LETTER G WITH BREVE" )
 288  : ( "ƒ†"   U+0120 Lu 1 "LATIN CAPITAL LETTER G WITH DOT ABOVE" )
 289  : ( "ƒ°"   U+0121 Ll 1 "LATIN SMALL LETTER G WITH DOT ABOVE" )
 290  : ( "ƒ¢"   U+0122 Lu 1 "LATIN CAPITAL LETTER G WITH CEDILLA" )
 291  : ( "ƒ£"   U+0123 Ll 1 "LATIN SMALL LETTER G WITH CEDILLA" )
 292  : ( "ƒ§"   U+0124 Lu 1 "LATIN CAPITAL LETTER H WITH CIRCUMFLEX" )
 293  : ( "ƒ•"   U+0125 Ll 1 "LATIN SMALL LETTER H WITH CIRCUMFLEX" )
 294  : ( "ƒ¶"   U+0126 Lu 1 "LATIN CAPITAL LETTER H WITH STROKE" )
 295  : ( "ƒß"   U+0127 Ll 1 "LATIN SMALL LETTER H WITH STROKE" )
 296  : ( "ƒ®"   U+0128 Lu 1 "LATIN CAPITAL LETTER I WITH TILDE" )
 297  : ( "ƒ©"   U+0129 Ll 1 "LATIN SMALL LETTER I WITH TILDE" )
 298  : ( "ƒ™"   U+012A Lu 1 "LATIN CAPITAL LETTER I WITH MACRON" )
 299  : ( "ƒ´"   U+012B Ll 1 "LATIN SMALL LETTER I WITH MACRON" )
 300  : ( "ƒ¨"   U+012C Lu 1 "LATIN CAPITAL LETTER I WITH BREVE" )
 301  : ( "ƒ≠"   U+012D Ll 1 "LATIN SMALL LETTER I WITH BREVE" )
 302  : ( "ƒÆ"   U+012E Lu 1 "LATIN CAPITAL LETTER I WITH OGONEK" )
 303  : ( "ƒØ"   U+012F Ll 1 "LATIN SMALL LETTER I WITH OGONEK" )
 304  : ( "ƒ∞"   U+0130 Lu 1 "LATIN CAPITAL LETTER I WITH DOT ABOVE" )
 305  : ( "ƒ±"   U+0131 Ll 1 "LATIN SMALL LETTER DOTLESS I" )
 306  : ( "ƒ≤"   U+0132 Lu 1 "LATIN CAPITAL LIGATURE IJ" )
 307  : ( "ƒ≥"   U+0133 Ll 1 "LATIN SMALL LIGATURE IJ" )
 308  : ( "ƒ¥"   U+0134 Lu 1 "LATIN CAPITAL LETTER J WITH CIRCUMFLEX" )
 309  : ( "ƒµ"   U+0135 Ll 1 "LATIN SMALL LETTER J WITH CIRCUMFLEX" )
 310  : ( "ƒ∂"   U+0136 Lu 1 "LATIN CAPITAL LETTER K WITH CEDILLA" )
 311  : ( "ƒ∑"   U+0137 Ll 1 "LATIN SMALL LETTER K WITH CEDILLA" )
 312  : ( "ƒ∏"   U+0138 Ll 1 "LATIN SMALL LETTER KRA" )
 313  : ( "ƒπ"   U+0139 Lu 1 "LATIN CAPITAL LETTER L WITH ACUTE" )
 314  : ( "ƒ∫"   U+013A Ll 1 "LATIN SMALL LETTER L WITH ACUTE" )
 315  : ( "ƒª"   U+013B Lu 1 "LATIN CAPITAL LETTER L WITH CEDILLA" )
 316  : ( "ƒº"   U+013C Ll 1 "LATIN SMALL LETTER L WITH CEDILLA" )
 317  : ( "ƒΩ"   U+013D Lu 1 "LATIN CAPITAL LETTER L WITH CARON" )
 318  : ( "ƒæ"   U+013E Ll 1 "LATIN SMALL LETTER L WITH CARON" )
 319  : ( "ƒø"   U+013F Lu 1 "LATIN CAPITAL LETTER L WITH MIDDLE DOT" )
 320  : ( "≈Ä"   U+0140 Ll 1 "LATIN SMALL LETTER L WITH MIDDLE DOT" )
 321  : ( "≈Å"   U+0141 Lu 1 "LATIN CAPITAL LETTER L WITH STROKE" )
 322  : ( "≈Ç"   U+0142 Ll 1 "LATIN SMALL LETTER L WITH STROKE" )
 323  : ( "≈É"   U+0143 Lu 1 "LATIN CAPITAL LETTER N WITH ACUTE" )
 324  : ( "≈Ñ"   U+0144 Ll 1 "LATIN SMALL LETTER N WITH ACUTE" )
 325  : ( "≈Ö"   U+0145 Lu 1 "LATIN CAPITAL LETTER N WITH CEDILLA" )
 326  : ( "≈Ü"   U+0146 Ll 1 "LATIN SMALL LETTER N WITH CEDILLA" )
 327  : ( "≈á"   U+0147 Lu 1 "LATIN CAPITAL LETTER N WITH CARON" )
 328  : ( "≈à"   U+0148 Ll 1 "LATIN SMALL LETTER N WITH CARON" )
 329  : ( "≈â"   U+0149 Ll 1 "LATIN SMALL LETTER N PRECEDED BY APOSTROPHE" )
 330  : ( "≈ä"   U+014A Lu 1 "LATIN CAPITAL LETTER ENG" )
 331  : ( "≈ã"   U+014B Ll 1 "LATIN SMALL LETTER ENG" )
 332  : ( "≈å"   U+014C Lu 1 "LATIN CAPITAL LETTER O WITH MACRON" )
 333  : ( "≈ç"   U+014D Ll 1 "LATIN SMALL LETTER O WITH MACRON" )
 334  : ( "≈é"   U+014E Lu 1 "LATIN CAPITAL LETTER O WITH BREVE" )
 335  : ( "≈è"   U+014F Ll 1 "LATIN SMALL LETTER O WITH BREVE" )
 336  : ( "≈ê"   U+0150 Lu 1 "LATIN CAPITAL LETTER O WITH DOUBLE ACUTE" )
 337  : ( "≈ë"   U+0151 Ll 1 "LATIN SMALL LETTER O WITH DOUBLE ACUTE" )
 338  : ( "≈í"   U+0152 Lu 1 "LATIN CAPITAL LIGATURE OE" )
 339  : ( "≈ì"   U+0153 Ll 1 "LATIN SMALL LIGATURE OE" )
 340  : ( "≈î"   U+0154 Lu 1 "LATIN CAPITAL LETTER R WITH ACUTE" )
 341  : ( "≈ï"   U+0155 Ll 1 "LATIN SMALL LETTER R WITH ACUTE" )
 342  : ( "≈ñ"   U+0156 Lu 1 "LATIN CAPITAL LETTER R WITH CEDILLA" )
 343  : ( "≈ó"   U+0157 Ll 1 "LATIN SMALL LETTER R WITH CEDILLA" )
 344  : ( "≈ò"   U+0158 Lu 1 "LATIN CAPITAL LETTER R WITH CARON" )
 345  : ( "≈ô"   U+0159 Ll 1 "LATIN SMALL LETTER R WITH CARON" )
 346  : ( "≈ö"   U+015A Lu 1 "LATIN CAPITAL LETTER S WITH ACUTE" )
 347  : ( "≈õ"   U+015B Ll 1 "LATIN SMALL LETTER S WITH ACUTE" )
 348  : ( "≈ú"   U+015C Lu 1 "LATIN CAPITAL LETTER S WITH CIRCUMFLEX" )
 349  : ( "≈ù"   U+015D Ll 1 "LATIN SMALL LETTER S WITH CIRCUMFLEX" )
 350  : ( "≈û"   U+015E Lu 1 "LATIN CAPITAL LETTER S WITH CEDILLA" )
 351  : ( "≈ü"   U+015F Ll 1 "LATIN SMALL LETTER S WITH CEDILLA" )
 352  : ( "≈†"   U+0160 Lu 1 "LATIN CAPITAL LETTER S WITH CARON" )
 353  : ( "≈°"   U+0161 Ll 1 "LATIN SMALL LETTER S WITH CARON" )
 354  : ( "≈¢"   U+0162 Lu 1 "LATIN CAPITAL LETTER T WITH CEDILLA" )
 355  : ( "≈£"   U+0163 Ll 1 "LATIN SMALL LETTER T WITH CEDILLA" )
 356  : ( "≈§"   U+0164 Lu 1 "LATIN CAPITAL LETTER T WITH CARON" )
 357  : ( "≈•"   U+0165 Ll 1 "LATIN SMALL LETTER T WITH CARON" )
 358  : ( "≈¶"   U+0166 Lu 1 "LATIN CAPITAL LETTER T WITH STROKE" )
 359  : ( "≈ß"   U+0167 Ll 1 "LATIN SMALL LETTER T WITH STROKE" )
 360  : ( "≈®"   U+0168 Lu 1 "LATIN CAPITAL LETTER U WITH TILDE" )
 361  : ( "≈©"   U+0169 Ll 1 "LATIN SMALL LETTER U WITH TILDE" )
 362  : ( "≈™"   U+016A Lu 1 "LATIN CAPITAL LETTER U WITH MACRON" )
 363  : ( "≈´"   U+016B Ll 1 "LATIN SMALL LETTER U WITH MACRON" )
 364  : ( "≈¨"   U+016C Lu 1 "LATIN CAPITAL LETTER U WITH BREVE" )
 365  : ( "≈≠"   U+016D Ll 1 "LATIN SMALL LETTER U WITH BREVE" )
 366  : ( "≈Æ"   U+016E Lu 1 "LATIN CAPITAL LETTER U WITH RING ABOVE" )
 367  : ( "≈Ø"   U+016F Ll 1 "LATIN SMALL LETTER U WITH RING ABOVE" )
 368  : ( "≈∞"   U+0170 Lu 1 "LATIN CAPITAL LETTER U WITH DOUBLE ACUTE" )
 369  : ( "≈±"   U+0171 Ll 1 "LATIN SMALL LETTER U WITH DOUBLE ACUTE" )
 370  : ( "≈≤"   U+0172 Lu 1 "LATIN CAPITAL LETTER U WITH OGONEK" )
 371  : ( "≈≥"   U+0173 Ll 1 "LATIN SMALL LETTER U WITH OGONEK" )
 372  : ( "≈¥"   U+0174 Lu 1 "LATIN CAPITAL LETTER W WITH CIRCUMFLEX" )
 373  : ( "≈µ"   U+0175 Ll 1 "LATIN SMALL LETTER W WITH CIRCUMFLEX" )
 374  : ( "≈∂"   U+0176 Lu 1 "LATIN CAPITAL LETTER Y WITH CIRCUMFLEX" )
 375  : ( "≈∑"   U+0177 Ll 1 "LATIN SMALL LETTER Y WITH CIRCUMFLEX" )
 376  : ( "≈∏"   U+0178 Lu 1 "LATIN CAPITAL LETTER Y WITH DIAERESIS" )
 377  : ( "≈π"   U+0179 Lu 1 "LATIN CAPITAL LETTER Z WITH ACUTE" )
 378  : ( "≈∫"   U+017A Ll 1 "LATIN SMALL LETTER Z WITH ACUTE" )
 379  : ( "≈ª"   U+017B Lu 1 "LATIN CAPITAL LETTER Z WITH DOT ABOVE" )
 380  : ( "≈º"   U+017C Ll 1 "LATIN SMALL LETTER Z WITH DOT ABOVE" )
 381  : ( "≈Ω"   U+017D Lu 1 "LATIN CAPITAL LETTER Z WITH CARON" )
 382  : ( "≈æ"   U+017E Ll 1 "LATIN SMALL LETTER Z WITH CARON" )
 383  : ( "≈ø"   U+017F Ll 1 "LATIN SMALL LETTER LONG S" )
 384  : ( "∆Ä"   U+0180 Ll 1 "LATIN SMALL LETTER B WITH STROKE" )
 385  : ( "∆Å"   U+0181 Lu 1 "LATIN CAPITAL LETTER B WITH HOOK" )
 386  : ( "∆Ç"   U+0182 Lu 1 "LATIN CAPITAL LETTER B WITH TOPBAR" )
 387  : ( "∆É"   U+0183 Ll 1 "LATIN SMALL LETTER B WITH TOPBAR" )
 388  : ( "∆Ñ"   U+0184 Lu 1 "LATIN CAPITAL LETTER TONE SIX" )
 389  : ( "∆Ö"   U+0185 Ll 1 "LATIN SMALL LETTER TONE SIX" )
 390  : ( "∆Ü"   U+0186 Lu 1 "LATIN CAPITAL LETTER OPEN O" )
 391  : ( "∆á"   U+0187 Lu 1 "LATIN CAPITAL LETTER C WITH HOOK" )
 392  : ( "∆à"   U+0188 Ll 1 "LATIN SMALL LETTER C WITH HOOK" )
 393  : ( "∆â"   U+0189 Lu 1 "LATIN CAPITAL LETTER AFRICAN D" )
 394  : ( "∆ä"   U+018A Lu 1 "LATIN CAPITAL LETTER D WITH HOOK" )
 395  : ( "∆ã"   U+018B Lu 1 "LATIN CAPITAL LETTER D WITH TOPBAR" )
 396  : ( "∆å"   U+018C Ll 1 "LATIN SMALL LETTER D WITH TOPBAR" )
 397  : ( "∆ç"   U+018D Ll 1 "LATIN SMALL LETTER TURNED DELTA" )
 398  : ( "∆é"   U+018E Lu 1 "LATIN CAPITAL LETTER REVERSED E" )
 399  : ( "∆è"   U+018F Lu 1 "LATIN CAPITAL LETTER SCHWA" )
 400  : ( "∆ê"   U+0190 Lu 1 "LATIN CAPITAL LETTER OPEN E" )
 401  : ( "∆ë"   U+0191 Lu 1 "LATIN CAPITAL LETTER F WITH HOOK" )
 402  : ( "∆í"   U+0192 Ll 1 "LATIN SMALL LETTER F WITH HOOK" )
 403  : ( "∆ì"   U+0193 Lu 1 "LATIN CAPITAL LETTER G WITH HOOK" )
 404  : ( "∆î"   U+0194 Lu 1 "LATIN CAPITAL LETTER GAMMA" )
 405  : ( "∆ï"   U+0195 Ll 1 "LATIN SMALL LETTER HV" )
 406  : ( "∆ñ"   U+0196 Lu 1 "LATIN CAPITAL LETTER IOTA" )
 407  : ( "∆ó"   U+0197 Lu 1 "LATIN CAPITAL LETTER I WITH STROKE" )
 408  : ( "∆ò"   U+0198 Lu 1 "LATIN CAPITAL LETTER K WITH HOOK" )
 409  : ( "∆ô"   U+0199 Ll 1 "LATIN SMALL LETTER K WITH HOOK" )
 410  : ( "∆ö"   U+019A Ll 1 "LATIN SMALL LETTER L WITH BAR" )
 411  : ( "∆õ"   U+019B Ll 1 "LATIN SMALL LETTER LAMBDA WITH STROKE" )
 412  : ( "∆ú"   U+019C Lu 1 "LATIN CAPITAL LETTER TURNED M" )
 413  : ( "∆ù"   U+019D Lu 1 "LATIN CAPITAL LETTER N WITH LEFT HOOK" )
 414  : ( "∆û"   U+019E Ll 1 "LATIN SMALL LETTER N WITH LONG RIGHT LEG" )
 415  : ( "∆ü"   U+019F Lu 1 "LATIN CAPITAL LETTER O WITH MIDDLE TILDE" )
 416  : ( "∆†"   U+01A0 Lu 1 "LATIN CAPITAL LETTER O WITH HORN" )
 417  : ( "∆°"   U+01A1 Ll 1 "LATIN SMALL LETTER O WITH HORN" )
 418  : ( "∆¢"   U+01A2 Lu 1 "LATIN CAPITAL LETTER OI", "LATIN CAPITAL LETTER GHA" )
 419  : ( "∆£"   U+01A3 Ll 1 "LATIN SMALL LETTER OI", "LATIN SMALL LETTER GHA" )
 420  : ( "∆§"   U+01A4 Lu 1 "LATIN CAPITAL LETTER P WITH HOOK" )
 421  : ( "∆•"   U+01A5 Ll 1 "LATIN SMALL LETTER P WITH HOOK" )
 422  : ( "∆¶"   U+01A6 Lu 1 "LATIN LETTER YR" )
 423  : ( "∆ß"   U+01A7 Lu 1 "LATIN CAPITAL LETTER TONE TWO" )
 424  : ( "∆®"   U+01A8 Ll 1 "LATIN SMALL LETTER TONE TWO" )
 425  : ( "∆©"   U+01A9 Lu 1 "LATIN CAPITAL LETTER ESH" )
 426  : ( "∆™"   U+01AA Ll 1 "LATIN LETTER REVERSED ESH LOOP" )
 427  : ( "∆´"   U+01AB Ll 1 "LATIN SMALL LETTER T WITH PALATAL HOOK" )
 428  : ( "∆¨"   U+01AC Lu 1 "LATIN CAPITAL LETTER T WITH HOOK" )
 429  : ( "∆≠"   U+01AD Ll 1 "LATIN SMALL LETTER T WITH HOOK" )
 430  : ( "∆Æ"   U+01AE Lu 1 "LATIN CAPITAL LETTER T WITH RETROFLEX HOOK" )
 431  : ( "∆Ø"   U+01AF Lu 1 "LATIN CAPITAL LETTER U WITH HORN" )
 432  : ( "∆∞"   U+01B0 Ll 1 "LATIN SMALL LETTER U WITH HORN" )
 433  : ( "∆±"   U+01B1 Lu 1 "LATIN CAPITAL LETTER UPSILON" )
 434  : ( "∆≤"   U+01B2 Lu 1 "LATIN CAPITAL LETTER V WITH HOOK" )
 435  : ( "∆≥"   U+01B3 Lu 1 "LATIN CAPITAL LETTER Y WITH HOOK" )
 436  : ( "∆¥"   U+01B4 Ll 1 "LATIN SMALL LETTER Y WITH HOOK" )
 437  : ( "∆µ"   U+01B5 Lu 1 "LATIN CAPITAL LETTER Z WITH STROKE" )
 438  : ( "∆∂"   U+01B6 Ll 1 "LATIN SMALL LETTER Z WITH STROKE" )
 439  : ( "∆∑"   U+01B7 Lu 1 "LATIN CAPITAL LETTER EZH" )
 440  : ( "∆∏"   U+01B8 Lu 1 "LATIN CAPITAL LETTER EZH REVERSED" )
 441  : ( "∆π"   U+01B9 Ll 1 "LATIN SMALL LETTER EZH REVERSED" )
 442  : ( "∆∫"   U+01BA Ll 1 "LATIN SMALL LETTER EZH WITH TAIL" )
 443  : ( "∆ª"   U+01BB Lo 1 "LATIN LETTER TWO WITH STROKE" )
 444  : ( "∆º"   U+01BC Lu 1 "LATIN CAPITAL LETTER TONE FIVE" )
 445  : ( "∆Ω"   U+01BD Ll 1 "LATIN SMALL LETTER TONE FIVE" )
 446  : ( "∆æ"   U+01BE Ll 1 "LATIN LETTER INVERTED GLOTTAL STOP WITH STROKE" )
 447  : ( "∆ø"   U+01BF Ll 1 "LATIN LETTER WYNN" )
 448  : ( "«Ä"   U+01C0 Lo 1 "LATIN LETTER DENTAL CLICK" )
 449  : ( "«Å"   U+01C1 Lo 1 "LATIN LETTER LATERAL CLICK" )
 450  : ( "«Ç"   U+01C2 Lo 1 "LATIN LETTER ALVEOLAR CLICK" )
 451  : ( "«É"   U+01C3 Lo 1 "LATIN LETTER RETROFLEX CLICK" )
 452  : ( "«Ñ"   U+01C4 Lu 1 "LATIN CAPITAL LETTER DZ WITH CARON" )
 453  : ( "«Ö"   U+01C5 Lt 1 "LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON" )
 454  : ( "«Ü"   U+01C6 Ll 1 "LATIN SMALL LETTER DZ WITH CARON" )
 455  : ( "«á"   U+01C7 Lu 1 "LATIN CAPITAL LETTER LJ" )
 456  : ( "«à"   U+01C8 Lt 1 "LATIN CAPITAL LETTER L WITH SMALL LETTER J" )
 457  : ( "«â"   U+01C9 Ll 1 "LATIN SMALL LETTER LJ" )
 458  : ( "«ä"   U+01CA Lu 1 "LATIN CAPITAL LETTER NJ" )
 459  : ( "«ã"   U+01CB Lt 1 "LATIN CAPITAL LETTER N WITH SMALL LETTER J" )
 460  : ( "«å"   U+01CC Ll 1 "LATIN SMALL LETTER NJ" )
 461  : ( "«ç"   U+01CD Lu 1 "LATIN CAPITAL LETTER A WITH CARON" )
 462  : ( "«é"   U+01CE Ll 1 "LATIN SMALL LETTER A WITH CARON" )
 463  : ( "«è"   U+01CF Lu 1 "LATIN CAPITAL LETTER I WITH CARON" )
 464  : ( "«ê"   U+01D0 Ll 1 "LATIN SMALL LETTER I WITH CARON" )
 465  : ( "«ë"   U+01D1 Lu 1 "LATIN CAPITAL LETTER O WITH CARON" )
 466  : ( "«í"   U+01D2 Ll 1 "LATIN SMALL LETTER O WITH CARON" )
 467  : ( "«ì"   U+01D3 Lu 1 "LATIN CAPITAL LETTER U WITH CARON" )
 468  : ( "«î"   U+01D4 Ll 1 "LATIN SMALL LETTER U WITH CARON" )
 469  : ( "«ï"   U+01D5 Lu 1 "LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON" )
 470  : ( "«ñ"   U+01D6 Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS AND MACRON" )
 471  : ( "«ó"   U+01D7 Lu 1 "LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE" )
 472  : ( "«ò"   U+01D8 Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE" )
 473  : ( "«ô"   U+01D9 Lu 1 "LATIN CAPITAL LETTER U WITH DIAERESIS AND CARON" )
 474  : ( "«ö"   U+01DA Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS AND CARON" )
 475  : ( "«õ"   U+01DB Lu 1 "LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE" )
 476  : ( "«ú"   U+01DC Ll 1 "LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE" )
 477  : ( "«ù"   U+01DD Ll 1 "LATIN SMALL LETTER TURNED E" )
 478  : ( "«û"   U+01DE Lu 1 "LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON" )
 479  : ( "«ü"   U+01DF Ll 1 "LATIN SMALL LETTER A WITH DIAERESIS AND MACRON" )
 480  : ( "«†"   U+01E0 Lu 1 "LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON" )
 481  : ( "«°"   U+01E1 Ll 1 "LATIN SMALL LETTER A WITH DOT ABOVE AND MACRON" )
 482  : ( "«¢"   U+01E2 Lu 1 "LATIN CAPITAL LETTER AE WITH MACRON" )
 483  : ( "«£"   U+01E3 Ll 1 "LATIN SMALL LETTER AE WITH MACRON" )
 484  : ( "«§"   U+01E4 Lu 1 "LATIN CAPITAL LETTER G WITH STROKE" )
 485  : ( "«•"   U+01E5 Ll 1 "LATIN SMALL LETTER G WITH STROKE" )
 486  : ( "«¶"   U+01E6 Lu 1 "LATIN CAPITAL LETTER G WITH CARON" )
 487  : ( "«ß"   U+01E7 Ll 1 "LATIN SMALL LETTER G WITH CARON" )
 488  : ( "«®"   U+01E8 Lu 1 "LATIN CAPITAL LETTER K WITH CARON" )
 489  : ( "«©"   U+01E9 Ll 1 "LATIN SMALL LETTER K WITH CARON" )
 490  : ( "«™"   U+01EA Lu 1 "LATIN CAPITAL LETTER O WITH OGONEK" )
 491  : ( "«´"   U+01EB Ll 1 "LATIN SMALL LETTER O WITH OGONEK" )
 492  : ( "«¨"   U+01EC Lu 1 "LATIN CAPITAL LETTER O WITH OGONEK AND MACRON" )
 493  : ( "«≠"   U+01ED Ll 1 "LATIN SMALL LETTER O WITH OGONEK AND MACRON" )
 494  : ( "«Æ"   U+01EE Lu 1 "LATIN CAPITAL LETTER EZH WITH CARON" )
 495  : ( "«Ø"   U+01EF Ll 1 "LATIN SMALL LETTER EZH WITH CARON" )
 496  : ( "«∞"   U+01F0 Ll 1 "LATIN SMALL LETTER J WITH CARON" )
 497  : ( "«±"   U+01F1 Lu 1 "LATIN CAPITAL LETTER DZ" )
 498  : ( "«≤"   U+01F2 Lt 1 "LATIN CAPITAL LETTER D WITH SMALL LETTER Z" )
 499  : ( "«≥"   U+01F3 Ll 1 "LATIN SMALL LETTER DZ" )
 500  : ( "«¥"   U+01F4 Lu 1 "LATIN CAPITAL LETTER G WITH ACUTE" )
 501  : ( "«µ"   U+01F5 Ll 1 "LATIN SMALL LETTER G WITH ACUTE" )
 502  : ( "«∂"   U+01F6 Lu 1 "LATIN CAPITAL LETTER HWAIR" )
 503  : ( "«∑"   U+01F7 Lu 1 "LATIN CAPITAL LETTER WYNN" )
 504  : ( "«∏"   U+01F8 Lu 1 "LATIN CAPITAL LETTER N WITH GRAVE" )
 505  : ( "«π"   U+01F9 Ll 1 "LATIN SMALL LETTER N WITH GRAVE" )
 506  : ( "«∫"   U+01FA Lu 1 "LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE" )
 507  : ( "«ª"   U+01FB Ll 1 "LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE" )
 508  : ( "«º"   U+01FC Lu 1 "LATIN CAPITAL LETTER AE WITH ACUTE" )
 509  : ( "«Ω"   U+01FD Ll 1 "LATIN SMALL LETTER AE WITH ACUTE" )
 510  : ( "«æ"   U+01FE Lu 1 "LATIN CAPITAL LETTER O WITH STROKE AND ACUTE" )
 511  : ( "«ø"   U+01FF Ll 1 "LATIN SMALL LETTER O WITH STROKE AND ACUTE" )
 512  : ( "»Ä"   U+0200 Lu 1 "LATIN CAPITAL LETTER A WITH DOUBLE GRAVE" )
 513  : ( "»Å"   U+0201 Ll 1 "LATIN SMALL LETTER A WITH DOUBLE GRAVE" )
 514  : ( "»Ç"   U+0202 Lu 1 "LATIN CAPITAL LETTER A WITH INVERTED BREVE" )
 515  : ( "»É"   U+0203 Ll 1 "LATIN SMALL LETTER A WITH INVERTED BREVE" )
 516  : ( "»Ñ"   U+0204 Lu 1 "LATIN CAPITAL LETTER E WITH DOUBLE GRAVE" )
 517  : ( "»Ö"   U+0205 Ll 1 "LATIN SMALL LETTER E WITH DOUBLE GRAVE" )
 518  : ( "»Ü"   U+0206 Lu 1 "LATIN CAPITAL LETTER E WITH INVERTED BREVE" )
 519  : ( "»á"   U+0207 Ll 1 "LATIN SMALL LETTER E WITH INVERTED BREVE" )
 520  : ( "»à"   U+0208 Lu 1 "LATIN CAPITAL LETTER I WITH DOUBLE GRAVE" )
 521  : ( "»â"   U+0209 Ll 1 "LATIN SMALL LETTER I WITH DOUBLE GRAVE" )
 522  : ( "»ä"   U+020A Lu 1 "LATIN CAPITAL LETTER I WITH INVERTED BREVE" )
 523  : ( "»ã"   U+020B Ll 1 "LATIN SMALL LETTER I WITH INVERTED BREVE" )
 524  : ( "»å"   U+020C Lu 1 "LATIN CAPITAL LETTER O WITH DOUBLE GRAVE" )
 525  : ( "»ç"   U+020D Ll 1 "LATIN SMALL LETTER O WITH DOUBLE GRAVE" )
 526  : ( "»é"   U+020E Lu 1 "LATIN CAPITAL LETTER O WITH INVERTED BREVE" )
 527  : ( "»è"   U+020F Ll 1 "LATIN SMALL LETTER O WITH INVERTED BREVE" )
 528  : ( "»ê"   U+0210 Lu 1 "LATIN CAPITAL LETTER R WITH DOUBLE GRAVE" )
 529  : ( "»ë"   U+0211 Ll 1 "LATIN SMALL LETTER R WITH DOUBLE GRAVE" )
 530  : ( "»í"   U+0212 Lu 1 "LATIN CAPITAL LETTER R WITH INVERTED BREVE" )
 531  : ( "»ì"   U+0213 Ll 1 "LATIN SMALL LETTER R WITH INVERTED BREVE" )
 532  : ( "»î"   U+0214 Lu 1 "LATIN CAPITAL LETTER U WITH DOUBLE GRAVE" )
 533  : ( "»ï"   U+0215 Ll 1 "LATIN SMALL LETTER U WITH DOUBLE GRAVE" )
 534  : ( "»ñ"   U+0216 Lu 1 "LATIN CAPITAL LETTER U WITH INVERTED BREVE" )
 535  : ( "»ó"   U+0217 Ll 1 "LATIN SMALL LETTER U WITH INVERTED BREVE" )
 536  : ( "»ò"   U+0218 Lu 1 "LATIN CAPITAL LETTER S WITH COMMA BELOW" )
 537  : ( "»ô"   U+0219 Ll 1 "LATIN SMALL LETTER S WITH COMMA BELOW" )
 538  : ( "»ö"   U+021A Lu 1 "LATIN CAPITAL LETTER T WITH COMMA BELOW" )
 539  : ( "»õ"   U+021B Ll 1 "LATIN SMALL LETTER T WITH COMMA BELOW" )
 540  : ( "»ú"   U+021C Lu 1 "LATIN CAPITAL LETTER YOGH" )
 541  : ( "»ù"   U+021D Ll 1 "LATIN SMALL LETTER YOGH" )
 542  : ( "»û"   U+021E Lu 1 "LATIN CAPITAL LETTER H WITH CARON" )
 543  : ( "»ü"   U+021F Ll 1 "LATIN SMALL LETTER H WITH CARON" )
 544  : ( "»†"   U+0220 Lu 1 "LATIN CAPITAL LETTER N WITH LONG RIGHT LEG" )
 545  : ( "»°"   U+0221 Ll 1 "LATIN SMALL LETTER D WITH CURL" )
 546  : ( "»¢"   U+0222 Lu 1 "LATIN CAPITAL LETTER OU" )
 547  : ( "»£"   U+0223 Ll 1 "LATIN SMALL LETTER OU" )
 548  : ( "»§"   U+0224 Lu 1 "LATIN CAPITAL LETTER Z WITH HOOK" )
 549  : ( "»•"   U+0225 Ll 1 "LATIN SMALL LETTER Z WITH HOOK" )
 550  : ( "»¶"   U+0226 Lu 1 "LATIN CAPITAL LETTER A WITH DOT ABOVE" )
 551  : ( "»ß"   U+0227 Ll 1 "LATIN SMALL LETTER A WITH DOT ABOVE" )
 552  : ( "»®"   U+0228 Lu 1 "LATIN CAPITAL LETTER E WITH CEDILLA" )
 553  : ( "»©"   U+0229 Ll 1 "LATIN SMALL LETTER E WITH CEDILLA" )
 554  : ( "»™"   U+022A Lu 1 "LATIN CAPITAL LETTER O WITH DIAERESIS AND MACRON" )
 555  : ( "»´"   U+022B Ll 1 "LATIN SMALL LETTER O WITH DIAERESIS AND MACRON" )
 556  : ( "»¨"   U+022C Lu 1 "LATIN CAPITAL LETTER O WITH TILDE AND MACRON" )
 557  : ( "»≠"   U+022D Ll 1 "LATIN SMALL LETTER O WITH TILDE AND MACRON" )
 558  : ( "»Æ"   U+022E Lu 1 "LATIN CAPITAL LETTER O WITH DOT ABOVE" )
 559  : ( "»Ø"   U+022F Ll 1 "LATIN SMALL LETTER O WITH DOT ABOVE" )
 560  : ( "»∞"   U+0230 Lu 1 "LATIN CAPITAL LETTER O WITH DOT ABOVE AND MACRON" )
 561  : ( "»±"   U+0231 Ll 1 "LATIN SMALL LETTER O WITH DOT ABOVE AND MACRON" )
 562  : ( "»≤"   U+0232 Lu 1 "LATIN CAPITAL LETTER Y WITH MACRON" )
 563  : ( "»≥"   U+0233 Ll 1 "LATIN SMALL LETTER Y WITH MACRON" )
 564  : ( "»¥"   U+0234 Ll 1 "LATIN SMALL LETTER L WITH CURL" )
 565  : ( "»µ"   U+0235 Ll 1 "LATIN SMALL LETTER N WITH CURL" )
 566  : ( "»∂"   U+0236 Ll 1 "LATIN SMALL LETTER T WITH CURL" )
 567  : ( "»∑"   U+0237 Ll 1 "LATIN SMALL LETTER DOTLESS J" )
 568  : ( "»∏"   U+0238 Ll 1 "LATIN SMALL LETTER DB DIGRAPH" )
 569  : ( "»π"   U+0239 Ll 1 "LATIN SMALL LETTER QP DIGRAPH" )
 570  : ( "»∫"   U+023A Lu 1 "LATIN CAPITAL LETTER A WITH STROKE" )
 571  : ( "»ª"   U+023B Lu 1 "LATIN CAPITAL LETTER C WITH STROKE" )
 572  : ( "»º"   U+023C Ll 1 "LATIN SMALL LETTER C WITH STROKE" )
 573  : ( "»Ω"   U+023D Lu 1 "LATIN CAPITAL LETTER L WITH BAR" )
 574  : ( "»æ"   U+023E Lu 1 "LATIN CAPITAL LETTER T WITH DIAGONAL STROKE" )
 575  : ( "»ø"   U+023F Ll 1 "LATIN SMALL LETTER S WITH SWASH TAIL" )
 576  : ( "…Ä"   U+0240 Ll 1 "LATIN SMALL LETTER Z WITH SWASH TAIL" )
 577  : ( "…Å"   U+0241 Lu 1 "LATIN CAPITAL LETTER GLOTTAL STOP" )
 578  : ( "…Ç"   U+0242 Ll 1 "LATIN SMALL LETTER GLOTTAL STOP" )
 579  : ( "…É"   U+0243 Lu 1 "LATIN CAPITAL LETTER B WITH STROKE" )
 580  : ( "…Ñ"   U+0244 Lu 1 "LATIN CAPITAL LETTER U BAR" )
 581  : ( "…Ö"   U+0245 Lu 1 "LATIN CAPITAL LETTER TURNED V" )
 582  : ( "…Ü"   U+0246 Lu 1 "LATIN CAPITAL LETTER E WITH STROKE" )
 583  : ( "…á"   U+0247 Ll 1 "LATIN SMALL LETTER E WITH STROKE" )
 584  : ( "…à"   U+0248 Lu 1 "LATIN CAPITAL LETTER J WITH STROKE" )
 585  : ( "…â"   U+0249 Ll 1 "LATIN SMALL LETTER J WITH STROKE" )
 586  : ( "…ä"   U+024A Lu 1 "LATIN CAPITAL LETTER SMALL Q WITH HOOK TAIL" )
 587  : ( "…ã"   U+024B Ll 1 "LATIN SMALL LETTER Q WITH HOOK TAIL" )
 588  : ( "…å"   U+024C Lu 1 "LATIN CAPITAL LETTER R WITH STROKE" )
 589  : ( "…ç"   U+024D Ll 1 "LATIN SMALL LETTER R WITH STROKE" )
 590  : ( "…é"   U+024E Lu 1 "LATIN CAPITAL LETTER Y WITH STROKE" )
 591  : ( "…è"   U+024F Ll 1 "LATIN SMALL LETTER Y WITH STROKE" )
 592  : ( "…ê"   U+0250 Ll 1 "LATIN SMALL LETTER TURNED A" )
 593  : ( "…ë"   U+0251 Ll 1 "LATIN SMALL LETTER ALPHA" )
 594  : ( "…í"   U+0252 Ll 1 "LATIN SMALL LETTER TURNED ALPHA" )
 595  : ( "…ì"   U+0253 Ll 1 "LATIN SMALL LETTER B WITH HOOK" )
 596  : ( "…î"   U+0254 Ll 1 "LATIN SMALL LETTER OPEN O" )
 597  : ( "…ï"   U+0255 Ll 1 "LATIN SMALL LETTER C WITH CURL" )
 598  : ( "…ñ"   U+0256 Ll 1 "LATIN SMALL LETTER D WITH TAIL" )
 599  : ( "…ó"   U+0257 Ll 1 "LATIN SMALL LETTER D WITH HOOK" )
 600  : ( "…ò"   U+0258 Ll 1 "LATIN SMALL LETTER REVERSED E" )
 601  : ( "…ô"   U+0259 Ll 1 "LATIN SMALL LETTER SCHWA" )
 602  : ( "…ö"   U+025A Ll 1 "LATIN SMALL LETTER SCHWA WITH HOOK" )
 603  : ( "…õ"   U+025B Ll 1 "LATIN SMALL LETTER OPEN E" )
 604  : ( "…ú"   U+025C Ll 1 "LATIN SMALL LETTER REVERSED OPEN E" )
 605  : ( "…ù"   U+025D Ll 1 "LATIN SMALL LETTER REVERSED OPEN E WITH HOOK" )
 606  : ( "…û"   U+025E Ll 1 "LATIN SMALL LETTER CLOSED REVERSED OPEN E" )
 607  : ( "…ü"   U+025F Ll 1 "LATIN SMALL LETTER DOTLESS J WITH STROKE" )
 608  : ( "…†"   U+0260 Ll 1 "LATIN SMALL LETTER G WITH HOOK" )
 609  : ( "…°"   U+0261 Ll 1 "LATIN SMALL LETTER SCRIPT G" )
 610  : ( "…¢"   U+0262 Ll 1 "LATIN LETTER SMALL CAPITAL G" )
 611  : ( "…£"   U+0263 Ll 1 "LATIN SMALL LETTER GAMMA" )
 612  : ( "…§"   U+0264 Ll 1 "LATIN SMALL LETTER RAMS HORN" )
 613  : ( "…•"   U+0265 Ll 1 "LATIN SMALL LETTER TURNED H" )
 614  : ( "…¶"   U+0266 Ll 1 "LATIN SMALL LETTER H WITH HOOK" )
 615  : ( "…ß"   U+0267 Ll 1 "LATIN SMALL LETTER HENG WITH HOOK" )
 616  : ( "…®"   U+0268 Ll 1 "LATIN SMALL LETTER I WITH STROKE" )
 617  : ( "…©"   U+0269 Ll 1 "LATIN SMALL LETTER IOTA" )
 618  : ( "…™"   U+026A Ll 1 "LATIN LETTER SMALL CAPITAL I" )
 619  : ( "…´"   U+026B Ll 1 "LATIN SMALL LETTER L WITH MIDDLE TILDE" )
 620  : ( "…¨"   U+026C Ll 1 "LATIN SMALL LETTER L WITH BELT" )
 621  : ( "…≠"   U+026D Ll 1 "LATIN SMALL LETTER L WITH RETROFLEX HOOK" )
 622  : ( "…Æ"   U+026E Ll 1 "LATIN SMALL LETTER LEZH" )
 623  : ( "…Ø"   U+026F Ll 1 "LATIN SMALL LETTER TURNED M" )
 624  : ( "…∞"   U+0270 Ll 1 "LATIN SMALL LETTER TURNED M WITH LONG LEG" )
 625  : ( "…±"   U+0271 Ll 1 "LATIN SMALL LETTER M WITH HOOK" )
 626  : ( "…≤"   U+0272 Ll 1 "LATIN SMALL LETTER N WITH LEFT HOOK" )
 627  : ( "…≥"   U+0273 Ll 1 "LATIN SMALL LETTER N WITH RETROFLEX HOOK" )
 628  : ( "…¥"   U+0274 Ll 1 "LATIN LETTER SMALL CAPITAL N" )
 629  : ( "…µ"   U+0275 Ll 1 "LATIN SMALL LETTER BARRED O" )
 630  : ( "…∂"   U+0276 Ll 1 "LATIN LETTER SMALL CAPITAL OE" )
 631  : ( "…∑"   U+0277 Ll 1 "LATIN SMALL LETTER CLOSED OMEGA" )
 632  : ( "…∏"   U+0278 Ll 1 "LATIN SMALL LETTER PHI" )
 633  : ( "…π"   U+0279 Ll 1 "LATIN SMALL LETTER TURNED R" )
 634  : ( "…∫"   U+027A Ll 1 "LATIN SMALL LETTER TURNED R WITH LONG LEG" )
 635  : ( "…ª"   U+027B Ll 1 "LATIN SMALL LETTER TURNED R WITH HOOK" )
 636  : ( "…º"   U+027C Ll 1 "LATIN SMALL LETTER R WITH LONG LEG" )
 637  : ( "…Ω"   U+027D Ll 1 "LATIN SMALL LETTER R WITH TAIL" )
 638  : ( "…æ"   U+027E Ll 1 "LATIN SMALL LETTER R WITH FISHHOOK" )
 639  : ( "…ø"   U+027F Ll 1 "LATIN SMALL LETTER REVERSED R WITH FISHHOOK" )
 640  : ( " Ä"   U+0280 Ll 1 "LATIN LETTER SMALL CAPITAL R" )
 641  : ( " Å"   U+0281 Ll 1 "LATIN LETTER SMALL CAPITAL INVERTED R" )
 642  : ( " Ç"   U+0282 Ll 1 "LATIN SMALL LETTER S WITH HOOK" )
 643  : ( " É"   U+0283 Ll 1 "LATIN SMALL LETTER ESH" )
 644  : ( " Ñ"   U+0284 Ll 1 "LATIN SMALL LETTER DOTLESS J WITH STROKE AND HOOK" )
 645  : ( " Ö"   U+0285 Ll 1 "LATIN SMALL LETTER SQUAT REVERSED ESH" )
 646  : ( " Ü"   U+0286 Ll 1 "LATIN SMALL LETTER ESH WITH CURL" )
 647  : ( " á"   U+0287 Ll 1 "LATIN SMALL LETTER TURNED T" )
 648  : ( " à"   U+0288 Ll 1 "LATIN SMALL LETTER T WITH RETROFLEX HOOK" )
 649  : ( " â"   U+0289 Ll 1 "LATIN SMALL LETTER U BAR" )
 650  : ( " ä"   U+028A Ll 1 "LATIN SMALL LETTER UPSILON" )
 651  : ( " ã"   U+028B Ll 1 "LATIN SMALL LETTER V WITH HOOK" )
 652  : ( " å"   U+028C Ll 1 "LATIN SMALL LETTER TURNED V" )
 653  : ( " ç"   U+028D Ll 1 "LATIN SMALL LETTER TURNED W" )
 654  : ( " é"   U+028E Ll 1 "LATIN SMALL LETTER TURNED Y" )
 655  : ( " è"   U+028F Ll 1 "LATIN LETTER SMALL CAPITAL Y" )
 656  : ( " ê"   U+0290 Ll 1 "LATIN SMALL LETTER Z WITH RETROFLEX HOOK" )
 657  : ( " ë"   U+0291 Ll 1 "LATIN SMALL LETTER Z WITH CURL" )
 658  : ( " í"   U+0292 Ll 1 "LATIN SMALL LETTER EZH" )
 659  : ( " ì"   U+0293 Ll 1 "LATIN SMALL LETTER EZH WITH CURL" )
 660  : ( " î"   U+0294 Lo 1 "LATIN LETTER GLOTTAL STOP" )
 661  : ( " ï"   U+0295 Ll 1 "LATIN LETTER PHARYNGEAL VOICED FRICATIVE" )
 662  : ( " ñ"   U+0296 Ll 1 "LATIN LETTER INVERTED GLOTTAL STOP" )
 663  : ( " ó"   U+0297 Ll 1 "LATIN LETTER STRETCHED C" )
 664  : ( " ò"   U+0298 Ll 1 "LATIN LETTER BILABIAL CLICK" )
 665  : ( " ô"   U+0299 Ll 1 "LATIN LETTER SMALL CAPITAL B" )
 666  : ( " ö"   U+029A Ll 1 "LATIN SMALL LETTER CLOSED OPEN E" )
 667  : ( " õ"   U+029B Ll 1 "LATIN LETTER SMALL CAPITAL G WITH HOOK" )
 668  : ( " ú"   U+029C Ll 1 "LATIN LETTER SMALL CAPITAL H" )
 669  : ( " ù"   U+029D Ll 1 "LATIN SMALL LETTER J WITH CROSSED-TAIL" )
 670  : ( " û"   U+029E Ll 1 "LATIN SMALL LETTER TURNED K" )
 671  : ( " ü"   U+029F Ll 1 "LATIN LETTER SMALL CAPITAL L" )
 672  : ( " †"   U+02A0 Ll 1 "LATIN SMALL LETTER Q WITH HOOK" )
 673  : ( " °"   U+02A1 Ll 1 "LATIN LETTER GLOTTAL STOP WITH STROKE" )
 674  : ( " ¢"   U+02A2 Ll 1 "LATIN LETTER REVERSED GLOTTAL STOP WITH STROKE" )
 675  : ( " £"   U+02A3 Ll 1 "LATIN SMALL LETTER DZ DIGRAPH" )
 676  : ( " §"   U+02A4 Ll 1 "LATIN SMALL LETTER DEZH DIGRAPH" )
 677  : ( " •"   U+02A5 Ll 1 "LATIN SMALL LETTER DZ DIGRAPH WITH CURL" )
 678  : ( " ¶"   U+02A6 Ll 1 "LATIN SMALL LETTER TS DIGRAPH" )
 679  : ( " ß"   U+02A7 Ll 1 "LATIN SMALL LETTER TESH DIGRAPH" )
 680  : ( " ®"   U+02A8 Ll 1 "LATIN SMALL LETTER TC DIGRAPH WITH CURL" )
 681  : ( " ©"   U+02A9 Ll 1 "LATIN SMALL LETTER FENG DIGRAPH" )
 682  : ( " ™"   U+02AA Ll 1 "LATIN SMALL LETTER LS DIGRAPH" )
 683  : ( " ´"   U+02AB Ll 1 "LATIN SMALL LETTER LZ DIGRAPH" )
 684  : ( " ¨"   U+02AC Ll 1 "LATIN LETTER BILABIAL PERCUSSIVE" )
 685  : ( " ≠"   U+02AD Ll 1 "LATIN LETTER BIDENTAL PERCUSSIVE" )
 686  : ( " Æ"   U+02AE Ll 1 "LATIN SMALL LETTER TURNED H WITH FISHHOOK" )
 687  : ( " Ø"   U+02AF Ll 1 "LATIN SMALL LETTER TURNED H WITH FISHHOOK AND TAIL" )
 688  : ( " ∞"   U+02B0 Lm 1 "MODIFIER LETTER SMALL H" )
 689  : ( " ±"   U+02B1 Lm 1 "MODIFIER LETTER SMALL H WITH HOOK" )
 690  : ( " ≤"   U+02B2 Lm 1 "MODIFIER LETTER SMALL J" )
 691  : ( " ≥"   U+02B3 Lm 1 "MODIFIER LETTER SMALL R" )
 692  : ( " ¥"   U+02B4 Lm 1 "MODIFIER LETTER SMALL TURNED R" )
 693  : ( " µ"   U+02B5 Lm 1 "MODIFIER LETTER SMALL TURNED R WITH HOOK" )
 694  : ( " ∂"   U+02B6 Lm 1 "MODIFIER LETTER SMALL CAPITAL INVERTED R" )
 695  : ( " ∑"   U+02B7 Lm 1 "MODIFIER LETTER SMALL W" )
 696  : ( " ∏"   U+02B8 Lm 1 "MODIFIER LETTER SMALL Y" )
 697  : ( " π"   U+02B9 Lm 1 "MODIFIER LETTER PRIME" )
 698  : ( " ∫"   U+02BA Lm 1 "MODIFIER LETTER DOUBLE PRIME" )
 699  : ( " ª"   U+02BB Lm 1 "MODIFIER LETTER TURNED COMMA" )
 700  : ( " º"   U+02BC Lm 1 "MODIFIER LETTER APOSTROPHE" )
 701  : ( " Ω"   U+02BD Lm 1 "MODIFIER LETTER REVERSED COMMA" )
 702  : ( " æ"   U+02BE Lm 1 "MODIFIER LETTER RIGHT HALF RING" )
 703  : ( " ø"   U+02BF Lm 1 "MODIFIER LETTER LEFT HALF RING" )
 704  : ( "ÀÄ"   U+02C0 Lm 1 "MODIFIER LETTER GLOTTAL STOP" )
 705  : ( "ÀÅ"   U+02C1 Lm 1 "MODIFIER LETTER REVERSED GLOTTAL STOP" )
 706  : ( "ÀÇ"   U+02C2 Sk 1 "MODIFIER LETTER LEFT ARROWHEAD" )
 707  : ( "ÀÉ"   U+02C3 Sk 1 "MODIFIER LETTER RIGHT ARROWHEAD" )
 708  : ( "ÀÑ"   U+02C4 Sk 1 "MODIFIER LETTER UP ARROWHEAD" )
 709  : ( "ÀÖ"   U+02C5 Sk 1 "MODIFIER LETTER DOWN ARROWHEAD" )
 710  : ( "ÀÜ"   U+02C6 Lm 1 "MODIFIER LETTER CIRCUMFLEX ACCENT" )
 711  : ( "Àá"   U+02C7 Lm 1 "CARON" )
 712  : ( "Àà"   U+02C8 Lm 1 "MODIFIER LETTER VERTICAL LINE" )
 713  : ( "Àâ"   U+02C9 Lm 1 "MODIFIER LETTER MACRON" )
 714  : ( "Àä"   U+02CA Lm 1 "MODIFIER LETTER ACUTE ACCENT" )
 715  : ( "Àã"   U+02CB Lm 1 "MODIFIER LETTER GRAVE ACCENT" )
 716  : ( "Àå"   U+02CC Lm 1 "MODIFIER LETTER LOW VERTICAL LINE" )
 717  : ( "Àç"   U+02CD Lm 1 "MODIFIER LETTER LOW MACRON" )
 718  : ( "Àé"   U+02CE Lm 1 "MODIFIER LETTER LOW GRAVE ACCENT" )
 719  : ( "Àè"   U+02CF Lm 1 "MODIFIER LETTER LOW ACUTE ACCENT" )
 720  : ( "Àê"   U+02D0 Lm 1 "MODIFIER LETTER TRIANGULAR COLON" )
 721  : ( "Àë"   U+02D1 Lm 1 "MODIFIER LETTER HALF TRIANGULAR COLON" )
 722  : ( "Àí"   U+02D2 Sk 1 "MODIFIER LETTER CENTRED RIGHT HALF RING" )
 723  : ( "Àì"   U+02D3 Sk 1 "MODIFIER LETTER CENTRED LEFT HALF RING" )
 724  : ( "Àî"   U+02D4 Sk 1 "MODIFIER LETTER UP TACK" )
 725  : ( "Àï"   U+02D5 Sk 1 "MODIFIER LETTER DOWN TACK" )
 726  : ( "Àñ"   U+02D6 Sk 1 "MODIFIER LETTER PLUS SIGN" )
 727  : ( "Àó"   U+02D7 Sk 1 "MODIFIER LETTER MINUS SIGN" )
 728  : ( "Àò"   U+02D8 Sk 1 "BREVE" )
 729  : ( "Àô"   U+02D9 Sk 1 "DOT ABOVE" )
 730  : ( "Àö"   U+02DA Sk 1 "RING ABOVE" )
 731  : ( "Àõ"   U+02DB Sk 1 "OGONEK" )
 732  : ( "Àú"   U+02DC Sk 1 "SMALL TILDE" )
 733  : ( "Àù"   U+02DD Sk 1 "DOUBLE ACUTE ACCENT" )
 734  : ( "Àû"   U+02DE Sk 1 "MODIFIER LETTER RHOTIC HOOK" )
 735  : ( "Àü"   U+02DF Sk 1 "MODIFIER LETTER CROSS ACCENT" )
 736  : ( "À†"   U+02E0 Lm 1 "MODIFIER LETTER SMALL GAMMA" )
 737  : ( "À°"   U+02E1 Lm 1 "MODIFIER LETTER SMALL L" )
 738  : ( "À¢"   U+02E2 Lm 1 "MODIFIER LETTER SMALL S" )
 739  : ( "À£"   U+02E3 Lm 1 "MODIFIER LETTER SMALL X" )
 740  : ( "À§"   U+02E4 Lm 1 "MODIFIER LETTER SMALL REVERSED GLOTTAL STOP" )
 741  : ( "À•"   U+02E5 Sk 1 "MODIFIER LETTER EXTRA-HIGH TONE BAR" )
 742  : ( "À¶"   U+02E6 Sk 1 "MODIFIER LETTER HIGH TONE BAR" )
 743  : ( "Àß"   U+02E7 Sk 1 "MODIFIER LETTER MID TONE BAR" )
 744  : ( "À®"   U+02E8 Sk 1 "MODIFIER LETTER LOW TONE BAR" )
 745  : ( "À©"   U+02E9 Sk 1 "MODIFIER LETTER EXTRA-LOW TONE BAR" )
 746  : ( "À™"   U+02EA Sk 1 "MODIFIER LETTER YIN DEPARTING TONE MARK" )
 747  : ( "À´"   U+02EB Sk 1 "MODIFIER LETTER YANG DEPARTING TONE MARK" )
 748  : ( "À¨"   U+02EC Lm 1 "MODIFIER LETTER VOICING" )
 749  : ( "À≠"   U+02ED Sk 1 "MODIFIER LETTER UNASPIRATED" )
 750  : ( "ÀÆ"   U+02EE Lm 1 "MODIFIER LETTER DOUBLE APOSTROPHE" )
 751  : ( "ÀØ"   U+02EF Sk 1 "MODIFIER LETTER LOW DOWN ARROWHEAD" )
 752  : ( "À∞"   U+02F0 Sk 1 "MODIFIER LETTER LOW UP ARROWHEAD" )
 753  : ( "À±"   U+02F1 Sk 1 "MODIFIER LETTER LOW LEFT ARROWHEAD" )
 754  : ( "À≤"   U+02F2 Sk 1 "MODIFIER LETTER LOW RIGHT ARROWHEAD" )
 755  : ( "À≥"   U+02F3 Sk 1 "MODIFIER LETTER LOW RING" )
 756  : ( "À¥"   U+02F4 Sk 1 "MODIFIER LETTER MIDDLE GRAVE ACCENT" )
 757  : ( "Àµ"   U+02F5 Sk 1 "MODIFIER LETTER MIDDLE DOUBLE GRAVE ACCENT" )
 758  : ( "À∂"   U+02F6 Sk 1 "MODIFIER LETTER MIDDLE DOUBLE ACUTE ACCENT" )
 759  : ( "À∑"   U+02F7 Sk 1 "MODIFIER LETTER LOW TILDE" )
 760  : ( "À∏"   U+02F8 Sk 1 "MODIFIER LETTER RAISED COLON" )
 761  : ( "Àπ"   U+02F9 Sk 1 "MODIFIER LETTER BEGIN HIGH TONE" )
 762  : ( "À∫"   U+02FA Sk 1 "MODIFIER LETTER END HIGH TONE" )
 763  : ( "Àª"   U+02FB Sk 1 "MODIFIER LETTER BEGIN LOW TONE" )
 764  : ( "Àº"   U+02FC Sk 1 "MODIFIER LETTER END LOW TONE" )
 765  : ( "ÀΩ"   U+02FD Sk 1 "MODIFIER LETTER SHELF" )
 766  : ( "Àæ"   U+02FE Sk 1 "MODIFIER LETTER OPEN SHELF" )
 767  : ( "Àø"   U+02FF Sk 1 "MODIFIER LETTER LOW LEFT ARROW" )
 768  : ( "ÃÄ"    U+0300 Mn 0 "COMBINING GRAVE ACCENT" )
 769  : ( "ÃÅ"    U+0301 Mn 0 "COMBINING ACUTE ACCENT" )
 770  : ( "ÃÇ"    U+0302 Mn 0 "COMBINING CIRCUMFLEX ACCENT" )
 771  : ( "ÃÉ"    U+0303 Mn 0 "COMBINING TILDE" )
 772  : ( "ÃÑ"    U+0304 Mn 0 "COMBINING MACRON" )
 773  : ( "ÃÖ"    U+0305 Mn 0 "COMBINING OVERLINE" )
 774  : ( "ÃÜ"    U+0306 Mn 0 "COMBINING BREVE" )
 775  : ( "Ãá"    U+0307 Mn 0 "COMBINING DOT ABOVE" )
 776  : ( "Ãà"    U+0308 Mn 0 "COMBINING DIAERESIS" )
 777  : ( "Ãâ"    U+0309 Mn 0 "COMBINING HOOK ABOVE" )
 778  : ( "Ãä"    U+030A Mn 0 "COMBINING RING ABOVE" )
 779  : ( "Ãã"    U+030B Mn 0 "COMBINING DOUBLE ACUTE ACCENT" )
 780  : ( "Ãå"    U+030C Mn 0 "COMBINING CARON" )
 781  : ( "Ãç"    U+030D Mn 0 "COMBINING VERTICAL LINE ABOVE" )
 782  : ( "Ãé"    U+030E Mn 0 "COMBINING DOUBLE VERTICAL LINE ABOVE" )
 783  : ( "Ãè"    U+030F Mn 0 "COMBINING DOUBLE GRAVE ACCENT" )
 784  : ( "Ãê"    U+0310 Mn 0 "COMBINING CANDRABINDU" )
 785  : ( "Ãë"    U+0311 Mn 0 "COMBINING INVERTED BREVE" )
 786  : ( "Ãí"    U+0312 Mn 0 "COMBINING TURNED COMMA ABOVE" )
 787  : ( "Ãì"    U+0313 Mn 0 "COMBINING COMMA ABOVE" )
 788  : ( "Ãî"    U+0314 Mn 0 "COMBINING REVERSED COMMA ABOVE" )
 789  : ( "Ãï"    U+0315 Mn 0 "COMBINING COMMA ABOVE RIGHT" )
 790  : ( "Ãñ"    U+0316 Mn 0 "COMBINING GRAVE ACCENT BELOW" )
 791  : ( "Ãó"    U+0317 Mn 0 "COMBINING ACUTE ACCENT BELOW" )
 792  : ( "Ãò"    U+0318 Mn 0 "COMBINING LEFT TACK BELOW" )
 793  : ( "Ãô"    U+0319 Mn 0 "COMBINING RIGHT TACK BELOW" )
 794  : ( "Ãö"    U+031A Mn 0 "COMBINING LEFT ANGLE ABOVE" )
 795  : ( "Ãõ"    U+031B Mn 0 "COMBINING HORN" )
 796  : ( "Ãú"    U+031C Mn 0 "COMBINING LEFT HALF RING BELOW" )
 797  : ( "Ãù"    U+031D Mn 0 "COMBINING UP TACK BELOW" )
 798  : ( "Ãû"    U+031E Mn 0 "COMBINING DOWN TACK BELOW" )
 799  : ( "Ãü"    U+031F Mn 0 "COMBINING PLUS SIGN BELOW" )
 800  : ( "Ã†"    U+0320 Mn 0 "COMBINING MINUS SIGN BELOW" )
 801  : ( "Ã°"    U+0321 Mn 0 "COMBINING PALATALIZED HOOK BELOW" )
 802  : ( "Ã¢"    U+0322 Mn 0 "COMBINING RETROFLEX HOOK BELOW" )
 803  : ( "Ã£"    U+0323 Mn 0 "COMBINING DOT BELOW" )
 804  : ( "Ã§"    U+0324 Mn 0 "COMBINING DIAERESIS BELOW" )
 805  : ( "Ã•"    U+0325 Mn 0 "COMBINING RING BELOW" )
 806  : ( "Ã¶"    U+0326 Mn 0 "COMBINING COMMA BELOW" )
 807  : ( "Ãß"    U+0327 Mn 0 "COMBINING CEDILLA" )
 808  : ( "Ã®"    U+0328 Mn 0 "COMBINING OGONEK" )
 809  : ( "Ã©"    U+0329 Mn 0 "COMBINING VERTICAL LINE BELOW" )
 810  : ( "Ã™"    U+032A Mn 0 "COMBINING BRIDGE BELOW" )
 811  : ( "Ã´"    U+032B Mn 0 "COMBINING INVERTED DOUBLE ARCH BELOW" )
 812  : ( "Ã¨"    U+032C Mn 0 "COMBINING CARON BELOW" )
 813  : ( "Ã≠"    U+032D Mn 0 "COMBINING CIRCUMFLEX ACCENT BELOW" )
 814  : ( "ÃÆ"    U+032E Mn 0 "COMBINING BREVE BELOW" )
 815  : ( "ÃØ"    U+032F Mn 0 "COMBINING INVERTED BREVE BELOW" )
 816  : ( "Ã∞"    U+0330 Mn 0 "COMBINING TILDE BELOW" )
 817  : ( "Ã±"    U+0331 Mn 0 "COMBINING MACRON BELOW" )
 818  : ( "Ã≤"    U+0332 Mn 0 "COMBINING LOW LINE" )
 819  : ( "Ã≥"    U+0333 Mn 0 "COMBINING DOUBLE LOW LINE" )
 820  : ( "Ã¥"    U+0334 Mn 0 "COMBINING TILDE OVERLAY" )
 821  : ( "Ãµ"    U+0335 Mn 0 "COMBINING SHORT STROKE OVERLAY" )
 822  : ( "Ã∂"    U+0336 Mn 0 "COMBINING LONG STROKE OVERLAY" )
 823  : ( "Ã∑"    U+0337 Mn 0 "COMBINING SHORT SOLIDUS OVERLAY" )
 824  : ( "Ã∏"    U+0338 Mn 0 "COMBINING LONG SOLIDUS OVERLAY" )
 825  : ( "Ãπ"    U+0339 Mn 0 "COMBINING RIGHT HALF RING BELOW" )
 826  : ( "Ã∫"    U+033A Mn 0 "COMBINING INVERTED BRIDGE BELOW" )
 827  : ( "Ãª"    U+033B Mn 0 "COMBINING SQUARE BELOW" )
 828  : ( "Ãº"    U+033C Mn 0 "COMBINING SEAGULL BELOW" )
 829  : ( "ÃΩ"    U+033D Mn 0 "COMBINING X ABOVE" )
 830  : ( "Ãæ"    U+033E Mn 0 "COMBINING VERTICAL TILDE" )
 831  : ( "Ãø"    U+033F Mn 0 "COMBINING DOUBLE OVERLINE" )
 832  : ( "ÕÄ"    U+0340 Mn 0 "COMBINING GRAVE TONE MARK" )
 833  : ( "ÕÅ"    U+0341 Mn 0 "COMBINING ACUTE TONE MARK" )
 834  : ( "ÕÇ"    U+0342 Mn 0 "COMBINING GREEK PERISPOMENI" )
 835  : ( "ÕÉ"    U+0343 Mn 0 "COMBINING GREEK KORONIS" )
 836  : ( "ÕÑ"    U+0344 Mn 0 "COMBINING GREEK DIALYTIKA TONOS" )
 837  : ( "ÕÖ"    U+0345 Mn 0 "COMBINING GREEK YPOGEGRAMMENI" )
 838  : ( "ÕÜ"    U+0346 Mn 0 "COMBINING BRIDGE ABOVE" )
 839  : ( "Õá"    U+0347 Mn 0 "COMBINING EQUALS SIGN BELOW" )
 840  : ( "Õà"    U+0348 Mn 0 "COMBINING DOUBLE VERTICAL LINE BELOW" )
 841  : ( "Õâ"    U+0349 Mn 0 "COMBINING LEFT ANGLE BELOW" )
 842  : ( "Õä"    U+034A Mn 0 "COMBINING NOT TILDE ABOVE" )
 843  : ( "Õã"    U+034B Mn 0 "COMBINING HOMOTHETIC ABOVE" )
 844  : ( "Õå"    U+034C Mn 0 "COMBINING ALMOST EQUAL TO ABOVE" )
 845  : ( "Õç"    U+034D Mn 0 "COMBINING LEFT RIGHT ARROW BELOW" )
 846  : ( "Õé"    U+034E Mn 0 "COMBINING UPWARDS ARROW BELOW" )
 847  : ( "Õè"    U+034F Mn 0 "COMBINING GRAPHEME JOINER", "CGJ" )
 848  : ( "Õê"    U+0350 Mn 0 "COMBINING RIGHT ARROWHEAD ABOVE" )
 849  : ( "Õë"    U+0351 Mn 0 "COMBINING LEFT HALF RING ABOVE" )
 850  : ( "Õí"    U+0352 Mn 0 "COMBINING FERMATA" )
 851  : ( "Õì"    U+0353 Mn 0 "COMBINING X BELOW" )
 852  : ( "Õî"    U+0354 Mn 0 "COMBINING LEFT ARROWHEAD BELOW" )
 853  : ( "Õï"    U+0355 Mn 0 "COMBINING RIGHT ARROWHEAD BELOW" )
 854  : ( "Õñ"    U+0356 Mn 0 "COMBINING RIGHT ARROWHEAD AND UP ARROWHEAD BELOW" )
 855  : ( "Õó"    U+0357 Mn 0 "COMBINING RIGHT HALF RING ABOVE" )
 856  : ( "Õò"    U+0358 Mn 0 "COMBINING DOT ABOVE RIGHT" )
 857  : ( "Õô"    U+0359 Mn 0 "COMBINING ASTERISK BELOW" )
 858  : ( "Õö"    U+035A Mn 0 "COMBINING DOUBLE RING BELOW" )
 859  : ( "Õõ"    U+035B Mn 0 "COMBINING ZIGZAG ABOVE" )
 860  : ( "Õú"    U+035C Mn 0 "COMBINING DOUBLE BREVE BELOW" )
 861  : ( "Õù"    U+035D Mn 0 "COMBINING DOUBLE BREVE" )
 862  : ( "Õû"    U+035E Mn 0 "COMBINING DOUBLE MACRON" )
 863  : ( "Õü"    U+035F Mn 0 "COMBINING DOUBLE MACRON BELOW" )
 864  : ( "Õ†"    U+0360 Mn 0 "COMBINING DOUBLE TILDE" )
 865  : ( "Õ°"    U+0361 Mn 0 "COMBINING DOUBLE INVERTED BREVE" )
 866  : ( "Õ¢"    U+0362 Mn 0 "COMBINING DOUBLE RIGHTWARDS ARROW BELOW" )
 867  : ( "Õ£"    U+0363 Mn 0 "COMBINING LATIN SMALL LETTER A" )
 868  : ( "Õ§"    U+0364 Mn 0 "COMBINING LATIN SMALL LETTER E" )
 869  : ( "Õ•"    U+0365 Mn 0 "COMBINING LATIN SMALL LETTER I" )
 870  : ( "Õ¶"    U+0366 Mn 0 "COMBINING LATIN SMALL LETTER O" )
 871  : ( "Õß"    U+0367 Mn 0 "COMBINING LATIN SMALL LETTER U" )
 872  : ( "Õ®"    U+0368 Mn 0 "COMBINING LATIN SMALL LETTER C" )
 873  : ( "Õ©"    U+0369 Mn 0 "COMBINING LATIN SMALL LETTER D" )
 874  : ( "Õ™"    U+036A Mn 0 "COMBINING LATIN SMALL LETTER H" )
 875  : ( "Õ´"    U+036B Mn 0 "COMBINING LATIN SMALL LETTER M" )
 876  : ( "Õ¨"    U+036C Mn 0 "COMBINING LATIN SMALL LETTER R" )
 877  : ( "Õ≠"    U+036D Mn 0 "COMBINING LATIN SMALL LETTER T" )
 878  : ( "ÕÆ"    U+036E Mn 0 "COMBINING LATIN SMALL LETTER V" )
 879  : ( "ÕØ"    U+036F Mn 0 "COMBINING LATIN SMALL LETTER X" )
 880  : ( "Õ∞"   U+0370 Lu 1 "GREEK CAPITAL LETTER HETA" )
 881  : ( "Õ±"   U+0371 Ll 1 "GREEK SMALL LETTER HETA" )
 882  : ( "Õ≤"   U+0372 Lu 1 "GREEK CAPITAL LETTER ARCHAIC SAMPI" )
 883  : ( "Õ≥"   U+0373 Ll 1 "GREEK SMALL LETTER ARCHAIC SAMPI" )
 884  : ( "Õ¥"   U+0374 Lm 1 "GREEK NUMERAL SIGN" )
 885  : ( "Õµ"   U+0375 Sk 1 "GREEK LOWER NUMERAL SIGN" )
 886  : ( "Õ∂"   U+0376 Lu 1 "GREEK CAPITAL LETTER PAMPHYLIAN DIGAMMA" )
 887  : ( "Õ∑"   U+0377 Ll 1 "GREEK SMALL LETTER PAMPHYLIAN DIGAMMA" )
 890  : ( "Õ∫"   U+037A Lm 1 "GREEK YPOGEGRAMMENI" )
 891  : ( "Õª"   U+037B Ll 1 "GREEK SMALL REVERSED LUNATE SIGMA SYMBOL" )
 892  : ( "Õº"   U+037C Ll 1 "GREEK SMALL DOTTED LUNATE SIGMA SYMBOL" )
 893  : ( "ÕΩ"   U+037D Ll 1 "GREEK SMALL REVERSED DOTTED LUNATE SIGMA SYMBOL" )
 894  : ( "Õæ"   U+037E Po 1 "GREEK QUESTION MARK" )
 895  : ( "Õø"   U+037F Lu 1 "GREEK CAPITAL LETTER YOT" )
 900  : ( "ŒÑ"   U+0384 Sk 1 "GREEK TONOS" )
 901  : ( "ŒÖ"   U+0385 Sk 1 "GREEK DIALYTIKA TONOS" )
 902  : ( "ŒÜ"   U+0386 Lu 1 "GREEK CAPITAL LETTER ALPHA WITH TONOS" )
 903  : ( "Œá"   U+0387 Po 1 "GREEK ANO TELEIA" )
 904  : ( "Œà"   U+0388 Lu 1 "GREEK CAPITAL LETTER EPSILON WITH TONOS" )
 905  : ( "Œâ"   U+0389 Lu 1 "GREEK CAPITAL LETTER ETA WITH TONOS" )
 906  : ( "Œä"   U+038A Lu 1 "GREEK CAPITAL LETTER IOTA WITH TONOS" )
 908  : ( "Œå"   U+038C Lu 1 "GREEK CAPITAL LETTER OMICRON WITH TONOS" )
 910  : ( "Œé"   U+038E Lu 1 "GREEK CAPITAL LETTER UPSILON WITH TONOS" )
 911  : ( "Œè"   U+038F Lu 1 "GREEK CAPITAL LETTER OMEGA WITH TONOS" )
 912  : ( "Œê"   U+0390 Ll 1 "GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS" )
 913  : ( "Œë"   U+0391 Lu 1 "GREEK CAPITAL LETTER ALPHA" )
 914  : ( "Œí"   U+0392 Lu 1 "GREEK CAPITAL LETTER BETA" )
 915  : ( "Œì"   U+0393 Lu 1 "GREEK CAPITAL LETTER GAMMA" )
 916  : ( "Œî"   U+0394 Lu 1 "GREEK CAPITAL LETTER DELTA" )
 917  : ( "Œï"   U+0395 Lu 1 "GREEK CAPITAL LETTER EPSILON" )
 918  : ( "Œñ"   U+0396 Lu 1 "GREEK CAPITAL LETTER ZETA" )
 919  : ( "Œó"   U+0397 Lu 1 "GREEK CAPITAL LETTER ETA" )
 920  : ( "Œò"   U+0398 Lu 1 "GREEK CAPITAL LETTER THETA" )
 921  : ( "Œô"   U+0399 Lu 1 "GREEK CAPITAL LETTER IOTA" )
 922  : ( "Œö"   U+039A Lu 1 "GREEK CAPITAL LETTER KAPPA" )
 923  : ( "Œõ"   U+039B Lu 1 "GREEK CAPITAL LETTER LAMDA" )
 924  : ( "Œú"   U+039C Lu 1 "GREEK CAPITAL LETTER MU" )
 925  : ( "Œù"   U+039D Lu 1 "GREEK CAPITAL LETTER NU" )
 926  : ( "Œû"   U+039E Lu 1 "GREEK CAPITAL LETTER XI" )
 927  : ( "Œü"   U+039F Lu 1 "GREEK CAPITAL LETTER OMICRON" )
 928  : ( "Œ†"   U+03A0 Lu 1 "GREEK CAPITAL LETTER PI" )
 929  : ( "Œ°"   U+03A1 Lu 1 "GREEK CAPITAL LETTER RHO" )
 931  : ( "Œ£"   U+03A3 Lu 1 "GREEK CAPITAL LETTER SIGMA" )
 932  : ( "Œ§"   U+03A4 Lu 1 "GREEK CAPITAL LETTER TAU" )
 933  : ( "Œ•"   U+03A5 Lu 1 "GREEK CAPITAL LETTER UPSILON" )
 934  : ( "Œ¶"   U+03A6 Lu 1 "GREEK CAPITAL LETTER PHI" )
 935  : ( "Œß"   U+03A7 Lu 1 "GREEK CAPITAL LETTER CHI" )
 936  : ( "Œ®"   U+03A8 Lu 1 "GREEK CAPITAL LETTER PSI" )
 937  : ( "Œ©"   U+03A9 Lu 1 "GREEK CAPITAL LETTER OMEGA" )
 938  : ( "Œ™"   U+03AA Lu 1 "GREEK CAPITAL LETTER IOTA WITH DIALYTIKA" )
 939  : ( "Œ´"   U+03AB Lu 1 "GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA" )
 940  : ( "Œ¨"   U+03AC Ll 1 "GREEK SMALL LETTER ALPHA WITH TONOS" )
 941  : ( "Œ≠"   U+03AD Ll 1 "GREEK SMALL LETTER EPSILON WITH TONOS" )
 942  : ( "ŒÆ"   U+03AE Ll 1 "GREEK SMALL LETTER ETA WITH TONOS" )
 943  : ( "ŒØ"   U+03AF Ll 1 "GREEK SMALL LETTER IOTA WITH TONOS" )
 944  : ( "Œ∞"   U+03B0 Ll 1 "GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS" )
 945  : ( "Œ±"   U+03B1 Ll 1 "GREEK SMALL LETTER ALPHA" )
 946  : ( "Œ≤"   U+03B2 Ll 1 "GREEK SMALL LETTER BETA" )
 947  : ( "Œ≥"   U+03B3 Ll 1 "GREEK SMALL LETTER GAMMA" )
 948  : ( "Œ¥"   U+03B4 Ll 1 "GREEK SMALL LETTER DELTA" )
 949  : ( "Œµ"   U+03B5 Ll 1 "GREEK SMALL LETTER EPSILON" )
 950  : ( "Œ∂"   U+03B6 Ll 1 "GREEK SMALL LETTER ZETA" )
 951  : ( "Œ∑"   U+03B7 Ll 1 "GREEK SMALL LETTER ETA" )
 952  : ( "Œ∏"   U+03B8 Ll 1 "GREEK SMALL LETTER THETA" )
 953  : ( "Œπ"   U+03B9 Ll 1 "GREEK SMALL LETTER IOTA" )
 954  : ( "Œ∫"   U+03BA Ll 1 "GREEK SMALL LETTER KAPPA" )
 955  : ( "Œª"   U+03BB Ll 1 "GREEK SMALL LETTER LAMDA" )
 956  : ( "Œº"   U+03BC Ll 1 "GREEK SMALL LETTER MU" )
 957  : ( "ŒΩ"   U+03BD Ll 1 "GREEK SMALL LETTER NU" )
 958  : ( "Œæ"   U+03BE Ll 1 "GREEK SMALL LETTER XI" )
 959  : ( "Œø"   U+03BF Ll 1 "GREEK SMALL LETTER OMICRON" )
 960  : ( "œÄ"   U+03C0 Ll 1 "GREEK SMALL LETTER PI" )
 961  : ( "œÅ"   U+03C1 Ll 1 "GREEK SMALL LETTER RHO" )
 962  : ( "œÇ"   U+03C2 Ll 1 "GREEK SMALL LETTER FINAL SIGMA" )
 963  : ( "œÉ"   U+03C3 Ll 1 "GREEK SMALL LETTER SIGMA" )
 964  : ( "œÑ"   U+03C4 Ll 1 "GREEK SMALL LETTER TAU" )
 965  : ( "œÖ"   U+03C5 Ll 1 "GREEK SMALL LETTER UPSILON" )
 966  : ( "œÜ"   U+03C6 Ll 1 "GREEK SMALL LETTER PHI" )
 967  : ( "œá"   U+03C7 Ll 1 "GREEK SMALL LETTER CHI" )
 968  : ( "œà"   U+03C8 Ll 1 "GREEK SMALL LETTER PSI" )
 969  : ( "œâ"   U+03C9 Ll 1 "GREEK SMALL LETTER OMEGA" )
 970  : ( "œä"   U+03CA Ll 1 "GREEK SMALL LETTER IOTA WITH DIALYTIKA" )
 971  : ( "œã"   U+03CB Ll 1 "GREEK SMALL LETTER UPSILON WITH DIALYTIKA" )
 972  : ( "œå"   U+03CC Ll 1 "GREEK SMALL LETTER OMICRON WITH TONOS" )
 973  : ( "œç"   U+03CD Ll 1 "GREEK SMALL LETTER UPSILON WITH TONOS" )
 974  : ( "œé"   U+03CE Ll 1 "GREEK SMALL LETTER OMEGA WITH TONOS" )
 975  : ( "œè"   U+03CF Lu 1 "GREEK CAPITAL KAI SYMBOL" )
 976  : ( "œê"   U+03D0 Ll 1 "GREEK BETA SYMBOL" )
 977  : ( "œë"   U+03D1 Ll 1 "GREEK THETA SYMBOL" )
 978  : ( "œí"   U+03D2 Lu 1 "GREEK UPSILON WITH HOOK SYMBOL" )
 979  : ( "œì"   U+03D3 Lu 1 "GREEK UPSILON WITH ACUTE AND HOOK SYMBOL" )
 980  : ( "œî"   U+03D4 Lu 1 "GREEK UPSILON WITH DIAERESIS AND HOOK SYMBOL" )
 981  : ( "œï"   U+03D5 Ll 1 "GREEK PHI SYMBOL" )
 982  : ( "œñ"   U+03D6 Ll 1 "GREEK PI SYMBOL" )
 983  : ( "œó"   U+03D7 Ll 1 "GREEK KAI SYMBOL" )
 984  : ( "œò"   U+03D8 Lu 1 "GREEK LETTER ARCHAIC KOPPA" )
 985  : ( "œô"   U+03D9 Ll 1 "GREEK SMALL LETTER ARCHAIC KOPPA" )
 986  : ( "œö"   U+03DA Lu 1 "GREEK LETTER STIGMA" )
 987  : ( "œõ"   U+03DB Ll 1 "GREEK SMALL LETTER STIGMA" )
 988  : ( "œú"   U+03DC Lu 1 "GREEK LETTER DIGAMMA" )
 989  : ( "œù"   U+03DD Ll 1 "GREEK SMALL LETTER DIGAMMA" )
 990  : ( "œû"   U+03DE Lu 1 "GREEK LETTER KOPPA" )
 991  : ( "œü"   U+03DF Ll 1 "GREEK SMALL LETTER KOPPA" )
 992  : ( "œ†"   U+03E0 Lu 1 "GREEK LETTER SAMPI" )
 993  : ( "œ°"   U+03E1 Ll 1 "GREEK SMALL LETTER SAMPI" )
 994  : ( "œ¢"   U+03E2 Lu 1 "COPTIC CAPITAL LETTER SHEI" )
 995  : ( "œ£"   U+03E3 Ll 1 "COPTIC SMALL LETTER SHEI" )
 996  : ( "œ§"   U+03E4 Lu 1 "COPTIC CAPITAL LETTER FEI" )
 997  : ( "œ•"   U+03E5 Ll 1 "COPTIC SMALL LETTER FEI" )
 998  : ( "œ¶"   U+03E6 Lu 1 "COPTIC CAPITAL LETTER KHEI" )
 999  : ( "œß"   U+03E7 Ll 1 "COPTIC SMALL LETTER KHEI" )
 1000 : ( "œ®"   U+03E8 Lu 1 "COPTIC CAPITAL LETTER HORI" )
 1001 : ( "œ©"   U+03E9 Ll 1 "COPTIC SMALL LETTER HORI" )
 1002 : ( "œ™"   U+03EA Lu 1 "COPTIC CAPITAL LETTER GANGIA" )
 1003 : ( "œ´"   U+03EB Ll 1 "COPTIC SMALL LETTER GANGIA" )
 1004 : ( "œ¨"   U+03EC Lu 1 "COPTIC CAPITAL LETTER SHIMA" )
 1005 : ( "œ≠"   U+03ED Ll 1 "COPTIC SMALL LETTER SHIMA" )
 1006 : ( "œÆ"   U+03EE Lu 1 "COPTIC CAPITAL LETTER DEI" )
 1007 : ( "œØ"   U+03EF Ll 1 "COPTIC SMALL LETTER DEI" )
 1008 : ( "œ∞"   U+03F0 Ll 1 "GREEK KAPPA SYMBOL" )
...

-- The last 10 characters
ooRexx> .unicode~characters~pipe(.take "last" 10 | .console)
917990 : ( "Û†á¶"    U+E01E6 Mn 0 "VARIATION SELECTOR-247", "VS247" )
917991 : ( "Û†áß"    U+E01E7 Mn 0 "VARIATION SELECTOR-248", "VS248" )
917992 : ( "Û†á®"    U+E01E8 Mn 0 "VARIATION SELECTOR-249", "VS249" )
917993 : ( "Û†á©"    U+E01E9 Mn 0 "VARIATION SELECTOR-250", "VS250" )
917994 : ( "Û†á™"    U+E01EA Mn 0 "VARIATION SELECTOR-251", "VS251" )
917995 : ( "Û†á´"    U+E01EB Mn 0 "VARIATION SELECTOR-252", "VS252" )
917996 : ( "Û†á¨"    U+E01EC Mn 0 "VARIATION SELECTOR-253", "VS253" )
917997 : ( "Û†á≠"    U+E01ED Mn 0 "VARIATION SELECTOR-254", "VS254" )
917998 : ( "Û†áÆ"    U+E01EE Mn 0 "VARIATION SELECTOR-255", "VS255" )
917999 : ( "Û†áØ"    U+E01EF Mn 0 "VARIATION SELECTOR-256", "VS256" )

-- get a character by codepoint
ooRexx> .unicode~character(8203)=                   -- (U+200B Cf "ZERO WIDTH SPACE")
( "‚Äã"    U+200B Cf 0 "ZERO WIDTH SPACE", "ZWSP" )
ooRexx> .unicode~character("U+200B")=               -- (U+200B Cf "ZERO WIDTH SPACE")
( "‚Äã"    U+200B Cf 0 "ZERO WIDTH SPACE", "ZWSP" )
ooRexx> .unicode~character("u+200b")=               -- (U+200B Cf "ZERO WIDTH SPACE")
( "‚Äã"    U+200B Cf 0 "ZERO WIDTH SPACE", "ZWSP" )

-- get a character by name.
-- loose matching name. See https://unicode.org/reports/tr44/#UAX44-LM2
ooRexx> .unicode~character("ZERO WIDTH SPACE")=     -- (U+200B Cf "ZERO WIDTH SPACE")
( "‚Äã"    U+200B Cf 0 "ZERO WIDTH SPACE", "ZWSP" )
ooRexx> .unicode~character("ZERO_WIDTH-SPACE")=     -- (U+200B Cf "ZERO WIDTH SPACE")
( "‚Äã"    U+200B Cf 0 "ZERO WIDTH SPACE", "ZWSP" )
ooRexx> .unicode~character("ZEROWIDTHSPACE")=       -- (U+200B Cf "ZERO WIDTH SPACE")
( "‚Äã"    U+200B Cf 0 "ZERO WIDTH SPACE", "ZWSP" )
ooRexx> .unicode~character("zerowidthspace")=       -- (U+200B Cf "ZERO WIDTH SPACE")
( "‚Äã"    U+200B Cf 0 "ZERO WIDTH SPACE", "ZWSP" )

-- select characters using a matcher
-- remember: it's better to initialize the matcher outside the iteration.
ooRexx> matcher = "*chris*"~matcher; .unicode~characters~select{expose matcher; matcher~(item~name)}==
an Array (shape [3], 3 items)
 1 : ( "üéÑ"  U+1F384 So 2 "CHRISTMAS TREE" )
 2 : ( "üéÖ"  U+1F385 So 2 "FATHER CHRISTMAS" )
 3 : ( "ü§∂"  U+1F936 So 2 "MOTHER CHRISTMAS" )

-- string character names
ooRexx> "no√´lüë©‚Äçüë®‚Äçüë©‚ÄçüëßüéÖ"~text~codepoints~each{uchar = .unicode~character(item); uchar~charWidth uchar~categoryName uchar~name}==
an Array (shape [12], 12 items)
 1  : '1 Ll LATIN SMALL LETTER N'
 2  : '1 Ll LATIN SMALL LETTER O'
 3  : '1 Ll LATIN SMALL LETTER E WITH DIAERESIS'
 4  : '1 Ll LATIN SMALL LETTER L'
 5  : '2 So WOMAN'
 6  : '0 Cf ZERO WIDTH JOINER'
 7  : '2 So MAN'
 8  : '0 Cf ZERO WIDTH JOINER'
 9  : '2 So WOMAN'
 10 : '0 Cf ZERO WIDTH JOINER'
 11 : '2 So GIRL'
 12 : '2 So FATHER CHRISTMAS'

-- shortest name:
ooRexx> .unicode~characters~reduce{if accu~name~length > item~name~length, item~name~length <> 0 then item }=
( ""    U+0000 Cc 0 "", "NULL", "NUL" )

-- longest name:
ooRexx> .unicode~characters~reduce{if accu~name~length < item~name~length then item }=
( "üÆ®"   U+1FBA8 So 1 "BOX DRAWINGS LIGHT DIAGONAL UPPER CENTRE TO MIDDLE LEFT AND MIDDLE RIGHT TO LOWER CENTRE" )


-- ===============================================================================
-- 2021 September 12

/*
[String chunks]

The functionality of splitting text by quoted/unquoted chunks is moved from
ooRexxShell to a dedicated package:
extension/stringChunk.cls               (compatible with official ooRexx)

The initial need was to parse a command line and split it the same way as a cmd
or bash shell. Also used to parse the queries in ooRexxShell.
The quotes are removed, but each character is associated to a 'quote flag' to
remember if the character was inside a quoted section.
These flags are typically used by the matchers of type string pattern, to decide
if a character can be special or not.

Description:
    routine stringChunks
    use strict arg string, withInfos=.false, breakTokens="", splitLevel=1

    Converts a string to an array of String or to an array of stringChunk.
    The type of result is indicated by the argument withInfos:
    - If withInfos == .false (default) then the result is an array of String.
    - If withInfos == .true then the result is an array of StringChunk.

    A StringChunk is a substring which references the start and end character
    in its container. It's associated to a string of booleans (quotedFlags)
    which indicate for each character if it was inside a quoted section.

    A quote is either " or '.

    An unquoted section is splitted in StringChunks delimited by whitespaces
    (anything <= 32) and break tokens.

    A quoted section is not splitted:
    - Whitespaces are kept,
    - single occurences of quotes are removed,
    - double occurrence of quotes are replaced by a single embedded quote,
    - break tokens and escape characters are ignored.

    An escape character is any character passed in the argument escapeCharacters.
    An escape character sets the quote flag of the next character to 1.
    Escape characters are removed, even if they are not followed by another
    character (truncated string).
    Example with 'a' declared escape character:
    - "a" --> ""
    - "aa" --> "a"
    - "aaa" --> "a"
    - "aaaa" --> "aa"

    If a quote is declared escape character, there is no impact: a quote is
    already an escape mechanism.

    If a space is declared escape character, there is an impact when splitLevel=0:
    the quote flag of a character following an unquoted space is set to 1, the
    unquoted spaces are removed
    Example:
        'one two "three four" five six' --> onetwothree fourfivesix
                                            00010011111111111000100

    Break tokens are passed in the argument breakTokens.
    A break token cannot contains spaces.
    The break tokens can be case sensitive (default) or case insensitive.
    Each break token can be prefixed by:
    - cs:  case sensitive
    - ci:  case insensitive
    - cl:  caseless (synonym of case insensitive)
    Any other prefix is not an error. It's just not a case prefix.

    If a quote is declared break token then it's no longer recognized as a quote.
    If an escape character is declared break token then it's no longer recognized
    as an escape character.

    The split process is controlled by the argument splitLevel:
    - If splitLevel == 0 then the string is not splitted but the quotes and
      escape characters are managed, quotedFlags is set.
        'xx aa"b b"cc"d d"ee yy' is 1 StringChunk.
    - If splitLevel == 1 (default) then adjacent quoted/unquoted sections are kept glued.
        'xx aa"b b"cc"d d"ee yy' is 3 StringChunk: xx "aab bccd dee" yy
    - If splitLevel == 2 then adjacent quoted/unquoted sections are separated.
        'xx aa"b b"cc"d d"ee yy' is splitted in 7 StringChunk: xx aa "b b" cc "d d" ee yy

    Illustration with splitLevel=1:
     11111111111111111111111111 222222222222222 333333333333333333333
    '"hello "John" how are you" good" bye "John "my name is ""BOND"""'
     0000000001111111111222222222233333333334444444444555555555566666
     1234567890123456789012345678901234567890123456789012345678901234
    arg1 = |hello John how are you|      containerStart = 01      containerEnd = 26      quotedFlags = 1111110000111111111111
    arg2 = |good bye John|               containerStart = 28      containerEnd = 42      quotedFlags = 0000111110000
    arg3 = |my name is "BOND"|           containerStart = 44      containerEnd = 64      quotedFlags = 11111111111111111

Extensions available in Executor only:
    .String~chunk           withInfos is true, splitLevel is 0 --> always returns ONE StringChunk
    .String~chunks          withInfos is true by default, splitLevel is 1 by default

Examples:
*/
ooRexx>     -- splitLevel = 0: no split
ooRexx>     'aa"b\ b"cc"d\ d"ee\* ff'~chunks(splitLevel:0)~each{item~sayDescription(25, index, 2)}
1  |aab\ bccd\ dee\* ff|       01 23 |aa"b\ b"cc"d\ d"ee\* ff|  
1  |0011110011110000000|      
/*
        1  |aab\ bccd\ dee\* ff|       01 23 |aa"b\ b"cc"d\ d"ee\* ff|
        1  |0011110011110000000|
*/

ooRexx>     -- splitLevel = 1: Adjacent quoted/unquoted sections are kept glued
ooRexx>     'aa"b\ b"cc"d\ d"ee\* ff'~chunks(splitLevel:1)~each{item~sayDescription(25, index, 2)}
1  |aab\ bccd\ dee\*|          01 20 |aa"b\ b"cc"d\ d"ee\*|     
1  |0011110011110000|         
2  |ff|                        22 23 |ff|                       
2  |00|                       
/*
        1  |aab\ bccd\ dee\*|          01 20 |aa"b\ b"cc"d\ d"ee\*|
        1  |0011110011110000|
        2  |ff|                        22 23 |ff|
        2  |00|
*/

ooRexx>     -- splitLevel = 2: Adjacent quoted/unquoted sections are separated
ooRexx>     'aa"b\ b"cc"d\ d"ee\* ff'~chunks(splitLevel:2)~each{item~sayDescription(25, index, 2)}
1  |aa|                        01 02 |aa|                       
1  |00|                       
2  |b\ b|                      03 08 |"b\ b"|                   
2  |1111|                     
3  |cc|                        09 10 |cc|                       
3  |00|                       
4  |d\ d|                      11 16 |"d\ d"|                   
4  |1111|                     
5  |ee\*|                      17 20 |ee\*|                     
5  |0000|                     
6  |ff|                        22 23 |ff|                       
6  |00|                       
/*
        1  |aa|                        01 02 |aa|
        1  |00|
        2  |b\ b|                      03 08 |"b\ b"|
        2  |1111|
        3  |cc|                        09 10 |cc|
        3  |00|
        4  |d\ d|                      11 16 |"d\ d"|
        4  |1111|
        5  |ee\*|                      17 20 |ee\*|
        5  |0000|
        6  |ff|                        22 23 |ff|
        6  |00|
*/

ooRexx>     -- Default splitLevel (1)
ooRexx>     -- The quote is declared break token, there is no more quoted sections, and the quote itself is returned
ooRexx>     'aa"b\ b"cc"d\ d"ee\* ff'~chunks(breakTokens: '"')~each{item~sayDescription(25, index, 2)}
1  |aa|                        01 02 |aa|                       
1  |00|                       
2  |"|                         03 03 |"|                        
2  |0|                        
3  |b\|                        04 05 |b\|                       
3  |00|                       
4  |b|                         07 07 |b|                        
4  |0|                        
5  |"|                         08 08 |"|                        
5  |0|                        
6  |cc|                        09 10 |cc|                       
6  |00|                       
7  |"|                         11 11 |"|                        
7  |0|                        
8  |d\|                        12 13 |d\|                       
8  |00|                       
9  |d|                         15 15 |d|                        
9  |0|                        
10 |"|                         16 16 |"|                        
10 |0|                        
11 |ee\*|                      17 20 |ee\*|                     
11 |0000|                     
12 |ff|                        22 23 |ff|                       
12 |00|                       
/*
        1  |aa|                        01 02 |aa|
        1  |00|
        2  |"|                         03 03 |"|
        2  |0|
        3  |b\|                        04 05 |b\|
        3  |00|
        4  |b|                         07 07 |b|
        4  |0|
        5  |"|                         08 08 |"|
        5  |0|
        6  |cc|                        09 10 |cc|
        6  |00|
        7  |"|                         11 11 |"|
        7  |0|
        8  |d\|                        12 13 |d\|
        8  |00|
        9  |d|                         15 15 |d|
        9  |0|
        10 |"|                         16 16 |"|
        10 |0|
        11 |ee\*|                      17 20 |ee\*|
        11 |0000|
        12 |ff|                        22 23 |ff|
        12 |00|
*/

ooRexx>     -- Same as previous, plus \ which is declared escape character
ooRexx>     'aa"b\ b"cc"d\ d"ee\* ff'~chunks(breakTokens: '"', escapeCharacters:"\")~each{item~sayDescription(25, index, 2)}
1  |aa|                        01 02 |aa|                       
1  |00|                       
2  |"|                         03 03 |"|                        
2  |0|                        
3  |b b|                       04 07 |b\ b|                     
3  |010|                      
4  |"|                         08 08 |"|                        
4  |0|                        
5  |cc|                        09 10 |cc|                       
5  |00|                       
6  |"|                         11 11 |"|                        
6  |0|                        
7  |d d|                       12 15 |d\ d|                     
7  |010|                      
8  |"|                         16 16 |"|                        
8  |0|                        
9  |ee*|                       17 20 |ee\*|                     
9  |001|                      
10 |ff|                        22 23 |ff|                       
10 |00|                       
/*
        1  |aa|                        01 02 |aa|
        1  |00|
        2  |"|                         03 03 |"|
        2  |0|
        3  |b b|                       04 07 |b\ b|
        3  |010|
        4  |"|                         08 08 |"|
        4  |0|
        5  |cc|                        09 10 |cc|
        5  |00|
        6  |"|                         11 11 |"|
        6  |0|
        7  |d d|                       12 15 |d\ d|
        7  |010|
        8  |"|                         16 16 |"|
        8  |0|
        9  |ee*|                       17 20 |ee\*|
        9  |001|
        10 |ff|                        22 23 |ff|
        10 |00|
*/

ooRexx>     -- A break token can be made of several characters, and can contain a quote
ooRexx>     'aa"b\ b"cc"d\ d"ee\* ff'~chunks(breakTokens: ' a"b ')~each{item~sayDescription(25, index, 2)}
1  |a|                         01 01 |a|                        
1  |0|                        
2  |a"b|                       02 04 |a"b|                      
2  |000|                      
3  |\|                         05 05 |\|                        
3  |0|                        
4  |bccd\|                     07 13 |b"cc"d\|                  
4  |01100|                    
5  |dee\* ff|                  15 23 |d"ee\* ff|                
5  |01111111|                 
/*
        1  |a|                         01 01 |a|
        1  |0|
        2  |a"b|                       02 04 |a"b|
        2  |000|
        3  |\|                         05 05 |\|
        3  |0|
        4  |bccd\|                     07 13 |b"cc"d\|
        4  |01100|
        5  |dee\* ff|                  15 23 |d"ee\* ff|
        5  |01111111|
*/

ooRexx>     -- If an escape character is also declared break token then it's no longer an escape character
ooRexx>     'aa"b\ b"cc"d\ d"ee\* ff'~chunks(breakTokens:"\", escapeCharacters:"\")~each{item~sayDescription(25, index, 2)}==
1  |aab\ bccd\ dee|            01 18 |aa"b\ b"cc"d\ d"ee|       
1  |00111100111100|           
2  |\|                         19 19 |\|                        
2  |0|                        
3  |*|                         20 20 |*|                        
3  |0|                        
4  |ff|                        22 23 |ff|                       
4  |00|                       
an Array (no shape, 0 items)
/*
        1  |aab\ bccd\ dee|            01 18 |aa"b\ b"cc"d\ d"ee|
        1  |00111100111100|
        2  |\|                         19 19 |\|
        2  |0|
        3  |*|                         20 20 |*|
        3  |0|
        4  |ff|                        22 23 |ff|
        4  |00|
*/

ooRexx>     -- A break token can contain characters that are declared escape character
ooRexx>     'aa"b\ b"cc"d\ d"ee\* ff'~chunks(breakTokens:"e\*", escapeCharacters:"\*")~each{item~sayDescription(25, index, 2)}==
1  |aab\ bccd\ de|             01 17 |aa"b\ b"cc"d\ d"e|        
1  |0011110011110|            
2  |e\*|                       18 20 |e\*|                      
2  |000|                      
3  |ff|                        22 23 |ff|                       
3  |00|                       
an Array (no shape, 0 items)
/*
        1  |aab\ bccd\ de|             01 17 |aa"b\ b"cc"d\ d"e|
        1  |0011110011110|
        2  |e\*|                       18 20 |e\*|
        2  |000|
        3  |ff|                        22 23 |ff|
        3  |00|
*/

ooRexx>     -- A break token can be case insensitive (prefix ci: or cl:)
ooRexx>     '1Plus2'~chunks(breakTokens:"ci:plus")~each{item~sayDescription(25, index, 2)}
1  |1|                         1 1 |1|                        
1  |0|                        
2  |Plus|                      2 5 |Plus|                     
2  |0000|                     
3  |2|                         6 6 |2|                        
3  |0|                        
/*
        1  |1|                         1 1 |1|
        1  |0|
        2  |Plus|                      2 5 |Plus|
        2  |0000|
        3  |2|                         6 6 |2|
        3  |0|
*/

/*
[String patterns]

The functionality of selecting text using patterns is moved from ooRexxShell
to a dedicated package:
extension/stringChunkExtended.cls       (not compatible with official ooRexx)

Description
    .StringChunk~matcher
    use strict named arg wholeString(1)=.true, caseless(1)=.true,-
                         trace(1)=.false, displayer(1)=.traceOutput, prefix(1)=""

    Pattern matching by equality (whole) or by inclusion (not whole), caseless or not.

    If the package regex.cls is loaded, then the pattern (a StringChunk) can be
    a regular expression prefixed by "/".

    When whole, and the pattern is not a regular expression, then the charecter
    "*" is recognized as a generic character when first or last character.

    When not whole, and the pattern is not a regular expression, then the character
    "^" is recognized as the metacharacter 'begining of string' when first character.

    When not whole, and the pattern is not a regular expression, then the character
    "$" is recognized as the metacharacter 'end of string' when last character.

    The returned result is a closure (matcher) which implements the pattern matching,
    or .nil if error.

    The pattern matching is tested when the closure is evaluated with a string passed
    as argument.

    Examples:

        '*' or '**'      : matches everything
        '"*"' or '"**"'  : matches exactly "*" or "**", see case stringPattern
        '***'            : matches all names containing "*", see case *stringPattern*
        '*"*"*'          : matches all names containing "*", see case *stringPattern*
        '*"**"*'         : matches all names containing "**", see case *stringPattern*
        '*stringPattern' : string~right(stringPattern~length)~caselessEquals(stringPattern)
        'stringPattern*' : string~left(stringPattern~length)~caselessEquals(stringPattern)
        '*stringPattern*': string~caselessPos(stringPattern) <> 0
        'stringPattern'  : string~caselessEquals(stringPattern)
*/

ooRexx>         -- caseless equality
ooRexx>         matcher = "object"~matcher
ooRexx>         say matcher~("ObjeCt") -- true
1
ooRexx>         say matcher~("my ObjeCt") -- false
0

ooRexx>         -- caseless equality with generic character
ooRexx>         matcher = "*object"~matcher
ooRexx>         say matcher~("ObjeCt") -- true
1
ooRexx>         say matcher~("my ObjeCt") -- true
1

ooRexx>         -- caseless inclusion
ooRexx>         matcher = "object"~matcher(wholeString:.false)
ooRexx>         say matcher~("ObjeCt") -- true
1
ooRexx>         say matcher~("my ObjeCt") -- true
1

ooRexx>         -- caseless inclusion, regular expression: "object" at the begining or at the end.
ooRexx>         matcher = "/^object|object$"~matcher(wholeString:.false)
ooRexx>         say matcher~("ObjeCt") -- true
1
ooRexx>         say matcher~("my ObjeCt") -- true
1
ooRexx>         say matcher~("my ObjeCts") -- false
0

ooRexx>         -- trace
ooRexx>         "*stringPattern"~matcher(trace:.true)
description: stringChunkPattern="*stringPattern" wholeString=1 caseless=1
stringPattern="stringPattern"
matcher: expose description stringPattern; use strict arg string; return string~right(stringPattern~length)~caselessEquals(stringPattern)
/*
        output:
            description: stringChunkPattern="*stringPattern" wholeString=1 caseless=1
            stringPattern="stringPattern"
            matcher: expose description stringPattern; use strict arg string; return string~right(stringPattern~length)~caselessEquals(stringPattern)
*/

ooRexx>         -- trace when regular expression
ooRexx>         "/.*stringPattern"~matcher(trace:.true)
description: stringChunkPattern="/.*stringPattern" wholeString=1 caseless=1
stringPattern=".*stringPattern"
pattern = .Pattern~compile(stringPattern, .RegexCompiler~new(.RegexCompiler~caseless))
matcher: expose description pattern; use strict arg string; return pattern~matches(string)
/*
        output:
            description: stringChunkPattern="/.*stringPattern" wholeString=1 caseless=1
            stringPattern=".*stringPattern"
            pattern = .Pattern~compile(stringPattern, .RegexCompiler~new(.RegexCompiler~caseless))
            matcher: expose description pattern; use strict arg string; return pattern~matches(string)
*/

-- ===============================================================================
-- 2021 August 11

/*
Added support for strings of codepoints encoded as native integers.
3 representations:
    Unicode8_Encoding
    Unicode16_Encoding
    Unicode32_Encoding.
The method ~unicode returns one of these encodings, depending on the character
with the largest Unicode codepoint (1, 2, or 4 bytes) in the source string.
Unlike the flexible representation of Python, the 3 representions are first-class.
No BOM, the endiannes is the CPU one. This is for internal use only.
Unicode32_Encoding can be used with utf8proc for the functions taking a buffer of 32-bit integers.
*/

ooRexx> "c√¥t√©"~text("unicode8")=    -- T'c√¥t√© Just an interpretative layer put above the string
T'c√¥t√©'
ooRexx> "c√¥t√©"~text("unicode8")~pipe{item~description(short:1) ":" item~c2x}=
'Unicode8 not-ASCII : 63 C3 B4 74 C3 A9'
--    'Unicode8 not-ASCII : 63 C3 B4 74 C3 A9

ooRexx> "c√¥t√©"~text~unicode=        -- T'c?t?' UTF-8 converted to Unicode8
T'cÙtÈ'
ooRexx> "c√¥t√©"~text~unicode~pipe{item~description(short:1) ":" item~c2x}=
'Unicode8 not-ASCII : 63 F4 74 E9'
--    'Unicode8 not-ASCII : 63 F4 74 E9

ooRexx> "no√´l‚Äçüë®‚Äçüë©‚Äçüëß"~text~maximumCodepoint~pipe{"U+"item~d2x}=   -- U+1F469 is the maximum codepoint
'U+1F469'
ooRexx> "no√´l‚Äçüë®‚Äçüë©‚Äçüëß"~text~unicode~description(technical:1)=      -- For this maximum codepoint, we need Unicode32
'Unicode32 (5 characters (1 index from index 5), 10 codepoints (0 index), 40 bytes, 0 error)'
--    'Unicode32 not-ASCII (5 graphemes (1 index from index 5), 10 codepoints (0 index), 40 bytes, 0 error)'

-- The endianness of the UnicodeXX_Encoding is the one of the machine.
-- With an Intel CPU, it's little-endian.
ooRexx> "no√´l‚Äçüë®‚Äçüë©‚Äçüëß"~text~unicode~c2x=
'6E000000 6F000000 EB000000 6C000000 0D200000 68F40100 0D200000 69F40100 0D200000 67F40100'
--    '6E000000 6F000000 EB000000 6C000000 0D200000 68F40100 0D200000 69F40100 0D200000 67F40100'

-- The default endianness for UTF32 is big-endian.
ooRexx> "no√´l‚Äçüë®‚Äçüë©‚Äçüëß"~text~utf32~c2x=
'0000006E 0000006F 000000EB 0000006C 0000200D 0001F468 0000200D 0001F469 0000200D 0001F467'
--    '0000006E 0000006F 000000EB 0000006C 0000200D 0001F468 0000200D 0001F469 0000200D 0001F467'


-- ===============================================================================
-- 2021 may 31

/*
Encodeded strings.
The ooRexx programmer has the choice:
- working with String at byte level
- working with RexxText at grapheme level.
- the same instance of String is used in both cases.

    aString
     ‚ñ≤  text --------> aRexxText
     ‚îÇ                     indexer (anEncoding)
     ‚îÇ                          codepoints (sequential access)
     ‚îÇ                          graphemes  (direct access)
     +-----------------------<- string
*/

-- First binding of utf8proc, for the detection of grapheme cluster break.
ooRexx> "( Õ°¬∞ Õú ñÔªø Õ°¬∞)"~text~description=                    -- 'UTF-8 not-ASCII ( 9 graphemes, 12 codepoints, 20 bytes )'
'UTF-8 not-ASCII (9 characters, 12 codepoints, 20 bytes, 0 error)'
ooRexx> "( Õ°¬∞ Õú ñÔªø Õ°¬∞)"~text~graphemes~each{item~c2x}=       -- [ 28,'20CDA1','C2B0','20CD9C','CA96','EFBBBF','20CDA1','C2B0', 29]
[ 28,'20 CDA1','C2B0','20 CD9C','CA96','EFBBBF','20 CDA1','C2B0', 29]

-- Classes in relation with Unicode and encoded strings:
ooRexx> ?c *encoding* *encoded* *indexer* *codepoint* *grapheme* *RexxText* *Unicode*
P.         'Byte_Encoding'                    : (byte_encoding.cls)
P.         'CodePointSupplier'                : (stringIndexer.cls)
.M         'EncodedMutableBuffer'             : (text.cls)
.M         'EncodedString'                    : (text.cls)
P.         'Encoding'                         : (encoding.cls)
P.         'IBM1252_Encoding'                 : (ibm-1252_encoding.cls)
P.         'IBM437_Encoding'                  : (ibm-437_encoding.cls)
P.         'ISO88591_Encoding'                : (iso-8859-1_encoding.cls)
PM         'IndexerHelpers'                   : (stringInterface.cls)
PM         'IndexerStringInterface'           : (stringInterface.cls)
P.         'RexxText'                         : (REXX)
.M         'RexxTextContents'                 : (text.cls)
.M         'RexxTextInitializer'              : (text.cls)
PM         'RexxTextMapper'                   : (functionals.cls)
.M         'RexxTextOperators'                : (text.cls)
.M         'RexxTextPrettyPrinter'            : (trace.cls)
.M         'RexxTextStringInterface'          : (text.cls)
P.         'RexxTextTransformer'              : (stringIndexer.cls)
PM         'StringIndexer'                    : (stringIndexer.cls)
P.         'UTF16BE_Encoding'                 : (utf16_encoding.cls)
P.         'UTF16LE_Encoding'                 : (utf16_encoding.cls)
P.         'UTF32BE_Encoding'                 : (utf32_encoding.cls)
P.         'UTF32LE_Encoding'                 : (utf32_encoding.cls)
P.         'UTF8_Encoding'                    : (utf8_encoding.cls)
P.         'Unicode'                          : (REXX)
P.         'Unicode16_Encoding'               : (unicode16_encoding.cls)
P.         'Unicode32_Encoding'               : (unicode32_encoding.cls)
P.         'Unicode8_Encoding'                : (unicode8_encoding.cls)
P.         'UnicodeCharacter'                 : (unicode.cls)
P.         'UnicodeCharacterAlias'            : (unicode.cls)
P.         'UnicodeCharacterInterval'         : (unicode.cls)
P.         'UnicodeCharacterIntervalSupplier' : (unicode.cls)
P.         'UnicodeCharacterSupplier'         : (unicode.cls)
PM         'UnicodeN_Encoding'                : (unicodeN_encoding.cls)
PM         'Unicode_CommonServices'           : (unicode_common.cls)
P.         'WINDOWS1252_Encoding'             : (windows-1252_encoding.cls)
P.         'WTF16BE_Encoding'                 : (wtf16_encoding.cls)
P.         'WTF16LE_Encoding'                 : (wtf16_encoding.cls)
P.         'WTF8_Encoding'                    : (wtf8_encoding.cls)
[Info] 39 lines displayed

-- ===============================================================================
-- 2021 mar 24

/*
Optimization of String~isASCII:
The old implementation checks from start to end.
The new implementation checks from start ascending, from middle descending, from middle ascending, from end descending.
That will divide by 4 the number of iterations, while increasing the chance to find a not-ascii character faster.
Strangely, the new implementation is also faster when all the characters are ASCII.

Benchmark using a version where the flag isASCII is not stored:
*/
ooRexx> big10m = "0123456789"~copies(1e6)
ooRexx> s = big10m                              -- 10 millions of ASCII characters, must check all of them
-- do 1000; s~isASCIIold; end              -- 9.3s
ooRexx> do 1000; s~isASCII; end                 -- 6.2s
ooRexx> s = "√©" || big10m                       -- 1 non-ASCII character followed by 10 millions of ASCII characters
-- do 1000; s~isASCIIold; end              -- 0.001s
ooRexx> do 1000; s~isASCII; end                 -- 0.001s
ooRexx> s = big10m || "√©"                       -- 10 millions of ASCII characters followed by 1 non-ASCII character
-- do 1000; s~isASCIIold; end              -- 9.3s
ooRexx> do 1000; s~isASCII; end                 -- 0.001s
ooRexx> big5m = "01234"~copies(1e6)
ooRexx> s = big5m || "√©" || big5m               -- 1 non-ASCII character in the middle of 10 millions of ASCII characters
-- do 1000; s~isASCIIold; end              -- 4.7s
ooRexx> do 1000; s~isASCII; end                 -- 0.001s


-- ===============================================================================
-- 2021 mar 15

/*
Encoded strings (prototype).
Added support for UTF-8.
Added suppliers for codepoints and graphemes.
*/

ooRexx> s = "√ßa va ?"
ooRexx> s~length=                           -- 8
 8
ooRexx> s~eachC{item~c2x" "}=               -- ['C3 ','A7 ', 61 , 20 , 76 , 61 , 20 ,'3F ']
['C3 ','A7 ', 61 , 20 , 76 , 61 , 20 ,'3F ']
ooRexx> s~text~encoding=                    -- (The Byte_Encoding class)
(The UTF8_Encoding class)
ooRexx> s~text~length=                      -- 8
 7
ooRexx> s~text("utf8")~length==             -- 7
 7
ooRexx> s~text~codepoints~each=             -- [ 231, 97, 32, 118, 97, 32, 63]
[ 231, 97, 32, 118, 97, 32, 63]
ooRexx> s~text~graphemes~each("c2x")=       -- ['C3A7', 61, 20, 76, 61, 20,'3F']
['C3A7', 61, 20, 76, 61, 20,'3F']
