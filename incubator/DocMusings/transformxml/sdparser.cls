::requires "sdtokenizer"
::requires "indentedstream.cls"
::requires "trace.cls"


-------------------------------------------------------------------------------
/*
The abstract syntax is made of DITA elements :
syntaxdiagram
groupseq
groupchoice
groupcomp
fragment
fragref
kwd
var
oper
delim
sep
repsep
See http://www.ditainfocenter.com/eclipsehelp/index.jsp?topic=/org.ditausers.infomanager.LangSpec1.1/common/pr-d.html
*/

::class "SyntaxDiagramParser" public
::attribute errorCount
::attribute mainEntries
::attribute messages -- list of strings
::attribute nameGenerator -- any object which understands the message syntax_diagram_name(prefix, suffix)
::attribute tokenizer


::method parse class
    use strict arg tokenizer, nameGenerator
    parser = self~new(tokenizer, nameGenerator)
    tokenizer~clearVisitMarks
    tokenizer~dereferenceContinuations = .true
    do entry over tokenizer~mainEntries
        select
            when entry~isA(.sdtokenizer~BeginingOfStatement) then do
                syntaxDiagram = .SyntaxDiagram~new(.nil, parser)
                parser~mainEntries~append(syntaxDiagram)
                syntaxDiagram~parse(entry)
                syntaxDiagram = syntaxDiagram~simplify
                syntaxDiagram = syntaxDiagram~groupify
                syntaxDiagram~hrefbase = syntaxDiagram~title
            end
            when entry~isA(.sdtokenizer~BeginingOfFragment) then do
                -- Each fragment is stored in a separate syntax diagram.
                -- Why ? because sometimes, the fragment is alone in the text,
                -- with no preceding syntax diagram. So adopt a common behavior,
                -- whatever the situation.
                -- No title for this syntax diagram => no image will be generated by syntaxdiagram2svg
                syntaxDiagram = .SyntaxDiagram~new(.nil, parser)
                parser~mainEntries~append(syntaxDiagram)
                fragment = .Fragment~new(syntaxDiagram, parser)
                -- a title will be assigned to this fragment ==> an image will be generated by syntaxdiagram2svg
                fragment~parse(entry)
                fragment = fragment~simplify
                fragment = fragment~groupify
                syntaxDiagram~hrefbase = fragment~title
            end
            when entry~isA(.sdtokenizer~Comment) then do
                comment = .Comment~new(.nil, parser)
                parser~mainEntries~append(comment)
                comment~parse(entry)
                -- no need of simplification
            end
            otherwise parser~addError("[error] Unexpected token : "entry)
        end
    end
    if \ tokenizer~checkVisitCompletness then parser~addError("[error] Some tokens have not been visited")
    return parser


::method init
    use strict arg tokenizer, nameGenerator
    self~errorCount = 0
    self~mainEntries = .List~new
    self~messages = .List~new
    self~nameGenerator = nameGenerator
    self~tokenizer = tokenizer
    self~objectName = self~class~id


::method addMessage
    use strict arg message
    self~messages~append(message)


::method addError
    use strict arg message
    self~addMessage(message)
    self~errorCount += 1
    -- raise syntax 4


::method dumpAbstractSyntaxTree
    use strict arg stream = (.IndentedStream~stdout)
    stream~lineout("Abstract syntax tree :")
    do entry over self~mainEntries
        entry~inspect(stream)
    end


::method dump
    use strict arg stream = (.IndentedStream~stdout)
    self~tokenizer~dumpTextWithPointers(stream)
    stream~lineout("")
    -- diagnostic
    if self~errorCount == 0 then stream~lineout("Parsing : OK")
    else stream~lineout("Parsing : KO")
    do m over self~messages
        stream~lineout(m)
    end
    stream~lineout("")
    -- tokens not visited
    if \ self~tokenizer~visitIsComplete then do
        stream~lineout("Tokens not visited :")
        self~tokenizer~dumpNotVisitedTokens(stream)
        stream~lineout("")
    end
    -- Abstract syntax elements
    self~dumpAbstractSyntaxTree(stream)


::method inspect -- for debug
    use strict arg stream = (.IndentedStream~stdout)
    stream~lineout(self~string" :")
    stream~lineout("")
    self~dump(stream)


-------------------------------------------------------------------------------
::class "AbstractSyntaxElement"
::attribute childs

::attribute firstToken get
::attribute firstToken set
    expose firstToken
    use strict arg firstToken
    self~updateObjectName

::attribute lastToken

::attribute parser

::attribute text get
::attribute text set
    expose text
    use strict arg text
    self~updateObjectName

::constant default 1
::constant required 2
::constant optional 3
::attribute importance

::method importanceString
    use strict arg -- none
    select
        when self~importance == .AbstractSyntaxElement~default then return "default"
        when self~importance == .AbstractSyntaxElement~required then return "required"
        when self~importance == .AbstractSyntaxElement~optional then return "optional"
        otherwise return self~importance
    end


::method init
    use strict arg parent, parser
    self~childs = .List~new
    self~firstToken = .nil
    self~lastToken = .nil
    if parent <> .nil then parent~childs~append(self)
    self~parser = parser
    self~text = ""
    self~importance = 0


::method parse
    -- the simple case : the grammar element is made of one single token
    use strict arg token
    self~firstToken = token
    self~lastToken = token
    self~text = token~value
    token~setVisitMark
    return token~rightToken -- next token to parse


::method updateObjectName
    objectName = "The '"self~text"' "self~class~id
    if self~firstToken <> .nil then do
        objectName ||= " at ["self~firstToken~firstSymbol~line","self~firstToken~firstSymbol~col"]"
    end
    self~objectName = objectName


::method simplify
    -- The parser creates a lot of intermediate groups that can be eliminated
    if .t~istraced("simplify") then call trace .t~traceoption("simplify")
    use strict arg -- none
    if self~childs~isEmpty then return self
    newChilds = .List~new
    do child over self~childs
        newChild = child~simplify
        newChilds~append(newChild)
    end
    self~childs = newChilds
    return self


::method groupify
    -- syntaxdiagram and fragment can have only groups, fragref or fragment as childs.
    -- The simplification may move kwd, var or other similar elements to toplevel.
    -- This method takes care to put them back in a group.
    use strict arg -- none
    newChilds = .List~new
    group = .nil
    do child over self~childs
        if child~isA(.Kwd) | child~isA(.Var) | child~isA(.Characters) | child~isA(.Fragref) then do
            if group == .nil then do
                group = .Group~new(.nil, self~parser)
                group~kind = .Group~groupseq
            end
            group~childs~append(child)
        end
        else do
            if group <> .nil then do
                newChilds~append(group)
                group = .nil
            end
            newChilds~append(child)
        end
    end
    if group <> .nil then newChilds~append(group)
    self~childs = newChilds
    return self


::method inspect -- for debug
    use strict arg stream = (.IndentedStream~stdout)
    stream~lineout(self~string)
    stream~indent
        self~inspectProperties(stream)
        stream~lineout("childs :")
        stream~indent
            do child over self~childs
                child~inspect(stream)
            end
        stream~dedent
    stream~dedent


::method inspectProperties -- for debug
    use strict arg stream = (.IndentedStream~stdout)
    stream~lineout("firstToken = "self~firstToken)
    stream~lineout("lastToken = "self~lastToken)
    -- stream~lineout("parser = "self~parser)
    stream~lineout("text = '"self~text"'")
    stream~lineout("importance = "self~importanceString)


-------------------------------------------------------------------------------
::class "SyntaxDiagram" subclass "AbstractSyntaxElement"
::attribute hasFirstIdentifier -- to make proper distinction between kwd and var
::attribute hrefbase -- the basename that will be used to build the complete image href
::attribute label
::attribute title


::method init
    forward class (super) continue
    self~hasFirstIdentifier = .false
    self~hrefbase = ""
    self~label = ""
    self~title = ""


::method text
    use strict arg -- none
    return self~title


::method parse
    -- ( ( title) (optional) then ( groupseq or groupchoice or groupcomp or fragref or fragment or synblk or synnote or synnoteref) (any number) )
    use strict arg beginingOfStatement
    self~firstToken = beginingOfStatement
    beginingOfStatement~setVisitMark
    self~title = self~parser~nameGenerator~syntax_diagram_name("sd", beginingOfStatement~label) -- will be used as filename when generating the SVG
    self~label = beginingOfStatement~label
    if self~label == "" then do
        self~label = self~parser~nameGenerator~syntax_diagram_label
    end
    token = beginingOfStatement~rightToken
    do forever
        group = .Group~new(.nil, self~parser)
        token = group~parse(token)
        if group~childs~isEmpty & group~repsep == .nil then leave
        self~childs~append(group)
    end
    if token~isA(.sdtokenizer~EndOfStatement) then do
        token~setVisitMark
        self~lastToken = token
    end
    else self~parser~addError("[error] Expected an EndOfStatement, got : "token)
    return .nil -- no more tokens


::method inspectProperties
    use strict arg stream = (.IndentedStream~stdout)
    self~inspectProperties:super(stream)
    stream~lineout("title = '"self~title"'")


-------------------------------------------------------------------------------
::class "Fragment" subclass "AbstractSyntaxElement"
::attribute hasFirstIdentifier -- to make proper distinction between kwd and var
::attribute label
::attribute title


::method init
    forward class (super) continue
    self~hasFirstIdentifier = .false
    self~label = ""
    self~title = ""


::method text
    use strict arg -- none
    return self~title


::method parse
    -- ( ( title) (optional) then ( groupseq or groupchoice or groupcomp or fragref or synnote or synnoteref) (any number) )
    use strict arg beginingOfFragment
    self~firstToken = beginingOfFragment
    beginingOfFragment~setVisitMark
    self~title = self~parser~nameGenerator~syntax_diagram_name("sd", beginingOfFragment~label) -- will be used as filename when generating the SVG
    self~label = beginingOfFragment~label
    if self~label == "" then do
        self~label = self~parser~nameGenerator~syntax_diagram_label
    end
    token = beginingOfFragment~rightToken
    do forever
        group = .Group~new(.nil, self~parser)
        token = group~parse(token)
        if group~childs~isEmpty & group~repsep == .nil then leave
        self~childs~append(group)
    end
    if token~isA(.sdtokenizer~EndOfFragment) then do
        token~setVisitMark
        self~lastToken = token
    end
    else self~parser~addError("[error] Expected an EndOfFragment, got : "token)
    return .nil -- no more tokens


::method inspectProperties
    use strict arg stream = (.IndentedStream~stdout)
    self~inspectProperties:super(stream)
    stream~lineout("title = '"self~title"'")


-------------------------------------------------------------------------------
::class "Group" subclass "AbstractSyntaxElement"
::constant groupseq 1
::constant groupchoice 2
::constant groupcomp 3
::attribute kind

::method kindString
    use strict arg -- none
    select
        when self~kind == .Group~groupseq then return "groupseq"
        when self~kind == .Group~groupchoice then return "groupchoice"
        when self~kind == .Group~groupcomp then return "groupcomp"
        otherwise return self~kind
    end

::attribute repsep

::attribute r2lDispatcher private -- used by ParseChoice, ParseRepeated
::attribute endMismatch private -- used by ParseChoice, ParseRepeated

::method init
    forward class (super) continue
    self~kind = 0
    self~repsep = .nil


::method parse
    -- ( ( title) (optional) then ( repsep) (optional) then ( groupseq or groupchoice or groupcomp or fragref or kwd or var or delim or oper or sep or synnote or synnoteref) (any number) )
    if .t~istraced("parse") then call trace .t~traceoption("parse")
    use strict arg token
    self~firstToken = token
    token = self~parseGroup(token)
    if self~kind == 0 then self~kind = .Group~groupseq -- an empty group can occur (for example) in a choice : the main path can be empty if no required value
    if token <> .nil then self~lastToken = token~leftToken
    return token


::method parseGroup private
    /*
    We test if the repeat arrow has been already visited because parseRepeated will call parseGroup
    recursively on the same token when the repeat is like that :
          +-,--------+
          V          |
        --+----------+--
          +-,-string-+
    */
    if .t~istraced("parseGroup") then call trace .t~traceoption("parseGroup")
    use strict arg token
    -- skip dash separators
    do while token~isA(.sdtokenizer~l2rPath)
        if token~upperToken~isA(.sdtokenizer~RepeatArrow) then do
            if \ token~upperToken~alreadyVisited then leave
        end
        token~setVisitMark
        token = token~rightToken
    end
    if token == .nil then return .nil
    if token~upperToken~isA(.sdtokenizer~RepeatArrow), \ token~upperToken~alreadyVisited then return self~parseRepeated(token)
    if token~isA(.sdtokenizer~l2rCrossroads) then do
        if token~isl2rDispatcher then return self~parseChoice(token)
        if token~isr2lDispatcher then return token
        self~parser~addError("[error] "token" has both L2R and R2L paths")
        return .nil
    end
    return self~parseSeqComp(token)


::method parseSeqComp private
    -- groupseq or groupcomp
    if .t~istraced("parseSeqComp") then call trace .t~traceoption("parseSeqComp")
    use strict arg token
    do forever
        previousToken = token
        select
            when token~isA(.sdtokenizer~Identifier) then do
                -- try to improve the distinction kwd/var : if first identifier of the current entry then it's a kwd (it's rare to have a variable as first element)
                if self~parser~mainEntries~lastItem~hasFirstIdentifier == .false then token = .Kwd~new(self, self~parser)~parse(token)
                -- ALL UPPERCASE (i.e. no lowercase) ==> keyword
                else if token~hasLowerCase == .false then token = .Kwd~new(self, self~parser)~parse(token)
                -- After a "~" we have a kwd (most of the time)
                else if token~leftToken <> .nil, token~leftToken~value == "~" then token = .Kwd~new(self, self~parser)~parse(token)
                -- Before a "(", we have a kwd (most of the time)
                else if token~rightToken <> .nil, token~rightToken~value == "(" then token = .Kwd~new(self, self~parser)~parse(token)
                -- An identifier surrounded by quotes is a kwd
                else if token~leftToken <> .nil, token~rightToken <> .nil,,
                        (token~leftToken~value == '"' & token~rightToken~value == '"'),
                        |,
                        (token~leftToken~value == "'" & token~rightToken~value == "'"),
                     then token = .Kwd~new(self, self~parser)~parse(token)
                -- The doc says "Variables appear in all lowercase letters" but this is not true...
                -- We have a lot of variables whose name is a mix of upper- and lowercase letters, so...
                else token = .Var~new(self, self~parser)~parse(token)
                self~parser~mainEntries~lastItem~hasFirstIdentifier = .true
            end
            when token~isA(.sdtokenizer~Number) then token = .Kwd~new(self, self~parser)~parse(token)
            when token~isA(.sdtokenizer~Character) then token = .Characters~new(self, self~parser)~parse(token)
            when token~isA(.sdtokenizer~EscapedCharacter) then token = .Characters~new(self, self~parser)~parse(token)
            when token~isA(.sdtokenizer~SpecialCharacters) then token = .Characters~new(self, self~parser)~parse(token)
            when token~isA(.sdtokenizer~BeginingOfFragmentReference) then token = .FragRef~new(self, self~parser)~parse(token)
            otherwise return token -- end of group
        end

        -- Determine the kind of group (if first iteration) or test if the group is ended.
        -- Got a problem with +-| repetitor |-+ (no separators here, tokens were "-| " and " |-")
        -- because the fragref was put in a groupcomp, and the generated SVG was not good (empty box).
        -- To bypass that, I modified the tokenizer to recognize "| " and ' |".
        -- The problem will still occur with such (unlikely) string : before| repetitor |after.
        if token~isA(.sdtokenizer~l2rPath) then do
            if self~kind == .Group~groupcomp then return token -- we have reached a separator --> end of groupcomp
            if self~kind == 0 then self~kind = .Group~groupseq -- we have a separator after the first element --> groupseq
        end
        else do
            if self~kind == .Group~groupseq then do
                -- the current grammar element is not followed by a separator --> he's part of a groupcomp
                -- must undo the last append and close the groupseq (the visit marks are not undo'ed, not a problem)
                self~childs~remove(self~childs~last)
                return previousToken
            end
            if self~kind == 0 then self~kind = .Group~groupcomp -- we don't have a separator after the first element --> groupcomp
        end

        -- skip dash separators
        do while token~isA(.sdtokenizer~l2rPath), \ token~upperToken~isA(.sdtokenizer~RepeatArrow)
            token~setVisitMark
            token = token~rightToken
        end
    end


::method parseChoice private
    if .t~istraced("parseChoice") then call trace .t~traceoption("parseChoice")
    use strict arg l2rDispatcher
    l2rDispatcher~setVisitMark
    self~kind = .Group~groupchoice
    self~r2lDispatcher = .nil -- choice's end, will be calculated for each path, must be the same for all paths
    self~endMismatch = .false

    -- default choice (above main path, normally only one path, but support several paths above the main path)
    token = l2rDispatcher~upperToken
    if \ token~isA(.sdtokenizer~RepeatArrow) then do
        if self~parseChoiceAboveMainPath(token) == .nil then return .nil
    end
    -- main path
    if self~parseChoiceMainPath(l2rDispatcher) == .nil then return .nil
    -- optional choices (below main path)
    if self~parseChoiceBelowMainPath(l2rDispatcher~lowerToken) == .nil then return .nil

    if self~endMismatch then do
        self~parser~addError(  "[error] The choice "l2rDispatcher" does not end consistently")
    end
    if self~r2lDispatcher == .nil then return .nil

    /*
    Next test needed to support that : the [+] is both the end of the enclosed group
    and the end of the repeat main path.
         +--------------------+
         V                    |
        ---+-BORDERSELECT----[+]-
           +-CHECKBOXES-------+
    */
    if self~r2lDispatcher~annotation == "EndOfRepeat" then return self~r2lDispatcher
    return self~r2lDispatcher~rightToken


::method parseChoiceAboveMainPath private
    -- default choice (above main path, normally only one path, but support several paths above the main path)
    if .t~istraced("parseChoiceAboveMainPath") then call trace .t~traceoption("parseChoiceAboveMainPath")
    use strict arg token
    previousToken = .nil -- for accurate error message
    do forever
        select
            when token == .nil then leave -- end of b2t vertical path
            when token~isA(.sdtokenizer~b2tPath) then token~setVisitMark
            when token~isA(.sdtokenizer~b2tCrossroads) | token~isA(.sdtokenizer~b2tCorner) then do
                token~setVisitMark
                -- follow the horizontal path of default choice
                group = .Group~new(.nil, self~parser)
                group~importance = .AbstractSyntaxElement~default
                -- the topmost path must be the first : we are moving b2t so must always be the first child
                self~childs~insert(group, .nil)
                endTokenClass = token~class
                if endTokenClass == .sdtokenizer~b2tCorner then endTokenClass = .sdtokenizer~l2rCorner -- todo : should modify the tokenizer to be symmetrical
                endtoken = group~parseDelimitedPath(token, .false, endTokenClass)
                if endtoken == .nil then return .nil
                -- follow the t2b vertical path to find the choice's end
                choiceEnd = self~getr2lDispatcher(endtoken, "t2b")
                if choiceEnd == .nil then return .nil
                if self~r2lDispatcher == .nil then self~r2lDispatcher = choiceEnd
                else if self~r2lDispatcher <> choiceEnd then self~endMismatch = .true
            end
            otherwise do
                if token == .nil & previousToken == .nil then self~parser~addError("[error] Unexpected NIL token while walking b2t (parseChoiceAboveMainPath)")
                else if token == .nil then self~parser~addError("[error] Unexpected NIL token while walking b2t from "previousToken)
                else self~parser~addError("[error] Unexpected token while walking b2t : "token)
                return .nil
            end
        end
        previousToken = token
        token = token~upperToken
    end
    return .true -- no token to return here, so...


::method parseChoiceMainPath private
    -- main path
    if .t~istraced("parseChoiceMainPath") then call trace .t~traceoption("parseChoiceMainPath")
    use strict arg token
    group = .Group~new(self, self~parser)
    -- group~importance = .AbstractSyntaxElement~required -- not needed
    endtoken = group~parseDelimitedPath(token, .false, .sdtokenizer~l2rCrossroads)
    if endtoken == .nil then return .nil
    endtoken~setVisitMark
    if self~r2lDispatcher == .nil then self~r2lDispatcher = endtoken
    else if self~r2lDispatcher <> endtoken then self~endMismatch = .true
    return .true -- no token to return here, so...


::method parseChoiceBelowMainPath private
    -- optional choices (below main path)
    if .t~istraced("parseChoiceBelowMainPath") then call trace .t~traceoption("parseChoiceBelowMainPath")
    use strict arg token
    previousToken = .nil -- for accurate error message
    do forever
        select
            when token == .nil then leave -- end of t2b vertical path
            when token~isA(.sdtokenizer~t2bPath) then token~setVisitMark
            when token~isA(.sdtokenizer~t2bCrossroads) | token~isA(.sdtokenizer~t2bCorner) then do
                token~setVisitMark
                -- follow the horizontal path of optional choice
                group = .Group~new(self, self~parser)
                -- group~importance = .AbstractSyntaxElement~optional -- not needed
                endTokenClass = token~class
                if endTokenClass == .sdtokenizer~t2bCorner then endTokenClass = .sdtokenizer~l2rCorner -- todo : should modify the tokenizer to be symmetrical
                endtoken = group~parseDelimitedPath(token, .false, endTokenClass)
                if endtoken == .nil then return .nil
                -- follow the b2t vertical path to find the choice's end
                choiceEnd = self~getr2lDispatcher(endtoken, "b2t")
                if choiceEnd == .nil then return .nil
                if self~r2lDispatcher == .nil then self~r2lDispatcher = choiceEnd
                else if self~r2lDispatcher <> choiceEnd then self~endMismatch = .true
            end
            otherwise do
                if token == .nil & previousToken == .nil then self~parser~addError("[error] Unexpected NIL token while walking t2b (parseChoiceBelowMainPath)")
                else if token == .nil then self~parser~addError("[error] Unexpected NIL token while walking t2b from "previousToken)
                else self~parser~addError("[error] Unexpected token while walking t2b : "token)
                return .nil
            end
        end
        previousToken = token
        token = token~lowerToken
    end
    return .true -- no token to return here, so...


::method parseRepeated private
    if .t~istraced("parseRepeated") then call trace .t~traceoption("parseRepeated")
    use strict arg tokenUnderArrow
    self~r2lDispatcher = .nil -- repeat's end, will be calculated for the repeat arrow and the repeated path, must be the same
    self~endMismatch = .false
    repeatArrow = tokenUnderArrow~upperToken
    repeatArrow~setVisitMark
    -- follow the b2t vertical end path of the repeat arrow, until the first fork is reached
    -- and then parse the l2r horizontal path (will bring the repsep)
    -- and then follow the t2b vertical path to reach the repeat's end
    token = repeatArrow~upperToken
    previousToken = .nil -- for accurate error message
    do forever
        select
            when token~isA(.sdtokenizer~b2tPath) then token~setVisitMark
            when token~isA(.sdtokenizer~b2tCrossroads) | token~isA(.sdtokenizer~b2tCorner) then do
                token~setVisitMark
                -- follow the horizontal path of the repeat arrow
                self~repsep = .RepSep~new(.nil, self~parser)
                endTokenClass = token~class
                if endTokenClass == .sdtokenizer~b2tCorner then endTokenClass = .sdtokenizer~l2rCorner -- todo : should modify the tokenizer to be symmetrical
                endtoken = self~repsep~parseDelimitedPath(token, .false, endTokenClass)
                if endtoken == .nil then return .nil
                -- follow the vertical start path of the repeat arrow
                repeatEnd = self~getr2lDispatcher(endtoken, "t2b")
                if repeatEnd == .nil then return .nil
                if self~r2lDispatcher == .nil then self~r2lDispatcher = repeatEnd
                else if self~r2lDispatcher <> repeatEnd then self~endMismatch = .true
                repeatEnd~annotation = "EndOfRepeat"
                -- support only one horizontal path (i.e. only one repeat arrow)
                if token~upperToken <> .nil then self~parser~addError("{error] Not supported : More than one repeat path reaching "repeatArrow) -- not blocking
                leave -- we have processed the first fork
            end
            otherwise do
                if token == .nil & previousToken == .nil then self~parser~addError("[error] Unexpected NIL token while following repeat arrow")
                else if token == .nil then self~parser~addError("[error] Unexpected NIL token while following repeat arrow from "previousToken)
                else self~parser~addError("[error] Unexpected token while following repeat arrow "token)
                return .nil
            end
        end
        previousToken = token
        token = token~upperToken
    end

    -- parse the main path
    endtoken = self~parseDelimitedPath(tokenUnderArrow, .true, .sdtokenizer~l2rCrossroads)
    if self~r2lDispatcher == .nil then self~r2lDispatcher = endtoken
    else if self~r2lDispatcher <> endtoken then self~endMismatch = .true

    if self~endMismatch then do
        self~parser~addError(  "[error] The repeat at "tokenUnderArrow" does not end consistently")
    end
    return self~r2lDispatcher~rightToken


::method parseDelimitedPath private
    if .t~istraced("parseDelimitedPath") then call trace .t~traceoption("parseDelimitedPath")
    use strict arg startToken /*the start delimiter (+ or . or ...)*/, parseStart, endTokenClass
    self~kind = .Group~groupseq
    self~firstToken = startToken
    if parseStart then token = startToken
    else token = startToken~rightToken
    do forever
        group = .Group~new(.nil, self~parser)
        token = group~parse(token)
        if group~childs~isEmpty & group~repsep == .nil then leave
        self~childs~append(group)
        if token~isA(endTokenClass) then do
            if \ token~isA(.sdtokenizer~l2rCrossroads) then leave
            -- additional test needed for l2rCrossroads
            if token~isr2lDispatcher then leave
        end
    end
    if \ token~isA(endTokenClass) then do
        self~parser~addError(  "[error] While parsing delimited path from "startToken)
        self~parser~addMessage("        Expected a "endTokenClass~id" as end token, got "token)
        return .nil
    end
    token~setVisitMark
    self~lastToken = token
    return token -- the end delimiter (+ or .)


::method getr2lDispatcher private
    -- walk through the closing vertical path of a choice or repeat, searching for the "+" on the main path (the r2lDispatcher)
    if .t~istraced("getr2lDispatcher") then call trace .t~traceoption("getr2lDispatcher")
    use strict arg token, direction
    if direction == "t2b" then token = token~lowerToken
    if direction == "b2t" then token = token~upperToken
    previousToken = .nil -- for accurate error message
    do forever
        select
            when direction == "t2b", token~isA(.sdtokenizer~b2tPath) | token~isA(.sdtokenizer~b2tCrossroads) then do -- yes, b2t because the tokenization was made b2t
                token~setVisitMark
                token = token~lowerToken
            end
            when direction == "b2t", token~isA(.sdtokenizer~t2bPath) | token~isA(.sdtokenizer~t2bCrossroads) then do -- yes, t2b because the tokenization was made t2b
                token~setVisitMark
                token = token~upperToken
            end
            when token~isA(.sdtokenizer~l2rCrossroads) then leave -- we have reached the r2lDispatcher
            otherwise do
                if token == .nil & previousToken == .nil then self~parser~addError("[error] Unexpected NIL token while walking "direction" (getr2lDispatcher)")
                else if token == .nil then self~parser~addError("[error] Unexpected NIL token while walking "direction" from "previousToken)
                else self~parser~addError("[error] Unexpected token while walking "direction" : "token)
                return .nil
            end
        end
        previousToken = token
    end
    return token -- the r2lDispatcher


::method simplify
    if .t~istraced("simplify") then call trace .t~traceoption("simplify")
    use strict arg -- none
    if self~repsep <> .nil then self~repsep = self~repsep~simplify
    group = self~simplify:super -- simplify each child separately
    select
        when group~repsep <> .nil then return group -- a group with repeat can't be simplified
        when group~childs~items == 1 then do
            -- a group with only one child can be replaced by its child (if no information loss)
            child = group~childs~firstItem
            if group~importance <> 0 & child~importance <> 0 then return group
            if child~importance == 0 then child~importance = group~importance
            return child
        end
        when group~kind == .Group~groupchoice & group~childs~items == 2 then do
            -- a choice with 2 childs may be just an optional element (if main path is empty and no loss of information)
            index1 = group~childs~first
            path1 = group~childs[index1] -- not [1] ! todo : improve doc...
            index2 = group~childs~next(index1)
            path2 = group~childs[index2] -- not [2] ! todo : improve doc...
            if path1~isA(.Group) & path1~childs~isEmpty & path2~importance == 0 then do
                path2~importance = .AbstractSyntaxElement~optional
                return path2
            end
            return group
        end
        otherwise return group
    end


::method inspectProperties
    use strict arg stream = (.IndentedStream~stdout)
    self~inspectProperties:super(stream)
    stream~lineout("kind = "self~kindString)
    stream~charout("repsep : ")
    if self~repsep == .nil then stream~lineout(self~repsep~string)
    else do
        stream~lineout("")
        stream~indent
            self~repsep~inspect(stream)
        stream~dedent
    end


-------------------------------------------------------------------------------
::class "RepSep" subclass "Group"

::method simplify
    if .t~istraced("simplify") then call trace .t~traceoption("simplify")
    use strict arg -- none
    self~simplify:super -- simplify the childs
    if self~childs~items == 1 then do
        child = self~childs~firstItem
        if child~isA(.Kwd) | child~isA(.Characters) then do
            -- not displayed in italic, so can be stored in text
            self~text = child~text
            self~childs~empty
        end
    end
    return self


-------------------------------------------------------------------------------
::class "FragRef" subclass "AbstractSyntaxElement"


::method init
    forward class (super) continue
    self~text = ""


::method parse
    use strict arg beginingOfFragmentReference
    self~firstToken = beginingOfFragmentReference
    beginingOfFragmentReference~setVisitMark
    token = beginingOfFragmentReference~rightToken
    buffer = .MutableBuffer~new
    -- iterate over the tokens that can be converted to text, and concatenate
    do forever
        select
            when token~isA(.sdtokenizer~Identifier) then buffer~append(token~value)
            when token~isA(.sdtokenizer~Character) then buffer~append(token~value)
            when token~isA(.sdtokenizer~EscapedCharacter) then buffer~append(token~value)
            when token~isA(.sdtokenizer~SpecialCharacters) then buffer~append(token~value)
            when token~isA(.sdtokenizer~Number) then buffer~append(token~value)
            otherwise leave
        end
        token~setVisitMark
        token = token~rightToken
    end
    self~text = buffer~string
    if \ token~isA(.sdtokenizer~EndOfFragmentReference) then do
        self~parser~addError("[error] Expected an EndOfFragmentReference, got : "token)
        return .nil
    end
    token~setVisitMark
    self~lastToken = token

    -- semantic check
    if self~text == "" then do
        self~parser~addError("[error] The text attribute of "self" is empty")
    end

    return token~rightToken


-------------------------------------------------------------------------------
::class "Kwd" subclass "AbstractSyntaxElement"


-------------------------------------------------------------------------------
::class "Var" subclass "AbstractSyntaxElement"


-------------------------------------------------------------------------------
::class "Characters" subclass "AbstractSyntaxElement"
::constant delim 1
::constant oper 2
::constant sep 3
::attribute kind

::method kindString
    use strict arg -- none
    select
        when self~kind == .Characters~delim then return "delim"
        when self~kind == .Characters~oper then return "oper"
        when self~kind == .Characters~sep then return "sep"
        otherwise return self~kind
    end


::method init
    forward class (super) continue
    self~kind = 0
    self~text = ""


::method parse
    use strict arg token
    self~firstToken = token
    buffer = .MutableBuffer~new
    do forever
        select
            when token~isA(.sdtokenizer~Character) then buffer~append(token~value)
            when token~isA(.sdtokenizer~EscapedCharacter) then buffer~append(token~value)
            when token~isA(.sdtokenizer~SpecialCharacters) then buffer~append(token~value) -- could be parsed as a distinct Characters instance, if the need arises
            otherwise leave
        end
        token~setVisitMark
        self~lastToken = token
        token = token~rightToken
    end
    self~text = buffer~string
    -- not sure that the distinction between oper, sep and delim is important.
    select
        when self~text == " " then self~kind = .Characters~oper
        when self~text == "||" then self~kind = .Characters~oper
        when self~text == "+" then self~kind = .Characters~oper
        when self~text == "-" then self~kind = .Characters~oper
        when self~text == "*" then self~kind = .Characters~oper
        when self~text == "/" then self~kind = .Characters~oper
        when self~text == "%" then self~kind = .Characters~oper
        when self~text == "//" then self~kind = .Characters~oper
        when self~text == "**" then self~kind = .Characters~oper
        when self~text == "=" then self~kind = .Characters~oper
        when self~text == "\=" then self~kind = .Characters~oper
        when self~text == ">" then self~kind = .Characters~oper
        when self~text == "<" then self~kind = .Characters~oper
        when self~text == "><" then self~kind = .Characters~oper
        when self~text == "<>" then self~kind = .Characters~oper
        when self~text == ">=" then self~kind = .Characters~oper
        when self~text == "\<" then self~kind = .Characters~oper
        when self~text == "<=" then self~kind = .Characters~oper
        when self~text == "\>" then self~kind = .Characters~oper
        when self~text == "==" then self~kind = .Characters~oper
        when self~text == "\==" then self~kind = .Characters~oper
        when self~text == ">>" then self~kind = .Characters~oper
        when self~text == "<<" then self~kind = .Characters~oper
        when self~text == ">>=" then self~kind = .Characters~oper
        when self~text == "\<<" then self~kind = .Characters~oper
        when self~text == "<<=" then self~kind = .Characters~oper
        when self~text == "\>>" then self~kind = .Characters~oper
        when self~text == "&" then self~kind = .Characters~oper
        when self~text == "|" then self~kind = .Characters~oper
        when self~text == "&&" then self~kind = .Characters~oper
        when self~text == "\" then self~kind = .Characters~oper
        when self~text == "~" then self~kind = .Characters~oper
        when self~text == "~~" then self~kind = .Characters~oper
        when self~text == "->" then self~kind = .Characters~oper
        when self~text == "+=" then self~kind = .Characters~oper
        when self~text == "-=" then self~kind = .Characters~oper
        when self~text == "*=" then self~kind = .Characters~oper
        when self~text == "/=" then self~kind = .Characters~oper
        when self~text == "%=" then self~kind = .Characters~oper
        when self~text == "//=" then self~kind = .Characters~oper
        when self~text == "||=" then self~kind = .Characters~oper
        when self~text == "&=" then self~kind = .Characters~oper
        when self~text == "|=" then self~kind = .Characters~oper
        when self~text == "&&=" then self~kind = .Characters~oper

        when self~text == "," then self~kind = .Characters~sep
        when self~text == ";" then self~kind = .Characters~sep
        when self~text == ":" then self~kind = .Characters~sep

        when self~text == "(" then self~kind = .Characters~delim
        when self~text == ")" then self~kind = .Characters~delim
        when self~text == "[" then self~kind = .Characters~delim
        when self~text == "]" then self~kind = .Characters~delim
        when self~text == '"' then self~kind = .Characters~delim

        otherwise self~kind = .Characters~sep
    end
    return token


::method inspectProperties
    use strict arg stream = (.IndentedStream~stdout)
    self~inspectProperties:super(stream)
    stream~lineout("kind = "self~kindString)


-------------------------------------------------------------------------------
::class "Comment" subclass "AbstractSyntaxElement"


-------------------------------------------------------------------------------
::class sdparser public -- ako namespace


::method unknown class
    -- Collisions are possible with parser classes (ex : Comment).
    -- This method forwards everything to the directory of classes of the package (ako namespace).
    -- Usage : .sdparser~MyClass
    forward to (.Context~package~classes)

